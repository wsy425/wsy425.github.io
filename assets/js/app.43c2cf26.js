(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,i,s=e[0],l=e[1],c=e[2],d=0,p=[];d<s.length;d++)i=s[d],Object.prototype.hasOwnProperty.call(a,i)&&a[i]&&p.push(a[i][0]),a[i]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(u&&u(e);p.length;)p.shift()();return o.push.apply(o,c||[]),t()}function t(){for(var n,e=0;e<o.length;e++){for(var t=o[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==a[l]&&(r=!1)}r&&(o.splice(e--,1),n=i(i.s=t[0]))}return n}var r={},a={1:0},o=[];function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=a[n]=[e,r]}));e.push(t[2]=r);var o,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{2:"f96eca0e",3:"1c2fbab6",4:"57193269",5:"a543affa",6:"2d31ac0f",7:"b4570dd1",8:"fb6278ad",9:"8c310901",10:"bc85cf75",11:"3b363d77",12:"58809464",13:"48e0ec3e",14:"86f1f148",15:"5aec71d5",16:"f60f4b2c",17:"be1e8f52",18:"f3eb9f1b",19:"3346c91b",20:"aa9eaba8",21:"b1c2fe57",22:"09de122b",23:"bcbfc185",24:"b9a7221a",25:"24c8d455",26:"c82f5f99",27:"13e313aa",28:"604b2adb",29:"b9e889f8",30:"e9b0b227",31:"d2df7604",32:"3936ea87",33:"07b9921b",34:"7c36b2fa",35:"b0c28aec",36:"d89bce87",37:"4790def5",38:"3f900adf",39:"77a65b38",40:"e5eef212",41:"b5e2aed4",42:"477e81e4",43:"fba0ad7d",44:"ced2a21f",45:"72e29209",46:"ca0fcd32",47:"706e45e7",48:"9b07d2ec",49:"1e93a937",50:"7f680f06",51:"5e1a67a7",52:"63aaf607",53:"188de40c",54:"a1cb5365",55:"837f3a71",56:"39813210",57:"77de5448",58:"d1d4e042",59:"330296bc",60:"e460d057",61:"b1bbc352",62:"73e7fd7c",63:"830a4ce6",64:"f6b6d6e8",65:"360be319",66:"6ec1601e",67:"939f1e28",68:"9bf9b4bf",69:"2cda4e4e",70:"8c40764a",71:"10d53f76",72:"5422aa3d",73:"d69494b3",74:"0c6e9990",75:"904c111a",76:"d033d761",77:"83f0b5e4",78:"3a57f458",79:"df105e8f",80:"1a138f38",81:"2e196dae",82:"fee27c99",83:"ad889686",84:"eda4ad28",85:"5b49c997",86:"b86409fd",87:"945e03f3",88:"c40c83be",89:"d7c8ee8d",90:"14561d9b",91:"bc5ed798",92:"c02365cb",93:"cb9d227a",94:"5417cc79",95:"d69d15cb",96:"9e4d7632",97:"9093b69f",98:"230cb308",99:"35842c80",100:"625971d8",101:"b3c32f87",102:"3bf50b02",103:"406fd81a",104:"897240b1",105:"634eea14"}[n]+".js"}(n);var l=new Error;o=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=a[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+o+")",l.name="ChunkLoadError",l.type=r,l.request=o,t[1](l)}a[n]=void 0}};var c=setTimeout((function(){o({type:"timeout",target:s})}),12e4);s.onerror=s.onload=o,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=r,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)i.d(t,r,function(e){return n[e]}.bind(null,r));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var u=l;o.push([233,0]),t()}([function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var r=t(60),a=Function.prototype,o=a.bind,i=a.call,s=r&&o.bind(i,i);n.exports=r?function(n){return n&&s(n)}:function(n){return n&&function(){return i.apply(n,arguments)}}},function(n,e,t){var r=t(0),a=t(39).f,o=t(23),i=t(14),s=t(109),l=t(115),c=t(101);n.exports=function(n,e){var t,u,d,p,m,h=n.target,f=n.global,g=n.stat;if(t=f?r:g?r[h]||s(h,{}):(r[h]||{}).prototype)for(u in e){if(p=e[u],d=n.noTargetGet?(m=a(t,u))&&m.value:t[u],!c(f?u:h+(g?".":"#")+u,n.forced)&&void 0!==d){if(typeof p==typeof d)continue;l(p,d)}(n.sham||d&&d.sham)&&o(p,"sham",!0),i(t,u,p,n)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){var r=t(0),a=t(76),o=t(10),i=t(77),s=t(110),l=t(152),c=a("wks"),u=r.Symbol,d=u&&u.for,p=l?u:u&&u.withoutSetter||i;n.exports=function(n){if(!o(c,n)||!s&&"string"!=typeof c[n]){var e="Symbol."+n;s&&o(u,n)?c[n]=u[n]:c[n]=l&&d?d(e):p(e)}return c[n]}},function(n,e,t){var r=t(118),a=t(14),o=t(249);r||a(Object.prototype,"toString",o,{unsafe:!0})},function(n,e,t){var r=t(0),a=t(8),o=r.String,i=r.TypeError;n.exports=function(n){if(a(n))return n;throw i(o(n)+" is not an object")}},function(n,e,t){var r=t(4);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(3);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(1),a=t(15),o=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return o(a(n),e)}},function(n,e,t){var r=t(60),a=Function.prototype.call;n.exports=r?a.bind(a):function(){return a.apply(a,arguments)}},function(n,e,t){var r=t(0),a=t(73),o=r.String;n.exports=function(n){if("Symbol"===a(n))throw TypeError("Cannot convert a Symbol value to a string");return o(n)}},function(n,e,t){var r=t(0),a=t(9),o=t(154),i=t(153),s=t(7),l=t(79),c=r.TypeError,u=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=a?i?function(n,e,t){if(s(n),e=l(e),s(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=d(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return u(n,e,t)}:u:function(n,e,t){if(s(n),e=l(e),s(t),o)try{return u(n,e,t)}catch(n){}if("get"in t||"set"in t)throw c("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(0),a=t(4),o=t(10),i=t(23),s=t(109),l=t(84),c=t(36),u=t(63).CONFIGURABLE,d=c.get,p=c.enforce,m=String(String).split("String");(n.exports=function(n,e,t,l){var c,d=!!l&&!!l.unsafe,h=!!l&&!!l.enumerable,f=!!l&&!!l.noTargetGet,g=l&&void 0!==l.name?l.name:e;a(t)&&("Symbol("===String(g).slice(0,7)&&(g="["+String(g).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),(!o(t,"name")||u&&t.name!==g)&&i(t,"name",g),(c=p(t)).source||(c.source=m.join("string"==typeof g?g:""))),n!==r?(d?!f&&n[e]&&(h=!0):delete n[e],h?n[e]=t:i(n,e,t)):h?n[e]=t:s(e,t)})(Function.prototype,"toString",(function(){return a(this)&&d(this).source||l(this)}))},function(n,e,t){var r=t(0),a=t(18),o=r.Object;n.exports=function(n){return o(a(n))}},function(n,e,t){var r=t(0),a=t(4),o=function(n){return a(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?o(r[n]):r[n]&&r[n][e]}},function(n,e,t){"use strict";var r=t(2),a=t(90);r({target:"RegExp",proto:!0,forced:/./.exec!==a},{exec:a})},function(n,e,t){var r=t(0).TypeError;n.exports=function(n){if(null==n)throw r("Can't call method on "+n);return n}},function(n,e,t){var r=t(59),a=t(18);n.exports=function(n){return r(a(n))}},function(n,e,t){var r=t(50);n.exports=function(n){return r(n.length)}},function(n,e,t){var r=t(1),a=r({}.toString),o=r("".slice);n.exports=function(n){return o(a(n),8,-1)}},function(n,e){n.exports=!1},function(n,e,t){var r=t(9),a=t(13),o=t(47);n.exports=r?function(n,e,t){return a.f(n,e,o(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){"use strict";var r=t(171).charAt,a=t(12),o=t(36),i=t(158),s=o.set,l=o.getterFor("String Iterator");i(String,"String",(function(n){s(this,{type:"String Iterator",string:a(n),index:0})}),(function(){var n,e=l(this),t=e.string,a=e.index;return a>=t.length?{value:void 0,done:!0}:(n=r(t,a),e.index+=n.length,{value:n,done:!1})}))},function(n,e,t){var r=t(14),a=t(265),o=Error.prototype;o.toString!==a&&r(o,"toString",a)},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(16);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(187),a="object"==typeof self&&self&&self.Object===Object&&self,o=r||a||Function("return this")();n.exports=o},function(n,e,t){"use strict";function r(n,e,t,r,a,o,i,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),o&&(c._scopeId="data-v-"+o),i?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=l):a&&(l=s?function(){a.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:a),l)if(c.functional){c._injectStyles=l;var u=c.render;c.render=function(n,e){return l.call(e),u(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(2),a=t(54).filter;r({target:"Array",proto:!0,forced:!t(88)("filter")},{filter:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(0),a=t(172),o=t(173),i=t(139),s=t(23),l=t(5),c=l("iterator"),u=l("toStringTag"),d=i.values,p=function(n,e){if(n){if(n[c]!==d)try{s(n,c,d)}catch(e){n[c]=d}if(n[u]||s(n,u,e),a[e])for(var t in i)if(n[t]!==i[t])try{s(n,t,i[t])}catch(e){n[t]=i[t]}}};for(var m in a)p(r[m]&&r[m].prototype,m);p(o,"DOMTokenList")},function(n,e,t){var r,a=t(7),o=t(140),i=t(113),s=t(61),l=t(157),c=t(78),u=t(83),d=u("IE_PROTO"),p=function(){},m=function(n){return"<script>"+n+"<\/script>"},h=function(n){n.write(m("")),n.close();var e=n.parentWindow.Object;return n=null,e},f=function(){try{r=new ActiveXObject("htmlfile")}catch(n){}var n,e;f="undefined"!=typeof document?document.domain&&r?h(r):((e=c("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(m("document.F=Object")),n.close(),n.F):h(r);for(var t=i.length;t--;)delete f.prototype[i[t]];return f()};s[d]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(p.prototype=a(n),t=new p,p.prototype=null,t[d]=n):t=f(),void 0===e?t:o.f(t,e)}},function(n,e,t){var r=t(1);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r=t(60),a=Function.prototype,o=a.apply,i=a.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?i.bind(o):function(){return i.apply(o,arguments)})},function(n,e,t){var r=t(0),a=t(4),o=t(81),i=r.TypeError;n.exports=function(n){if(a(n))return n;throw i(o(n)+" is not a function")}},function(n,e,t){var r,a,o,i=t(235),s=t(0),l=t(1),c=t(8),u=t(23),d=t(10),p=t(108),m=t(83),h=t(61),f=s.TypeError,g=s.WeakMap;if(i||p.state){var v=p.state||(p.state=new g),x=l(v.get),b=l(v.has),y=l(v.set);r=function(n,e){if(b(v,n))throw new f("Object already initialized");return e.facade=n,y(v,n,e),e},a=function(n){return x(v,n)||{}},o=function(n){return b(v,n)}}else{var T=m("state");h[T]=!0,r=function(n,e){if(d(n,T))throw new f("Object already initialized");return e.facade=n,u(n,T,e),e},a=function(n){return d(n,T)?n[T]:{}},o=function(n){return d(n,T)}}n.exports={set:r,get:a,has:o,enforce:function(n){return o(n)?a(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=a(e)).type!==n)throw f("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){"use strict";var r=t(2),a=t(177);r({target:"Array",proto:!0,forced:[].forEach!=a},{forEach:a})},function(n,e,t){var r=t(0),a=t(172),o=t(173),i=t(177),s=t(23),l=function(n){if(n&&n.forEach!==i)try{s(n,"forEach",i)}catch(e){n.forEach=i}};for(var c in a)a[c]&&l(r[c]&&r[c].prototype);l(o)},function(n,e,t){var r=t(9),a=t(11),o=t(114),i=t(47),s=t(19),l=t(79),c=t(10),u=t(154),d=Object.getOwnPropertyDescriptor;e.f=r?d:function(n,e){if(n=s(n),e=l(e),u)try{return d(n,e)}catch(n){}if(c(n,e))return i(!a(o.f,n,e),n[e])}},function(n,e,t){var r=t(2),a=t(0),o=t(34),i=t(261),s=a.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=i(n,e,l),r({global:!0,forced:l},t)},u=function(n,e){if(s&&s[n]){var t={};t[n]=i("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,forced:l},t)}};c("Error",(function(n){return function(e){return o(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return o(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return o(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return o(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return o(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return o(n,this,arguments)}})),c("URIError",(function(n){return function(e){return o(n,this,arguments)}})),u("CompileError",(function(n){return function(e){return o(n,this,arguments)}})),u("LinkError",(function(n){return function(e){return o(n,this,arguments)}})),u("RuntimeError",(function(n){return function(e){return o(n,this,arguments)}}))},function(n,e,t){var r=t(285),a=t(288);n.exports=function(n,e){var t=a(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return o})),t.d(e,"j",(function(){return i})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return u})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return x})),t.d(e,"a",(function(){return y}));t(17),t(44),t(134),t(72),t(98),t(107),t(43),t(37),t(6),t(38),t(30),t(75),t(99),t(151),t(70),t(207),t(25),t(138);var r=/#.*$/,a=/\.(md|html)$/,o=/\/$/,i=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(a,"")}function l(n){return i.test(n)}function c(n){return/^mailto:/.test(n)}function u(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;var e=n.match(r),t=e?e[0]:"",a=s(n);return o.test(a)?n:a+".html"+t}function p(n,e){var t=n.hash,a=function(n){var e=n.match(r);if(e)return e[0]}(e);return(!a||t===a)&&s(n.path)===s(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var o=n.replace(/^\//,"").split("/"),i=0;i<o.length;i++){var s=o[i];".."===s?a.pop():"."!==s&&a.push(s)}""!==a[0]&&a.unshift("");return a.join("/")}(e,t));for(var r=s(e),a=0;a<n.length;a++)if(s(n[a].regularPath)===r)return Object.assign({},n[a],{type:"page",path:d(n[a].path)});return console.error('[vuepress] No matching page found for sidebar item "'.concat(e,'"')),{}}function h(n,e,t,r){var a=t.pages,o=t.themeConfig,i=r&&o.locales&&o.locales[r]||o;if("auto"===(n.frontmatter.sidebar||i.sidebar||o.sidebar))return f(n);var s=i.sidebar||o.sidebar;if(s){var l=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(var t in e)if(0===(r=n,/(\.html|\/)$/.test(r)?r:r+"/").indexOf(encodeURI(t)))return{base:t,config:e[t]};var r;return{}}(e,s),c=l.base,u=l.config;return"auto"===u?f(n):u?u.map((function(n){return function n(e,t,r){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;if("string"==typeof e)return m(t,e,r);if(Array.isArray(e))return Object.assign(m(t,e[0],r),{title:e[1]});a>3&&console.error("[vuepress] detected a too deep nested sidebar group.");var o=e.children||[];return 0===o.length&&e.path?Object.assign(m(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:o.map((function(e){return n(e,t,r,a+1)})),collapsable:!1!==e.collapsable}}(n,a,c)})):[]}return[]}function f(n){var e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map((function(e){return{type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}}))}]}function g(n){var e;return(n=n.map((function(n){return Object.assign({},n)}))).forEach((function(n){2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)})),n.filter((function(n){return 2===n.level}))}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function x(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function b(n){var e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function y(n,e){return b(e)-b(n)}},function(n,e,t){"use strict";var r=t(2),a=t(54).map;r({target:"Array",proto:!0,forced:!t(88)("map")},{map:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(34),a=t(11),o=t(1),i=t(105),s=t(3),l=t(7),c=t(4),u=t(52),d=t(50),p=t(12),m=t(18),h=t(122),f=t(46),g=t(266),v=t(106),x=t(5)("replace"),b=Math.max,y=Math.min,T=o([].concat),w=o([].push),_=o("".indexOf),k=o("".slice),j="$0"==="a".replace(/./,"$0"),I=!!/./[x]&&""===/./[x]("a","$0");i("replace",(function(n,e,t){var o=I?"$":"$0";return[function(n,t){var r=m(this),o=null==n?void 0:f(n,x);return o?a(o,n,r,t):a(e,p(r),n,t)},function(n,a){var i=l(this),s=p(n);if("string"==typeof a&&-1===_(a,o)&&-1===_(a,"$<")){var m=t(e,i,s,a);if(m.done)return m.value}var f=c(a);f||(a=p(a));var x=i.global;if(x){var j=i.unicode;i.lastIndex=0}for(var I=[];;){var z=v(i,s);if(null===z)break;if(w(I,z),!x)break;""===p(z[0])&&(i.lastIndex=h(s,d(i.lastIndex),j))}for(var E,S="",A=0,C=0;C<I.length;C++){for(var q=p((z=I[C])[0]),P=b(y(u(z.index),s.length),0),B=[],O=1;O<z.length;O++)w(B,void 0===(E=z[O])?E:String(E));var R=z.groups;if(f){var D=T([q],B,P,s);void 0!==R&&w(D,R);var M=p(r(a,void 0,D))}else M=g(q,s,P,B,R,a);P>=A&&(S+=k(s,A,P)+M,A=P+q.length)}return S+k(s,A)}]}),!!s((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")}))||!j||I)},function(n,e,t){"use strict";var r=t(3);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(35);n.exports=function(n,e){var t=n[e];return null==t?void 0:r(t)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r,a,o=t(0),i=t(27),s=o.process,l=o.Deno,c=s&&s.versions||l&&l.version,u=c&&c.v8;u&&(a=(r=u.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!a&&i&&(!(r=i.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=i.match(/Chrome\/(\d+)/))&&(a=+r[1]),n.exports=a},function(n,e,t){var r=t(52),a=Math.min;n.exports=function(n){return n>0?a(r(n),9007199254740991):0}},function(n,e,t){"use strict";var r=t(2),a=t(0),o=t(57),i=t(85),s=t(8),l=t(112),c=t(20),u=t(19),d=t(66),p=t(5),m=t(88),h=t(65),f=m("slice"),g=p("species"),v=a.Array,x=Math.max;r({target:"Array",proto:!0,forced:!f},{slice:function(n,e){var t,r,a,p=u(this),m=c(p),f=l(n,m),b=l(void 0===e?m:e,m);if(o(p)&&(t=p.constructor,(i(t)&&(t===v||o(t.prototype))||s(t)&&null===(t=t[g]))&&(t=void 0),t===v||void 0===t))return h(p,f,b);for(r=new(void 0===t?v:t)(x(b-f,0)),a=0;f<b;f++,a++)f in p&&d(r,a,p[f]);return r.length=a,r}})},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=function(n){var e=+n;return e!=e||0===e?0:(e>0?r:t)(e)}},function(n,e,t){var r=t(1),a=t(35),o=t(60),i=r(r.bind);n.exports=function(n,e){return a(n),void 0===e?n:o?i(n,e):function(){return n.apply(e,arguments)}}},function(n,e,t){var r=t(53),a=t(1),o=t(59),i=t(15),s=t(20),l=t(143),c=a([].push),u=function(n){var e=1==n,t=2==n,a=3==n,u=4==n,d=6==n,p=7==n,m=5==n||d;return function(h,f,g,v){for(var x,b,y=i(h),T=o(y),w=r(f,g),_=s(T),k=0,j=v||l,I=e?j(h,_):t||p?j(h,0):void 0;_>k;k++)if((m||k in T)&&(b=w(x=T[k],k,y),n))if(e)I[k]=b;else if(b)switch(n){case 3:return!0;case 5:return x;case 6:return k;case 2:c(I,x)}else switch(n){case 4:return!1;case 7:c(I,x)}return d?-1:a||u?u:I}};n.exports={forEach:u(0),map:u(1),filter:u(2),some:u(3),every:u(4),find:u(5),findIndex:u(6),filterReject:u(7)}},function(n,e,t){var r=t(156),a=t(113).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,a)}},function(n,e,t){var r=t(13).f,a=t(10),o=t(5)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!a(n,o)&&r(n,o,{configurable:!0,value:e})}},function(n,e,t){var r=t(21);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e,t){var r=t(67),a=t(270),o=t(271),i=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?a(n):o(n)}},function(n,e,t){var r=t(0),a=t(1),o=t(3),i=t(21),s=r.Object,l=a("".split);n.exports=o((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"==i(n)?l(n,""):s(n)}:s},function(n,e,t){var r=t(3);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e){n.exports={}},function(n,e){n.exports={}},function(n,e,t){var r=t(9),a=t(10),o=Function.prototype,i=r&&Object.getOwnPropertyDescriptor,s=a(o,"name"),l=s&&"something"===function(){}.name,c=s&&(!r||r&&i(o,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var r=t(1),a=t(7),o=t(236);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return a(t),o(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e,t){var r=t(1);n.exports=r([].slice)},function(n,e,t){"use strict";var r=t(79),a=t(13),o=t(47);n.exports=function(n,e,t){var i=r(e);i in n?a.f(n,i,o(0,t)):n[i]=t}},function(n,e,t){var r=t(28).Symbol;n.exports=r},function(n,e,t){"use strict";t.d(e,"a",(function(){return o}));t(75);var r=t(69);t(74),t(89),t(6),t(121),t(24),t(31),t(182);var a=t(96);t(40),t(25);function o(n){return function(n){if(Array.isArray(n))return Object(r.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||Object(a.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";function r(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,r=new Array(e);t<e;t++)r[t]=n[t];return r}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(2),a=t(0),o=t(3),i=t(57),s=t(8),l=t(15),c=t(20),u=t(66),d=t(143),p=t(88),m=t(5),h=t(49),f=m("isConcatSpreadable"),g=a.TypeError,v=h>=51||!o((function(){var n=[];return n[f]=!1,n.concat()[0]!==n})),x=p("concat"),b=function(n){if(!s(n))return!1;var e=n[f];return void 0!==e?!!e:i(n)};r({target:"Array",proto:!0,forced:!v||!x},{concat:function(n){var e,t,r,a,o,i=l(this),s=d(i,0),p=0;for(e=-1,r=arguments.length;e<r;e++)if(b(o=-1===e?i:arguments[e])){if(p+(a=c(o))>9007199254740991)throw g("Maximum allowed index exceeded");for(t=0;t<a;t++,p++)t in o&&u(s,p,o[t])}else{if(p>=9007199254740991)throw g("Maximum allowed index exceeded");u(s,p++,o)}return s.length=p,s}})},function(n,e,t){var r=t(2),a=t(0),o=t(34),i=t(4),s=t(27),l=t(65),c=t(142),u=/MSIE .\./.test(s),d=a.Function,p=function(n){return function(e,t){var r=c(arguments.length,1)>2,a=i(e)?e:d(e),s=r?l(arguments,2):void 0;return n(r?function(){o(a,this,s)}:a,t)}};r({global:!0,bind:!0,forced:u},{setTimeout:p(a.setTimeout),setInterval:p(a.setInterval)})},function(n,e,t){"use strict";t(17);var r,a,o=t(2),i=t(0),s=t(11),l=t(1),c=t(4),u=t(8),d=(r=!1,(a=/[ac]/).exec=function(){return r=!0,/./.exec.apply(this,arguments)},!0===a.test("abc")&&r),p=i.Error,m=l(/./.test);o({target:"RegExp",proto:!0,forced:!d},{test:function(n){var e=this.exec;if(!c(e))return m(this,n);var t=s(e,this,n);if(null!==t&&!u(t))throw new p("RegExp exec method returned something other than an Object or null");return!!t}})},function(n,e,t){var r=t(0),a=t(118),o=t(4),i=t(21),s=t(5)("toStringTag"),l=r.Object,c="Arguments"==i(function(){return arguments}());n.exports=a?i:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=l(n),s))?t:c?i(e):"Object"==(r=i(e))&&o(e.callee)?"Arguments":r}},function(n,e,t){"use strict";var r=t(2),a=t(0),o=t(16),i=t(34),s=t(11),l=t(1),c=t(22),u=t(9),d=t(110),p=t(3),m=t(10),h=t(57),f=t(4),g=t(8),v=t(33),x=t(80),b=t(7),y=t(15),T=t(19),w=t(79),_=t(12),k=t(47),j=t(32),I=t(82),z=t(55),E=t(179),S=t(116),A=t(39),C=t(13),q=t(140),P=t(114),B=t(65),O=t(14),R=t(76),D=t(83),M=t(61),N=t(77),L=t(5),U=t(180),$=t(181),J=t(56),H=t(36),F=t(54).forEach,V=D("hidden"),G=L("toPrimitive"),W=H.set,X=H.getterFor("Symbol"),Y=Object.prototype,Z=a.Symbol,K=Z&&Z.prototype,Q=a.TypeError,nn=a.QObject,en=o("JSON","stringify"),tn=A.f,rn=C.f,an=E.f,on=P.f,sn=l([].push),ln=R("symbols"),cn=R("op-symbols"),un=R("string-to-symbol-registry"),dn=R("symbol-to-string-registry"),pn=R("wks"),mn=!nn||!nn.prototype||!nn.prototype.findChild,hn=u&&p((function(){return 7!=j(rn({},"a",{get:function(){return rn(this,"a",{value:7}).a}})).a}))?function(n,e,t){var r=tn(Y,e);r&&delete Y[e],rn(n,e,t),r&&n!==Y&&rn(Y,e,r)}:rn,fn=function(n,e){var t=ln[n]=j(K);return W(t,{type:"Symbol",tag:n,description:e}),u||(t.description=e),t},gn=function(n,e,t){n===Y&&gn(cn,e,t),b(n);var r=w(e);return b(t),m(ln,r)?(t.enumerable?(m(n,V)&&n[V][r]&&(n[V][r]=!1),t=j(t,{enumerable:k(0,!1)})):(m(n,V)||rn(n,V,k(1,{})),n[V][r]=!0),hn(n,r,t)):rn(n,r,t)},vn=function(n,e){b(n);var t=T(e),r=I(t).concat(Tn(t));return F(r,(function(e){u&&!s(xn,t,e)||gn(n,e,t[e])})),n},xn=function(n){var e=w(n),t=s(on,this,e);return!(this===Y&&m(ln,e)&&!m(cn,e))&&(!(t||!m(this,e)||!m(ln,e)||m(this,V)&&this[V][e])||t)},bn=function(n,e){var t=T(n),r=w(e);if(t!==Y||!m(ln,r)||m(cn,r)){var a=tn(t,r);return!a||!m(ln,r)||m(t,V)&&t[V][r]||(a.enumerable=!0),a}},yn=function(n){var e=an(T(n)),t=[];return F(e,(function(n){m(ln,n)||m(M,n)||sn(t,n)})),t},Tn=function(n){var e=n===Y,t=an(e?cn:T(n)),r=[];return F(t,(function(n){!m(ln,n)||e&&!m(Y,n)||sn(r,ln[n])})),r};(d||(O(K=(Z=function(){if(v(K,this))throw Q("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?_(arguments[0]):void 0,e=N(n),t=function(n){this===Y&&s(t,cn,n),m(this,V)&&m(this[V],e)&&(this[V][e]=!1),hn(this,e,k(1,n))};return u&&mn&&hn(Y,e,{configurable:!0,set:t}),fn(e,n)}).prototype,"toString",(function(){return X(this).tag})),O(Z,"withoutSetter",(function(n){return fn(N(n),n)})),P.f=xn,C.f=gn,q.f=vn,A.f=bn,z.f=E.f=yn,S.f=Tn,U.f=function(n){return fn(L(n),n)},u&&(rn(K,"description",{configurable:!0,get:function(){return X(this).description}}),c||O(Y,"propertyIsEnumerable",xn,{unsafe:!0}))),r({global:!0,wrap:!0,forced:!d,sham:!d},{Symbol:Z}),F(I(pn),(function(n){$(n)})),r({target:"Symbol",stat:!0,forced:!d},{for:function(n){var e=_(n);if(m(un,e))return un[e];var t=Z(e);return un[e]=t,dn[t]=e,t},keyFor:function(n){if(!x(n))throw Q(n+" is not a symbol");if(m(dn,n))return dn[n]},useSetter:function(){mn=!0},useSimple:function(){mn=!1}}),r({target:"Object",stat:!0,forced:!d,sham:!u},{create:function(n,e){return void 0===e?j(n):vn(j(n),e)},defineProperty:gn,defineProperties:vn,getOwnPropertyDescriptor:bn}),r({target:"Object",stat:!0,forced:!d},{getOwnPropertyNames:yn,getOwnPropertySymbols:Tn}),r({target:"Object",stat:!0,forced:p((function(){S.f(1)}))},{getOwnPropertySymbols:function(n){return S.f(y(n))}}),en)&&r({target:"JSON",stat:!0,forced:!d||p((function(){var n=Z();return"[null]"!=en([n])||"{}"!=en({a:n})||"{}"!=en(Object(n))}))},{stringify:function(n,e,t){var r=B(arguments),a=e;if((g(e)||void 0!==n)&&!x(n))return h(e)||(e=function(n,e){if(f(a)&&(e=s(a,this,n,e)),!x(e))return e}),r[1]=e,i(en,null,r)}});if(!K[G]){var wn=K.valueOf;O(K,G,(function(n){return s(wn,this)}))}J(Z,"Symbol"),M[V]=!0},function(n,e,t){t(2)({target:"Array",stat:!0},{isArray:t(57)})},function(n,e,t){var r=t(22),a=t(108);(n.exports=function(n,e){return a[n]||(a[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.21.1",mode:r?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){var r=t(1),a=0,o=Math.random(),i=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+i(++a+o,36)}},function(n,e,t){var r=t(0),a=t(8),o=r.document,i=a(o)&&a(o.createElement);n.exports=function(n){return i?o.createElement(n):{}}},function(n,e,t){var r=t(155),a=t(80);n.exports=function(n){var e=r(n,"string");return a(e)?e:e+""}},function(n,e,t){var r=t(0),a=t(16),o=t(4),i=t(33),s=t(152),l=r.Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return o(e)&&i(e.prototype,l(n))}},function(n,e,t){var r=t(0).String;n.exports=function(n){try{return r(n)}catch(n){return"Object"}}},function(n,e,t){var r=t(156),a=t(113);n.exports=Object.keys||function(n){return r(n,a)}},function(n,e,t){var r=t(76),a=t(77),o=r("keys");n.exports=function(n){return o[n]||(o[n]=a(n))}},function(n,e,t){var r=t(1),a=t(4),o=t(108),i=r(Function.toString);a(o.inspectSource)||(o.inspectSource=function(n){return i(n)}),n.exports=o.inspectSource},function(n,e,t){var r=t(1),a=t(3),o=t(4),i=t(73),s=t(16),l=t(84),c=function(){},u=[],d=s("Reflect","construct"),p=/^\s*(?:class|function)\b/,m=r(p.exec),h=!p.exec(c),f=function(n){if(!o(n))return!1;try{return d(c,u,n),!0}catch(n){return!1}},g=function(n){if(!o(n))return!1;switch(i(n)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return h||!!m(p,l(n))}catch(n){return!0}};g.sham=!0,n.exports=!d||a((function(){var n;return f(f.call)||!f(Object)||!f((function(){n=!0}))||n}))?g:f},function(n,e,t){var r=t(21),a=t(0);n.exports="process"==r(a.process)},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(6);function r(n,e,t,r,a,o,i){try{var s=n[o](i),l=s.value}catch(n){return void t(n)}s.done?e(l):Promise.resolve(l).then(r,a)}function a(n){return function(){var e=this,t=arguments;return new Promise((function(a,o){var i=n.apply(e,t);function s(n){r(i,a,o,s,l,"next",n)}function l(n){r(i,a,o,s,l,"throw",n)}s(void 0)}))}}},function(n,e,t){var r=t(3),a=t(5),o=t(49),i=a("species");n.exports=function(n){return o>=51||!r((function(){var e=[];return(e.constructor={})[i]=function(){return{foo:1}},1!==e[n](Boolean).foo}))}},function(n,e,t){"use strict";var r=t(2),a=t(9),o=t(0),i=t(1),s=t(10),l=t(4),c=t(33),u=t(12),d=t(13).f,p=t(115),m=o.Symbol,h=m&&m.prototype;if(a&&l(m)&&(!("description"in h)||void 0!==m().description)){var f={},g=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:u(arguments[0]),e=c(h,this)?new m(n):void 0===n?m():m(n);return""===n&&(f[e]=!0),e};p(g,m),g.prototype=h,h.constructor=g;var v="Symbol(test)"==String(m("test")),x=i(h.toString),b=i(h.valueOf),y=/^Symbol\((.*)\)[^)]+$/,T=i("".replace),w=i("".slice);d(h,"description",{configurable:!0,get:function(){var n=b(this),e=x(n);if(s(f,n))return"";var t=v?w(e,7,-1):T(e,y,"$1");return""===t?void 0:t}}),r({global:!0,forced:!0},{Symbol:g})}},function(n,e,t){"use strict";var r,a,o=t(11),i=t(1),s=t(12),l=t(145),c=t(104),u=t(76),d=t(32),p=t(36).get,m=t(220),h=t(226),f=u("native-string-replace",String.prototype.replace),g=RegExp.prototype.exec,v=g,x=i("".charAt),b=i("".indexOf),y=i("".replace),T=i("".slice),w=(a=/b*/g,o(g,r=/a/,"a"),o(g,a,"a"),0!==r.lastIndex||0!==a.lastIndex),_=c.BROKEN_CARET,k=void 0!==/()??/.exec("")[1];(w||k||_||m||h)&&(v=function(n){var e,t,r,a,i,c,u,m=this,h=p(m),j=s(n),I=h.raw;if(I)return I.lastIndex=m.lastIndex,e=o(v,I,j),m.lastIndex=I.lastIndex,e;var z=h.groups,E=_&&m.sticky,S=o(l,m),A=m.source,C=0,q=j;if(E&&(S=y(S,"y",""),-1===b(S,"g")&&(S+="g"),q=T(j,m.lastIndex),m.lastIndex>0&&(!m.multiline||m.multiline&&"\n"!==x(j,m.lastIndex-1))&&(A="(?: "+A+")",q=" "+q,C++),t=new RegExp("^(?:"+A+")",S)),k&&(t=new RegExp("^"+A+"$(?!\\s)",S)),w&&(r=m.lastIndex),a=o(g,E?t:m,q),E?a?(a.input=T(a.input,C),a[0]=T(a[0],C),a.index=m.lastIndex,m.lastIndex+=a[0].length):m.lastIndex=0:w&&a&&(m.lastIndex=m.global?a.index+a[0].length:r),k&&a&&a.length>1&&o(f,a[0],t,(function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(a[i]=void 0)})),a&&z)for(a.groups=c=d(null),i=0;i<z.length;i++)c[(u=z[i])[0]]=a[u[1]];return a}),n.exports=v},function(n,e,t){var r=t(275),a=t(276),o=t(277),i=t(278),s=t(279);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(189);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(41)(Object,"create");n.exports=r},function(n,e,t){var r=t(297);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(130);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(51),t(6),t(103),t(182),t(24),t(17),t(72);var r=t(69);function a(n,e){if(n){if("string"==typeof n)return Object(r.a)(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(r.a)(n,e):void 0}}},function(n,e,t){var r,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function o(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),u=r.speed,d=r.easing;return l.offsetWidth,i((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var a;return(a="translate3d"===r.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+e+"ms "+t,a}(n,u,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var a,i=e.querySelector(r.barSelector),l=n?"-100":o(t.status||0),u=document.querySelector(r.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(a=e.querySelector(r.spinnerSelector))&&p(a),u!=document.body&&c(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,a=n.length,o=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((r=n[a]+o)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,a,o=arguments;if(2==o.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&r(n,t,a);else r(n,o[1],o[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function u(n,e){var t,r=d(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=a)},function(n,e,t){"use strict";var r=t(34),a=t(11),o=t(1),i=t(105),s=t(144),l=t(7),c=t(18),u=t(119),d=t(122),p=t(50),m=t(12),h=t(46),f=t(120),g=t(106),v=t(90),x=t(104),b=t(3),y=x.UNSUPPORTED_Y,T=Math.min,w=[].push,_=o(/./.exec),k=o(w),j=o("".slice);i("split",(function(n,e,t){var o;return o="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(n,t){var o=m(c(this)),i=void 0===t?4294967295:t>>>0;if(0===i)return[];if(void 0===n)return[o];if(!s(n))return a(e,o,n,i);for(var l,u,d,p=[],h=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),g=0,x=new RegExp(n.source,h+"g");(l=a(v,x,o))&&!((u=x.lastIndex)>g&&(k(p,j(o,g,l.index)),l.length>1&&l.index<o.length&&r(w,p,f(l,1)),d=l[0].length,g=u,p.length>=i));)x.lastIndex===l.index&&x.lastIndex++;return g===o.length?!d&&_(x,"")||k(p,""):k(p,j(o,g)),p.length>i?f(p,0,i):p}:"0".split(void 0,0).length?function(n,t){return void 0===n&&0===t?[]:a(e,this,n,t)}:e,[function(e,t){var r=c(this),i=null==e?void 0:h(e,n);return i?a(i,e,r,t):a(o,m(r),e,t)},function(n,r){var a=l(this),i=m(n),s=t(o,a,i,r,o!==e);if(s.done)return s.value;var c=u(a,RegExp),h=a.unicode,f=(a.ignoreCase?"i":"")+(a.multiline?"m":"")+(a.unicode?"u":"")+(y?"g":"y"),v=new c(y?"^(?:"+a.source+")":a,f),x=void 0===r?4294967295:r>>>0;if(0===x)return[];if(0===i.length)return null===g(v,i)?[i]:[];for(var b=0,w=0,_=[];w<i.length;){v.lastIndex=y?0:w;var I,z=g(v,y?j(i,w):i);if(null===z||(I=T(p(v.lastIndex+(y?w:0)),i.length))===b)w=d(i,w,h);else{if(k(_,j(i,b,w)),_.length===x)return _;for(var E=1;E<=z.length-1;E++)if(k(_,z[E]),_.length===x)return _;w=b=I}}return k(_,j(i,b)),_}]}),!!b((function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var t="ab".split(n);return 2!==t.length||"a"!==t[0]||"b"!==t[1]})),y)},function(n,e,t){"use strict";var r=t(2),a=t(1),o=t(111).indexOf,i=t(45),s=a([].indexOf),l=!!s&&1/s([1],1,-0)<0,c=i("indexOf");r({target:"Array",proto:!0,forced:l||!c},{indexOf:function(n){var e=arguments.length>1?arguments[1]:void 0;return l?s(this,n,e)||0:o(this,n,e)}})},function(n,e,t){var r=t(2),a=t(15),o=t(82);r({target:"Object",stat:!0,forced:t(3)((function(){o(1)}))},{keys:function(n){return o(a(n))}})},function(n,e,t){var r=t(3),a=t(4),o=/#|\.prototype\./,i=function(n,e){var t=l[s(n)];return t==u||t!=c&&(a(e)?r(e):!!e)},s=i.normalize=function(n){return String(n).replace(o,".").toLowerCase()},l=i.data={},c=i.NATIVE="N",u=i.POLYFILL="P";n.exports=i},function(n,e,t){var r=t(73),a=t(46),o=t(62),i=t(5)("iterator");n.exports=function(n){if(null!=n)return a(n,i)||a(n,"@@iterator")||o[r(n)]}},function(n,e,t){var r=t(9),a=t(63).EXISTS,o=t(1),i=t(13).f,s=Function.prototype,l=o(s.toString),c=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,u=o(c.exec);r&&!a&&i(s,"name",{configurable:!0,get:function(){try{return u(c,l(this))[1]}catch(n){return""}}})},function(n,e,t){var r=t(3),a=t(0).RegExp,o=r((function(){var n=a("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),i=o||r((function(){return!a("a","y").sticky})),s=o||r((function(){var n=a("^r","gy");return n.lastIndex=2,null!=n.exec("str")}));n.exports={BROKEN_CARET:s,MISSED_STICKY:i,UNSUPPORTED_Y:o}},function(n,e,t){"use strict";t(17);var r=t(1),a=t(14),o=t(90),i=t(3),s=t(5),l=t(23),c=s("species"),u=RegExp.prototype;n.exports=function(n,e,t,d){var p=s(n),m=!i((function(){var e={};return e[p]=function(){return 7},7!=""[n](e)})),h=m&&!i((function(){var e=!1,t=/a/;return"split"===n&&((t={}).constructor={},t.constructor[c]=function(){return t},t.flags="",t[p]=/./[p]),t.exec=function(){return e=!0,null},t[p](""),!e}));if(!m||!h||t){var f=r(/./[p]),g=e(p,""[n],(function(n,e,t,a,i){var s=r(n),l=e.exec;return l===o||l===u.exec?m&&!i?{done:!0,value:f(e,t,a)}:{done:!0,value:s(t,e,a)}:{done:!1}}));a(String.prototype,n,g[0]),a(u,p,g[1])}d&&l(u[p],"sham",!0)}},function(n,e,t){var r=t(0),a=t(11),o=t(7),i=t(4),s=t(21),l=t(90),c=r.TypeError;n.exports=function(n,e){var t=n.exec;if(i(t)){var r=a(t,n,e);return null!==r&&o(r),r}if("RegExp"===s(n))return a(l,n,e);throw c("RegExp#exec called on incompatible receiver")}},function(n,e,t){"use strict";var r=t(2),a=t(1),o=t(59),i=t(19),s=t(45),l=a([].join),c=o!=Object,u=s("join",",");r({target:"Array",proto:!0,forced:c||!u},{join:function(n){return l(i(this),void 0===n?",":n)}})},function(n,e,t){var r=t(0),a=t(109),o=r["__core-js_shared__"]||a("__core-js_shared__",{});n.exports=o},function(n,e,t){var r=t(0),a=Object.defineProperty;n.exports=function(n,e){try{a(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(49),a=t(3);n.exports=!!Object.getOwnPropertySymbols&&!a((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r=t(19),a=t(112),o=t(20),i=function(n){return function(e,t,i){var s,l=r(e),c=o(l),u=a(i,c);if(n&&t!=t){for(;c>u;)if((s=l[u++])!=s)return!0}else for(;c>u;u++)if((n||u in l)&&l[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e,t){var r=t(52),a=Math.max,o=Math.min;n.exports=function(n,e){var t=r(n);return t<0?a(t+e,0):o(t,e)}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,o=a&&!r.call({1:2},1);e.f=o?function(n){var e=a(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(10),a=t(159),o=t(39),i=t(13);n.exports=function(n,e,t){for(var s=a(e),l=i.f,c=o.f,u=0;u<s.length;u++){var d=s[u];r(n,d)||t&&r(t,d)||l(n,d,c(e,d))}}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(0),a=t(10),o=t(4),i=t(15),s=t(83),l=t(161),c=s("IE_PROTO"),u=r.Object,d=u.prototype;n.exports=l?u.getPrototypeOf:function(n){var e=i(n);if(a(e,c))return e[c];var t=e.constructor;return o(t)&&e instanceof t?t.prototype:e instanceof u?d:null}},function(n,e,t){var r={};r[t(5)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(7),a=t(166),o=t(5)("species");n.exports=function(n,e){var t,i=r(n).constructor;return void 0===i||null==(t=r(i)[o])?e:a(t)}},function(n,e,t){var r=t(0),a=t(112),o=t(20),i=t(66),s=r.Array,l=Math.max;n.exports=function(n,e,t){for(var r=o(n),c=a(e,r),u=a(void 0===t?r:t,r),d=s(l(u-c,0)),p=0;c<u;c++,p++)i(d,p,n[c]);return d.length=p,d}},function(n,e,t){t(181)("iterator")},function(n,e,t){"use strict";var r=t(171).charAt;n.exports=function(n,e,t){return e+(t?r(n,e).length:1)}},function(n,e,t){var r=t(269),a=t(48),o=Object.prototype,i=o.hasOwnProperty,s=o.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return a(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(41)(t(28),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(289),a=t(296),o=t(298),i=t(299),s=t(300);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(26),a=t(130),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(i.test(n)||!o.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(58),a=t(48);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(75);t(74),t(89),t(6),t(121),t(24),t(31);var r=t(96);t(40),t(25);function a(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=null==n?null:"undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var r,a,o=[],i=!0,s=!1;try{for(t=t.call(n);!(i=(r=t.next()).done)&&(o.push(r.value),!e||o.length!==e);i=!0);}catch(n){s=!0,a=n}finally{try{i||null==t.return||t.return()}finally{if(s)throw a}}return o}}(n,e)||Object(r.a)(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";var r=t(2),a=t(54).some;r({target:"Array",proto:!0,forced:!t(45)("some")},{some:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(11),a=t(105),o=t(7),i=t(50),s=t(12),l=t(18),c=t(46),u=t(122),d=t(106);a("match",(function(n,e,t){return[function(e){var t=l(this),a=null==e?void 0:c(e,n);return a?r(a,e,t):new RegExp(e)[n](s(t))},function(n){var r=o(this),a=s(n),l=t(e,r,a);if(l.done)return l.value;if(!r.global)return d(r,a);var c=r.unicode;r.lastIndex=0;for(var p,m=[],h=0;null!==(p=d(r,a));){var f=s(p[0]);m[h]=f,""===f&&(r.lastIndex=u(a,i(r.lastIndex),c)),h++}return 0===h?null:m}]}))},function(n,e,t){var r=t(5),a=t(32),o=t(13),i=r("unscopables"),s=Array.prototype;null==s[i]&&o.f(s,i,{configurable:!0,value:a(null)}),n.exports=function(n){s[i][n]=!0}},function(n,e,t){var r=function(n){"use strict";var e=Object.prototype,t=e.hasOwnProperty,r="function"==typeof Symbol?Symbol:{},a=r.iterator||"@@iterator",o=r.asyncIterator||"@@asyncIterator",i=r.toStringTag||"@@toStringTag";function s(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{s({},"")}catch(n){s=function(n,e,t){return n[e]=t}}function l(n,e,t,r){var a=e&&e.prototype instanceof d?e:d,o=Object.create(a.prototype),i=new _(r||[]);return o._invoke=function(n,e,t){var r="suspendedStart";return function(a,o){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===a)throw o;return j()}for(t.method=a,t.arg=o;;){var i=t.delegate;if(i){var s=y(i,t);if(s){if(s===u)continue;return s}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===r)throw r="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);r="executing";var l=c(n,e,t);if("normal"===l.type){if(r=t.done?"completed":"suspendedYield",l.arg===u)continue;return{value:l.arg,done:t.done}}"throw"===l.type&&(r="completed",t.method="throw",t.arg=l.arg)}}}(n,t,i),o}function c(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=l;var u={};function d(){}function p(){}function m(){}var h={};s(h,a,(function(){return this}));var f=Object.getPrototypeOf,g=f&&f(f(k([])));g&&g!==e&&t.call(g,a)&&(h=g);var v=m.prototype=d.prototype=Object.create(h);function x(n){["next","throw","return"].forEach((function(e){s(n,e,(function(n){return this._invoke(e,n)}))}))}function b(n,e){var r;this._invoke=function(a,o){function i(){return new e((function(r,i){!function r(a,o,i,s){var l=c(n[a],n,o);if("throw"!==l.type){var u=l.arg,d=u.value;return d&&"object"==typeof d&&t.call(d,"__await")?e.resolve(d.__await).then((function(n){r("next",n,i,s)}),(function(n){r("throw",n,i,s)})):e.resolve(d).then((function(n){u.value=n,i(u)}),(function(n){return r("throw",n,i,s)}))}s(l.arg)}(a,o,r,i)}))}return r=r?r.then(i,i):i()}}function y(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,y(n,e),"throw"===e.method))return u;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return u}var r=c(t,n.iterator,e.arg);if("throw"===r.type)return e.method="throw",e.arg=r.arg,e.delegate=null,u;var a=r.arg;return a?a.done?(e[n.resultName]=a.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,u):a:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,u)}function T(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function w(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function _(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(T,this),this.reset(!0)}function k(n){if(n){var e=n[a];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,o=function e(){for(;++r<n.length;)if(t.call(n,r))return e.value=n[r],e.done=!1,e;return e.value=void 0,e.done=!0,e};return o.next=o}}return{next:j}}function j(){return{value:void 0,done:!0}}return p.prototype=m,s(v,"constructor",m),s(m,"constructor",p),p.displayName=s(m,i,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===p||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,m):(n.__proto__=m,s(n,i,"GeneratorFunction")),n.prototype=Object.create(v),n},n.awrap=function(n){return{__await:n}},x(b.prototype),s(b.prototype,o,(function(){return this})),n.AsyncIterator=b,n.async=function(e,t,r,a,o){void 0===o&&(o=Promise);var i=new b(l(e,t,r,a),o);return n.isGeneratorFunction(t)?i:i.next().then((function(n){return n.done?n.value:i.next()}))},x(v),s(v,i,"Generator"),s(v,a,(function(){return this})),s(v,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var r=e.pop();if(r in n)return t.value=r,t.done=!1,t}return t.done=!0,t}},n.values=k,_.prototype={constructor:_,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(w),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function r(t,r){return i.type="throw",i.arg=n,e.next=t,r&&(e.method="next",e.arg=void 0),!!r}for(var a=this.tryEntries.length-1;a>=0;--a){var o=this.tryEntries[a],i=o.completion;if("root"===o.tryLoc)return r("end");if(o.tryLoc<=this.prev){var s=t.call(o,"catchLoc"),l=t.call(o,"finallyLoc");if(s&&l){if(this.prev<o.catchLoc)return r(o.catchLoc,!0);if(this.prev<o.finallyLoc)return r(o.finallyLoc)}else if(s){if(this.prev<o.catchLoc)return r(o.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return r(o.finallyLoc)}}}},abrupt:function(n,e){for(var r=this.tryEntries.length-1;r>=0;--r){var a=this.tryEntries[r];if(a.tryLoc<=this.prev&&t.call(a,"finallyLoc")&&this.prev<a.finallyLoc){var o=a;break}}o&&("break"===n||"continue"===n)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var i=o?o.completion:{};return i.type=n,i.arg=e,o?(this.method="next",this.next=o.finallyLoc,u):this.complete(i)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),u},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),w(t),u}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var r=t.completion;if("throw"===r.type){var a=r.arg;w(t)}return a}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:k(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),u}},n}(n.exports);try{regeneratorRuntime=r}catch(n){"object"==typeof globalThis?globalThis.regeneratorRuntime=r:Function("r","regeneratorRuntime = r")(r)}},function(n,e,t){var r=t(2),a=t(9),o=t(13).f;r({target:"Object",stat:!0,forced:Object.defineProperty!==o,sham:!a},{defineProperty:o})},function(n,e,t){"use strict";var r=t(1),a=t(63).PROPER,o=t(14),i=t(7),s=t(33),l=t(12),c=t(3),u=t(145),d=RegExp.prototype,p=d.toString,m=r(u),h=c((function(){return"/a/b"!=p.call({source:"a",flags:"b"})})),f=a&&"toString"!=p.name;(h||f)&&o(RegExp.prototype,"toString",(function(){var n=i(this),e=l(n.source),t=n.flags;return"/"+e+"/"+l(void 0===t&&s(d,n)&&!("flags"in d)?m(n):t)}),{unsafe:!0})},function(n,e,t){"use strict";var r=t(19),a=t(135),o=t(62),i=t(36),s=t(13).f,l=t(158),c=t(22),u=t(9),d=i.set,p=i.getterFor("Array Iterator");n.exports=l(Array,"Array",(function(n,e){d(this,{type:"Array Iterator",target:r(n),index:0,kind:e})}),(function(){var n=p(this),e=n.target,t=n.kind,r=n.index++;return!e||r>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:r,done:!1}:"values"==t?{value:e[r],done:!1}:{value:[r,e[r]],done:!1}}),"values");var m=o.Arguments=o.Array;if(a("keys"),a("values"),a("entries"),!c&&u&&"values"!==m.name)try{s(m,"name",{value:"values"})}catch(n){}},function(n,e,t){var r=t(9),a=t(153),o=t(13),i=t(7),s=t(19),l=t(82);e.f=r&&!a?Object.defineProperties:function(n,e){i(n);for(var t,r=s(e),a=l(e),c=a.length,u=0;c>u;)o.f(n,t=a[u++],r[t]);return n}},function(n,e,t){var r=t(0),a=t(11),o=t(35),i=t(7),s=t(81),l=t(102),c=r.TypeError;n.exports=function(n,e){var t=arguments.length<2?l(n):e;if(o(t))return i(a(t,n));throw c(s(n)+" is not iterable")}},function(n,e,t){var r=t(0).TypeError;n.exports=function(n,e){if(n<e)throw r("Not enough arguments");return n}},function(n,e,t){var r=t(250);n.exports=function(n,e){return new(r(n))(0===e?0:e)}},function(n,e,t){var r=t(8),a=t(21),o=t(5)("match");n.exports=function(n){var e;return r(n)&&(void 0!==(e=n[o])?!!e:"RegExp"==a(n))}},function(n,e,t){"use strict";var r=t(7);n.exports=function(){var n=r(this),e="";return n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.dotAll&&(e+="s"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},function(n,e,t){var r=t(4),a=t(8),o=t(64);n.exports=function(n,e,t){var i,s;return o&&r(i=e.constructor)&&i!==t&&a(s=i.prototype)&&s!==t.prototype&&o(n,s),n}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,o=/^0o[0-7]+$/i,i=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),u=Object.prototype.toString,d=Math.max,p=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=a.test(n);return s||o.test(n)?i(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,a,o,i,s,l,c=0,u=!1,g=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function x(e){var t=r,o=a;return r=a=void 0,c=e,i=n.apply(o,t)}function b(n){return c=n,s=setTimeout(T,e),u?x(n):i}function y(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=o}function T(){var n=m();if(y(n))return w(n);s=setTimeout(T,function(n){var t=e-(n-l);return g?p(t,o-(n-c)):t}(n))}function w(n){return s=void 0,v&&r?x(n):(r=a=void 0,i)}function _(){var n=m(),t=y(n);if(r=arguments,a=this,l=n,t){if(void 0===s)return b(l);if(g)return s=setTimeout(T,e),x(l)}return void 0===s&&(s=setTimeout(T,e)),i}return e=f(e)||0,h(t)&&(u=!!t.leading,o=(g="maxWait"in t)?d(f(t.maxWait)||0,e):o,v="trailing"in t?!!t.trailing:v),_.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=a=s=void 0},_.flush=function(){return void 0===s?i:w(m())},_}},function(n,e,t){var r=t(1),a=t(18),o=t(12),i=t(150),s=r("".replace),l="["+i+"]",c=RegExp("^"+l+l+"*"),u=RegExp(l+l+"*$"),d=function(n){return function(e){var t=o(a(e));return 1&n&&(t=s(t,c,"")),2&n&&(t=s(t,u,"")),t}};n.exports={start:d(1),end:d(2),trim:d(3)}},function(n,e){n.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},function(n,e,t){var r=t(1),a=t(14),o=Date.prototype,i=r(o.toString),s=r(o.getTime);"Invalid Date"!=String(new Date(NaN))&&a(o,"toString",(function(){var n=s(this);return n==n?i(this):"Invalid Date"}))},function(n,e,t){var r=t(110);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(9),a=t(3);n.exports=r&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(9),a=t(3),o=t(78);n.exports=!r&&!a((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(0),a=t(11),o=t(8),i=t(80),s=t(46),l=t(234),c=t(5),u=r.TypeError,d=c("toPrimitive");n.exports=function(n,e){if(!o(n)||i(n))return n;var t,r=s(n,d);if(r){if(void 0===e&&(e="default"),t=a(r,n,e),!o(t)||i(t))return t;throw u("Can't convert object to primitive value")}return void 0===e&&(e="number"),l(n,e)}},function(n,e,t){var r=t(1),a=t(10),o=t(19),i=t(111).indexOf,s=t(61),l=r([].push);n.exports=function(n,e){var t,r=o(n),c=0,u=[];for(t in r)!a(s,t)&&a(r,t)&&l(u,t);for(;e.length>c;)a(r,t=e[c++])&&(~i(u,t)||l(u,t));return u}},function(n,e,t){var r=t(16);n.exports=r("document","documentElement")},function(n,e,t){"use strict";var r=t(2),a=t(11),o=t(22),i=t(63),s=t(4),l=t(221),c=t(117),u=t(64),d=t(56),p=t(23),m=t(14),h=t(5),f=t(62),g=t(160),v=i.PROPER,x=i.CONFIGURABLE,b=g.IteratorPrototype,y=g.BUGGY_SAFARI_ITERATORS,T=h("iterator"),w=function(){return this};n.exports=function(n,e,t,i,h,g,_){l(t,e,i);var k,j,I,z=function(n){if(n===h&&q)return q;if(!y&&n in A)return A[n];switch(n){case"keys":case"values":case"entries":return function(){return new t(this,n)}}return function(){return new t(this)}},E=e+" Iterator",S=!1,A=n.prototype,C=A[T]||A["@@iterator"]||h&&A[h],q=!y&&C||z(h),P="Array"==e&&A.entries||C;if(P&&(k=c(P.call(new n)))!==Object.prototype&&k.next&&(o||c(k)===b||(u?u(k,b):s(k[T])||m(k,T,w)),d(k,E,!0,!0),o&&(f[E]=w)),v&&"values"==h&&C&&"values"!==C.name&&(!o&&x?p(A,"name","values"):(S=!0,q=function(){return a(C,this)})),h)if(j={values:z("values"),keys:g?q:z("keys"),entries:z("entries")},_)for(I in j)(y||S||!(I in A))&&m(A,I,j[I]);else r({target:e,proto:!0,forced:y||S},j);return o&&!_||A[T]===q||m(A,T,q,{name:h}),f[e]=q,j}},function(n,e,t){var r=t(16),a=t(1),o=t(55),i=t(116),s=t(7),l=a([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=o.f(s(n)),t=i.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var r,a,o,i=t(3),s=t(4),l=t(32),c=t(117),u=t(14),d=t(5),p=t(22),m=d("iterator"),h=!1;[].keys&&("next"in(o=[].keys())?(a=c(c(o)))!==Object.prototype&&(r=a):h=!0),null==r||i((function(){var n={};return r[m].call(n)!==n}))?r={}:p&&(r=l(r)),s(r[m])||u(r,m,(function(){return this})),n.exports={IteratorPrototype:r,BUGGY_SAFARI_ITERATORS:h}},function(n,e,t){var r=t(3);n.exports=!r((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){var r=t(0);n.exports=r.Promise},function(n,e,t){var r=t(5),a=t(62),o=r("iterator"),i=Array.prototype;n.exports=function(n){return void 0!==n&&(a.Array===n||i[o]===n)}},function(n,e,t){var r=t(11),a=t(7),o=t(46);n.exports=function(n,e,t){var i,s;a(n);try{if(!(i=o(n,"return"))){if("throw"===e)throw t;return t}i=r(i,n)}catch(n){s=!0,i=n}if("throw"===e)throw t;if(s)throw i;return a(i),t}},function(n,e,t){var r=t(5)("iterator"),a=!1;try{var o=0,i={next:function(){return{done:!!o++}},return:function(){a=!0}};i[r]=function(){return this},Array.from(i,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!a)return!1;var t=!1;try{var o={};o[r]=function(){return{next:function(){return{done:t=!0}}}},n(o)}catch(n){}return t}},function(n,e,t){var r=t(0),a=t(85),o=t(81),i=r.TypeError;n.exports=function(n){if(a(n))return n;throw i(o(n)+" is not a constructor")}},function(n,e,t){var r,a,o,i,s=t(0),l=t(34),c=t(53),u=t(4),d=t(10),p=t(3),m=t(157),h=t(65),f=t(78),g=t(142),v=t(168),x=t(86),b=s.setImmediate,y=s.clearImmediate,T=s.process,w=s.Dispatch,_=s.Function,k=s.MessageChannel,j=s.String,I=0,z={};try{r=s.location}catch(n){}var E=function(n){if(d(z,n)){var e=z[n];delete z[n],e()}},S=function(n){return function(){E(n)}},A=function(n){E(n.data)},C=function(n){s.postMessage(j(n),r.protocol+"//"+r.host)};b&&y||(b=function(n){g(arguments.length,1);var e=u(n)?n:_(n),t=h(arguments,1);return z[++I]=function(){l(e,void 0,t)},a(I),I},y=function(n){delete z[n]},x?a=function(n){T.nextTick(S(n))}:w&&w.now?a=function(n){w.now(S(n))}:k&&!v?(i=(o=new k).port2,o.port1.onmessage=A,a=c(i.postMessage,i)):s.addEventListener&&u(s.postMessage)&&!s.importScripts&&r&&"file:"!==r.protocol&&!p(C)?(a=C,s.addEventListener("message",A,!1)):a="onreadystatechange"in f("script")?function(n){m.appendChild(f("script")).onreadystatechange=function(){m.removeChild(this),E(n)}}:function(n){setTimeout(S(n),0)}),n.exports={set:b,clear:y}},function(n,e,t){var r=t(27);n.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(r)},function(n,e,t){var r=t(7),a=t(8),o=t(170);n.exports=function(n,e){if(r(n),a(e)&&e.constructor===n)return e;var t=o.f(n);return(0,t.resolve)(e),t.promise}},function(n,e,t){"use strict";var r=t(35),a=function(n){var e,t;this.promise=new n((function(n,r){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=r})),this.resolve=r(e),this.reject=r(t)};n.exports.f=function(n){return new a(n)}},function(n,e,t){var r=t(1),a=t(52),o=t(12),i=t(18),s=r("".charAt),l=r("".charCodeAt),c=r("".slice),u=function(n){return function(e,t){var r,u,d=o(i(e)),p=a(t),m=d.length;return p<0||p>=m?n?"":void 0:(r=l(d,p))<55296||r>56319||p+1===m||(u=l(d,p+1))<56320||u>57343?n?s(d,p):r:n?c(d,p,p+2):u-56320+(r-55296<<10)+65536}};n.exports={codeAt:u(!1),charAt:u(!0)}},function(n,e){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,e,t){var r=t(78)("span").classList,a=r&&r.constructor&&r.constructor.prototype;n.exports=a===Object.prototype?void 0:a},function(n,e,t){var r=t(2),a=t(3),o=t(15),i=t(117),s=t(161);r({target:"Object",stat:!0,forced:a((function(){i(1)})),sham:!s},{getPrototypeOf:function(n){return i(o(n))}})},function(n,e,t){var r=t(0),a=t(144),o=r.TypeError;n.exports=function(n){if(a(n))throw o("The method doesn't accept regular expressions");return n}},function(n,e,t){var r=t(5)("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[r]=!1,"/./"[n](e)}catch(n){}}return!1}},function(n,e,t){"use strict";var r=t(54).forEach,a=t(45)("forEach");n.exports=a?[].forEach:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,e,t){var r=t(3);n.exports=!r((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,e,t){var r=t(21),a=t(19),o=t(55).f,i=t(120),s="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return s&&"Window"==r(n)?function(n){try{return o(n)}catch(n){return i(s)}}(n):o(a(n))}},function(n,e,t){var r=t(5);e.f=r},function(n,e,t){var r=t(258),a=t(10),o=t(180),i=t(13).f;n.exports=function(n){var e=r.Symbol||(r.Symbol={});a(e,n)||i(e,n,{value:o.f(n)})}},function(n,e,t){var r=t(2),a=t(259);r({target:"Array",stat:!0,forced:!t(165)((function(n){Array.from(n)}))},{from:a})},function(n,e,t){var r=t(12);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){t(2)({target:"Object",stat:!0,sham:!t(9)},{create:t(32)})},function(n,e,t){var r=t(2),a=t(0),o=t(16),i=t(34),s=t(1),l=t(3),c=a.Array,u=o("JSON","stringify"),d=s(/./.exec),p=s("".charAt),m=s("".charCodeAt),h=s("".replace),f=s(1..toString),g=/[\uD800-\uDFFF]/g,v=/^[\uD800-\uDBFF]$/,x=/^[\uDC00-\uDFFF]$/,b=function(n,e,t){var r=p(t,e-1),a=p(t,e+1);return d(v,n)&&!d(x,a)||d(x,n)&&!d(v,r)?"\\u"+f(m(n,0),16):n},y=l((function(){return'"\\udf06\\ud834"'!==u("\udf06\ud834")||'"\\udead"'!==u("\udead")}));u&&r({target:"JSON",stat:!0,forced:y},{stringify:function(n,e,t){for(var r=0,a=arguments.length,o=c(a);r<a;r++)o[r]=arguments[r];var s=i(u,null,o);return"string"==typeof s?h(s,g,b):s}})},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,a=n.length;++t<r;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(91),a=t(280),o=t(281),i=t(282),s=t(283),l=t(284);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=a,c.prototype.delete=o,c.prototype.get=i,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(58),a=t(125);n.exports=function(n){if(!a(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(301),a=t(48);n.exports=function n(e,t,o,i,s){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:r(e,t,o,i,n,s))}},function(n,e,t){var r=t(194),a=t(304),o=t(195);n.exports=function(n,e,t,i,s,l){var c=1&t,u=n.length,d=e.length;if(u!=d&&!(c&&d>u))return!1;var p=l.get(n),m=l.get(e);if(p&&m)return p==e&&m==n;var h=-1,f=!0,g=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++h<u;){var v=n[h],x=e[h];if(i)var b=c?i(x,v,h,e,n,l):i(v,x,h,n,e,l);if(void 0!==b){if(b)continue;f=!1;break}if(g){if(!a(e,(function(n,e){if(!o(g,e)&&(v===n||s(v,n,t,i,l)))return g.push(e)}))){f=!1;break}}else if(v!==x&&!s(v,x,t,i,l)){f=!1;break}}return l.delete(n),l.delete(e),f}},function(n,e,t){var r=t(126),a=t(302),o=t(303);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=a,i.prototype.has=o,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(314),a=t(320),o=t(200);n.exports=function(n){return o(n)?r(n):a(n)}},function(n,e,t){(function(n){var r=t(28),a=t(316),o=e&&!e.nodeType&&e,i=o&&"object"==typeof n&&n&&!n.nodeType&&n,s=i&&i.exports===o?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||a;n.exports=l}).call(this,t(147)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(317),a=t(318),o=t(319),i=o&&o.isTypedArray,s=i?a(i):r;n.exports=s},function(n,e,t){var r=t(190),a=t(128);n.exports=function(n){return null!=n&&a(n.length)&&!r(n)}},function(n,e,t){var r=t(41)(t(28),"Set");n.exports=r},function(n,e,t){var r=t(125);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(205),a=t(95);n.exports=function(n,e){for(var t=0,o=(e=r(e,n)).length;null!=n&&t<o;)n=n[a(e[t++])];return t&&t==o?n:void 0}},function(n,e,t){var r=t(26),a=t(129),o=t(331),i=t(334);n.exports=function(n,e){return r(n)?n:a(n,e)?[n]:o(i(n))}},function(n,e,t){"use strict";var r=t(0),a=t(1),o=t(35),i=t(8),s=t(10),l=t(65),c=t(60),u=r.Function,d=a([].concat),p=a([].join),m={},h=function(n,e,t){if(!s(m,e)){for(var r=[],a=0;a<e;a++)r[a]="a["+a+"]";m[e]=u("C,a","return new C("+p(r,",")+")")}return m[e](n,t)};n.exports=c?u.bind:function(n){var e=o(this),t=e.prototype,r=l(arguments,1),a=function(){var t=d(r,l(arguments));return this instanceof a?h(e,t.length,t):e.apply(n,t)};return i(t)&&(a.prototype=t),a}},function(n,e,t){"use strict";var r=t(2),a=t(366).start;r({target:"String",proto:!0,forced:t(368)},{padStart:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){},function(n,e,t){},function(n,e,t){t(2)({target:"Object",stat:!0},{setPrototypeOf:t(64)})},function(n,e,t){var r=t(2),a=t(16),o=t(34),i=t(206),s=t(166),l=t(7),c=t(8),u=t(32),d=t(3),p=a("Reflect","construct"),m=Object.prototype,h=[].push,f=d((function(){function n(){}return!(p((function(){}),[],n)instanceof n)})),g=!d((function(){p((function(){}))})),v=f||g;r({target:"Reflect",stat:!0,forced:v,sham:v},{construct:function(n,e){s(n),l(e);var t=arguments.length<3?n:s(arguments[2]);if(g&&!f)return p(n,e,t);if(n==t){switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3])}var r=[null];return o(h,r,e),new(o(i,n,r))}var a=t.prototype,d=u(c(a)?a:m),v=o(n,d,e);return c(v)?v:d}})},function(n,e,t){var r=t(2),a=t(0),o=t(56);r({global:!0},{Reflect:{}}),o(a.Reflect,"Reflect",!0)},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(267),a=t(272),o=t(343),i=t(351),s=t(360),l=t(229),c=o((function(n){var e=l(n);return s(e)&&(e=void 0),i(r(n,1,s,!0),a(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,a=r.exec(t);if(!a)return t;var o="",i=0,s=0;for(i=a.index;i<t.length;i++){switch(t.charCodeAt(i)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==i&&(o+=t.substring(s,i)),s=i+1,o+=e}return s!==i?o+t.substring(s,i):o}},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},a=(t(369),t(29)),o=Object(a.a)(r,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=o.exports},function(n,e,t){"use strict";t.r(e);t(37),t(6),t(38),t(43),t(30);var r={name:"CodeGroup",data:function(){return{codeTabs:[],activeCodeTabIndex:-1}},watch:{activeCodeTabIndex:function(n){this.codeTabs.forEach((function(n){n.elm.classList.remove("theme-code-block__active")})),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted:function(){var n=this;this.codeTabs=(this.$slots.default||[]).filter((function(n){return Boolean(n.componentOptions)})).map((function(e,t){return""===e.componentOptions.propsData.active&&(n.activeCodeTabIndex=t),{title:e.componentOptions.propsData.title,elm:e.elm}})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab:function(n){this.activeCodeTabIndex=n}}},a=(t(370),t(29)),o=Object(a.a)(r,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"theme-code-group"},[t("div",{staticClass:"theme-code-group__nav"},[t("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(e,r){return t("li",{key:e.title,staticClass:"theme-code-group__li"},[t("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(e.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?t("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=o.exports},function(n,e,t){"use strict";var r=t(9),a=t(0),o=t(1),i=t(101),s=t(14),l=t(10),c=t(146),u=t(33),d=t(80),p=t(155),m=t(3),h=t(55).f,f=t(39).f,g=t(13).f,v=t(365),x=t(149).trim,b=a.Number,y=b.prototype,T=a.TypeError,w=o("".slice),_=o("".charCodeAt),k=function(n){var e=p(n,"number");return"bigint"==typeof e?e:j(e)},j=function(n){var e,t,r,a,o,i,s,l,c=p(n,"number");if(d(c))throw T("Cannot convert a Symbol value to a number");if("string"==typeof c&&c.length>2)if(c=x(c),43===(e=_(c,0))||45===e){if(88===(t=_(c,2))||120===t)return NaN}else if(48===e){switch(_(c,1)){case 66:case 98:r=2,a=49;break;case 79:case 111:r=8,a=55;break;default:return+c}for(i=(o=w(c,2)).length,s=0;s<i;s++)if((l=_(o,s))<48||l>a)return NaN;return parseInt(o,r)}return+c};if(i("Number",!b(" 0o1")||!b("0b1")||b("+0x1"))){for(var I,z=function(n){var e=arguments.length<1?0:b(k(n)),t=this;return u(y,t)&&m((function(){v(t)}))?c(Object(e),t,z):e},E=r?h(b):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","),S=0;E.length>S;S++)l(b,I=E[S])&&!l(z,I)&&g(z,I,f(b,I));z.prototype=y,y.constructor=z,s(a,"Number",z)}},function(n,e,t){var r=t(3),a=t(0).RegExp;n.exports=r((function(){var n=a(".","s");return!(n.dotAll&&n.exec("\n")&&"s"===n.flags)}))},function(n,e,t){"use strict";var r=t(160).IteratorPrototype,a=t(32),o=t(47),i=t(56),s=t(62),l=function(){return this};n.exports=function(n,e,t,c){var u=e+" Iterator";return n.prototype=a(r,{next:o(+!c,t)}),i(n,u,!1,!0),s[u]=l,n}},function(n,e,t){var r=t(14);n.exports=function(n,e,t){for(var a in e)r(n,a,e[a],t);return n}},function(n,e,t){"use strict";var r=t(16),a=t(13),o=t(5),i=t(9),s=o("species");n.exports=function(n){var e=r(n),t=a.f;i&&e&&!e[s]&&t(e,s,{configurable:!0,get:function(){return this}})}},function(n,e,t){var r=t(0),a=t(33),o=r.TypeError;n.exports=function(n,e){if(a(e,n))return n;throw o("Incorrect invocation")}},function(n,e,t){var r=t(2),a=t(9),o=t(159),i=t(19),s=t(39),l=t(66);r({target:"Object",stat:!0,sham:!a},{getOwnPropertyDescriptors:function(n){for(var e,t,r=i(n),a=s.f,c=o(r),u={},d=0;c.length>d;)void 0!==(t=a(r,e=c[d++]))&&l(u,e,t);return u}})},function(n,e,t){var r=t(3),a=t(0).RegExp;n.exports=r((function(){var n=a("(?<a>b)","g");return"b"!==n.exec("b").groups.a||"bc"!=="b".replace(n,"$<a>c")}))},function(n,e,t){"use strict";var r=t(2),a=t(111).includes,o=t(135);r({target:"Array",proto:!0},{includes:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}}),o("includes")},function(n,e,t){"use strict";var r=t(2),a=t(1),o=t(175),i=t(18),s=t(12),l=t(176),c=a("".indexOf);r({target:"String",proto:!0,forced:!l("includes")},{includes:function(n){return!!~c(s(i(this)),s(o(n)),arguments.length>1?arguments[1]:void 0)}})},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){"use strict";var r=t(2),a=t(149).trim;r({target:"String",proto:!0,forced:t(363)("trim")},{trim:function(){return a(this)}})},function(n,e,t){var r=t(120),a=Math.floor,o=function(n,e){var t=n.length,l=a(t/2);return t<8?i(n,e):s(n,o(r(n,0,l),e),o(r(n,l),e),e)},i=function(n,e){for(var t,r,a=n.length,o=1;o<a;){for(r=o,t=n[o];r&&e(n[r-1],t)>0;)n[r]=n[--r];r!==o++&&(n[r]=t)}return n},s=function(n,e,t,r){for(var a=e.length,o=t.length,i=0,s=0;i<a||s<o;)n[i+s]=i<a&&s<o?r(e[i],t[s])<=0?e[i++]:t[s++]:i<a?e[i++]:t[s++];return n};n.exports=o},function(n,e,t){var r=t(0),a=t(9),o=t(104).MISSED_STICKY,i=t(21),s=t(13).f,l=t(36).get,c=RegExp.prototype,u=r.TypeError;a&&o&&s(c,"sticky",{configurable:!0,get:function(){if(this!==c){if("RegExp"===i(this))return!!l(this).sticky;throw u("Incompatible receiver, RegExp required")}}})},function(n,e,t){n.exports=t(379)},function(n,e,t){var r=t(0),a=t(11),o=t(4),i=t(8),s=r.TypeError;n.exports=function(n,e){var t,r;if("string"===e&&o(t=n.toString)&&!i(r=a(t,n)))return r;if(o(t=n.valueOf)&&!i(r=a(t,n)))return r;if("string"!==e&&o(t=n.toString)&&!i(r=a(t,n)))return r;throw s("Can't convert object to primitive value")}},function(n,e,t){var r=t(0),a=t(4),o=t(84),i=r.WeakMap;n.exports=a(i)&&/native code/.test(o(i))},function(n,e,t){var r=t(0),a=t(4),o=r.String,i=r.TypeError;n.exports=function(n){if("object"==typeof n||a(n))return n;throw i("Can't set "+o(n)+" as a prototype")}},function(n,e,t){"use strict";var r,a,o,i,s=t(2),l=t(22),c=t(0),u=t(16),d=t(11),p=t(162),m=t(14),h=t(222),f=t(64),g=t(56),v=t(223),x=t(35),b=t(4),y=t(8),T=t(224),w=t(84),_=t(238),k=t(165),j=t(119),I=t(167).set,z=t(239),E=t(169),S=t(242),A=t(170),C=t(243),q=t(244),P=t(36),B=t(101),O=t(5),R=t(245),D=t(86),M=t(49),N=O("species"),L="Promise",U=P.getterFor(L),$=P.set,J=P.getterFor(L),H=p&&p.prototype,F=p,V=H,G=c.TypeError,W=c.document,X=c.process,Y=A.f,Z=Y,K=!!(W&&W.createEvent&&c.dispatchEvent),Q=b(c.PromiseRejectionEvent),nn=!1,en=B(L,(function(){var n=w(F),e=n!==String(F);if(!e&&66===M)return!0;if(l&&!V.finally)return!0;if(M>=51&&/native code/.test(n))return!1;var t=new F((function(n){n(1)})),r=function(n){n((function(){}),(function(){}))};return(t.constructor={})[N]=r,!(nn=t.then((function(){}))instanceof r)||!e&&R&&!Q})),tn=en||!k((function(n){F.all(n).catch((function(){}))})),rn=function(n){var e;return!(!y(n)||!b(e=n.then))&&e},an=function(n,e){var t,r,a,o=e.value,i=1==e.state,s=i?n.ok:n.fail,l=n.resolve,c=n.reject,u=n.domain;try{s?(i||(2===e.rejection&&un(e),e.rejection=1),!0===s?t=o:(u&&u.enter(),t=s(o),u&&(u.exit(),a=!0)),t===n.promise?c(G("Promise-chain cycle")):(r=rn(t))?d(r,t,l,c):l(t)):c(o)}catch(n){u&&!a&&u.exit(),c(n)}},on=function(n,e){n.notified||(n.notified=!0,z((function(){for(var t,r=n.reactions;t=r.get();)an(t,n);n.notified=!1,e&&!n.rejection&&ln(n)})))},sn=function(n,e,t){var r,a;K?((r=W.createEvent("Event")).promise=e,r.reason=t,r.initEvent(n,!1,!0),c.dispatchEvent(r)):r={promise:e,reason:t},!Q&&(a=c["on"+n])?a(r):"unhandledrejection"===n&&S("Unhandled promise rejection",t)},ln=function(n){d(I,c,(function(){var e,t=n.facade,r=n.value;if(cn(n)&&(e=C((function(){D?X.emit("unhandledRejection",r,t):sn("unhandledrejection",t,r)})),n.rejection=D||cn(n)?2:1,e.error))throw e.value}))},cn=function(n){return 1!==n.rejection&&!n.parent},un=function(n){d(I,c,(function(){var e=n.facade;D?X.emit("rejectionHandled",e):sn("rejectionhandled",e,n.value)}))},dn=function(n,e,t){return function(r){n(e,r,t)}},pn=function(n,e,t){n.done||(n.done=!0,t&&(n=t),n.value=e,n.state=2,on(n,!0))},mn=function(n,e,t){if(!n.done){n.done=!0,t&&(n=t);try{if(n.facade===e)throw G("Promise can't be resolved itself");var r=rn(e);r?z((function(){var t={done:!1};try{d(r,e,dn(mn,t,n),dn(pn,t,n))}catch(e){pn(t,e,n)}})):(n.value=e,n.state=1,on(n,!1))}catch(e){pn({done:!1},e,n)}}};if(en&&(V=(F=function(n){T(this,V),x(n),d(r,this);var e=U(this);try{n(dn(mn,e),dn(pn,e))}catch(n){pn(e,n)}}).prototype,(r=function(n){$(this,{type:L,done:!1,notified:!1,parent:!1,reactions:new q,rejection:!1,state:0,value:void 0})}).prototype=h(V,{then:function(n,e){var t=J(this),r=Y(j(this,F));return t.parent=!0,r.ok=!b(n)||n,r.fail=b(e)&&e,r.domain=D?X.domain:void 0,0==t.state?t.reactions.add(r):z((function(){an(r,t)})),r.promise},catch:function(n){return this.then(void 0,n)}}),a=function(){var n=new r,e=U(n);this.promise=n,this.resolve=dn(mn,e),this.reject=dn(pn,e)},A.f=Y=function(n){return n===F||n===o?new a(n):Z(n)},!l&&b(p)&&H!==Object.prototype)){i=H.then,nn||(m(H,"then",(function(n,e){var t=this;return new F((function(n,e){d(i,t,n,e)})).then(n,e)}),{unsafe:!0}),m(H,"catch",V.catch,{unsafe:!0}));try{delete H.constructor}catch(n){}f&&f(H,V)}s({global:!0,wrap:!0,forced:en},{Promise:F}),g(F,L,!1,!0),v(L),o=u(L),s({target:L,stat:!0,forced:en},{reject:function(n){var e=Y(this);return d(e.reject,void 0,n),e.promise}}),s({target:L,stat:!0,forced:l||en},{resolve:function(n){return E(l&&this===o?F:this,n)}}),s({target:L,stat:!0,forced:tn},{all:function(n){var e=this,t=Y(e),r=t.resolve,a=t.reject,o=C((function(){var t=x(e.resolve),o=[],i=0,s=1;_(n,(function(n){var l=i++,c=!1;s++,d(t,e,n).then((function(n){c||(c=!0,o[l]=n,--s||r(o))}),a)})),--s||r(o)}));return o.error&&a(o.value),t.promise},race:function(n){var e=this,t=Y(e),r=t.reject,a=C((function(){var a=x(e.resolve);_(n,(function(n){d(a,e,n).then(t.resolve,r)}))}));return a.error&&r(a.value),t.promise}})},function(n,e,t){var r=t(0),a=t(53),o=t(11),i=t(7),s=t(81),l=t(163),c=t(20),u=t(33),d=t(141),p=t(102),m=t(164),h=r.TypeError,f=function(n,e){this.stopped=n,this.result=e},g=f.prototype;n.exports=function(n,e,t){var r,v,x,b,y,T,w,_=t&&t.that,k=!(!t||!t.AS_ENTRIES),j=!(!t||!t.IS_ITERATOR),I=!(!t||!t.INTERRUPTED),z=a(e,_),E=function(n){return r&&m(r,"normal",n),new f(!0,n)},S=function(n){return k?(i(n),I?z(n[0],n[1],E):z(n[0],n[1])):I?z(n,E):z(n)};if(j)r=n;else{if(!(v=p(n)))throw h(s(n)+" is not iterable");if(l(v)){for(x=0,b=c(n);b>x;x++)if((y=S(n[x]))&&u(g,y))return y;return new f(!1)}r=d(n,v)}for(T=r.next;!(w=o(T,r)).done;){try{y=S(w.value)}catch(n){m(r,"throw",n)}if("object"==typeof y&&y&&u(g,y))return y}return new f(!1)}},function(n,e,t){var r,a,o,i,s,l,c,u,d=t(0),p=t(53),m=t(39).f,h=t(167).set,f=t(168),g=t(240),v=t(241),x=t(86),b=d.MutationObserver||d.WebKitMutationObserver,y=d.document,T=d.process,w=d.Promise,_=m(d,"queueMicrotask"),k=_&&_.value;k||(r=function(){var n,e;for(x&&(n=T.domain)&&n.exit();a;){e=a.fn,a=a.next;try{e()}catch(n){throw a?i():o=void 0,n}}o=void 0,n&&n.enter()},f||x||v||!b||!y?!g&&w&&w.resolve?((c=w.resolve(void 0)).constructor=w,u=p(c.then,c),i=function(){u(r)}):x?i=function(){T.nextTick(r)}:(h=p(h,d),i=function(){h(r)}):(s=!0,l=y.createTextNode(""),new b(r).observe(l,{characterData:!0}),i=function(){l.data=s=!s})),n.exports=k||function(n){var e={fn:n,next:void 0};o&&(o.next=e),a||(a=e,i()),o=e}},function(n,e,t){var r=t(27),a=t(0);n.exports=/ipad|iphone|ipod/i.test(r)&&void 0!==a.Pebble},function(n,e,t){var r=t(27);n.exports=/web0s(?!.*chrome)/i.test(r)},function(n,e,t){var r=t(0);n.exports=function(n,e){var t=r.console;t&&t.error&&(1==arguments.length?t.error(n):t.error(n,e))}},function(n,e){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,e){var t=function(){this.head=null,this.tail=null};t.prototype={add:function(n){var e={item:n,next:null};this.head?this.tail.next=e:this.head=e,this.tail=e},get:function(){var n=this.head;if(n)return this.head=n.next,this.tail===n&&(this.tail=null),n.item}},n.exports=t},function(n,e){n.exports="object"==typeof window},function(n,e,t){var r=t(2),a=t(247);r({target:"Object",stat:!0,forced:Object.assign!==a},{assign:a})},function(n,e,t){"use strict";var r=t(9),a=t(1),o=t(11),i=t(3),s=t(82),l=t(116),c=t(114),u=t(15),d=t(59),p=Object.assign,m=Object.defineProperty,h=a([].concat);n.exports=!p||i((function(){if(r&&1!==p({b:1},p(m({},"a",{enumerable:!0,get:function(){m(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},e={},t=Symbol();return n[t]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){e[n]=n})),7!=p({},n)[t]||"abcdefghijklmnopqrst"!=s(p({},e)).join("")}))?function(n,e){for(var t=u(n),a=arguments.length,i=1,p=l.f,m=c.f;a>i;)for(var f,g=d(arguments[i++]),v=p?h(s(g),p(g)):s(g),x=v.length,b=0;x>b;)f=v[b++],r&&!o(m,g,f)||(t[f]=g[f]);return t}:p},function(n,e,t){"use strict";var r=t(2),a=t(22),o=t(162),i=t(3),s=t(16),l=t(4),c=t(119),u=t(169),d=t(14);if(r({target:"Promise",proto:!0,real:!0,forced:!!o&&i((function(){o.prototype.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var e=c(this,s("Promise")),t=l(n);return this.then(t?function(t){return u(e,n()).then((function(){return t}))}:n,t?function(t){return u(e,n()).then((function(){throw t}))}:n)}}),!a&&l(o)){var p=s("Promise").prototype.finally;o.prototype.finally!==p&&d(o.prototype,"finally",p,{unsafe:!0})}},function(n,e,t){"use strict";var r=t(118),a=t(73);n.exports=r?{}.toString:function(){return"[object "+a(this)+"]"}},function(n,e,t){var r=t(0),a=t(57),o=t(85),i=t(8),s=t(5)("species"),l=r.Array;n.exports=function(n){var e;return a(n)&&(e=n.constructor,(o(e)&&(e===l||a(e.prototype))||i(e)&&null===(e=e[s]))&&(e=void 0)),void 0===e?l:e}},function(n,e,t){"use strict";var r=t(2),a=t(252).left,o=t(45),i=t(49),s=t(86);r({target:"Array",proto:!0,forced:!o("reduce")||!s&&i>79&&i<83},{reduce:function(n){var e=arguments.length;return a(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(0),a=t(35),o=t(15),i=t(59),s=t(20),l=r.TypeError,c=function(n){return function(e,t,r,c){a(t);var u=o(e),d=i(u),p=s(u),m=n?p-1:0,h=n?-1:1;if(r<2)for(;;){if(m in d){c=d[m],m+=h;break}if(m+=h,n?m<0:p<=m)throw l("Reduce of empty array with no initial value")}for(;n?m>=0:p>m;m+=h)m in d&&(c=t(c,d[m],m,u));return c}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var r,a=t(2),o=t(1),i=t(39).f,s=t(50),l=t(12),c=t(175),u=t(18),d=t(176),p=t(22),m=o("".startsWith),h=o("".slice),f=Math.min,g=d("startsWith");a({target:"String",proto:!0,forced:!!(p||g||(r=i(String.prototype,"startsWith"),!r||r.writable))&&!g},{startsWith:function(n){var e=l(u(this));c(n);var t=s(f(arguments.length>1?arguments[1]:void 0,e.length)),r=l(n);return m?m(e,r,t):h(e,t,t+r.length)===r}})},function(n,e,t){var r=t(2),a=t(178),o=t(3),i=t(8),s=t(255).onFreeze,l=Object.freeze;r({target:"Object",stat:!0,forced:o((function(){l(1)})),sham:!a},{freeze:function(n){return l&&i(n)?l(s(n)):n}})},function(n,e,t){var r=t(2),a=t(1),o=t(61),i=t(8),s=t(10),l=t(13).f,c=t(55),u=t(179),d=t(256),p=t(77),m=t(178),h=!1,f=p("meta"),g=0,v=function(n){l(n,f,{value:{objectID:"O"+g++,weakData:{}}})},x=n.exports={enable:function(){x.enable=function(){},h=!0;var n=c.f,e=a([].splice),t={};t[f]=1,n(t).length&&(c.f=function(t){for(var r=n(t),a=0,o=r.length;a<o;a++)if(r[a]===f){e(r,a,1);break}return r},r({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:u.f}))},fastKey:function(n,e){if(!i(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!s(n,f)){if(!d(n))return"F";if(!e)return"E";v(n)}return n[f].objectID},getWeakData:function(n,e){if(!s(n,f)){if(!d(n))return!0;if(!e)return!1;v(n)}return n[f].weakData},onFreeze:function(n){return m&&h&&d(n)&&!s(n,f)&&v(n),n}};o[f]=!0},function(n,e,t){var r=t(3),a=t(8),o=t(21),i=t(257),s=Object.isExtensible,l=r((function(){s(1)}));n.exports=l||i?function(n){return!!a(n)&&((!i||"ArrayBuffer"!=o(n))&&(!s||s(n)))}:s},function(n,e,t){var r=t(3);n.exports=r((function(){if("function"==typeof ArrayBuffer){var n=new ArrayBuffer(8);Object.isExtensible(n)&&Object.defineProperty(n,"a",{value:8})}}))},function(n,e,t){var r=t(0);n.exports=r},function(n,e,t){"use strict";var r=t(0),a=t(53),o=t(11),i=t(15),s=t(260),l=t(163),c=t(85),u=t(20),d=t(66),p=t(141),m=t(102),h=r.Array;n.exports=function(n){var e=i(n),t=c(this),r=arguments.length,f=r>1?arguments[1]:void 0,g=void 0!==f;g&&(f=a(f,r>2?arguments[2]:void 0));var v,x,b,y,T,w,_=m(e),k=0;if(!_||this==h&&l(_))for(v=u(e),x=t?new this(v):h(v);v>k;k++)w=g?f(e[k],k):e[k],d(x,k,w);else for(T=(y=p(e,_)).next,x=t?new this:[];!(b=o(T,y)).done;k++)w=g?s(y,f,[b.value,k],!0):b.value,d(x,k,w);return x.length=k,x}},function(n,e,t){var r=t(7),a=t(164);n.exports=function(n,e,t,o){try{return o?e(r(t)[0],t[1]):e(t)}catch(e){a(n,"throw",e)}}},function(n,e,t){"use strict";var r=t(16),a=t(10),o=t(23),i=t(33),s=t(64),l=t(115),c=t(146),u=t(183),d=t(262),p=t(263),m=t(264),h=t(22);n.exports=function(n,e,t,f){var g=f?2:1,v=n.split("."),x=v[v.length-1],b=r.apply(null,v);if(b){var y=b.prototype;if(!h&&a(y,"cause")&&delete y.cause,!t)return b;var T=r("Error"),w=e((function(n,e){var t=u(f?e:n,void 0),r=f?new b(n):new b;return void 0!==t&&o(r,"message",t),m&&o(r,"stack",p(r.stack,2)),this&&i(y,this)&&c(r,this,w),arguments.length>g&&d(r,arguments[g]),r}));if(w.prototype=y,"Error"!==x&&(s?s(w,T):l(w,T,{name:!0})),l(w,b),!h)try{y.name!==x&&o(y,"name",x),y.constructor=w}catch(n){}return w}}},function(n,e,t){var r=t(8),a=t(23);n.exports=function(n,e){r(e)&&"cause"in e&&a(n,"cause",e.cause)}},function(n,e,t){var r=t(1)("".replace),a=String(Error("zxcasd").stack),o=/\n\s*at [^:]*:[^\n]*/,i=o.test(a);n.exports=function(n,e){if(i&&"string"==typeof n)for(;e--;)n=r(n,o,"");return n}},function(n,e,t){var r=t(3),a=t(47);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",a(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var r=t(9),a=t(3),o=t(7),i=t(32),s=t(183),l=Error.prototype.toString,c=a((function(){if(r){var n=i(Object.defineProperty({},"name",{get:function(){return this===n}}));if("true"!==l.call(n))return!0}return"2: 1"!==l.call({message:1,name:2})||"Error"!==l.call({})}));n.exports=c?function(){var n=o(this),e=s(n.name,"Error"),t=s(n.message);return e?t?e+": "+t:e:t}:l},function(n,e,t){var r=t(1),a=t(15),o=Math.floor,i=r("".charAt),s=r("".replace),l=r("".slice),c=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,u=/\$([$&'`]|\d{1,2})/g;n.exports=function(n,e,t,r,d,p){var m=t+n.length,h=r.length,f=u;return void 0!==d&&(d=a(d),f=c),s(p,f,(function(a,s){var c;switch(i(s,0)){case"$":return"$";case"&":return n;case"`":return l(e,0,t);case"'":return l(e,m);case"<":c=d[l(s,1,-1)];break;default:var u=+s;if(0===u)return a;if(u>h){var p=o(u/10);return 0===p?a:p<=h?void 0===r[p-1]?i(s,1):r[p-1]+i(s,1):a}c=r[u-1]}return void 0===c?"":c}))}},function(n,e,t){var r=t(186),a=t(268);n.exports=function n(e,t,o,i,s){var l=-1,c=e.length;for(o||(o=a),s||(s=[]);++l<c;){var u=e[l];t>0&&o(u)?t>1?n(u,t-1,o,i,s):r(s,u):i||(s[s.length]=u)}return s}},function(n,e,t){var r=t(67),a=t(123),o=t(26),i=r?r.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||a(n)||!!(i&&n&&n[i])}},function(n,e,t){var r=t(58),a=t(48);n.exports=function(n){return a(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(67),a=Object.prototype,o=a.hasOwnProperty,i=a.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=o.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var a=i.call(n);return r&&(e?n[s]=t:delete n[s]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(273),a=t(329),o=t(131),i=t(26),s=t(340);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?i(n)?a(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(274),a=t(328),o=t(203);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(188),a=t(192);n.exports=function(n,e,t,o){var i=t.length,s=i,l=!o;if(null==n)return!s;for(n=Object(n);i--;){var c=t[i];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++i<s;){var u=(c=t[i])[0],d=n[u],p=c[1];if(l&&c[2]){if(void 0===d&&!(u in n))return!1}else{var m=new r;if(o)var h=o(d,p,u,n,e,m);if(!(void 0===h?a(p,d,3,o,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(92),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(92);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(92);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(92);n.exports=function(n,e){var t=this.__data__,a=r(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var r=t(91);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(91),a=t(124),o=t(126);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var i=t.__data__;if(!a||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new o(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(190),a=t(286),o=t(125),i=t(191),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,u=l.toString,d=c.hasOwnProperty,p=RegExp("^"+u.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||a(n))&&(r(n)?p:s).test(i(n))}},function(n,e,t){var r,a=t(287),o=(r=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!o&&o in n}},function(n,e,t){var r=t(28)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(290),a=t(91),o=t(124);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(o||a),string:new r}}},function(n,e,t){var r=t(291),a=t(292),o=t(293),i=t(294),s=t(295);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(93);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(93),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(93),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var r=t(93);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(94);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(94);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(94);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(94);n.exports=function(n,e){var t=r(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var r=t(188),a=t(193),o=t(305),i=t(308),s=t(324),l=t(26),c=t(197),u=t(199),d="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,f){var g=l(n),v=l(e),x=g?"[object Array]":s(n),b=v?"[object Array]":s(e),y=(x="[object Arguments]"==x?d:x)==d,T=(b="[object Arguments]"==b?d:b)==d,w=x==b;if(w&&c(n)){if(!c(e))return!1;g=!0,y=!1}if(w&&!y)return f||(f=new r),g||u(n)?a(n,e,t,m,h,f):o(n,e,x,t,m,h,f);if(!(1&t)){var _=y&&p.call(n,"__wrapped__"),k=T&&p.call(e,"__wrapped__");if(_||k){var j=_?n.value():n,I=k?e.value():e;return f||(f=new r),h(j,I,t,m,f)}}return!!w&&(f||(f=new r),i(n,e,t,m,h,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(67),a=t(306),o=t(189),i=t(193),s=t(307),l=t(127),c=r?r.prototype:void 0,u=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,d,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var h=1&r;if(m||(m=l),n.size!=e.size&&!h)return!1;var f=p.get(n);if(f)return f==e;r|=2,p.set(n,e);var g=i(m(n),m(e),r,c,d,p);return p.delete(n),g;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var r=t(28).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(309),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,o,i,s){var l=1&t,c=r(n),u=c.length;if(u!=r(e).length&&!l)return!1;for(var d=u;d--;){var p=c[d];if(!(l?p in e:a.call(e,p)))return!1}var m=s.get(n),h=s.get(e);if(m&&h)return m==e&&h==n;var f=!0;s.set(n,e),s.set(e,n);for(var g=l;++d<u;){var v=n[p=c[d]],x=e[p];if(o)var b=l?o(x,v,p,e,n,s):o(v,x,p,n,e,s);if(!(void 0===b?v===x||i(v,x,t,o,s):b)){f=!1;break}g||(g="constructor"==p)}if(f&&!g){var y=n.constructor,T=e.constructor;y==T||!("constructor"in n)||!("constructor"in e)||"function"==typeof y&&y instanceof y&&"function"==typeof T&&T instanceof T||(f=!1)}return s.delete(n),s.delete(e),f}},function(n,e,t){var r=t(310),a=t(311),o=t(196);n.exports=function(n){return r(n,o,a)}},function(n,e,t){var r=t(186),a=t(26);n.exports=function(n,e,t){var o=e(n);return a(n)?o:r(o,t(n))}},function(n,e,t){var r=t(312),a=t(313),o=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),r(i(n),(function(e){return o.call(n,e)})))}:a;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=0,o=[];++t<r;){var i=n[t];e(i,t,n)&&(o[a++]=i)}return o}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(315),a=t(123),o=t(26),i=t(197),s=t(198),l=t(199),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=o(n),u=!t&&a(n),d=!t&&!u&&i(n),p=!t&&!u&&!d&&l(n),m=t||u||d||p,h=m?r(n.length,String):[],f=h.length;for(var g in n)!e&&!c.call(n,g)||m&&("length"==g||d&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,f))||h.push(g);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(58),a=t(128),o=t(48),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&a(n.length)&&!!i[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(187),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,i=o&&o.exports===a&&r.process,s=function(){try{var n=o&&o.require&&o.require("util").types;return n||i&&i.binding&&i.binding("util")}catch(n){}}();n.exports=s}).call(this,t(147)(n))},function(n,e,t){var r=t(321),a=t(322),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return a(n);var e=[];for(var t in Object(n))o.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(323)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(325),a=t(124),o=t(326),i=t(201),s=t(327),l=t(58),c=t(191),u=c(r),d=c(a),p=c(o),m=c(i),h=c(s),f=l;(r&&"[object DataView]"!=f(new r(new ArrayBuffer(1)))||a&&"[object Map]"!=f(new a)||o&&"[object Promise]"!=f(o.resolve())||i&&"[object Set]"!=f(new i)||s&&"[object WeakMap]"!=f(new s))&&(f=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case u:return"[object DataView]";case d:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var r=t(41)(t(28),"DataView");n.exports=r},function(n,e,t){var r=t(41)(t(28),"Promise");n.exports=r},function(n,e,t){var r=t(41)(t(28),"WeakMap");n.exports=r},function(n,e,t){var r=t(202),a=t(196);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var o=e[t],i=n[o];e[t]=[o,i,r(i)]}return e}},function(n,e,t){var r=t(192),a=t(330),o=t(337),i=t(129),s=t(202),l=t(203),c=t(95);n.exports=function(n,e){return i(n)&&s(e)?l(c(n),e):function(t){var i=a(t,n);return void 0===i&&i===e?o(t,n):r(e,i,3)}}},function(n,e,t){var r=t(204);n.exports=function(n,e,t){var a=null==n?void 0:r(n,e);return void 0===a?t:a}},function(n,e,t){var r=t(332),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,i=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,r,a){e.push(r?a.replace(o,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var r=t(333);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(126);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,a=e?e.apply(this,r):r[0],o=t.cache;if(o.has(a))return o.get(a);var i=n.apply(this,r);return t.cache=o.set(a,i)||o,i};return t.cache=new(a.Cache||r),t}a.Cache=r,n.exports=a},function(n,e,t){var r=t(335);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(67),a=t(336),o=t(26),i=t(130),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(o(e))return a(e,n)+"";if(i(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=Array(r);++t<r;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var r=t(338),a=t(339);n.exports=function(n,e){return null!=n&&a(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(205),a=t(123),o=t(26),i=t(198),s=t(128),l=t(95);n.exports=function(n,e,t){for(var c=-1,u=(e=r(e,n)).length,d=!1;++c<u;){var p=l(e[c]);if(!(d=null!=n&&t(n,p)))break;n=n[p]}return d||++c!=u?d:!!(u=null==n?0:n.length)&&s(u)&&i(p,u)&&(o(n)||a(n))}},function(n,e,t){var r=t(341),a=t(342),o=t(129),i=t(95);n.exports=function(n){return o(n)?r(i(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(204);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(131),a=t(344),o=t(346);n.exports=function(n,e){return o(a(n,e,r),n+"")}},function(n,e,t){var r=t(345),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var o=arguments,i=-1,s=a(o.length-e,0),l=Array(s);++i<s;)l[i]=o[e+i];i=-1;for(var c=Array(e+1);++i<e;)c[i]=o[i];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(347),a=t(350)(r);n.exports=a},function(n,e,t){var r=t(348),a=t(349),o=t(131),i=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:o;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(41),a=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var a=t(),o=16-(a-r);if(r=a,o>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(194),a=t(352),o=t(357),i=t(195),s=t(358),l=t(127);n.exports=function(n,e,t){var c=-1,u=a,d=n.length,p=!0,m=[],h=m;if(t)p=!1,u=o;else if(d>=200){var f=e?null:s(n);if(f)return l(f);p=!1,u=i,h=new r}else h=e?[]:m;n:for(;++c<d;){var g=n[c],v=e?e(g):g;if(g=t||0!==g?g:0,p&&v==v){for(var x=h.length;x--;)if(h[x]===v)continue n;e&&h.push(v),m.push(g)}else u(h,v,t)||(h!==m&&h.push(v),m.push(g))}return m}},function(n,e,t){var r=t(353);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(354),a=t(355),o=t(356);n.exports=function(n,e,t){return e==e?o(n,e,t):r(n,a,t)}},function(n,e){n.exports=function(n,e,t,r){for(var a=n.length,o=t+(r?1:-1);r?o--:++o<a;)if(e(n[o],o,n))return o;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,a=n.length;++r<a;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,a=null==n?0:n.length;++r<a;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(201),a=t(359),o=t(127),i=r&&1/o(new r([,-0]))[1]==1/0?function(n){return new r(n)}:a;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(200),a=t(48);n.exports=function(n){return a(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(63).PROPER,a=t(3),o=t(150);n.exports=function(n){return a((function(){return!!o[n]()||"​᠎"!=="​᠎"[n]()||r&&o[n].name!==n}))}},function(n,e,t){var r=t(2),a=t(206);r({target:"Function",proto:!0,forced:Function.bind!==a},{bind:a})},function(n,e,t){var r=t(1);n.exports=r(1..valueOf)},function(n,e,t){var r=t(1),a=t(50),o=t(12),i=t(367),s=t(18),l=r(i),c=r("".slice),u=Math.ceil,d=function(n){return function(e,t,r){var i,d,p=o(s(e)),m=a(t),h=p.length,f=void 0===r?" ":o(r);return m<=h||""==f?p:((d=l(f,u((i=m-h)/f.length))).length>i&&(d=c(d,0,i)),n?p+d:d+p)}};n.exports={start:d(!1),end:d(!0)}},function(n,e,t){"use strict";var r=t(0),a=t(52),o=t(12),i=t(18),s=r.RangeError;n.exports=function(n){var e=o(i(this)),t="",r=a(n);if(r<0||r==1/0)throw s("Wrong number of repetitions");for(;r>0;(r>>>=1)&&(e+=e))1&r&&(t+=e);return t}},function(n,e,t){var r=t(27);n.exports=/Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(r)},function(n,e,t){"use strict";t(208)},function(n,e,t){"use strict";t(209)},function(n,e,t){"use strict";var r=t(2),a=t(1),o=t(35),i=t(15),s=t(20),l=t(12),c=t(3),u=t(231),d=t(45),p=t(372),m=t(373),h=t(49),f=t(374),g=[],v=a(g.sort),x=a(g.push),b=c((function(){g.sort(void 0)})),y=c((function(){g.sort(null)})),T=d("sort"),w=!c((function(){if(h)return h<70;if(!(p&&p>3)){if(m)return!0;if(f)return f<603;var n,e,t,r,a="";for(n=65;n<76;n++){switch(e=String.fromCharCode(n),n){case 66:case 69:case 70:case 72:t=3;break;case 68:case 71:t=4;break;default:t=2}for(r=0;r<47;r++)g.push({k:e+r,v:t})}for(g.sort((function(n,e){return e.v-n.v})),r=0;r<g.length;r++)e=g[r].k.charAt(0),a.charAt(a.length-1)!==e&&(a+=e);return"DGBEFHACIJK"!==a}}));r({target:"Array",proto:!0,forced:b||!y||!T||!w},{sort:function(n){void 0!==n&&o(n);var e=i(this);if(w)return void 0===n?v(e):v(e,n);var t,r,a=[],c=s(e);for(r=0;r<c;r++)r in e&&x(a,e[r]);for(u(a,function(n){return function(e,t){return void 0===t?-1:void 0===e?1:void 0!==n?+n(e,t)||0:l(e)>l(t)?1:-1}}(n)),t=a.length,r=0;r<t;)e[r]=a[r++];for(;r<c;)delete e[r++];return e}})},function(n,e,t){var r=t(27).match(/firefox\/(\d+)/i);n.exports=!!r&&+r[1]},function(n,e,t){var r=t(27);n.exports=/MSIE|Trident/.test(r)},function(n,e,t){var r=t(27).match(/AppleWebKit\/(\d+)\./);n.exports=!!r&&+r[1]},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(213)},function(n,e,t){"use strict";t(214)},function(n,e,t){"use strict";t.r(e);t(139),t(237),t(246),t(248);var r=t(87),a=(t(136),t(51),t(6),t(24),t(31),t(43),t(30),Object.freeze({}));function o(n){return null==n}function i(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function d(n){return"[object Object]"===u.call(n)}function p(n){return"[object RegExp]"===u.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function h(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function g(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),r=n.split(","),a=0;a<r.length;a++)t[r[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var x=v("key,ref,slot,slot-scope,is");function b(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var y=Object.prototype.hasOwnProperty;function T(n,e){return y.call(n,e)}function w(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var _=/-(\w)/g,k=w((function(n){return n.replace(_,(function(n,e){return e?e.toUpperCase():""}))})),j=w((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),I=/\B([A-Z])/g,z=w((function(n){return n.replace(I,"-$1").toLowerCase()}));var E=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function S(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function A(n,e){for(var t in e)n[t]=e[t];return n}function C(n){for(var e={},t=0;t<n.length;t++)n[t]&&A(e,n[t]);return e}function q(n,e,t){}var P=function(n,e,t){return!1},B=function(n){return n};function O(n,e){if(n===e)return!0;var t=c(n),r=c(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Array.isArray(n),o=Array.isArray(e);if(a&&o)return n.length===e.length&&n.every((function(n,t){return O(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||o)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return O(n[t],e[t])}))}catch(n){return!1}}function R(n,e){for(var t=0;t<n.length;t++)if(O(n[t],e))return t;return-1}function D(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var M=["component","directive","filter"],N=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],L={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:P,isReservedAttr:P,isUnknownElement:P,getTagNamespace:q,parsePlatformTagName:B,mustUseProp:P,async:!0,_lifecycleHooks:N},U=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function $(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var J=new RegExp("[^"+U.source+".$_\\d]");var H,F="__proto__"in{},V="undefined"!=typeof window,G="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,W=G&&WXEnvironment.platform.toLowerCase(),X=V&&window.navigator.userAgent.toLowerCase(),Y=X&&/msie|trident/.test(X),Z=X&&X.indexOf("msie 9.0")>0,K=X&&X.indexOf("edge/")>0,Q=(X&&X.indexOf("android"),X&&/iphone|ipad|ipod|ios/.test(X)||"ios"===W),nn=(X&&/chrome\/\d+/.test(X),X&&/phantomjs/.test(X),X&&X.match(/firefox\/(\d+)/)),en={}.watch,tn=!1;if(V)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){tn=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var an=function(){return void 0===H&&(H=!V&&!G&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),H},on=V&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function sn(n){return"function"==typeof n&&/native code/.test(n.toString())}var ln,cn="undefined"!=typeof Symbol&&sn(Symbol)&&"undefined"!=typeof Reflect&&sn(Reflect.ownKeys);ln="undefined"!=typeof Set&&sn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=q,dn=0,pn=function(){this.id=dn++,this.subs=[]};pn.prototype.addSub=function(n){this.subs.push(n)},pn.prototype.removeSub=function(n){b(this.subs,n)},pn.prototype.depend=function(){pn.target&&pn.target.addDep(this)},pn.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},pn.target=null;var mn=[];function hn(n){mn.push(n),pn.target=n}function fn(){mn.pop(),pn.target=mn[mn.length-1]}var gn=function(n,e,t,r,a,o,i,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=a,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},vn={child:{configurable:!0}};vn.child.get=function(){return this.componentInstance},Object.defineProperties(gn.prototype,vn);var xn=function(n){void 0===n&&(n="");var e=new gn;return e.text=n,e.isComment=!0,e};function bn(n){return new gn(void 0,void 0,void 0,String(n))}function yn(n){var e=new gn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var Tn=Array.prototype,wn=Object.create(Tn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=Tn[n];$(wn,n,(function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];var a,o=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&i.observeArray(a),i.dep.notify(),o}))}));var _n=Object.getOwnPropertyNames(wn),kn=!0;function jn(n){kn=n}var In=function(n){this.value=n,this.dep=new pn,this.vmCount=0,$(n,"__ob__",this),Array.isArray(n)?(F?function(n,e){n.__proto__=e}(n,wn):function(n,e,t){for(var r=0,a=t.length;r<a;r++){var o=t[r];$(n,o,e[o])}}(n,wn,_n),this.observeArray(n)):this.walk(n)};function zn(n,e){var t;if(c(n)&&!(n instanceof gn))return T(n,"__ob__")&&n.__ob__ instanceof In?t=n.__ob__:kn&&!an()&&(Array.isArray(n)||d(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new In(n)),e&&t&&t.vmCount++,t}function En(n,e,t,r,a){var o=new pn,i=Object.getOwnPropertyDescriptor(n,e);if(!i||!1!==i.configurable){var s=i&&i.get,l=i&&i.set;s&&!l||2!==arguments.length||(t=n[e]);var c=!a&&zn(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=s?s.call(n):t;return pn.target&&(o.depend(),c&&(c.dep.depend(),Array.isArray(e)&&Cn(e))),e},set:function(e){var r=s?s.call(n):t;e===r||e!=e&&r!=r||s&&!l||(l?l.call(n,e):t=e,c=!a&&zn(e),o.notify())}})}}function Sn(n,e,t){if(Array.isArray(n)&&m(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var r=n.__ob__;return n._isVue||r&&r.vmCount?t:r?(En(r.value,e,t),r.dep.notify(),t):(n[e]=t,t)}function An(n,e){if(Array.isArray(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||T(n,e)&&(delete n[e],t&&t.dep.notify())}}function Cn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&Cn(e)}In.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)En(n,e[t])},In.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)zn(n[e])};var qn=L.optionMergeStrategies;function Pn(n,e){if(!e)return n;for(var t,r,a,o=cn?Reflect.ownKeys(e):Object.keys(e),i=0;i<o.length;i++)"__ob__"!==(t=o[i])&&(r=n[t],a=e[t],T(n,t)?r!==a&&d(r)&&d(a)&&Pn(r,a):Sn(n,t,a));return n}function Bn(n,e,t){return t?function(){var r="function"==typeof e?e.call(t,t):e,a="function"==typeof n?n.call(t,t):n;return r?Pn(r,a):a}:e?n?function(){return Pn("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function On(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Rn(n,e,t,r){var a=Object.create(n||null);return e?A(a,e):a}qn.data=function(n,e,t){return t?Bn(n,e,t):e&&"function"!=typeof e?n:Bn(n,e)},N.forEach((function(n){qn[n]=On})),M.forEach((function(n){qn[n+"s"]=Rn})),qn.watch=function(n,e,t,r){if(n===en&&(n=void 0),e===en&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var o in A(a,n),e){var i=a[o],s=e[o];i&&!Array.isArray(i)&&(i=[i]),a[o]=i?i.concat(s):Array.isArray(s)?s:[s]}return a},qn.props=qn.methods=qn.inject=qn.computed=function(n,e,t,r){if(!n)return e;var a=Object.create(null);return A(a,n),e&&A(a,e),a},qn.provide=Bn;var Dn=function(n,e){return void 0===e?n:e};function Mn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var r,a,o={};if(Array.isArray(t))for(r=t.length;r--;)"string"==typeof(a=t[r])&&(o[k(a)]={type:null});else if(d(t))for(var i in t)a=t[i],o[k(i)]=d(a)?a:{type:a};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(Array.isArray(t))for(var a=0;a<t.length;a++)r[t[a]]={from:t[a]};else if(d(t))for(var o in t){var i=t[o];r[o]=d(i)?A({from:o},i):{from:i}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];"function"==typeof r&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Mn(n,e.extends,t)),e.mixins))for(var r=0,a=e.mixins.length;r<a;r++)n=Mn(n,e.mixins[r],t);var o,i={};for(o in n)s(o);for(o in e)T(n,o)||s(o);function s(r){var a=qn[r]||Dn;i[r]=a(n[r],e[r],t,r)}return i}function Nn(n,e,t,r){if("string"==typeof t){var a=n[e];if(T(a,t))return a[t];var o=k(t);if(T(a,o))return a[o];var i=j(o);return T(a,i)?a[i]:a[t]||a[o]||a[i]}}function Ln(n,e,t,r){var a=e[n],o=!T(t,n),i=t[n],s=Hn(Boolean,a.type);if(s>-1)if(o&&!T(a,"default"))i=!1;else if(""===i||i===z(n)){var l=Hn(String,a.type);(l<0||s<l)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!T(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof r&&"Function"!==$n(e.type)?r.call(n):r}(r,a,n);var c=kn;jn(!0),zn(i),jn(c)}return i}var Un=/^\s*function (\w+)/;function $n(n){var e=n&&n.toString().match(Un);return e?e[1]:""}function Jn(n,e){return $n(n)===$n(e)}function Hn(n,e){if(!Array.isArray(e))return Jn(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Jn(e[t],n))return t;return-1}function Fn(n,e,t){hn();try{if(e)for(var r=e;r=r.$parent;){var a=r.$options.errorCaptured;if(a)for(var o=0;o<a.length;o++)try{if(!1===a[o].call(r,n,e,t))return}catch(n){Gn(n,r,"errorCaptured hook")}}Gn(n,e,t)}finally{fn()}}function Vn(n,e,t,r,a){var o;try{(o=t?n.apply(e,t):n.call(e))&&!o._isVue&&h(o)&&!o._handled&&(o.catch((function(n){return Fn(n,r,a+" (Promise/async)")})),o._handled=!0)}catch(n){Fn(n,r,a)}return o}function Gn(n,e,t){if(L.errorHandler)try{return L.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Wn(e,null,"config.errorHandler")}Wn(n,e,t)}function Wn(n,e,t){if(!V&&!G||"undefined"==typeof console)throw n;console.error(n)}var Xn,Yn=!1,Zn=[],Kn=!1;function Qn(){Kn=!1;var n=Zn.slice(0);Zn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&sn(Promise)){var ne=Promise.resolve();Xn=function(){ne.then(Qn),Q&&setTimeout(q)},Yn=!0}else if(Y||"undefined"==typeof MutationObserver||!sn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Xn="undefined"!=typeof setImmediate&&sn(setImmediate)?function(){setImmediate(Qn)}:function(){setTimeout(Qn,0)};else{var ee=1,te=new MutationObserver(Qn),re=document.createTextNode(String(ee));te.observe(re,{characterData:!0}),Xn=function(){ee=(ee+1)%2,re.data=String(ee)},Yn=!0}function ae(n,e){var t;if(Zn.push((function(){if(n)try{n.call(e)}catch(n){Fn(n,e,"nextTick")}else t&&t(e)})),Kn||(Kn=!0,Xn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var oe=new ln;function ie(n){!function n(e,t){var r,a,o=Array.isArray(e);if(!o&&!c(e)||Object.isFrozen(e)||e instanceof gn)return;if(e.__ob__){var i=e.__ob__.dep.id;if(t.has(i))return;t.add(i)}if(o)for(r=e.length;r--;)n(e[r],t);else for(a=Object.keys(e),r=a.length;r--;)n(e[a[r]],t)}(n,oe),oe.clear()}var se=w((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function le(n,e){function t(){var n=arguments,r=t.fns;if(!Array.isArray(r))return Vn(r,null,arguments,e,"v-on handler");for(var a=r.slice(),o=0;o<a.length;o++)Vn(a[o],null,n,e,"v-on handler")}return t.fns=n,t}function ce(n,e,t,r,a,i){var l,c,u,d;for(l in n)c=n[l],u=e[l],d=se(l),o(c)||(o(u)?(o(c.fns)&&(c=n[l]=le(c,i)),s(d.once)&&(c=n[l]=a(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==u&&(u.fns=c,n[l]=u));for(l in e)o(n[l])&&r((d=se(l)).name,e[l],d.capture)}function ue(n,e,t){var r;n instanceof gn&&(n=n.data.hook||(n.data.hook={}));var a=n[e];function l(){t.apply(this,arguments),b(r.fns,l)}o(a)?r=le([l]):i(a.fns)&&s(a.merged)?(r=a).fns.push(l):r=le([a,l]),r.merged=!0,n[e]=r}function de(n,e,t,r,a){if(i(e)){if(T(e,t))return n[t]=e[t],a||delete e[t],!0;if(T(e,r))return n[t]=e[r],a||delete e[r],!0}return!1}function pe(n){return l(n)?[bn(n)]:Array.isArray(n)?function n(e,t){var r,a,c,u,d=[];for(r=0;r<e.length;r++)o(a=e[r])||"boolean"==typeof a||(c=d.length-1,u=d[c],Array.isArray(a)?a.length>0&&(me((a=n(a,(t||"")+"_"+r))[0])&&me(u)&&(d[c]=bn(u.text+a[0].text),a.shift()),d.push.apply(d,a)):l(a)?me(u)?d[c]=bn(u.text+a):""!==a&&d.push(bn(a)):me(a)&&me(u)?d[c]=bn(u.text+a.text):(s(e._isVList)&&i(a.tag)&&o(a.key)&&i(t)&&(a.key="__vlist"+t+"_"+r+"__"),d.push(a)));return d}(n):void 0}function me(n){return i(n)&&i(n.text)&&!1===n.isComment}function he(n,e){if(n){for(var t=Object.create(null),r=cn?Reflect.ownKeys(n):Object.keys(n),a=0;a<r.length;a++){var o=r[a];if("__ob__"!==o){for(var i=n[o].from,s=e;s;){if(s._provided&&T(s._provided,i)){t[o]=s._provided[i];break}s=s.$parent}if(!s)if("default"in n[o]){var l=n[o].default;t[o]="function"==typeof l?l.call(e):l}else 0}}return t}}function fe(n,e){if(!n||!n.length)return{};for(var t={},r=0,a=n.length;r<a;r++){var o=n[r],i=o.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,o.context!==e&&o.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(o);else{var s=i.slot,l=t[s]||(t[s]=[]);"template"===o.tag?l.push.apply(l,o.children||[]):l.push(o)}}for(var c in t)t[c].every(ge)&&delete t[c];return t}function ge(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ve(n){return n.isComment&&n.asyncFactory}function xe(n,e,t){var r,o=Object.keys(e).length>0,i=n?!!n.$stable:!o,s=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(i&&t&&t!==a&&s===t.$key&&!o&&!t.$hasNormal)return t;for(var l in r={},n)n[l]&&"$"!==l[0]&&(r[l]=be(e,l,n[l]))}else r={};for(var c in e)c in r||(r[c]=ye(e,c));return n&&Object.isExtensible(n)&&(n._normalized=r),$(r,"$stable",i),$(r,"$key",s),$(r,"$hasNormal",o),r}function be(n,e,t){var r=function(){var n=arguments.length?t.apply(null,arguments):t({}),e=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:pe(n))&&n[0];return n&&(!e||1===n.length&&e.isComment&&!ve(e))?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:r,enumerable:!0,configurable:!0}),r}function ye(n,e){return function(){return n[e]}}function Te(n,e){var t,r,a,o,s;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),r=0,a=n.length;r<a;r++)t[r]=e(n[r],r);else if("number"==typeof n)for(t=new Array(n),r=0;r<n;r++)t[r]=e(r+1,r);else if(c(n))if(cn&&n[Symbol.iterator]){t=[];for(var l=n[Symbol.iterator](),u=l.next();!u.done;)t.push(e(u.value,t.length)),u=l.next()}else for(o=Object.keys(n),t=new Array(o.length),r=0,a=o.length;r<a;r++)s=o[r],t[r]=e(n[s],s,r);return i(t)||(t=[]),t._isVList=!0,t}function we(n,e,t,r){var a,o=this.$scopedSlots[n];o?(t=t||{},r&&(t=A(A({},r),t)),a=o(t)||("function"==typeof e?e():e)):a=this.$slots[n]||("function"==typeof e?e():e);var i=t&&t.slot;return i?this.$createElement("template",{slot:i},a):a}function _e(n){return Nn(this.$options,"filters",n)||B}function ke(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function je(n,e,t,r,a){var o=L.keyCodes[e]||t;return a&&r&&!L.keyCodes[e]?ke(a,r):o?ke(o,n):r?z(r)!==e:void 0===n}function Ie(n,e,t,r,a){if(t)if(c(t)){var o;Array.isArray(t)&&(t=C(t));var i=function(i){if("class"===i||"style"===i||x(i))o=n;else{var s=n.attrs&&n.attrs.type;o=r||L.mustUseProp(e,s,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=k(i),c=z(i);l in o||c in o||(o[i]=t[i],a&&((n.on||(n.on={}))["update:"+i]=function(n){t[i]=n}))};for(var s in t)i(s)}else;return n}function ze(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||Se(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),r}function Ee(n,e,t){return Se(n,"__once__"+e+(t?"_"+t:""),!0),n}function Se(n,e,t){if(Array.isArray(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&Ae(n[r],e+"_"+r,t);else Ae(n,e,t)}function Ae(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Ce(n,e){if(e)if(d(e)){var t=n.on=n.on?A({},n.on):{};for(var r in e){var a=t[r],o=e[r];t[r]=a?[].concat(a,o):o}}else;return n}function qe(n,e,t,r){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var o=n[a];Array.isArray(o)?qe(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return r&&(e.$key=r),e}function Pe(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function Be(n,e){return"string"==typeof n?e+n:n}function Oe(n){n._o=Ee,n._n=g,n._s=f,n._l=Te,n._t=we,n._q=O,n._i=R,n._m=ze,n._f=_e,n._k=je,n._b=Ie,n._v=bn,n._e=xn,n._u=qe,n._g=Ce,n._d=Pe,n._p=Be}function Re(n,e,t,r,o){var i,l=this,c=o.options;T(r,"_uid")?(i=Object.create(r))._original=r:(i=r,r=r._original);var u=s(c._compiled),d=!u;this.data=n,this.props=e,this.children=t,this.parent=r,this.listeners=n.on||a,this.injections=he(c.inject,r),this.slots=function(){return l.$slots||xe(n.scopedSlots,l.$slots=fe(t,r)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return xe(n.scopedSlots,this.slots())}}),u&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=xe(n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,a){var o=Je(i,n,e,t,a,d);return o&&!Array.isArray(o)&&(o.fnScopeId=c._scopeId,o.fnContext=r),o}:this._c=function(n,e,t,r){return Je(i,n,e,t,r,d)}}function De(n,e,t,r,a){var o=yn(n);return o.fnContext=t,o.fnOptions=r,e.slot&&((o.data||(o.data={})).slot=e.slot),o}function Me(n,e){for(var t in e)n[k(t)]=e[t]}Oe(Re.prototype);var Ne={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Ne.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;i(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ke)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,o){0;var i=r.data.scopedSlots,s=n.$scopedSlots,l=!!(i&&!i.$stable||s!==a&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key||!i&&n.$scopedSlots.$key),c=!!(o||n.$options._renderChildren||l);n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r);if(n.$options._renderChildren=o,n.$attrs=r.data.attrs||a,n.$listeners=t||a,e&&n.$options.props){jn(!1);for(var u=n._props,d=n.$options._propKeys||[],p=0;p<d.length;p++){var m=d[p],h=n.$options.props;u[m]=Ln(m,h,e,n)}jn(!0),n.$options.propsData=e}t=t||a;var f=n.$options._parentListeners;n.$options._parentListeners=t,Ze(n,t,f),c&&(n.$slots=fe(o,r.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,tt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,at.push(e)):et(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,nt(e)))return;if(!e._inactive){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);tt(e,"deactivated")}}(e,!0):e.$destroy())}},Le=Object.keys(Ne);function Ue(n,e,t,r,l){if(!o(n)){var u=t.$options._base;if(c(n)&&(n=u.extend(n)),"function"==typeof n){var d;if(o(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=Fe;t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(s(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var r=n.owners=[t],a=!0,l=null,u=null;t.$on("hook:destroyed",(function(){return b(r,t)}));var d=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==u&&(clearTimeout(u),u=null))},p=D((function(t){n.resolved=Ve(t,e),a?r.length=0:d(!0)})),m=D((function(e){i(n.errorComp)&&(n.error=!0,d(!0))})),f=n(p,m);return c(f)&&(h(f)?o(n.resolved)&&f.then(p,m):h(f.component)&&(f.component.then(p,m),i(f.error)&&(n.errorComp=Ve(f.error,e)),i(f.loading)&&(n.loadingComp=Ve(f.loading,e),0===f.delay?n.loading=!0:l=setTimeout((function(){l=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,d(!1))}),f.delay||200)),i(f.timeout)&&(u=setTimeout((function(){u=null,o(n.resolved)&&m(null)}),f.timeout)))),a=!1,n.loading?n.loadingComp:n.resolved}}(d=n,u)))return function(n,e,t,r,a){var o=xn();return o.asyncFactory=n,o.asyncMeta={data:e,context:t,children:r,tag:a},o}(d,e,t,r,l);e=e||{},kt(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),o=a[r],s=e.model.callback;i(o)?(Array.isArray(o)?-1===o.indexOf(s):o!==s)&&(a[r]=[s].concat(o)):a[r]=s}(n.options,e);var p=function(n,e,t){var r=e.options.props;if(!o(r)){var a={},s=n.attrs,l=n.props;if(i(s)||i(l))for(var c in r){var u=z(c);de(a,l,c,u,!0)||de(a,s,c,u,!1)}return a}}(e,n);if(s(n.options.functional))return function(n,e,t,r,o){var s=n.options,l={},c=s.props;if(i(c))for(var u in c)l[u]=Ln(u,c,e||a);else i(t.attrs)&&Me(l,t.attrs),i(t.props)&&Me(l,t.props);var d=new Re(t,l,o,r,n),p=s.render.call(null,d._c,d);if(p instanceof gn)return De(p,t,d.parent,s,d);if(Array.isArray(p)){for(var m=pe(p)||[],h=new Array(m.length),f=0;f<m.length;f++)h[f]=De(m[f],t,d.parent,s,d);return h}}(n,p,e,t,r);var m=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var f=e.slot;e={},f&&(e.slot=f)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Le.length;t++){var r=Le[t],a=e[r],o=Ne[r];a===o||a&&a._merged||(e[r]=a?$e(o,a):o)}}(e);var g=n.options.name||l;return new gn("vue-component-"+n.cid+(g?"-"+g:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:p,listeners:m,tag:l,children:r},d)}}}function $e(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}function Je(n,e,t,r,a,u){return(Array.isArray(t)||l(t))&&(a=r,r=t,t=void 0),s(u)&&(a=2),function(n,e,t,r,a){if(i(t)&&i(t.__ob__))return xn();i(t)&&i(t.is)&&(e=t.is);if(!e)return xn();0;Array.isArray(r)&&"function"==typeof r[0]&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===a?r=pe(r):1===a&&(r=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var l,u;if("string"==typeof e){var d;u=n.$vnode&&n.$vnode.ns||L.getTagNamespace(e),l=L.isReservedTag(e)?new gn(L.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!i(d=Nn(n.$options,"components",e))?new gn(e,t,r,void 0,void 0,n):Ue(d,t,n,r,e)}else l=Ue(e,t,n,r);return Array.isArray(l)?l:i(l)?(i(u)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(i(e.children))for(var a=0,l=e.children.length;a<l;a++){var c=e.children[a];i(c.tag)&&(o(c.ns)||s(r)&&"svg"!==c.tag)&&n(c,t,r)}}(l,u),i(t)&&function(n){c(n.style)&&ie(n.style);c(n.class)&&ie(n.class)}(t),l):xn()}(n,e,t,r,a)}var He,Fe=null;function Ve(n,e){return(n.__esModule||cn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),c(n)?e.extend(n):n}function Ge(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||ve(t)))return t}}function We(n,e){He.$on(n,e)}function Xe(n,e){He.$off(n,e)}function Ye(n,e){var t=He;return function r(){var a=e.apply(null,arguments);null!==a&&t.$off(n,r)}}function Ze(n,e,t){He=n,ce(e,t||{},We,Xe,Ye,n),He=void 0}var Ke=null;function Qe(n){var e=Ke;return Ke=n,function(){Ke=e}}function nt(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function et(n,e){if(e){if(n._directInactive=!1,nt(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)et(n.$children[t]);tt(n,"activated")}}function tt(n,e){hn();var t=n.$options[e],r=e+" hook";if(t)for(var a=0,o=t.length;a<o;a++)Vn(t[a],n,null,n,r);n._hasHookEvent&&n.$emit("hook:"+e),fn()}var rt=[],at=[],ot={},it=!1,st=!1,lt=0;var ct=0,ut=Date.now;if(V&&!Y){var dt=window.performance;dt&&"function"==typeof dt.now&&ut()>document.createEvent("Event").timeStamp&&(ut=function(){return dt.now()})}function pt(){var n,e;for(ct=ut(),st=!0,rt.sort((function(n,e){return n.id-e.id})),lt=0;lt<rt.length;lt++)(n=rt[lt]).before&&n.before(),e=n.id,ot[e]=null,n.run();var t=at.slice(),r=rt.slice();lt=rt.length=at.length=0,ot={},it=st=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,et(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r._watcher===t&&r._isMounted&&!r._isDestroyed&&tt(r,"updated")}}(r),on&&L.devtools&&on.emit("flush")}var mt=0,ht=function(n,e,t,r,a){this.vm=n,a&&(n._watcher=this),n._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++mt,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new ln,this.newDepIds=new ln,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!J.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=q)),this.value=this.lazy?void 0:this.get()};ht.prototype.get=function(){var n;hn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Fn(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&ie(n),fn(),this.cleanupDeps()}return n},ht.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},ht.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},ht.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==ot[e]){if(ot[e]=!0,st){for(var t=rt.length-1;t>lt&&rt[t].id>n.id;)t--;rt.splice(t+1,0,n)}else rt.push(n);it||(it=!0,ae(pt))}}(this)},ht.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||c(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'+this.expression+'"';Vn(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},ht.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},ht.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},ht.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||b(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var ft={enumerable:!0,configurable:!0,get:q,set:q};function gt(n,e,t){ft.get=function(){return this[e][t]},ft.set=function(n){this[e][t]=n},Object.defineProperty(n,t,ft)}function vt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props={},a=n.$options._propKeys=[];n.$parent&&jn(!1);var o=function(o){a.push(o);var i=Ln(o,e,t,n);En(r,o,i),o in n||gt(n,"_props",o)};for(var i in e)o(i);jn(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?q:E(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;d(e=n._data="function"==typeof e?function(n,e){hn();try{return n.call(e,e)}catch(n){return Fn(n,e,"data()"),{}}finally{fn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var o=t[a];0,r&&T(r,o)||(i=void 0,36!==(i=(o+"").charCodeAt(0))&&95!==i&&gt(n,"_data",o))}var i;zn(e,!0)}(n):zn(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=an();for(var a in e){var o=e[a],i="function"==typeof o?o:o.get;0,r||(t[a]=new ht(n,i||q,q,xt)),a in n||bt(n,a,o)}}(n,e.computed),e.watch&&e.watch!==en&&function(n,e){for(var t in e){var r=e[t];if(Array.isArray(r))for(var a=0;a<r.length;a++)wt(n,t,r[a]);else wt(n,t,r)}}(n,e.watch)}var xt={lazy:!0};function bt(n,e,t){var r=!an();"function"==typeof t?(ft.get=r?yt(e):Tt(t),ft.set=q):(ft.get=t.get?r&&!1!==t.cache?yt(e):Tt(t.get):q,ft.set=t.set||q),Object.defineProperty(n,e,ft)}function yt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),pn.target&&e.depend(),e.value}}function Tt(n){return function(){return n.call(this,this)}}function wt(n,e,t,r){return d(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var _t=0;function kt(n){var e=n.options;if(n.super){var t=kt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var a in t)t[a]!==r[a]&&(e||(e={}),e[a]=t[a]);return e}(n);r&&A(n.extendOptions,r),(e=n.options=Mn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function jt(n){this._init(n)}function It(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,a=n._Ctor||(n._Ctor={});if(a[r])return a[r];var o=n.name||t.options.name;var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=Mn(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)gt(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)bt(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,M.forEach((function(n){i[n]=t[n]})),o&&(i.options.components[o]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=A({},i.options),a[r]=i,i}}function zt(n){return n&&(n.Ctor.options.name||n.tag)}function Et(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!p(n)&&n.test(e)}function St(n,e){var t=n.cache,r=n.keys,a=n._vnode;for(var o in t){var i=t[o];if(i){var s=i.name;s&&!e(s)&&At(t,o,r,a)}}}function At(n,e,t,r){var a=n[e];!a||r&&a.tag===r.tag||a.componentInstance.$destroy(),n[e]=null,b(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=_t++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var a=r.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Mn(kt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ze(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=fe(e._renderChildren,r),n.$scopedSlots=a,n._c=function(e,t,r,a){return Je(n,e,t,r,a,!1)},n.$createElement=function(e,t,r,a){return Je(n,e,t,r,a,!0)};var o=t&&t.data;En(n,"$attrs",o&&o.attrs||a,null,!0),En(n,"$listeners",e._parentListeners||a,null,!0)}(e),tt(e,"beforeCreate"),function(n){var e=he(n.$options.inject,n);e&&(jn(!1),Object.keys(e).forEach((function(t){En(n,t,e[t])})),jn(!0))}(e),vt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),tt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(jt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Sn,n.prototype.$delete=An,n.prototype.$watch=function(n,e,t){if(d(e))return wt(this,n,e,t);(t=t||{}).user=!0;var r=new ht(this,n,e,t);if(t.immediate){var a='callback for immediate watcher "'+r.expression+'"';hn(),Vn(e,this,[r.value],this,a),fn()}return function(){r.teardown()}}}(jt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(Array.isArray(n))for(var a=0,o=n.length;a<o;a++)r.$on(n[a],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var r=0,a=n.length;r<a;r++)t.$off(n[r],e);return t}var o,i=t._events[n];if(!i)return t;if(!e)return t._events[n]=null,t;for(var s=i.length;s--;)if((o=i[s])===e||o.fn===e){i.splice(s,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?S(t):t;for(var r=S(arguments,1),a='event handler for "'+n+'"',o=0,i=t.length;o<i;o++)Vn(t[o],e,r,e,a)}return e}}(jt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,a=t._vnode,o=Qe(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),o(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){tt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||b(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),tt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(jt),function(n){Oe(n.prototype),n.prototype.$nextTick=function(n){return ae(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,a=t._parentVnode;a&&(e.$scopedSlots=xe(a.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=a;try{Fe=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Fn(t,e,"render"),n=e._vnode}finally{Fe=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof gn||(n=xn()),n.parent=a,n}}(jt);var Ct=[String,RegExp,Array],qt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Ct,exclude:Ct,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var a=t.tag,o=t.componentInstance,i=t.componentOptions;n[r]={name:zt(i),tag:a,componentInstance:o},e.push(r),this.max&&e.length>parseInt(this.max)&&At(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)At(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){St(n,(function(n){return Et(e,n)}))})),this.$watch("exclude",(function(e){St(n,(function(n){return!Et(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Ge(n),t=e&&e.componentOptions;if(t){var r=zt(t),a=this.include,o=this.exclude;if(a&&(!r||!Et(a,r))||o&&r&&Et(o,r))return e;var i=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;i[l]?(e.componentInstance=i[l].componentInstance,b(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return L}};Object.defineProperty(n,"config",e),n.util={warn:un,extend:A,mergeOptions:Mn,defineReactive:En},n.set=Sn,n.delete=An,n.nextTick=ae,n.observable=function(n){return zn(n),n},n.options=Object.create(null),M.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,A(n.options.components,qt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=S(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Mn(this.options,n),this}}(n),It(n),function(n){M.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(jt),Object.defineProperty(jt.prototype,"$isServer",{get:an}),Object.defineProperty(jt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(jt,"FunctionalRenderContext",{value:Re}),jt.version="2.6.14";var Pt=v("style,class"),Bt=v("input,textarea,option,select,progress"),Ot=v("contenteditable,draggable,spellcheck"),Rt=v("events,caret,typing,plaintext-only"),Dt=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Mt="http://www.w3.org/1999/xlink",Nt=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Lt=function(n){return Nt(n)?n.slice(6,n.length):""},Ut=function(n){return null==n||!1===n};function $t(n){for(var e=n.data,t=n,r=n;i(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=Jt(r.data,e));for(;i(t=t.parent);)t&&t.data&&(e=Jt(e,t.data));return function(n,e){if(i(n)||i(e))return Ht(n,Ft(e));return""}(e.staticClass,e.class)}function Jt(n,e){return{staticClass:Ht(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function Ht(n,e){return n?e?n+" "+e:n:e||""}function Ft(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,a=n.length;r<a;r++)i(e=Ft(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):c(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Vt={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Gt=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Wt=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Xt=function(n){return Gt(n)||Wt(n)};var Yt=Object.create(null);var Zt=v("text,number,password,search,email,tel,url");var Kt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Vt[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Qt={create:function(n,e){nr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(nr(n,!0),nr(e))},destroy:function(n){nr(n,!0)}};function nr(n,e){var t=n.data.ref;if(i(t)){var r=n.context,a=n.componentInstance||n.elm,o=r.$refs;e?Array.isArray(o[t])?b(o[t],a):o[t]===a&&(o[t]=void 0):n.data.refInFor?Array.isArray(o[t])?o[t].indexOf(a)<0&&o[t].push(a):o[t]=[a]:o[t]=a}}var er=new gn("",{},[]),tr=["create","activate","update","remove","destroy"];function rr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=i(t=n.data)&&i(t=t.attrs)&&t.type,a=i(t=e.data)&&i(t=t.attrs)&&t.type;return r===a||Zt(r)&&Zt(a)}(n,e)||s(n.isAsyncPlaceholder)&&o(e.asyncFactory.error))}function ar(n,e,t){var r,a,o={};for(r=e;r<=t;++r)i(a=n[r].key)&&(o[a]=r);return o}var or={create:ir,update:ir,destroy:function(n){ir(n,er)}};function ir(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,a,o=n===er,i=e===er,s=lr(n.data.directives,n.context),l=lr(e.data.directives,e.context),c=[],u=[];for(t in l)r=s[t],a=l[t],r?(a.oldValue=r.value,a.oldArg=r.arg,ur(a,"update",e,n),a.def&&a.def.componentUpdated&&u.push(a)):(ur(a,"bind",e,n),a.def&&a.def.inserted&&c.push(a));if(c.length){var d=function(){for(var t=0;t<c.length;t++)ur(c[t],"inserted",e,n)};o?ue(e,"insert",d):d()}u.length&&ue(e,"postpatch",(function(){for(var t=0;t<u.length;t++)ur(u[t],"componentUpdated",e,n)}));if(!o)for(t in s)l[t]||ur(s[t],"unbind",n,n,i)}(n,e)}var sr=Object.create(null);function lr(n,e){var t,r,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=sr),a[cr(r)]=r,r.def=Nn(e.$options,"directives",r.name);return a}function cr(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function ur(n,e,t,r,a){var o=n.def&&n.def[e];if(o)try{o(t.elm,n,t,r,a)}catch(r){Fn(r,t.context,"directive "+n.name+" "+e+" hook")}}var dr=[Qt,or];function pr(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(e.data.attrs))){var r,a,s=e.elm,l=n.data.attrs||{},c=e.data.attrs||{};for(r in i(c.__ob__)&&(c=e.data.attrs=A({},c)),c)a=c[r],l[r]!==a&&mr(s,r,a,e.data.pre);for(r in(Y||K)&&c.value!==l.value&&mr(s,"value",c.value),l)o(c[r])&&(Nt(r)?s.removeAttributeNS(Mt,Lt(r)):Ot(r)||s.removeAttribute(r))}}function mr(n,e,t,r){r||n.tagName.indexOf("-")>-1?hr(n,e,t):Dt(e)?Ut(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Ot(e)?n.setAttribute(e,function(n,e){return Ut(e)||"false"===e?"false":"contenteditable"===n&&Rt(e)?e:"true"}(e,t)):Nt(e)?Ut(t)?n.removeAttributeNS(Mt,Lt(e)):n.setAttributeNS(Mt,e,t):hr(n,e,t)}function hr(n,e,t){if(Ut(t))n.removeAttribute(e);else{if(Y&&!Z&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var fr={create:pr,update:pr};function gr(n,e){var t=e.elm,r=e.data,a=n.data;if(!(o(r.staticClass)&&o(r.class)&&(o(a)||o(a.staticClass)&&o(a.class)))){var s=$t(e),l=t._transitionClasses;i(l)&&(s=Ht(s,Ft(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var vr,xr={create:gr,update:gr};function br(n,e,t){var r=vr;return function a(){var o=e.apply(null,arguments);null!==o&&wr(n,a,t,r)}}var yr=Yn&&!(nn&&Number(nn[1])<=53);function Tr(n,e,t,r){if(yr){var a=ct,o=e;e=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}vr.addEventListener(n,e,tn?{capture:t,passive:r}:t)}function wr(n,e,t,r){(r||vr).removeEventListener(n,e._wrapper||e,t)}function _r(n,e){if(!o(n.data.on)||!o(e.data.on)){var t=e.data.on||{},r=n.data.on||{};vr=e.elm,function(n){if(i(n.__r)){var e=Y?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),ce(t,r,Tr,wr,br,e.context),vr=void 0}}var kr,jr={create:_r,update:_r};function Ir(n,e){if(!o(n.data.domProps)||!o(e.data.domProps)){var t,r,a=e.elm,s=n.data.domProps||{},l=e.data.domProps||{};for(t in i(l.__ob__)&&(l=e.data.domProps=A({},l)),s)t in l||(a[t]="");for(t in l){if(r=l[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===s[t])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===t&&"PROGRESS"!==a.tagName){a._value=r;var c=o(r)?"":String(r);zr(a,c)&&(a.value=c)}else if("innerHTML"===t&&Wt(a.tagName)&&o(a.innerHTML)){(kr=kr||document.createElement("div")).innerHTML="<svg>"+r+"</svg>";for(var u=kr.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;u.firstChild;)a.appendChild(u.firstChild)}else if(r!==s[t])try{a[t]=r}catch(n){}}}}function zr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(i(r)){if(r.number)return g(t)!==g(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Er={create:Ir,update:Ir},Sr=w((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Ar(n){var e=Cr(n.style);return n.staticStyle?A(n.staticStyle,e):e}function Cr(n){return Array.isArray(n)?C(n):"string"==typeof n?Sr(n):n}var qr,Pr=/^--/,Br=/\s*!important$/,Or=function(n,e,t){if(Pr.test(e))n.style.setProperty(e,t);else if(Br.test(t))n.style.setProperty(z(e),t.replace(Br,""),"important");else{var r=Dr(e);if(Array.isArray(t))for(var a=0,o=t.length;a<o;a++)n.style[r]=t[a];else n.style[r]=t}},Rr=["Webkit","Moz","ms"],Dr=w((function(n){if(qr=qr||document.createElement("div").style,"filter"!==(n=k(n))&&n in qr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<Rr.length;t++){var r=Rr[t]+e;if(r in qr)return r}}));function Mr(n,e){var t=e.data,r=n.data;if(!(o(t.staticStyle)&&o(t.style)&&o(r.staticStyle)&&o(r.style))){var a,s,l=e.elm,c=r.staticStyle,u=r.normalizedStyle||r.style||{},d=c||u,p=Cr(e.data.style)||{};e.data.normalizedStyle=i(p.__ob__)?A({},p):p;var m=function(n,e){var t,r={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Ar(a.data))&&A(r,t);(t=Ar(n.data))&&A(r,t);for(var o=n;o=o.parent;)o.data&&(t=Ar(o.data))&&A(r,t);return r}(e,!0);for(s in d)o(m[s])&&Or(l,s,"");for(s in m)(a=m[s])!==d[s]&&Or(l,s,null==a?"":a)}}var Nr={create:Mr,update:Mr},Lr=/\s+/;function Ur(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Lr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function $r(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Lr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Jr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&A(e,Hr(n.name||"v")),A(e,n),e}return"string"==typeof n?Hr(n):void 0}}var Hr=w((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Fr=V&&!Z,Vr="transition",Gr="transitionend",Wr="animation",Xr="animationend";Fr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Vr="WebkitTransition",Gr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Wr="WebkitAnimation",Xr="webkitAnimationEnd"));var Yr=V?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Zr(n){Yr((function(){Yr(n)}))}function Kr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),Ur(n,e))}function Qr(n,e){n._transitionClasses&&b(n._transitionClasses,e),$r(n,e)}function na(n,e,t){var r=ta(n,e),a=r.type,o=r.timeout,i=r.propCount;if(!a)return t();var s="transition"===a?Gr:Xr,l=0,c=function(){n.removeEventListener(s,u),t()},u=function(e){e.target===n&&++l>=i&&c()};setTimeout((function(){l<i&&c()}),o+1),n.addEventListener(s,u)}var ea=/\b(transform|all)(,|$)/;function ta(n,e){var t,r=window.getComputedStyle(n),a=(r[Vr+"Delay"]||"").split(", "),o=(r[Vr+"Duration"]||"").split(", "),i=ra(a,o),s=(r[Wr+"Delay"]||"").split(", "),l=(r[Wr+"Duration"]||"").split(", "),c=ra(s,l),u=0,d=0;return"transition"===e?i>0&&(t="transition",u=i,d=o.length):"animation"===e?c>0&&(t="animation",u=c,d=l.length):d=(t=(u=Math.max(i,c))>0?i>c?"transition":"animation":null)?"transition"===t?o.length:l.length:0,{type:t,timeout:u,propCount:d,hasTransform:"transition"===t&&ea.test(r[Vr+"Property"])}}function ra(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return aa(e)+aa(n[t])})))}function aa(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function oa(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=Jr(n.data.transition);if(!o(r)&&!i(t._enterCb)&&1===t.nodeType){for(var a=r.css,s=r.type,l=r.enterClass,u=r.enterToClass,d=r.enterActiveClass,p=r.appearClass,m=r.appearToClass,h=r.appearActiveClass,f=r.beforeEnter,v=r.enter,x=r.afterEnter,b=r.enterCancelled,y=r.beforeAppear,T=r.appear,w=r.afterAppear,_=r.appearCancelled,k=r.duration,j=Ke,I=Ke.$vnode;I&&I.parent;)j=I.context,I=I.parent;var z=!j._isMounted||!n.isRootInsert;if(!z||T||""===T){var E=z&&p?p:l,S=z&&h?h:d,A=z&&m?m:u,C=z&&y||f,q=z&&"function"==typeof T?T:v,P=z&&w||x,B=z&&_||b,O=g(c(k)?k.enter:k);0;var R=!1!==a&&!Z,M=la(q),N=t._enterCb=D((function(){R&&(Qr(t,A),Qr(t,S)),N.cancelled?(R&&Qr(t,E),B&&B(t)):P&&P(t),t._enterCb=null}));n.data.show||ue(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),q&&q(t,N)})),C&&C(t),R&&(Kr(t,E),Kr(t,S),Zr((function(){Qr(t,E),N.cancelled||(Kr(t,A),M||(sa(O)?setTimeout(N,O):na(t,s,N)))}))),n.data.show&&(e&&e(),q&&q(t,N)),R||M||N()}}}function ia(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=Jr(n.data.transition);if(o(r)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var a=r.css,s=r.type,l=r.leaveClass,u=r.leaveToClass,d=r.leaveActiveClass,p=r.beforeLeave,m=r.leave,h=r.afterLeave,f=r.leaveCancelled,v=r.delayLeave,x=r.duration,b=!1!==a&&!Z,y=la(m),T=g(c(x)?x.leave:x);0;var w=t._leaveCb=D((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),b&&(Qr(t,u),Qr(t,d)),w.cancelled?(b&&Qr(t,l),f&&f(t)):(e(),h&&h(t)),t._leaveCb=null}));v?v(_):_()}function _(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),b&&(Kr(t,l),Kr(t,d),Zr((function(){Qr(t,l),w.cancelled||(Kr(t,u),y||(sa(T)?setTimeout(w,T):na(t,s,w)))}))),m&&m(t,w),b||y||w())}}function sa(n){return"number"==typeof n&&!isNaN(n)}function la(n){if(o(n))return!1;var e=n.fns;return i(e)?la(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function ca(n,e){!0!==e.data.show&&oa(e)}var ua=function(n){var e,t,r={},a=n.modules,c=n.nodeOps;for(e=0;e<tr.length;++e)for(r[tr[e]]=[],t=0;t<a.length;++t)i(a[t][tr[e]])&&r[tr[e]].push(a[t][tr[e]]);function u(n){var e=c.parentNode(n);i(e)&&c.removeChild(e,n)}function d(n,e,t,a,o,l,u){if(i(n.elm)&&i(l)&&(n=l[u]=yn(n)),n.isRootInsert=!o,!function(n,e,t,a){var o=n.data;if(i(o)){var l=i(n.componentInstance)&&o.keepAlive;if(i(o=o.hook)&&i(o=o.init)&&o(n,!1),i(n.componentInstance))return p(n,e),m(t,n.elm,a),s(l)&&function(n,e,t,a){var o,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,i(o=s.data)&&i(o=o.transition)){for(o=0;o<r.activate.length;++o)r.activate[o](er,s);e.push(s);break}m(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var d=n.data,f=n.children,v=n.tag;i(v)?(n.elm=n.ns?c.createElementNS(n.ns,v):c.createElement(v,n),x(n),h(n,f,e),i(d)&&g(n,e),m(t,n.elm,a)):s(n.isComment)?(n.elm=c.createComment(n.text),m(t,n.elm,a)):(n.elm=c.createTextNode(n.text),m(t,n.elm,a))}}function p(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(g(n,e),x(n)):(nr(n),e.push(n))}function m(n,e,t){i(n)&&(i(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function h(n,e,t){if(Array.isArray(e)){0;for(var r=0;r<e.length;++r)d(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function g(n,t){for(var a=0;a<r.create.length;++a)r.create[a](er,n);i(e=n.data.hook)&&(i(e.create)&&e.create(er,n),i(e.insert)&&t.push(n))}function x(n){var e;if(i(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;i(e=Ke)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function b(n,e,t,r,a,o){for(;r<=a;++r)d(t[r],o,n,e,!1,t,r)}function y(n){var e,t,a=n.data;if(i(a))for(i(e=a.hook)&&i(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)y(n.children[t])}function T(n,e,t){for(;e<=t;++e){var r=n[e];i(r)&&(i(r.tag)?(w(r),y(r)):u(r.elm))}}function w(n,e){if(i(e)||i(n.data)){var t,a=r.remove.length+1;for(i(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,a),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&w(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else u(n.elm)}function _(n,e,t,r){for(var a=t;a<r;a++){var o=e[a];if(i(o)&&rr(n,o))return a}}function k(n,e,t,a,l,u){if(n!==e){i(e.elm)&&i(a)&&(e=a[l]=yn(e));var p=e.elm=n.elm;if(s(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?z(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;i(h)&&i(m=h.hook)&&i(m=m.prepatch)&&m(n,e);var g=n.children,v=e.children;if(i(h)&&f(e)){for(m=0;m<r.update.length;++m)r.update[m](n,e);i(m=h.hook)&&i(m=m.update)&&m(n,e)}o(e.text)?i(g)&&i(v)?g!==v&&function(n,e,t,r,a){var s,l,u,p=0,m=0,h=e.length-1,f=e[0],g=e[h],v=t.length-1,x=t[0],y=t[v],w=!a;for(0;p<=h&&m<=v;)o(f)?f=e[++p]:o(g)?g=e[--h]:rr(f,x)?(k(f,x,r,t,m),f=e[++p],x=t[++m]):rr(g,y)?(k(g,y,r,t,v),g=e[--h],y=t[--v]):rr(f,y)?(k(f,y,r,t,v),w&&c.insertBefore(n,f.elm,c.nextSibling(g.elm)),f=e[++p],y=t[--v]):rr(g,x)?(k(g,x,r,t,m),w&&c.insertBefore(n,g.elm,f.elm),g=e[--h],x=t[++m]):(o(s)&&(s=ar(e,p,h)),o(l=i(x.key)?s[x.key]:_(x,e,p,h))?d(x,r,n,f.elm,!1,t,m):rr(u=e[l],x)?(k(u,x,r,t,m),e[l]=void 0,w&&c.insertBefore(n,u.elm,f.elm)):d(x,r,n,f.elm,!1,t,m),x=t[++m]);p>h?b(n,o(t[v+1])?null:t[v+1].elm,t,m,v,r):m>v&&T(e,p,h)}(p,g,v,t,u):i(v)?(i(n.text)&&c.setTextContent(p,""),b(p,null,v,0,v.length-1,t)):i(g)?T(g,0,g.length-1):i(n.text)&&c.setTextContent(p,""):n.text!==e.text&&c.setTextContent(p,e.text),i(h)&&i(m=h.hook)&&i(m=m.postpatch)&&m(n,e)}}}function j(n,e,t){if(s(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var I=v("attrs,class,staticClass,staticStyle,key");function z(n,e,t,r){var a,o=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(l)&&(i(a=l.hook)&&i(a=a.init)&&a(e,!0),i(a=e.componentInstance)))return p(e,t),!0;if(i(o)){if(i(c))if(n.hasChildNodes())if(i(a=l)&&i(a=a.domProps)&&i(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var u=!0,d=n.firstChild,m=0;m<c.length;m++){if(!d||!z(d,c[m],t,r)){u=!1;break}d=d.nextSibling}if(!u||d)return!1}else h(e,c,t);if(i(l)){var f=!1;for(var v in l)if(!I(v)){f=!0,g(e,t);break}!f&&l.class&&ie(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,a){if(!o(e)){var l,u=!1,p=[];if(o(n))u=!0,d(e,p);else{var m=i(n.nodeType);if(!m&&rr(n,e))k(n,e,p,null,null,a);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&z(n,e,p))return j(e,p,!0),n;l=n,n=new gn(c.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,g=c.parentNode(h);if(d(e,p,h._leaveCb?null:g,c.nextSibling(h)),i(e.parent))for(var v=e.parent,x=f(e);v;){for(var b=0;b<r.destroy.length;++b)r.destroy[b](v);if(v.elm=e.elm,x){for(var w=0;w<r.create.length;++w)r.create[w](er,v);var _=v.data.hook.insert;if(_.merged)for(var I=1;I<_.fns.length;I++)_.fns[I]()}else nr(v);v=v.parent}i(g)?T([n],0,0):i(n.tag)&&y(n)}}return j(e,p,u),e.elm}i(n)&&y(n)}}({nodeOps:Kt,modules:[fr,xr,jr,Er,Nr,V?{create:ca,activate:ca,remove:function(n,e){!0!==n.data.show?ia(n,e):e()}}:{}].concat(dr)});Z&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&xa(n,"input")}));var da={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?ue(t,"postpatch",(function(){da.componentUpdated(n,e,t)})):pa(n,e,t.context),n._vOptions=[].map.call(n.options,fa)):("textarea"===t.tag||Zt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",ga),n.addEventListener("compositionend",va),n.addEventListener("change",va),Z&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){pa(n,e,t.context);var r=n._vOptions,a=n._vOptions=[].map.call(n.options,fa);if(a.some((function(n,e){return!O(n,r[e])})))(n.multiple?e.value.some((function(n){return ha(n,a)})):e.value!==e.oldValue&&ha(e.value,a))&&xa(n,"change")}}};function pa(n,e,t){ma(n,e,t),(Y||K)&&setTimeout((function(){ma(n,e,t)}),0)}function ma(n,e,t){var r=e.value,a=n.multiple;if(!a||Array.isArray(r)){for(var o,i,s=0,l=n.options.length;s<l;s++)if(i=n.options[s],a)o=R(r,fa(i))>-1,i.selected!==o&&(i.selected=o);else if(O(fa(i),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));a||(n.selectedIndex=-1)}}function ha(n,e){return e.every((function(e){return!O(e,n)}))}function fa(n){return"_value"in n?n._value:n.value}function ga(n){n.target.composing=!0}function va(n){n.target.composing&&(n.target.composing=!1,xa(n.target,"input"))}function xa(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function ba(n){return!n.componentInstance||n.data&&n.data.transition?n:ba(n.componentInstance._vnode)}var ya={model:da,show:{bind:function(n,e,t){var r=e.value,a=(t=ba(t)).data&&t.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&a?(t.data.show=!0,oa(t,(function(){n.style.display=o}))):n.style.display=r?o:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=ba(t)).data&&t.data.transition?(t.data.show=!0,r?oa(t,(function(){n.style.display=n.__vOriginalDisplay})):ia(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,a){a||(n.style.display=n.__vOriginalDisplay)}}},Ta={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function wa(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?wa(Ge(e.children)):n}function _a(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var a=t._parentListeners;for(var o in a)e[k(o)]=a[o];return e}function ka(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var ja=function(n){return n.tag||ve(n)},Ia=function(n){return"show"===n.name},za={name:"transition",props:Ta,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(ja)).length){0;var r=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var o=wa(a);if(!o)return a;if(this._leaving)return ka(n,a);var i="__transition-"+this._uid+"-";o.key=null==o.key?o.isComment?i+"comment":i+o.tag:l(o.key)?0===String(o.key).indexOf(i)?o.key:i+o.key:o.key;var s=(o.data||(o.data={})).transition=_a(this),c=this._vnode,u=wa(c);if(o.data.directives&&o.data.directives.some(Ia)&&(o.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(o,u)&&!ve(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var d=u.data.transition=A({},s);if("out-in"===r)return this._leaving=!0,ue(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),ka(n,a);if("in-out"===r){if(ve(o))return c;var p,m=function(){p()};ue(s,"afterEnter",m),ue(s,"enterCancelled",m),ue(d,"delayLeave",(function(n){p=n}))}}return a}}},Ea=A({tag:String,moveClass:String},Ta);function Sa(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Aa(n){n.data.newPos=n.elm.getBoundingClientRect()}function Ca(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,a=e.top-t.top;if(r||a){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate("+r+"px,"+a+"px)",o.transitionDuration="0s"}}delete Ea.mode;var qa={Transition:za,TransitionGroup:{props:Ea,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var a=Qe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,a=this.$slots.default||[],o=this.children=[],i=_a(this),s=0;s<a.length;s++){var l=a[s];if(l.tag)if(null!=l.key&&0!==String(l.key).indexOf("__vlist"))o.push(l),t[l.key]=l,(l.data||(l.data={})).transition=i;else;}if(r){for(var c=[],u=[],d=0;d<r.length;d++){var p=r[d];p.data.transition=i,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?c.push(p):u.push(p)}this.kept=n(e,null,c),this.removed=u}return n(e,null,o)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Sa),n.forEach(Aa),n.forEach(Ca),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;Kr(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(Gr,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(Gr,n),t._moveCb=null,Qr(t,e))})}})))},methods:{hasMove:function(n,e){if(!Fr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){$r(t,n)})),Ur(t,e),t.style.display="none",this.$el.appendChild(t);var r=ta(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};jt.config.mustUseProp=function(n,e,t){return"value"===t&&Bt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},jt.config.isReservedTag=Xt,jt.config.isReservedAttr=Pt,jt.config.getTagNamespace=function(n){return Wt(n)?"svg":"math"===n?"math":void 0},jt.config.isUnknownElement=function(n){if(!V)return!0;if(Xt(n))return!1;if(n=n.toLowerCase(),null!=Yt[n])return Yt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Yt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Yt[n]=/HTMLUnknownElement/.test(e.toString())},A(jt.options.directives,ya),A(jt.options.components,qa),jt.prototype.__patch__=V?ua:q,jt.prototype.$mount=function(n,e){return function(n,e,t){var r;return n.$el=e,n.$options.render||(n.$options.render=xn),tt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new ht(n,r,q,{before:function(){n._isMounted&&!n._isDestroyed&&tt(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,tt(n,"mounted")),n}(this,n=n&&V?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},V&&setTimeout((function(){L.devtools&&on&&on.emit("init",jt)}),0);var Pa=jt;
/*!
  * vue-router v3.5.3
  * (c) 2021 Evan You
  * @license MIT
  */function Ba(n,e){for(var t in e)n[t]=e[t];return n}var Oa=/[!'()*]/g,Ra=function(n){return"%"+n.charCodeAt(0).toString(16)},Da=/%2C/g,Ma=function(n){return encodeURIComponent(n).replace(Oa,Ra).replace(Da,",")};function Na(n){try{return decodeURIComponent(n)}catch(n){0}return n}var La=function(n){return null==n||"object"==typeof n?n:String(n)};function Ua(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=Na(t.shift()),a=t.length>0?Na(t.join("=")):null;void 0===e[r]?e[r]=a:Array.isArray(e[r])?e[r].push(a):e[r]=[e[r],a]})),e):e}function $a(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return Ma(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(Ma(e)):r.push(Ma(e)+"="+Ma(n)))})),r.join("&")}return Ma(e)+"="+Ma(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var Ja=/\/?$/;function Ha(n,e,t,r){var a=r&&r.options.stringifyQuery,o=e.query||{};try{o=Fa(o)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:o,params:e.params||{},fullPath:Wa(e,a),matched:n?Ga(n):[]};return t&&(i.redirectedFrom=Wa(t,a)),Object.freeze(i)}function Fa(n){if(Array.isArray(n))return n.map(Fa);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=Fa(n[t]);return e}return n}var Va=Ha(null,{path:"/"});function Ga(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function Wa(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||$a)(r)+a}function Xa(n,e,t){return e===Va?n===e:!!e&&(n.path&&e.path?n.path.replace(Ja,"")===e.path.replace(Ja,"")&&(t||n.hash===e.hash&&Ya(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&Ya(n.query,e.query)&&Ya(n.params,e.params))))}function Ya(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,a){var o=n[t];if(r[a]!==t)return!1;var i=e[t];return null==o||null==i?o===i:"object"==typeof o&&"object"==typeof i?Ya(o,i):String(o)===String(i)}))}function Za(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var a=t.instances[r],o=t.enteredCbs[r];if(a&&o){delete t.enteredCbs[r];for(var i=0;i<o.length;i++)a._isBeingDestroyed||o[i](a)}}}}var Ka={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,a=e.parent,o=e.data;o.routerView=!0;for(var i=a.$createElement,s=t.name,l=a.$route,c=a._routerViewCache||(a._routerViewCache={}),u=0,d=!1;a&&a._routerRoot!==a;){var p=a.$vnode?a.$vnode.data:{};p.routerView&&u++,p.keepAlive&&a._directInactive&&a._inactive&&(d=!0),a=a.$parent}if(o.routerViewDepth=u,d){var m=c[s],h=m&&m.component;return h?(m.configProps&&Qa(h,o,m.route,m.configProps),i(h,o,r)):i()}var f=l.matched[u],g=f&&f.components[s];if(!f||!g)return c[s]=null,i();c[s]={component:g},o.registerRouteInstance=function(n,e){var t=f.instances[s];(e&&t!==n||!e&&t===n)&&(f.instances[s]=e)},(o.hook||(o.hook={})).prepatch=function(n,e){f.instances[s]=e.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==f.instances[s]&&(f.instances[s]=n.componentInstance),Za(l)};var v=f.props&&f.props[s];return v&&(Ba(c[s],{route:l,configProps:v}),Qa(g,o,l,v)),i(g,o,r)}};function Qa(n,e,t,r){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(a){a=e.props=Ba({},a);var o=e.attrs=e.attrs||{};for(var i in a)n.props&&i in n.props||(o[i]=a[i],delete a[i])}}function no(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var o=n.replace(/^\//,"").split("/"),i=0;i<o.length;i++){var s=o[i];".."===s?a.pop():"."!==s&&a.push(s)}return""!==a[0]&&a.unshift(""),a.join("/")}function eo(n){return n.replace(/\/+/g,"/")}var to=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},ro=xo,ao=co,oo=function(n,e){return po(co(n,e),e)},io=po,so=vo,lo=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function co(n,e){for(var t,r=[],a=0,o=0,i="",s=e&&e.delimiter||"/";null!=(t=lo.exec(n));){var l=t[0],c=t[1],u=t.index;if(i+=n.slice(o,u),o=u+l.length,c)i+=c[1];else{var d=n[o],p=t[2],m=t[3],h=t[4],f=t[5],g=t[6],v=t[7];i&&(r.push(i),i="");var x=null!=p&&null!=d&&d!==p,b="+"===g||"*"===g,y="?"===g||"*"===g,T=t[2]||s,w=h||f;r.push({name:m||a++,prefix:p||"",delimiter:T,optional:y,repeat:b,partial:x,asterisk:!!v,pattern:w?ho(w):v?".*":"[^"+mo(T)+"]+?"})}}return o<n.length&&(i+=n.substr(o)),i&&r.push(i),r}function uo(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function po(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",go(e)));return function(e,r){for(var a="",o=e||{},i=(r||{}).pretty?uo:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,u=o[l.name];if(null==u){if(l.optional){l.partial&&(a+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(to(u)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<u.length;d++){if(c=i(u[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");a+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(u),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');a+=l.prefix+c}}else a+=l}return a}}function mo(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function ho(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function fo(n,e){return n.keys=e,n}function go(n){return n&&n.sensitive?"":"i"}function vo(n,e,t){to(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,a=!1!==t.end,o="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)o+=mo(s);else{var l=mo(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),o+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var u=mo(t.delimiter||"/"),d=o.slice(-u.length)===u;return r||(o=(d?o.slice(0,-u.length):o)+"(?:"+u+"(?=$))?"),o+=a?"$":r&&d?"":"(?="+u+"|$)",fo(new RegExp("^"+o,go(t)),e)}function xo(n,e,t){return to(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return fo(n,e)}(n,e):to(n)?function(n,e,t){for(var r=[],a=0;a<n.length;a++)r.push(xo(n[a],e,t).source);return fo(new RegExp("(?:"+r.join("|")+")",go(t)),e)}(n,e,t):function(n,e,t){return vo(co(n,t),e,t)}(n,e,t)}ro.parse=ao,ro.compile=oo,ro.tokensToFunction=io,ro.tokensToRegExp=so;var bo=Object.create(null);function yo(n,e,t){e=e||{};try{var r=bo[n]||(bo[n]=ro.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function To(n,e,t,r){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var o=(a=Ba({},n)).params;return o&&"object"==typeof o&&(a.params=Ba({},o)),a}if(!a.path&&a.params&&e){(a=Ba({},a))._normalized=!0;var i=Ba(Ba({},e.params),a.params);if(e.name)a.name=e.name,a.params=i;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;a.path=yo(s,i,e.path)}else 0;return a}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(a.path||""),c=e&&e.path||"/",u=l.path?no(l.path,c,t||a.append):c,d=function(n,e,t){void 0===e&&(e={});var r,a=t||Ua;try{r=a(n||"")}catch(n){r={}}for(var o in e){var i=e[o];r[o]=Array.isArray(i)?i.map(La):La(i)}return r}(l.query,a.query,r&&r.options.parseQuery),p=a.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:u,query:d,hash:p}}var wo,_o=function(){},ko={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,a=t.resolve(this.to,r,this.append),o=a.location,i=a.route,s=a.href,l={},c=t.options.linkActiveClass,u=t.options.linkExactActiveClass,d=null==c?"router-link-active":c,p=null==u?"router-link-exact-active":u,m=null==this.activeClass?d:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,f=i.redirectedFrom?Ha(null,To(i.redirectedFrom),null,t):i;l[h]=Xa(r,f,this.exactPath),l[m]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(Ja,"/").indexOf(e.path.replace(Ja,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,f);var g=l[h]?this.ariaCurrentValue:null,v=function(n){jo(n)&&(e.replace?t.replace(o,_o):t.push(o,_o))},x={click:jo};Array.isArray(this.event)?this.event.forEach((function(n){x[n]=v})):x[this.event]=v;var b={class:l},y=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:i,navigate:v,isActive:l[m],isExactActive:l[h]});if(y){if(1===y.length)return y[0];if(y.length>1||!y.length)return 0===y.length?n():n("span",{},y)}if("a"===this.tag)b.on=x,b.attrs={href:s,"aria-current":g};else{var T=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(T){T.isStatic=!1;var w=T.data=Ba({},T.data);for(var _ in w.on=w.on||{},w.on){var k=w.on[_];_ in x&&(w.on[_]=Array.isArray(k)?k:[k])}for(var j in x)j in w.on?w.on[j].push(x[j]):w.on[j]=v;var I=T.data.attrs=Ba({},T.data.attrs);I.href=s,I["aria-current"]=g}else b.on=x}return n(this.tag,b,this.$slots.default)}};function jo(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Io="undefined"!=typeof window;function zo(n,e,t,r,a){var o=e||[],i=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,a,o,i){var s=a.path,l=a.name;0;var c=a.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return eo(e.path+"/"+n)}(s,o,c.strict);"boolean"==typeof a.caseSensitive&&(c.sensitive=a.caseSensitive);var d={path:u,regex:Eo(u,c),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:l,parent:o,matchAs:i,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var o=i?eo(i+"/"+a.path):void 0;n(e,t,r,a,d,o)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==a.alias)for(var p=Array.isArray(a.alias)?a.alias:[a.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:a.children};n(e,t,r,h,o,d.path||"/")}l&&(r[l]||(r[l]=d))}(o,i,s,n,a)}));for(var l=0,c=o.length;l<c;l++)"*"===o[l]&&(o.push(o.splice(l,1)[0]),c--,l--);return{pathList:o,pathMap:i,nameMap:s}}function Eo(n,e){return ro(n,[],e)}function So(n,e){var t=zo(n),r=t.pathList,a=t.pathMap,o=t.nameMap;function i(n,t,i){var s=To(n,t,!1,e),c=s.name;if(c){var u=o[c];if(!u)return l(null,s);var d=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in s.params)&&d.indexOf(p)>-1&&(s.params[p]=t.params[p]);return s.path=yo(u.path,s.params),l(u,s,i)}if(s.path){s.params={};for(var m=0;m<r.length;m++){var h=r[m],f=a[h];if(Ao(f.regex,s.path,s.params))return l(f,s,i)}}return l(null,s)}function s(n,t){var r=n.redirect,a="function"==typeof r?r(Ha(n,t,null,e)):r;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return l(null,t);var s=a,c=s.name,u=s.path,d=t.query,p=t.hash,m=t.params;if(d=s.hasOwnProperty("query")?s.query:d,p=s.hasOwnProperty("hash")?s.hash:p,m=s.hasOwnProperty("params")?s.params:m,c){o[c];return i({_normalized:!0,name:c,query:d,hash:p,params:m},void 0,t)}if(u){var h=function(n,e){return no(n,e.parent?e.parent.path:"/",!0)}(u,n);return i({_normalized:!0,path:yo(h,m),query:d,hash:p},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=i({_normalized:!0,path:yo(t,e.params)});if(r){var a=r.matched,o=a[a.length-1];return e.params=r.params,l(o,e)}return l(null,e)}(0,t,n.matchAs):Ha(n,t,r,e)}return{match:i,addRoute:function(n,e){var t="object"!=typeof n?o[n]:void 0;zo([e||n],r,a,o,t),t&&t.alias.length&&zo(t.alias.map((function(n){return{path:n,children:[e]}})),r,a,o,t)},getRoutes:function(){return r.map((function(n){return a[n]}))},addRoutes:function(n){zo(n,r,a,o)}}}function Ao(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var a=1,o=r.length;a<o;++a){var i=n.keys[a-1];i&&(t[i.name||"pathMatch"]="string"==typeof r[a]?Na(r[a]):r[a])}return!0}var Co=Io&&window.performance&&window.performance.now?window.performance:Date;function qo(){return Co.now().toFixed(3)}var Po=qo();function Bo(){return Po}function Oo(n){return Po=n}var Ro=Object.create(null);function Do(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=Ba({},window.history.state);return t.key=Bo(),window.history.replaceState(t,"",e),window.addEventListener("popstate",Lo),function(){window.removeEventListener("popstate",Lo)}}function Mo(n,e,t,r){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var o=function(){var n=Bo();if(n)return Ro[n]}(),i=a.call(n,e,t,r?o:null);i&&("function"==typeof i.then?i.then((function(n){Fo(n,o)})).catch((function(n){0})):Fo(i,o))}))}}function No(){var n=Bo();n&&(Ro[n]={x:window.pageXOffset,y:window.pageYOffset})}function Lo(n){No(),n.state&&n.state.key&&Oo(n.state.key)}function Uo(n){return Jo(n.x)||Jo(n.y)}function $o(n){return{x:Jo(n.x)?n.x:window.pageXOffset,y:Jo(n.y)?n.y:window.pageYOffset}}function Jo(n){return"number"==typeof n}var Ho=/^#\d/;function Fo(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var a=Ho.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var o=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(a,o={x:Jo((t=o).x)?t.x:0,y:Jo(t.y)?t.y:0})}else Uo(n)&&(e=$o(n))}else r&&Uo(n)&&(e=$o(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var Vo,Go=Io&&((-1===(Vo=window.navigator.userAgent).indexOf("Android 2.")&&-1===Vo.indexOf("Android 4.0")||-1===Vo.indexOf("Mobile Safari")||-1!==Vo.indexOf("Chrome")||-1!==Vo.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Wo(n,e){No();var t=window.history;try{if(e){var r=Ba({},t.state);r.key=Bo(),t.replaceState(r,"",n)}else t.pushState({key:Oo(qo())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function Xo(n){Wo(n,!0)}function Yo(n,e,t){var r=function(a){a>=n.length?t():n[a]?e(n[a],(function(){r(a+1)})):r(a+1)};r(0)}var Zo={redirected:2,aborted:4,cancelled:8,duplicated:16};function Ko(n,e){return ni(n,e,Zo.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return ei.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Qo(n,e){return ni(n,e,Zo.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function ni(n,e,t,r){var a=new Error(r);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var ei=["params","query","hash"];function ti(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ri(n,e){return ti(n)&&n._isRouter&&(null==e||n.type===e)}function ai(n){return function(e,t,r){var a=!1,o=0,i=null;oi(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){a=!0,o++;var l,c=li((function(e){var a;((a=e).__esModule||si&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:wo.extend(e),t.components[s]=e,--o<=0&&r()})),u=li((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=ti(n)?n:new Error(e),r(i))}));try{l=n(c,u)}catch(n){u(n)}if(l)if("function"==typeof l.then)l.then(c,u);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,u)}}})),a||r()}}function oi(n,e){return ii(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function ii(n){return Array.prototype.concat.apply([],n)}var si="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function li(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var ci=function(n,e){this.router=n,this.base=function(n){if(!n)if(Io){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=Va,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function ui(n,e,t,r){var a=oi(n,(function(n,r,a,o){var i=function(n,e){"function"!=typeof n&&(n=wo.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,r,a,o)})):t(i,r,a,o)}));return ii(r?a.reverse():a)}function di(n,e){if(e)return function(){return n.apply(e,arguments)}}ci.prototype.listen=function(n){this.cb=n},ci.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},ci.prototype.onError=function(n){this.errorCbs.push(n)},ci.prototype.transitionTo=function(n,e,t){var r,a=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var o=this.current;this.confirmTransition(r,(function(){a.updateRoute(r),e&&e(r),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(r,o)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!a.ready&&(ri(n,Zo.redirected)&&o===Va||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},ci.prototype.confirmTransition=function(n,e,t){var r=this,a=this.current;this.pending=n;var o,i,s=function(n){!ri(n)&&ti(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=a.matched.length-1;if(Xa(n,a)&&l===c&&n.matched[l]===a.matched[c])return this.ensureURL(),n.hash&&Mo(this.router,a,n,!1),s(((i=ni(o=a,n,Zo.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",i));var u=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=u.updated,p=u.deactivated,m=u.activated,h=[].concat(function(n){return ui(n,"beforeRouteLeave",di,!0)}(p),this.router.beforeHooks,function(n){return ui(n,"beforeRouteUpdate",di)}(d),m.map((function(n){return n.beforeEnter})),ai(m)),f=function(e,t){if(r.pending!==n)return s(Qo(a,n));try{e(n,a,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return ni(n,e,Zo.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):ti(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(Ko(a,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};Yo(h,f,(function(){Yo(function(n){return ui(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,a,o){return n(r,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),o(n)}))}}(n,t,r)}))}(m).concat(r.router.resolveHooks),f,(function(){if(r.pending!==n)return s(Qo(a,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){Za(n)}))}))}))},ci.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},ci.prototype.setupListeners=function(){},ci.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Va,this.pending=null};var pi=function(n){function e(e,t){n.call(this,e,t),this._startLocation=mi(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=Go&&t;r&&this.listeners.push(Do());var a=function(){var t=n.current,a=mi(n.base);n.current===Va&&a===n._startLocation||n.transitionTo(a,(function(n){r&&Mo(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Wo(eo(r.base+n.fullPath)),Mo(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Xo(eo(r.base+n.fullPath)),Mo(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(mi(this.base)!==this.current.fullPath){var e=eo(this.base+this.current.fullPath);n?Wo(e):Xo(e)}},e.prototype.getCurrentLocation=function(){return mi(this.base)},e}(ci);function mi(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(eo(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var hi=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=mi(n);if(!/^\/#/.test(e))return window.location.replace(eo(n+"/#"+e)),!0}(this.base)||fi()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=Go&&e;t&&this.listeners.push(Do());var r=function(){var e=n.current;fi()&&n.transitionTo(gi(),(function(r){t&&Mo(n.router,r,e,!0),Go||bi(r.fullPath)}))},a=Go?"popstate":"hashchange";window.addEventListener(a,r),this.listeners.push((function(){window.removeEventListener(a,r)}))}},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){xi(n.fullPath),Mo(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){bi(n.fullPath),Mo(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;gi()!==e&&(n?xi(e):bi(e))},e.prototype.getCurrentLocation=function(){return gi()},e}(ci);function fi(){var n=gi();return"/"===n.charAt(0)||(bi("/"+n),!1)}function gi(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function vi(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function xi(n){Go?Wo(vi(n)):window.location.hash=n}function bi(n){Go?Xo(vi(n)):window.location.replace(vi(n))}var yi=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){ri(n,Zo.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(ci),Ti=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=So(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!Go&&!1!==n.fallback,this.fallback&&(e="hash"),Io||(e="abstract"),this.mode=e,e){case"history":this.history=new pi(this,n.base);break;case"hash":this.history=new hi(this,n.base,this.fallback);break;case"abstract":this.history=new yi(this,n.base);break;default:0}},wi={currentRoute:{configurable:!0}};function _i(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Ti.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},wi.currentRoute.get=function(){return this.history&&this.history.current},Ti.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof pi||t instanceof hi){var r=function(n){t.setupListeners(),function(n){var r=t.current,a=e.options.scrollBehavior;Go&&a&&"fullPath"in n&&Mo(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Ti.prototype.beforeEach=function(n){return _i(this.beforeHooks,n)},Ti.prototype.beforeResolve=function(n){return _i(this.resolveHooks,n)},Ti.prototype.afterEach=function(n){return _i(this.afterHooks,n)},Ti.prototype.onReady=function(n,e){this.history.onReady(n,e)},Ti.prototype.onError=function(n){this.history.onError(n)},Ti.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Ti.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Ti.prototype.go=function(n){this.history.go(n)},Ti.prototype.back=function(){this.go(-1)},Ti.prototype.forward=function(){this.go(1)},Ti.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Ti.prototype.resolve=function(n,e,t){var r=To(n,e=e||this.history.current,t,this),a=this.match(r,e),o=a.redirectedFrom||a.fullPath;return{location:r,route:a,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?eo(n+"/"+r):r}(this.history.base,o,this.mode),normalizedTo:r,resolved:a}},Ti.prototype.getRoutes=function(){return this.matcher.getRoutes()},Ti.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==Va&&this.history.transitionTo(this.history.getCurrentLocation())},Ti.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Va&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Ti.prototype,wi),Ti.install=function n(e){if(!n.installed||wo!==e){n.installed=!0,wo=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",Ka),e.component("RouterLink",ko);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},Ti.version="3.5.3",Ti.isNavigationFailure=ri,Ti.NavigationFailureType=Zo,Ti.START_LOCATION=Va,Io&&window.Vue&&window.Vue.use(Ti);var ki=Ti;t(225),t(174),t(251),t(100),t(253),t(37),t(38),t(254);function ji(n){n.locales&&Object.keys(n.locales).forEach((function(e){n.locales[e].path=e})),Object.freeze(n)}t(74),t(89),t(121);function Ii(n){return(Ii="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}var zi=t(68),Ei=(t(184),t(17),t(44),t(227),t(228),t(40),t(25),{NotFound:function(){return Promise.all([t.e(0),t.e(4)]).then(t.bind(null,471))},Layout:function(){return Promise.all([t.e(0),t.e(2)]).then(t.bind(null,470))}}),Si={"v-77ed192e":function(){return t.e(5).then(t.bind(null,473))},"v-60a53068":function(){return t.e(6).then(t.bind(null,474))},"v-2af2dc2f":function(){return t.e(7).then(t.bind(null,475))},"v-53886bda":function(){return t.e(9).then(t.bind(null,476))},"v-08fb9d9b":function(){return t.e(8).then(t.bind(null,477))},"v-1e25af49":function(){return t.e(11).then(t.bind(null,478))},"v-6825d8c9":function(){return t.e(12).then(t.bind(null,479))},"v-1c4a9466":function(){return t.e(10).then(t.bind(null,480))},"v-08adb969":function(){return t.e(13).then(t.bind(null,481))},"v-4251b96e":function(){return t.e(14).then(t.bind(null,482))},"v-7554dcb0":function(){return t.e(15).then(t.bind(null,483))},"v-495f2cc9":function(){return t.e(16).then(t.bind(null,484))},"v-1804787e":function(){return t.e(17).then(t.bind(null,485))},"v-a030fbc4":function(){return t.e(19).then(t.bind(null,486))},"v-5512e450":function(){return t.e(20).then(t.bind(null,487))},"v-7675c675":function(){return t.e(22).then(t.bind(null,488))},"v-0f016060":function(){return t.e(18).then(t.bind(null,489))},"v-0bedbba6":function(){return t.e(21).then(t.bind(null,490))},"v-4b231790":function(){return t.e(23).then(t.bind(null,491))},"v-49874ed0":function(){return t.e(24).then(t.bind(null,492))},"v-8040b698":function(){return t.e(25).then(t.bind(null,493))},"v-1343a71d":function(){return t.e(26).then(t.bind(null,494))},"v-7df42191":function(){return t.e(28).then(t.bind(null,472))},"v-77b5865d":function(){return t.e(27).then(t.bind(null,495))},"v-f24f57d4":function(){return t.e(29).then(t.bind(null,496))},"v-4d788087":function(){return t.e(31).then(t.bind(null,497))},"v-5eeaf1e8":function(){return t.e(30).then(t.bind(null,498))},"v-51262ae7":function(){return t.e(32).then(t.bind(null,499))},"v-9547eff2":function(){return t.e(33).then(t.bind(null,500))},"v-35a1e8e8":function(){return t.e(34).then(t.bind(null,501))},"v-057acb1e":function(){return t.e(35).then(t.bind(null,502))},"v-ccd252e8":function(){return t.e(36).then(t.bind(null,503))},"v-2c233f33":function(){return t.e(37).then(t.bind(null,504))},"v-547c61b3":function(){return t.e(39).then(t.bind(null,505))},"v-40e59601":function(){return t.e(38).then(t.bind(null,506))},"v-598358ac":function(){return t.e(41).then(t.bind(null,507))},"v-4ef11850":function(){return t.e(40).then(t.bind(null,508))},"v-606287cc":function(){return t.e(42).then(t.bind(null,509))},"v-486f5f39":function(){return t.e(43).then(t.bind(null,510))},"v-05fdb0ec":function(){return t.e(44).then(t.bind(null,511))},"v-d7e58e4e":function(){return t.e(46).then(t.bind(null,512))},"v-1a72a707":function(){return t.e(48).then(t.bind(null,513))},"v-bbee7fd6":function(){return t.e(49).then(t.bind(null,514))},"v-23f81a77":function(){return t.e(47).then(t.bind(null,515))},"v-501d21b4":function(){return t.e(50).then(t.bind(null,516))},"v-7fa1e8d0":function(){return t.e(51).then(t.bind(null,517))},"v-32676bf1":function(){return t.e(52).then(t.bind(null,518))},"v-8507e4da":function(){return t.e(53).then(t.bind(null,519))},"v-30ff3e14":function(){return t.e(45).then(t.bind(null,520))},"v-ea774b7a":function(){return t.e(54).then(t.bind(null,521))},"v-a29aacc4":function(){return t.e(55).then(t.bind(null,522))},"v-0496ed8a":function(){return t.e(56).then(t.bind(null,523))},"v-2ef9475e":function(){return t.e(57).then(t.bind(null,524))},"v-6be602be":function(){return t.e(58).then(t.bind(null,525))},"v-f7a43d88":function(){return t.e(59).then(t.bind(null,526))},"v-19bb367d":function(){return t.e(60).then(t.bind(null,527))},"v-7ea8d084":function(){return t.e(61).then(t.bind(null,528))},"v-07547a19":function(){return t.e(62).then(t.bind(null,529))},"v-10e417f0":function(){return t.e(63).then(t.bind(null,530))},"v-1a4a2e8e":function(){return t.e(64).then(t.bind(null,531))},"v-2cd68ace":function(){return t.e(65).then(t.bind(null,532))},"v-7a34485c":function(){return t.e(66).then(t.bind(null,533))},"v-6e98cc5e":function(){return t.e(67).then(t.bind(null,534))},"v-1e209392":function(){return t.e(68).then(t.bind(null,535))},"v-3261ab78":function(){return t.e(69).then(t.bind(null,536))},"v-ba76f414":function(){return t.e(70).then(t.bind(null,537))},"v-633879ee":function(){return t.e(71).then(t.bind(null,538))},"v-4cdeeb1e":function(){return t.e(72).then(t.bind(null,539))},"v-a637d8d0":function(){return t.e(73).then(t.bind(null,540))},"v-74a249be":function(){return t.e(74).then(t.bind(null,541))},"v-195fc2cb":function(){return t.e(75).then(t.bind(null,542))},"v-4555a0c3":function(){return t.e(76).then(t.bind(null,543))},"v-6e015157":function(){return t.e(77).then(t.bind(null,544))},"v-2721eb0a":function(){return t.e(78).then(t.bind(null,545))},"v-a3689244":function(){return t.e(79).then(t.bind(null,546))},"v-d68294b4":function(){return t.e(80).then(t.bind(null,547))},"v-1308a3c9":function(){return t.e(81).then(t.bind(null,548))},"v-20a6df83":function(){return t.e(82).then(t.bind(null,549))},"v-58d3d128":function(){return t.e(83).then(t.bind(null,550))},"v-fb3dd6b6":function(){return t.e(84).then(t.bind(null,551))},"v-81321e74":function(){return t.e(85).then(t.bind(null,552))},"v-21911570":function(){return t.e(86).then(t.bind(null,553))},"v-2f72dc3c":function(){return t.e(87).then(t.bind(null,554))},"v-503841a2":function(){return t.e(89).then(t.bind(null,555))},"v-2f02c477":function(){return t.e(90).then(t.bind(null,556))},"v-50f4f5cb":function(){return t.e(88).then(t.bind(null,557))},"v-4ee9b879":function(){return t.e(91).then(t.bind(null,558))},"v-43b8a596":function(){return t.e(92).then(t.bind(null,559))},"v-6f7a53e0":function(){return t.e(93).then(t.bind(null,560))},"v-3a04ede6":function(){return t.e(94).then(t.bind(null,561))},"v-31791362":function(){return t.e(95).then(t.bind(null,562))},"v-22aa0bf8":function(){return t.e(96).then(t.bind(null,563))},"v-eee07e4e":function(){return t.e(97).then(t.bind(null,564))},"v-40aa029e":function(){return t.e(98).then(t.bind(null,565))},"v-6e91eb02":function(){return t.e(99).then(t.bind(null,566))},"v-1d5af834":function(){return t.e(100).then(t.bind(null,567))},"v-7001a452":function(){return t.e(101).then(t.bind(null,568))},"v-529c581c":function(){return t.e(102).then(t.bind(null,569))},"v-60d5e8ae":function(){return t.e(103).then(t.bind(null,570))},"v-ea0af4f6":function(){return t.e(104).then(t.bind(null,571))},"v-17908965":function(){return t.e(105).then(t.bind(null,572))}};function Ai(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var Ci=/-(\w)/g,qi=Ai((function(n){return n.replace(Ci,(function(n,e){return e?e.toUpperCase():""}))})),Pi=/\B([A-Z])/g,Bi=Ai((function(n){return n.replace(Pi,"-$1").toLowerCase()})),Oi=Ai((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function Ri(n,e){if(e)return n(e)?n(e):e.includes("-")?n(Oi(qi(e))):n(Oi(e))||n(Bi(e))}var Di=Object.assign({},Ei,Si),Mi=function(n){return Di[n]},Ni=function(n){return Si[n]},Li=function(n){return Ei[n]},Ui=function(n){return Pa.component(n)};function $i(n){return Ri(Ni,n)}function Ji(n){return Ri(Li,n)}function Hi(n){return Ri(Mi,n)}function Fi(n){return Ri(Ui,n)}function Vi(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return Promise.all(e.filter((function(n){return n})).map(function(){var n=Object(r.a)(regeneratorRuntime.mark((function n(e){var t;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(Fi(e)||!Hi(e)){n.next=5;break}return n.next=3,Hi(e)();case 3:t=n.sent,Pa.component(e,t.default);case 5:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}()))}function Gi(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var Wi=t(132),Xi=(t(185),t(107),t(70),t(215)),Yi=t.n(Xi),Zi=t(216),Ki=t.n(Zi),Qi={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Object(Wi.a)(n,1)[0]})).map((function(n){var e=Object(Wi.a)(n,2);e[0];return e[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=n)?e.map((function(n){var e="<meta";return Object.keys(n).forEach((function(t){e+=" ".concat(t,'="').concat(Ki()(n[t]),'"')})),e+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=es(this.$canonicalUrl)}var e},mounted:function(){this.currentMetaTags=Object(zi.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=ts(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return Yi()([{name:"description",content:this.$description}],n,this.siteMeta,rs)},updateCanonicalLink:function(){ns(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",es(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){ts(null,this.currentMetaTags),ns()}};function ns(){var n=document.querySelector("link[rel='canonical']");n&&n.remove()}function es(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return n?'<link href="'.concat(n,'" rel="canonical" />'):""}function ts(n,e){if(e&&Object(zi.a)(e).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var e=document.createElement("meta");return Object.keys(n).forEach((function(t){e.setAttribute(t,n[t])})),document.head.appendChild(e),e}))}function rs(n){for(var e=0,t=["name","property","itemprop"];e<t.length;e++){var r=t[e];if(n.hasOwnProperty(r))return n[r]+r}return JSON.stringify(n)}t(133);var as=t(148),os={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(as)()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,e=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return e.some((function(e){return e.hash===n.hash}))})),r=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),o=window.innerHeight+r,i=0;i<t.length;i++){var s=t[i],l=t[i+1],c=0===i&&0===r||r>=s.parentElement.offsetTop+10&&(!l||r<l.parentElement.offsetTop-10),u=decodeURIComponent(this.$route.hash);if(c&&u!==decodeURIComponent(s.hash)){var d=s;if(o===a)for(var p=i+1;p<t.length;p++)if(u===decodeURIComponent(t[p].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(d.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},is=(t(103),t(97)),ss=t.n(is),ls={mounted:function(){var n=this;ss.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,e,t){n.path===e.path||Pa.component(n.name)||ss.a.start(),t()})),this.$router.afterEach((function(){ss.a.done(),n.isSidebarOpen=!1}))}};t(72),t(71),t(75),t(361);function cs(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}t(137);function us(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function ds(n,e,t){return e&&us(n.prototype,e),t&&us(n,t),Object.defineProperty(n,"prototype",{writable:!1}),n}t(362);var ps=function(){function n(){cs(this,n);this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}return ds(n,[{key:"show",value:function(n){var e=this,t=n.text,r=void 0===t?"":t,a=n.duration,o=void 0===a?3e3:a,i=document.createElement("div");i.className="message move-in",i.innerHTML='\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">'.concat(r,"</div>\n    "),this.containerEl.appendChild(i),o>0&&setTimeout((function(){e.close(i)}),o)}},{key:"close",value:function(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",(function(){n.remove()}))}}]),n}(),ms={mounted:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy:function(){var n=this;setTimeout((function(){(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach((function(e){document.querySelectorAll(e).forEach(n.generateCopyButton)}))}),1e3)},generateCopyButton:function(n){var e=this;if(!n.classList.contains("codecopy-enabled")){var t=document.createElement("i");t.className="code-copy",t.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',t.title="Copy to clipboard",t.addEventListener("click",(function(){e.copyToClipboard(n.innerText)})),n.appendChild(t),n.classList.add("codecopy-enabled")}},copyToClipboard:function(n){var e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);var t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy"),(new ps).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};t(230),t(99),t(98),t(134),t(364);!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===t&&r.firstChild?r.insertBefore(a,r.firstChild):r.appendChild(a),a.styleSheet?a.styleSheet.cssText=n:a.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var hs={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},fs={},gs=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},vs=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:hs[n]},xs=function n(e,t,r){var a=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))a[n]=t[n];else{var e=n.replace("data","");a.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,o=e.children;a.appendChild(n(t,r,o))})),a},bs=function(n,e,t){var r,a=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==a.length||t?a:a[0]},ys=function(n,e){var t,r,a=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<template>([\s\S]+)<\/template>/),i=n.match(/<script>([\s\S]+)<\/script>/),s={css:a&&a[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=gs(s.html),s.jsTpl=(t=s.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),a=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,o=[eval][0](a);return o.template=e,o}(s.js,s.html);var l=vs("vue");return s.jsLib.unshift(l),s},Ts=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<html>([\s\S]+)<\/html>/),o=n.match(/<script>([\s\S]+)<\/script>/),i={css:r&&r[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return i.htmlTpl=i.html,i.jsTpl=i.js,i.script=(t=i.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),i},ws=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function _s(){var n=bs(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=bs(n,"vuepress-plugin-demo-block__code"),t=bs(n,"vuepress-plugin-demo-block__display"),r=bs(n,"vuepress-plugin-demo-block__footer"),a=bs(t,"vuepress-plugin-demo-block__app"),o=decodeURIComponent(n.dataset.code),i=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);i=i?JSON.parse(i):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),a=new Function("return ".concat(r))(),o={js:a,css:a.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:ws(n),htmlTpl:gs("")},i=vs("react"),s=vs("reactDOM");return o.jsLib.unshift(i,s),o}(o,i):"vanilla"===s?Ts(o,i):ys(o,i),u=xs("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(u),u.addEventListener("click",ks.bind(null,u,l,e,r)),vs("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,o=n.cssLib,i=a.concat(o).concat(vs("cssLib")).concat(vs("jsLib")).join(",");return xs("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:i}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),vs("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,o=n.cssLib,i=JSON.stringify({css:e,html:t,js:r,js_external:a.concat(vs("jsLib")).join(";"),css_external:o.concat(vs("cssLib")).join(";"),layout:vs("codepenLayout"),js_pre_processor:vs("codepenJsProcessor"),editors:vs("codepenEditors")});return xs("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:i}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==i.horizontal?i.horizontal:vs("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var d=e.firstChild.cloneNode(!0);d.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(d)}if(c.css&&function(n){if(!fs[n]){var e=xs("style",{innerHTML:n});document.body.appendChild(e),fs[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),a);else if("vue"===s){var p=(new(Vue.extend(c.script))).$mount();a.appendChild(p.$el)}else"vanilla"===s&&(a.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){_s()}),300)}function ks(n,e,t,r){var a="1"!==n.dataset.isExpand;t.style.height=a?"".concat(e,"px"):0,a?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=a?"1":"0"}var js={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},_s()},updated:function(){_s()}},Is=(t(219),"auto"),zs="zoom-in",Es="zoom-out",Ss="grab",As="move";function Cs(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a={passive:!1};r?n.addEventListener(e,t,a):n.removeEventListener(e,t,a)}function qs(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Ps(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Bs(n,e,t){!function(n){var e=Os,t=Rs;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var a=n.transform;delete n.transform,n[t]=a}}(e);var r=n.style,a={};for(var o in e)t&&(a[o]=r[o]||""),r[o]=e[o];return a}var Os="transition",Rs="transform",Ds="transform",Ms="transitionend";var Ns=function(){},Ls={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Ns,onClose:Ns,onGrab:Ns,onMove:Ns,onRelease:Ns,onBeforeOpen:Ns,onBeforeClose:Ns,onBeforeGrab:Ns,onBeforeRelease:Ns,onImageLoading:Ns,onImageLoaded:Ns},Us={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Js(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,a=this.lastScrollPosition.y-t,o=this.options.scrollThreshold;(Math.abs(a)>=o||Math.abs(r)>=o)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if($s(n)&&!Js(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){$s(n)&&!Js(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function $s(n){return 0===n.button}function Js(n){return n.metaKey||n.ctrlKey}var Hs={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Bs(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Cs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Bs(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Fs="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Vs=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),Gs=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},Ws={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Ps(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,a=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Ss:Es,transition:Ds+"\n        "+r+"s\n        "+a,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Bs(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Bs(this.el,{transform:"none"})},grab:function(n,e,t){var r=Xs(),a=r.x-n,o=r.y-e;Bs(this.el,{cursor:As,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=Xs(),a=r.x-n,o=r.y-e;Bs(this.el,{transition:Ds,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Bs(this.el,this.styleClose)},restoreOpenStyle:function(){Bs(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Xs(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,a=r.customSize,o=r.scaleBase;if(!a&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(a&&"object"===(void 0===a?"undefined":Fs(a)))return{x:a.width/this.rect.width,y:a.height/this.rect.height};var i=this.rect.width/2,s=this.rect.height/2,l=Xs(),c={x:l.x-i,y:l.y-s},u=c.x/i,d=c.y/s,p=o+Math.min(u,d);if(a&&"string"==typeof a){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,f=parseFloat(a)*m/(100*this.rect.width),g=parseFloat(a)*h/(100*this.rect.height);if(p>f||p>g)return{x:f,y:g}}return{x:p,y:p}}};function Xs(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Ys(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){Cs(n,r,e[r],t)}))}var Zs=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Ws),this.overlay=Object.create(Hs),this.handler=Object.create(Us),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Gs({},Ls,e),this.overlay.init(this),this.handler.init(this)}return Vs(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=zs,Cs(n,"click",this.handler.click),this.options.preloadImage&&qs(Ps(n)));return this}},{key:"config",value:function(n){return n?(Gs(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var a=this.target.srcOriginal;null!=a&&(this.options.onImageLoading(r),qs(a,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Cs(document,"scroll",this.handler.scroll),Cs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Cs(window,"resize",this.handler.resizeWindow);var o=function n(){Cs(r,Ms,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Ys(document,e.handler,!0),t(r)};return Cs(r,Ms,o),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Is,this.overlay.fadeOut(),this.target.zoomOut(),Cs(document,"scroll",this.handler.scroll,!1),Cs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Cs(window,"resize",this.handler.resizeWindow,!1);var r=function r(){Cs(t,Ms,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Ys(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Cs(t,Ms,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var a=this.target.el;this.options.onBeforeGrab(a),this.released=!1,this.target.grab(n,e,t);var o=function n(){Cs(a,Ms,n,!1),r(a)};return Cs(a,Ms,o),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=As,this.target.move(n,e,t);var a=this.target.el,o=function n(){Cs(a,Ms,n,!1),r(a)};return Cs(a,Ms,o),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Is,this.target.restoreOpenStyle();var r=function r(){Cs(t,Ms,r,!1),n.lock=!1,n.released=!0,e(t)};return Cs(t,Ms,r),this}}}]),n}(),Ks=".theme-vdoing-content img:not(.no-zoom)",Qs=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),nl=Number("500"),el=function(){function n(){cs(this,n),this.instance=new Zs(Qs)}return ds(n,[{key:"update",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Ks;"undefined"!=typeof window&&this.instance.listen(n)}},{key:"updateDelay",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Ks,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:nl;setTimeout((function(){return n.update(e)}),t)}}]),n}(),tl=[Qi,os,ls,ms,js,{watch:{"$page.path":function(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted:function(){this.$vuepress.zooming=new el,this.$vuepress.zooming.updateDelay()}}],rl={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return Gi("layout",n),Pa.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},al=t(29),ol=Object(al.a)(rl,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){var r;switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),(r=n[e]).push.apply(r,Object(zi.a)(t));break;default:throw new Error("Unknown option name.")}}(ol,"mixins",tl);var il=[{name:"v-77ed192e",path:"/web/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-77ed192e").then(t)}},{path:"/web/index.html",redirect:"/web/"},{path:"/00.目录页/01.前端.html",redirect:"/web/"},{name:"v-60a53068",path:"/basic/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-60a53068").then(t)}},{path:"/basic/index.html",redirect:"/basic/"},{path:"/00.目录页/02.计算机基础.html",redirect:"/basic/"},{name:"v-2af2dc2f",path:"/technology/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-2af2dc2f").then(t)}},{path:"/technology/index.html",redirect:"/technology/"},{path:"/00.目录页/03.技术.html",redirect:"/technology/"},{name:"v-53886bda",path:"/note/javascript/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-53886bda").then(t)}},{path:"/note/javascript/index.html",redirect:"/note/javascript/"},{path:"/01.前端/20.学习笔记/00. JavaScript.html",redirect:"/note/javascript/"},{name:"v-08fb9d9b",path:"/more/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-08fb9d9b").then(t)}},{path:"/more/index.html",redirect:"/more/"},{path:"/00.目录页/04.更多.html",redirect:"/more/"},{name:"v-1e25af49",path:"/pages/2729d6/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-1e25af49").then(t)}},{path:"/pages/2729d6/index.html",redirect:"/pages/2729d6/"},{path:"/01.前端/20.学习笔记/10. CSS.html",redirect:"/pages/2729d6/"},{name:"v-6825d8c9",path:"/note/vue/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-6825d8c9").then(t)}},{path:"/note/vue/index.html",redirect:"/note/vue/"},{path:"/01.前端/20.学习笔记/15. Vue.html",redirect:"/note/vue/"},{name:"v-1c4a9466",path:"/pages/2eedd5/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-1c4a9466").then(t)}},{path:"/pages/2eedd5/index.html",redirect:"/pages/2eedd5/"},{path:"/01.前端/20.学习笔记/05. HTML.html",redirect:"/pages/2eedd5/"},{name:"v-08adb969",path:"/pages/74c0eb/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-08adb969").then(t)}},{path:"/pages/74c0eb/index.html",redirect:"/pages/74c0eb/"},{path:"/01.前端/20.学习笔记/20. Elctron.html",redirect:"/pages/74c0eb/"},{name:"v-4251b96e",path:"/pages/3bf799/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-4251b96e").then(t)}},{path:"/pages/3bf799/index.html",redirect:"/pages/3bf799/"},{path:"/01.前端/20.学习笔记/25. ThreeJS.html",redirect:"/pages/3bf799/"},{name:"v-7554dcb0",path:"/pages/51afd6/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-7554dcb0").then(t)}},{path:"/pages/51afd6/index.html",redirect:"/pages/51afd6/"},{path:"/01.前端/20.学习笔记/35.TypeScript笔记.html",redirect:"/pages/51afd6/"},{name:"v-495f2cc9",path:"/pages/196903/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-495f2cc9").then(t)}},{path:"/pages/196903/index.html",redirect:"/pages/196903/"},{path:"/01.前端/40.开发文档/00.ABP故障诊断系统开发文档.html",redirect:"/pages/196903/"},{name:"v-1804787e",path:"/pages/a1eaa9/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-1804787e").then(t)}},{path:"/pages/a1eaa9/index.html",redirect:"/pages/a1eaa9/"},{path:"/01.前端/40.开发文档/05.Electron-vue桌面端开发总结.html",redirect:"/pages/a1eaa9/"},{name:"v-a030fbc4",path:"/pages/8b9558/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-a030fbc4").then(t)}},{path:"/pages/8b9558/index.html",redirect:"/pages/8b9558/"},{path:"/02.计算机基础/05. 操作系统/05. 操作系统.html",redirect:"/pages/8b9558/"},{name:"v-5512e450",path:"/pages/184fd9/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-5512e450").then(t)}},{path:"/pages/184fd9/index.html",redirect:"/pages/184fd9/"},{path:"/02.计算机基础/10. Git/00. Git.html",redirect:"/pages/184fd9/"},{name:"v-7675c675",path:"/pages/42ad71/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-7675c675").then(t)}},{path:"/pages/42ad71/index.html",redirect:"/pages/42ad71/"},{path:"/03.其他技术/00. Python/00. Python语法.html",redirect:"/pages/42ad71/"},{name:"v-0f016060",path:"/pages/c317e3/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-0f016060").then(t)}},{path:"/pages/c317e3/index.html",redirect:"/pages/c317e3/"},{path:"/02.计算机基础/00. 计算机网络/00. 计算机网络.html",redirect:"/pages/c317e3/"},{name:"v-0bedbba6",path:"/note/Web3D/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-0bedbba6").then(t)}},{path:"/note/Web3D/index.html",redirect:"/note/Web3D/"},{path:"/02.计算机基础/25. Web3D/Web3D.html",redirect:"/note/Web3D/"},{name:"v-4b231790",path:"/pages/726723/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-4b231790").then(t)}},{path:"/pages/726723/index.html",redirect:"/pages/726723/"},{path:"/03.其他技术/00. Python/05. Numpy.html",redirect:"/pages/726723/"},{name:"v-49874ed0",path:"/pages/18746f/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-49874ed0").then(t)}},{path:"/pages/18746f/index.html",redirect:"/pages/18746f/"},{path:"/03.其他技术/00. Python/10. Matplotlib.html",redirect:"/pages/18746f/"},{name:"v-8040b698",path:"/pages/cd11f8/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-8040b698").then(t)}},{path:"/pages/cd11f8/index.html",redirect:"/pages/cd11f8/"},{path:"/04.更多/00. 面试/00. 前端面试八股文.html",redirect:"/pages/cd11f8/"},{name:"v-1343a71d",path:"/pages/8e13ff/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-1343a71d").then(t)}},{path:"/pages/8e13ff/index.html",redirect:"/pages/8e13ff/"},{path:"/04.更多/00. 面试/05. 美团前端实习一面.html",redirect:"/pages/8e13ff/"},{name:"v-7df42191",path:"/about/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-7df42191").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/05.关于/01.关于.html",redirect:"/about/"},{name:"v-77b5865d",path:"/pages/8384dd/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-77b5865d").then(t)}},{path:"/pages/8384dd/index.html",redirect:"/pages/8384dd/"},{path:"/04.更多/05. 收藏.html",redirect:"/pages/8384dd/"},{name:"v-f24f57d4",path:"/pages/beb6c0bd8a66cea6/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-f24f57d4").then(t)}},{path:"/pages/beb6c0bd8a66cea6/index.html",redirect:"/pages/beb6c0bd8a66cea6/"},{path:"/06.收藏夹/01.网站.html",redirect:"/pages/beb6c0bd8a66cea6/"},{name:"v-4d788087",path:"/archives/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-4d788087").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-5eeaf1e8",path:"/pages/47cf96/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-5eeaf1e8").then(t)}},{path:"/pages/47cf96/index.html",redirect:"/pages/47cf96/"},{path:"/06.收藏夹/02.常用的前端轮子.html",redirect:"/pages/47cf96/"},{name:"v-51262ae7",path:"/categories/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-51262ae7").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-9547eff2",path:"/tags/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-9547eff2").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-35a1e8e8",path:"/pages/f2e63f/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-35a1e8e8").then(t)}},{path:"/pages/f2e63f/index.html",redirect:"/pages/f2e63f/"},{path:"/_posts/随笔/你知道的越多，不知道的也就越多.html",redirect:"/pages/f2e63f/"},{name:"v-057acb1e",path:"/pages/829589/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-057acb1e").then(t)}},{path:"/pages/829589/index.html",redirect:"/pages/829589/"},{path:"/_posts/随笔/我做了一个手写春联小网页，祝大家虎年暴富.html",redirect:"/pages/829589/"},{name:"v-ccd252e8",path:"/pages/cd8bde/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-ccd252e8").then(t)}},{path:"/pages/cd8bde/index.html",redirect:"/pages/cd8bde/"},{path:"/_posts/随笔/拥抱生活，拥抱快乐.html",redirect:"/pages/cd8bde/"},{name:"v-2c233f33",path:"/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-2c233f33").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-547c61b3",path:"/pages/2431b2/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-547c61b3").then(t)}},{path:"/pages/2431b2/index.html",redirect:"/pages/2431b2/"},{path:"/《JavaScript》/01.《JavaScript初学》/05. ES6-11.html",redirect:"/pages/2431b2/"},{name:"v-40e59601",path:"/pages/618466/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-40e59601").then(t)}},{path:"/pages/618466/index.html",redirect:"/pages/618466/"},{path:"/《JavaScript》/01.《JavaScript初学》/00. JS基础.html",redirect:"/pages/618466/"},{name:"v-598358ac",path:"/pages/9503d3/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-598358ac").then(t)}},{path:"/pages/9503d3/index.html",redirect:"/pages/9503d3/"},{path:"/《JavaScript》/02.《现代JavaScript教程》/00. JavaScript编程语言/00. 简介.html",redirect:"/pages/9503d3/"},{name:"v-4ef11850",path:"/pages/f2f3bd/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-4ef11850").then(t)}},{path:"/pages/f2f3bd/index.html",redirect:"/pages/f2f3bd/"},{path:"/《JavaScript》/01.《JavaScript初学》/10. Web APIs.html",redirect:"/pages/f2f3bd/"},{name:"v-606287cc",path:"/pages/f7ae59/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-606287cc").then(t)}},{path:"/pages/f7ae59/index.html",redirect:"/pages/f7ae59/"},{path:"/《JavaScript》/02.《现代JavaScript教程》/00. JavaScript编程语言/01. JavaScript基础知识.html",redirect:"/pages/f7ae59/"},{name:"v-486f5f39",path:"/pages/d2d293/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-486f5f39").then(t)}},{path:"/pages/d2d293/index.html",redirect:"/pages/d2d293/"},{path:"/《JavaScript》/02.《现代JavaScript教程》/00. JavaScript编程语言/02. JavaScript基础语法.html",redirect:"/pages/d2d293/"},{name:"v-05fdb0ec",path:"/pages/ad315d/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-05fdb0ec").then(t)}},{path:"/pages/ad315d/index.html",redirect:"/pages/ad315d/"},{path:"/《JavaScript》/02.《现代JavaScript教程》/00. JavaScript编程语言/03. Object对象.html",redirect:"/pages/ad315d/"},{name:"v-d7e58e4e",path:"/pages/e05dce83e5129785/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-d7e58e4e").then(t)}},{path:"/pages/e05dce83e5129785/index.html",redirect:"/pages/e05dce83e5129785/"},{path:"/《TypeScript 从零实现 axios》/01.初识 TypeScript/01.简介.html",redirect:"/pages/e05dce83e5129785/"},{name:"v-1a72a707",path:"/pages/c85249f40e7a3517/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-1a72a707").then(t)}},{path:"/pages/c85249f40e7a3517/index.html",redirect:"/pages/c85249f40e7a3517/"},{path:"/《TypeScript 从零实现 axios》/01.初识 TypeScript/03.编写第一个 TypeScript 程序.html",redirect:"/pages/c85249f40e7a3517/"},{name:"v-bbee7fd6",path:"/pages/28672e2743bbc3a7/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-bbee7fd6").then(t)}},{path:"/pages/28672e2743bbc3a7/index.html",redirect:"/pages/28672e2743bbc3a7/"},{path:"/《TypeScript 从零实现 axios》/02.TypeScript 常用语法/01.基础类型.html",redirect:"/pages/28672e2743bbc3a7/"},{name:"v-23f81a77",path:"/pages/064e0f7b6b6142c8/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-23f81a77").then(t)}},{path:"/pages/064e0f7b6b6142c8/index.html",redirect:"/pages/064e0f7b6b6142c8/"},{path:"/《TypeScript 从零实现 axios》/01.初识 TypeScript/02.安装 TypeScript.html",redirect:"/pages/064e0f7b6b6142c8/"},{name:"v-501d21b4",path:"/pages/54add7f5cf78088e/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-501d21b4").then(t)}},{path:"/pages/54add7f5cf78088e/index.html",redirect:"/pages/54add7f5cf78088e/"},{path:"/《TypeScript 从零实现 axios》/02.TypeScript 常用语法/02.变量声明.html",redirect:"/pages/54add7f5cf78088e/"},{name:"v-7fa1e8d0",path:"/pages/54ea89b497ec3bb3/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-7fa1e8d0").then(t)}},{path:"/pages/54ea89b497ec3bb3/index.html",redirect:"/pages/54ea89b497ec3bb3/"},{path:"/《TypeScript 从零实现 axios》/02.TypeScript 常用语法/03.接口.html",redirect:"/pages/54ea89b497ec3bb3/"},{name:"v-32676bf1",path:"/pages/fad060bd9a8bfac6/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-32676bf1").then(t)}},{path:"/pages/fad060bd9a8bfac6/index.html",redirect:"/pages/fad060bd9a8bfac6/"},{path:"/《TypeScript 从零实现 axios》/02.TypeScript 常用语法/04.类.html",redirect:"/pages/fad060bd9a8bfac6/"},{name:"v-8507e4da",path:"/pages/870a51ba2a9edfad/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-8507e4da").then(t)}},{path:"/pages/870a51ba2a9edfad/index.html",redirect:"/pages/870a51ba2a9edfad/"},{path:"/《TypeScript 从零实现 axios》/02.TypeScript 常用语法/05.函数.html",redirect:"/pages/870a51ba2a9edfad/"},{name:"v-30ff3e14",path:"/pages/74296a/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-30ff3e14").then(t)}},{path:"/pages/74296a/index.html",redirect:"/pages/74296a/"},{path:"/《JavaScript》/02.《现代JavaScript教程》/00. JavaScript编程语言/04.数据类型.html",redirect:"/pages/74296a/"},{name:"v-ea774b7a",path:"/pages/8045759ec4ad3c01/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-ea774b7a").then(t)}},{path:"/pages/8045759ec4ad3c01/index.html",redirect:"/pages/8045759ec4ad3c01/"},{path:"/《TypeScript 从零实现 axios》/02.TypeScript 常用语法/06.泛型.html",redirect:"/pages/8045759ec4ad3c01/"},{name:"v-a29aacc4",path:"/pages/7279420c899c505d/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-a29aacc4").then(t)}},{path:"/pages/7279420c899c505d/index.html",redirect:"/pages/7279420c899c505d/"},{path:"/《TypeScript 从零实现 axios》/02.TypeScript 常用语法/07.类型推断.html",redirect:"/pages/7279420c899c505d/"},{name:"v-0496ed8a",path:"/pages/3fb6c2f52ab398e3/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-0496ed8a").then(t)}},{path:"/pages/3fb6c2f52ab398e3/index.html",redirect:"/pages/3fb6c2f52ab398e3/"},{path:"/《TypeScript 从零实现 axios》/02.TypeScript 常用语法/08.高级类型.html",redirect:"/pages/3fb6c2f52ab398e3/"},{name:"v-2ef9475e",path:"/pages/195af93fcc871b8b/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-2ef9475e").then(t)}},{path:"/pages/195af93fcc871b8b/index.html",redirect:"/pages/195af93fcc871b8b/"},{path:"/《TypeScript 从零实现 axios》/03.ts-axios 项目初始化/01.需求分析.html",redirect:"/pages/195af93fcc871b8b/"},{name:"v-6be602be",path:"/pages/6e11ac76475a2b3e/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-6be602be").then(t)}},{path:"/pages/6e11ac76475a2b3e/index.html",redirect:"/pages/6e11ac76475a2b3e/"},{path:"/《TypeScript 从零实现 axios》/03.ts-axios 项目初始化/02.初始化项目.html",redirect:"/pages/6e11ac76475a2b3e/"},{name:"v-f7a43d88",path:"/pages/acfe1e0b401fa984/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-f7a43d88").then(t)}},{path:"/pages/acfe1e0b401fa984/index.html",redirect:"/pages/acfe1e0b401fa984/"},{path:"/《TypeScript 从零实现 axios》/03.ts-axios 项目初始化/03.编写基础请求代码.html",redirect:"/pages/acfe1e0b401fa984/"},{name:"v-19bb367d",path:"/pages/1313dae575f6dddf/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-19bb367d").then(t)}},{path:"/pages/1313dae575f6dddf/index.html",redirect:"/pages/1313dae575f6dddf/"},{path:"/《TypeScript 从零实现 axios》/04.ts-axios 基础功能实现/01.处理请求 url 参数.html",redirect:"/pages/1313dae575f6dddf/"},{name:"v-7ea8d084",path:"/pages/887cd0918e2543d8/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-7ea8d084").then(t)}},{path:"/pages/887cd0918e2543d8/index.html",redirect:"/pages/887cd0918e2543d8/"},{path:"/《TypeScript 从零实现 axios》/04.ts-axios 基础功能实现/02.处理请求 body 数据.html",redirect:"/pages/887cd0918e2543d8/"},{name:"v-07547a19",path:"/pages/35c0ec1bb0b0faaf/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-07547a19").then(t)}},{path:"/pages/35c0ec1bb0b0faaf/index.html",redirect:"/pages/35c0ec1bb0b0faaf/"},{path:"/《TypeScript 从零实现 axios》/04.ts-axios 基础功能实现/03.处理请求 header.html",redirect:"/pages/35c0ec1bb0b0faaf/"},{name:"v-10e417f0",path:"/pages/a57debe141e1e4f4/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-10e417f0").then(t)}},{path:"/pages/a57debe141e1e4f4/index.html",redirect:"/pages/a57debe141e1e4f4/"},{path:"/《TypeScript 从零实现 axios》/04.ts-axios 基础功能实现/04.获取响应数据.html",redirect:"/pages/a57debe141e1e4f4/"},{name:"v-1a4a2e8e",path:"/pages/927161662ca32c24/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-1a4a2e8e").then(t)}},{path:"/pages/927161662ca32c24/index.html",redirect:"/pages/927161662ca32c24/"},{path:"/《TypeScript 从零实现 axios》/04.ts-axios 基础功能实现/05.处理响应 header.html",redirect:"/pages/927161662ca32c24/"},{name:"v-2cd68ace",path:"/pages/922cb4268499dc3f/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-2cd68ace").then(t)}},{path:"/pages/922cb4268499dc3f/index.html",redirect:"/pages/922cb4268499dc3f/"},{path:"/《TypeScript 从零实现 axios》/04.ts-axios 基础功能实现/06.处理响应 data.html",redirect:"/pages/922cb4268499dc3f/"},{name:"v-7a34485c",path:"/pages/6a8bef7b98dfdcf9/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-7a34485c").then(t)}},{path:"/pages/6a8bef7b98dfdcf9/index.html",redirect:"/pages/6a8bef7b98dfdcf9/"},{path:"/《TypeScript 从零实现 axios》/05.ts-axios 异常情况处理/01.错误处理.html",redirect:"/pages/6a8bef7b98dfdcf9/"},{name:"v-6e98cc5e",path:"/pages/22d581d8c2860b8a/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-6e98cc5e").then(t)}},{path:"/pages/22d581d8c2860b8a/index.html",redirect:"/pages/22d581d8c2860b8a/"},{path:"/《TypeScript 从零实现 axios》/05.ts-axios 异常情况处理/02.错误信息增强.html",redirect:"/pages/22d581d8c2860b8a/"},{name:"v-1e209392",path:"/pages/034e320f4af88bd4/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-1e209392").then(t)}},{path:"/pages/034e320f4af88bd4/index.html",redirect:"/pages/034e320f4af88bd4/"},{path:"/《TypeScript 从零实现 axios》/06.ts-axios 接口扩展/01.扩展接口.html",redirect:"/pages/034e320f4af88bd4/"},{name:"v-3261ab78",path:"/pages/8af227eae851ec97/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-3261ab78").then(t)}},{path:"/pages/8af227eae851ec97/index.html",redirect:"/pages/8af227eae851ec97/"},{path:"/《TypeScript 从零实现 axios》/06.ts-axios 接口扩展/02.axios 函数重载.html",redirect:"/pages/8af227eae851ec97/"},{name:"v-ba76f414",path:"/pages/c4489d0bab02cc0c/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-ba76f414").then(t)}},{path:"/pages/c4489d0bab02cc0c/index.html",redirect:"/pages/c4489d0bab02cc0c/"},{path:"/《TypeScript 从零实现 axios》/06.ts-axios 接口扩展/03.响应数据支持泛型.html",redirect:"/pages/c4489d0bab02cc0c/"},{name:"v-633879ee",path:"/pages/70651900f022f586/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-633879ee").then(t)}},{path:"/pages/70651900f022f586/index.html",redirect:"/pages/70651900f022f586/"},{path:"/《TypeScript 从零实现 axios》/07.ts-axios 拦截器实现/01.拦截器设计与实现.html",redirect:"/pages/70651900f022f586/"},{name:"v-4cdeeb1e",path:"/pages/937e4de6b81edeca/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-4cdeeb1e").then(t)}},{path:"/pages/937e4de6b81edeca/index.html",redirect:"/pages/937e4de6b81edeca/"},{path:"/《TypeScript 从零实现 axios》/08.ts-axios 配置化实现/01.合并配置的设计与实现.html",redirect:"/pages/937e4de6b81edeca/"},{name:"v-a637d8d0",path:"/pages/f5b627bfebba87fc/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-a637d8d0").then(t)}},{path:"/pages/f5b627bfebba87fc/index.html",redirect:"/pages/f5b627bfebba87fc/"},{path:"/《TypeScript 从零实现 axios》/08.ts-axios 配置化实现/02.请求和响应配置化.html",redirect:"/pages/f5b627bfebba87fc/"},{name:"v-74a249be",path:"/pages/7b49658c26f613bf/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-74a249be").then(t)}},{path:"/pages/7b49658c26f613bf/index.html",redirect:"/pages/7b49658c26f613bf/"},{path:"/《TypeScript 从零实现 axios》/08.ts-axios 配置化实现/03.扩展 create 静态接口.html",redirect:"/pages/7b49658c26f613bf/"},{name:"v-195fc2cb",path:"/pages/fdc6da5372397430/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-195fc2cb").then(t)}},{path:"/pages/fdc6da5372397430/index.html",redirect:"/pages/fdc6da5372397430/"},{path:"/《TypeScript 从零实现 axios》/09.ts-axios 取消功能实现/01.取消功能的设计与实现.html",redirect:"/pages/fdc6da5372397430/"},{name:"v-4555a0c3",path:"/pages/5dce43eba796a2ab/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-4555a0c3").then(t)}},{path:"/pages/5dce43eba796a2ab/index.html",redirect:"/pages/5dce43eba796a2ab/"},{path:"/《TypeScript 从零实现 axios》/10.ts-axios 更多功能实现/01.withCredentials.html",redirect:"/pages/5dce43eba796a2ab/"},{name:"v-6e015157",path:"/pages/390cb70e2b619449/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-6e015157").then(t)}},{path:"/pages/390cb70e2b619449/index.html",redirect:"/pages/390cb70e2b619449/"},{path:"/《TypeScript 从零实现 axios》/10.ts-axios 更多功能实现/02.XSRF 防御.html",redirect:"/pages/390cb70e2b619449/"},{name:"v-2721eb0a",path:"/pages/1376fd897809036e/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-2721eb0a").then(t)}},{path:"/pages/1376fd897809036e/index.html",redirect:"/pages/1376fd897809036e/"},{path:"/《TypeScript 从零实现 axios》/10.ts-axios 更多功能实现/03.上传和下载的进度监控.html",redirect:"/pages/1376fd897809036e/"},{name:"v-a3689244",path:"/pages/89cd6496c23159ae/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-a3689244").then(t)}},{path:"/pages/89cd6496c23159ae/index.html",redirect:"/pages/89cd6496c23159ae/"},{path:"/《TypeScript 从零实现 axios》/10.ts-axios 更多功能实现/04.HTTP 授权.html",redirect:"/pages/89cd6496c23159ae/"},{name:"v-d68294b4",path:"/pages/40b41ce8e8159567/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-d68294b4").then(t)}},{path:"/pages/40b41ce8e8159567/index.html",redirect:"/pages/40b41ce8e8159567/"},{path:"/《TypeScript 从零实现 axios》/10.ts-axios 更多功能实现/05.自定义合法状态码.html",redirect:"/pages/40b41ce8e8159567/"},{name:"v-1308a3c9",path:"/pages/7753b8141663e54a/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-1308a3c9").then(t)}},{path:"/pages/7753b8141663e54a/index.html",redirect:"/pages/7753b8141663e54a/"},{path:"/《TypeScript 从零实现 axios》/10.ts-axios 更多功能实现/06.自定义参数序列化.html",redirect:"/pages/7753b8141663e54a/"},{name:"v-20a6df83",path:"/pages/0b9f2ee2b4dbb728/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-20a6df83").then(t)}},{path:"/pages/0b9f2ee2b4dbb728/index.html",redirect:"/pages/0b9f2ee2b4dbb728/"},{path:"/《TypeScript 从零实现 axios》/10.ts-axios 更多功能实现/07.baseURL.html",redirect:"/pages/0b9f2ee2b4dbb728/"},{name:"v-58d3d128",path:"/pages/c26b053540a7dafa/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-58d3d128").then(t)}},{path:"/pages/c26b053540a7dafa/index.html",redirect:"/pages/c26b053540a7dafa/"},{path:"/《TypeScript 从零实现 axios》/10.ts-axios 更多功能实现/08.静态方法扩展.html",redirect:"/pages/c26b053540a7dafa/"},{name:"v-fb3dd6b6",path:"/pages/df36888424843793/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-fb3dd6b6").then(t)}},{path:"/pages/df36888424843793/index.html",redirect:"/pages/df36888424843793/"},{path:"/《TypeScript 从零实现 axios》/11.ts-axios 单元测试/01.前言.html",redirect:"/pages/df36888424843793/"},{name:"v-81321e74",path:"/pages/bf5c625a35757b37/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-81321e74").then(t)}},{path:"/pages/bf5c625a35757b37/index.html",redirect:"/pages/bf5c625a35757b37/"},{path:"/《TypeScript 从零实现 axios》/11.ts-axios 单元测试/02.Jest 安装和配置.html",redirect:"/pages/bf5c625a35757b37/"},{name:"v-21911570",path:"/pages/13f147a9b355c4c1/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-21911570").then(t)}},{path:"/pages/13f147a9b355c4c1/index.html",redirect:"/pages/13f147a9b355c4c1/"},{path:"/《TypeScript 从零实现 axios》/11.ts-axios 单元测试/03.辅助模块单元测试.html",redirect:"/pages/13f147a9b355c4c1/"},{name:"v-2f72dc3c",path:"/pages/e1d15dec8634e6b5/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-2f72dc3c").then(t)}},{path:"/pages/e1d15dec8634e6b5/index.html",redirect:"/pages/e1d15dec8634e6b5/"},{path:"/《TypeScript 从零实现 axios》/11.ts-axios 单元测试/04.请求模块单元测试.html",redirect:"/pages/e1d15dec8634e6b5/"},{name:"v-503841a2",path:"/pages/2eac7a0a0d644c15/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-503841a2").then(t)}},{path:"/pages/2eac7a0a0d644c15/index.html",redirect:"/pages/2eac7a0a0d644c15/"},{path:"/《TypeScript 从零实现 axios》/11.ts-axios 单元测试/06.Axios 实例模块单元测试.html",redirect:"/pages/2eac7a0a0d644c15/"},{name:"v-2f02c477",path:"/pages/97de6fd6293a2c6e/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-2f02c477").then(t)}},{path:"/pages/97de6fd6293a2c6e/index.html",redirect:"/pages/97de6fd6293a2c6e/"},{path:"/《TypeScript 从零实现 axios》/11.ts-axios 单元测试/07.拦截器模块单元测试.html",redirect:"/pages/97de6fd6293a2c6e/"},{name:"v-50f4f5cb",path:"/pages/ddd86ec39b5dfe33/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-50f4f5cb").then(t)}},{path:"/pages/ddd86ec39b5dfe33/index.html",redirect:"/pages/ddd86ec39b5dfe33/"},{path:"/《TypeScript 从零实现 axios》/11.ts-axios 单元测试/05.headers 模块单元测试.html",redirect:"/pages/ddd86ec39b5dfe33/"},{name:"v-4ee9b879",path:"/pages/cdf59840306f9e81/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-4ee9b879").then(t)}},{path:"/pages/cdf59840306f9e81/index.html",redirect:"/pages/cdf59840306f9e81/"},{path:"/《TypeScript 从零实现 axios》/11.ts-axios 单元测试/08.mergeConfig 模块单元测试.html",redirect:"/pages/cdf59840306f9e81/"},{name:"v-43b8a596",path:"/pages/6fa16aee29527032/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-43b8a596").then(t)}},{path:"/pages/6fa16aee29527032/index.html",redirect:"/pages/6fa16aee29527032/"},{path:"/《TypeScript 从零实现 axios》/11.ts-axios 单元测试/09.请求取消模块单元测试.html",redirect:"/pages/6fa16aee29527032/"},{name:"v-6f7a53e0",path:"/pages/9572134781ba6a25/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-6f7a53e0").then(t)}},{path:"/pages/9572134781ba6a25/index.html",redirect:"/pages/9572134781ba6a25/"},{path:"/《TypeScript 从零实现 axios》/11.ts-axios 单元测试/10.剩余模块单元测试.html",redirect:"/pages/9572134781ba6a25/"},{name:"v-3a04ede6",path:"/pages/3e5d5a45ad50f198/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-3a04ede6").then(t)}},{path:"/pages/3e5d5a45ad50f198/index.html",redirect:"/pages/3e5d5a45ad50f198/"},{path:"/《TypeScript 从零实现 axios》/12.ts-axios 部署与发布/01.ts-axios 编译与发布.html",redirect:"/pages/3e5d5a45ad50f198/"},{name:"v-31791362",path:"/pages/c6bdbd5bd60adf5a/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-31791362").then(t)}},{path:"/pages/c6bdbd5bd60adf5a/index.html",redirect:"/pages/c6bdbd5bd60adf5a/"},{path:"/《TypeScript 从零实现 axios》/12.ts-axios 部署与发布/02.引用 ts-axios 库.html",redirect:"/pages/c6bdbd5bd60adf5a/"},{name:"v-22aa0bf8",path:"/pages/81066a/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-22aa0bf8").then(t)}},{path:"/pages/81066a/index.html",redirect:"/pages/81066a/"},{path:"/《Vue》/00. Vue概念原理.html",redirect:"/pages/81066a/"},{name:"v-eee07e4e",path:"/pages/4e0a77/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-eee07e4e").then(t)}},{path:"/pages/4e0a77/index.html",redirect:"/pages/4e0a77/"},{path:"/《Vue》/05.  Vue核心.html",redirect:"/pages/4e0a77/"},{name:"v-40aa029e",path:"/pages/ecec85/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-40aa029e").then(t)}},{path:"/pages/ecec85/index.html",redirect:"/pages/ecec85/"},{path:"/《Vue》/10. Vue组件化.html",redirect:"/pages/ecec85/"},{name:"v-6e91eb02",path:"/pages/9c8d2a/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-6e91eb02").then(t)}},{path:"/pages/9c8d2a/index.html",redirect:"/pages/9c8d2a/"},{path:"/《Vue》/15. Vue CLI.html",redirect:"/pages/9c8d2a/"},{name:"v-1d5af834",path:"/pages/ea2c16/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-1d5af834").then(t)}},{path:"/pages/ea2c16/index.html",redirect:"/pages/ea2c16/"},{path:"/《Vue》/20. Vuex.html",redirect:"/pages/ea2c16/"},{name:"v-7001a452",path:"/pages/2ab1b4/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-7001a452").then(t)}},{path:"/pages/2ab1b4/index.html",redirect:"/pages/2ab1b4/"},{path:"/《Vue》/25. Vue Router.html",redirect:"/pages/2ab1b4/"},{name:"v-529c581c",path:"/pages/d6c83e/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-529c581c").then(t)}},{path:"/pages/d6c83e/index.html",redirect:"/pages/d6c83e/"},{path:"/《Vue》/30. Vue3.html",redirect:"/pages/d6c83e/"},{name:"v-60d5e8ae",path:"/pages/9ba5d9/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-60d5e8ae").then(t)}},{path:"/pages/9ba5d9/index.html",redirect:"/pages/9ba5d9/"},{path:"/《Web3D理论基础》/01.《现代计算机图形学》/00. 课程概论.html",redirect:"/pages/9ba5d9/"},{name:"v-ea0af4f6",path:"/pages/26dab9/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-ea0af4f6").then(t)}},{path:"/pages/26dab9/index.html",redirect:"/pages/26dab9/"},{path:"/《Web3D理论基础》/01.《现代计算机图形学》/02. 向量与线性代数.html",redirect:"/pages/26dab9/"},{name:"v-17908965",path:"/pages/37eb01/",component:ol,beforeEnter:function(n,e,t){Vi("Layout","v-17908965").then(t)}},{path:"/pages/37eb01/index.html",redirect:"/pages/37eb01/"},{path:"/《Web3D理论基础》/01.《现代计算机图形学》/03.变换.html",redirect:"/pages/37eb01/"},{path:"*",component:ol}],sl={title:"",description:"",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["meta",{name:"keywords",content:"前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"前端",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.前端",imgUrl:"/img/web.png",description:"JavaScript、ES6、Vue框架等前端技术"}},title:"前端",date:"2020-03-11T21:50:53.000Z",permalink:"/web",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E5%89%8D%E7%AB%AF.html",relativePath:"00.目录页/01.前端.md",key:"v-77ed192e",path:"/web/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"计算机基础",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.计算机基础",imgUrl:"/img/ui.png",description:"数据结构与算法、计算机网络、Git等"}},title:"计算机基础",date:"2020-03-11T21:50:54.000Z",permalink:"/basic",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html",relativePath:"00.目录页/02.计算机基础.md",key:"v-60a53068",path:"/basic/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"其他技术",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"03.其他技术",imgUrl:"/img/more.png",description:"技术文档、教程、技巧、总结等文章"}},title:"其他技术",date:"2020-03-11T21:50:55.000Z",permalink:"/technology",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.%E6%8A%80%E6%9C%AF.html",relativePath:"00.目录页/03.技术.md",key:"v-2af2dc2f",path:"/technology/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"JavaScript",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"《JavaScript》",imgUrl:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200112120340.png",description:"JavaScript学习笔记"}},title:"JavaScript",date:"2022-04-10T20:02:02.000Z",permalink:"/note/javascript",article:!1,comment:!1,editLink:!1,author:{name:"年华惊风雨",link:"https://github.com/wsy425"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/20.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/00.%20JavaScript.html",relativePath:"01.前端/20.学习笔记/00. JavaScript.md",key:"v-53886bda",path:"/note/javascript/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"更多",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"04.更多",imgUrl:"/img/more.png",description:"学习、面试、在线工具等更多文章和页面"}},title:"更多",date:"2020-03-11T21:50:56.000Z",permalink:"/more",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.%E6%9B%B4%E5%A4%9A.html",relativePath:"00.目录页/04.更多.md",key:"v-08fb9d9b",path:"/more/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"CSS",frontmatter:{title:"CSS",date:"2022-04-10T20:30:11.000Z",permalink:"/pages/2729d6/",categories:["前端","学习笔记"],tags:["CSS"],author:{name:"年华惊风雨",link:"https://github.com/wsy425"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/20.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%20CSS.html",relativePath:"01.前端/20.学习笔记/10. CSS.md",key:"v-1e25af49",path:"/pages/2729d6/",headers:[{level:2,title:"1 CSS简介",slug:"_1-css简介",normalizedTitle:"1 css简介",charIndex:2},{level:2,title:"2 语法规范",slug:"_2-语法规范",normalizedTitle:"2 语法规范",charIndex:81},{level:2,title:"3 代码风格",slug:"_3-代码风格",normalizedTitle:"3 代码风格",charIndex:369},{level:3,title:"3.1 样式格式",slug:"_3-1-样式格式",normalizedTitle:"3.1 样式格式",charIndex:380},{level:3,title:"3.2 样式大小写",slug:"_3-2-样式大小写",normalizedTitle:"3.2 样式大小写",charIndex:421},{level:3,title:"3.3 空格规范",slug:"_3-3-空格规范",normalizedTitle:"3.3 空格规范",charIndex:443},{level:2,title:"4 选择器",slug:"_4-选择器",normalizedTitle:"4 选择器",charIndex:494},{level:3,title:"4.1 基础选择器",slug:"_4-1-基础选择器",normalizedTitle:"4.1 基础选择器",charIndex:504},{level:4,title:"4.1.1 标签选择器",slug:"_4-1-1-标签选择器",normalizedTitle:"4.1.1 标签选择器",charIndex:517},{level:4,title:"4.1.2 类选择器",slug:"_4-1-2-类选择器",normalizedTitle:"4.1.2 类选择器",charIndex:570},{level:4,title:"4.1.3 id选择器",slug:"_4-1-3-id选择器",normalizedTitle:"4.1.3 id选择器",charIndex:790},{level:4,title:"4.1.4 通配符选择器",slug:"_4-1-4-通配符选择器",normalizedTitle:"4.1.4 通配符选择器",charIndex:952},{level:3,title:"4.2 复合选择器",slug:"_4-2-复合选择器",normalizedTitle:"4.2 复合选择器",charIndex:1101},{level:4,title:"4.2.1 后代选择器",slug:"_4-2-1-后代选择器",normalizedTitle:"4.2.1 后代选择器",charIndex:1129},{level:4,title:"4.2.2 子选择器",slug:"_4-2-2-子选择器",normalizedTitle:"4.2.2 子选择器",charIndex:1327},{level:4,title:"4.2.3 并集选择器",slug:"_4-2-3-并集选择器",normalizedTitle:"4.2.3 并集选择器",charIndex:1461},{level:4,title:"4.2.4 伪类选择器",slug:"_4-2-4-伪类选择器",normalizedTitle:"4.2.4 伪类选择器",charIndex:1545},{level:5,title:"链接伪类",slug:"链接伪类",normalizedTitle:"链接伪类",charIndex:1602},{level:5,title:"：focus伪类选择",slug:"focus伪类选择",normalizedTitle:"：focus伪类选择",charIndex:1768},{level:2,title:"5 字体属性",slug:"_5-字体属性",normalizedTitle:"5 字体属性",charIndex:1826},{level:3,title:"5.1 字体系列",slug:"_5-1-字体系列",normalizedTitle:"5.1 字体系列",charIndex:1837},{level:3,title:"5.2 字体大小",slug:"_5-2-字体大小",normalizedTitle:"5.2 字体大小",charIndex:2040},{level:3,title:"5.3 字体粗细",slug:"_5-3-字体粗细",normalizedTitle:"5.3 字体粗细",charIndex:2100},{level:3,title:"5.4 文字样式",slug:"_5-4-文字样式",normalizedTitle:"5.4 文字样式",charIndex:2195},{level:3,title:"5.5 字体复合属性",slug:"_5-5-字体复合属性",normalizedTitle:"5.5 字体复合属性",charIndex:2262},{level:2,title:"6 文本属性",slug:"_6-文本属性",normalizedTitle:"6 文本属性",charIndex:2396},{level:3,title:"6.1 文本颜色",slug:"_6-1-文本颜色",normalizedTitle:"6.1 文本颜色",charIndex:2444},{level:3,title:"6.2 对齐文本",slug:"_6-2-对齐文本",normalizedTitle:"6.2 对齐文本",charIndex:2554},{level:3,title:"6.3 装饰文本",slug:"_6-3-装饰文本",normalizedTitle:"6.3 装饰文本",charIndex:2651},{level:3,title:"6.4 文本缩进",slug:"_6-4-文本缩进",normalizedTitle:"6.4 文本缩进",charIndex:2864},{level:3,title:"6.5 行间距",slug:"_6-5-行间距",normalizedTitle:"6.5 行间距",charIndex:2980},{level:2,title:"7 引入方式",slug:"_7-引入方式",normalizedTitle:"7 引入方式",charIndex:3085},{level:3,title:"7.1 行内样式表（行内式）",slug:"_7-1-行内样式表-行内式",normalizedTitle:"7.1 行内样式表（行内式）",charIndex:3096},{level:3,title:"7.2 内部样式表（嵌入式）",slug:"_7-2-内部样式表-嵌入式",normalizedTitle:"7.2 内部样式表（嵌入式）",charIndex:3193},{level:3,title:"7.3 外部样式表",slug:"_7-3-外部样式表",normalizedTitle:"7.3 外部样式表",charIndex:3311},{level:2,title:"8 Emmet语法",slug:"_8-emmet语法",normalizedTitle:"8 emmet语法",charIndex:3424},{level:3,title:"8.1 快速生成CSS",slug:"_8-1-快速生成css",normalizedTitle:"8.1 快速生成css",charIndex:3438},{level:3,title:"8.2 快速格式化代码",slug:"_8-2-快速格式化代码",normalizedTitle:"8.2 快速格式化代码",charIndex:3466},{level:2,title:"9 元素显示模式",slug:"_9-元素显示模式",normalizedTitle:"9 元素显示模式",charIndex:3499},{level:3,title:"9.1 块元素",slug:"_9-1-块元素",normalizedTitle:"9.1 块元素",charIndex:3534},{level:3,title:"9.1.1 行内元素",slug:"_9-1-1-行内元素",normalizedTitle:"9.1.1 行内元素",charIndex:3663},{level:3,title:"9.1.2 行内块元素",slug:"_9-1-2-行内块元素",normalizedTitle:"9.1.2 行内块元素",charIndex:3797},{level:3,title:"9.1.3 元素显示模式的转换",slug:"_9-1-3-元素显示模式的转换",normalizedTitle:"9.1.3 元素显示模式的转换",charIndex:3919},{level:2,title:"10 背景",slug:"_10-背景",normalizedTitle:"10 背景",charIndex:4026},{level:3,title:"10.1 背景颜色",slug:"_10-1-背景颜色",normalizedTitle:"10.1 背景颜色",charIndex:4061},{level:3,title:"10.2 背景颜色线性渐变",slug:"_10-2-背景颜色线性渐变",normalizedTitle:"10.2 背景颜色线性渐变",charIndex:4130},{level:3,title:"10.3 背景图片",slug:"_10-3-背景图片",normalizedTitle:"10.3 背景图片",charIndex:4240},{level:3,title:"10.4 背景平铺",slug:"_10-4-背景平铺",normalizedTitle:"10.4 背景平铺",charIndex:4345},{level:3,title:"10.5 背景图片位置",slug:"_10-5-背景图片位置",normalizedTitle:"10.5 背景图片位置",charIndex:4468},{level:3,title:"10.6 背景附着",slug:"_10-6-背景附着",normalizedTitle:"10.6 背景附着",charIndex:4754},{level:3,title:"10.7 背景复合写法",slug:"_10-7-背景复合写法",normalizedTitle:"10.7 背景复合写法",charIndex:4839},{level:3,title:"10.8 背景色半透明",slug:"_10-8-背景色半透明",normalizedTitle:"10.8 背景色半透明",charIndex:4935},{level:2,title:"11 CSS三大特性",slug:"_11-css三大特性",normalizedTitle:"11 css三大特性",charIndex:5050},{level:3,title:"11.1 层叠性",slug:"_11-1-层叠性",normalizedTitle:"11.1 层叠性",charIndex:5065},{level:3,title:"11.2 继承性",slug:"_11-2-继承性",normalizedTitle:"11.2 继承性",charIndex:5130},{level:3,title:"11.3 优先级",slug:"_11-3-优先级",normalizedTitle:"11.3 优先级",charIndex:5208},{level:2,title:"12 盒子模型",slug:"_12-盒子模型",normalizedTitle:"12 盒子模型",charIndex:5290},{level:3,title:"12.1 border边框",slug:"_12-1-border边框",normalizedTitle:"12.1 border边框",charIndex:5302},{level:3,title:"12.1.1 content内容",slug:"_12-1-1-content内容",normalizedTitle:"12.1.1 content内容",charIndex:5654},{level:3,title:"12.1.2 padding内边距",slug:"_12-1-2-padding内边距",normalizedTitle:"12.1.2 padding内边距",charIndex:5686},{level:3,title:"12.1.3 margin外边距",slug:"_12-1-3-margin外边距",normalizedTitle:"12.1.3 margin外边距",charIndex:5910},{level:3,title:"12.1.4 圆角边框",slug:"_12-1-4-圆角边框",normalizedTitle:"12.1.4 圆角边框",charIndex:6287},{level:3,title:"12.1.5 盒子阴影",slug:"_12-1-5-盒子阴影",normalizedTitle:"12.1.5 盒子阴影",charIndex:6411},{level:2,title:"13 浮动",slug:"_13-浮动",normalizedTitle:"13 浮动",charIndex:6528},{level:3,title:"13.1 浮动语法",slug:"_13-1-浮动语法",normalizedTitle:"13.1 浮动语法",charIndex:6577},{level:3,title:"13.2 浮动特性",slug:"_13-2-浮动特性",normalizedTitle:"13.2 浮动特性",charIndex:6623},{level:3,title:"13.3 浮动布局注意点",slug:"_13-3-浮动布局注意点",normalizedTitle:"13.3 浮动布局注意点",charIndex:6768},{level:3,title:"13.4 清除浮动",slug:"_13-4-清除浮动",normalizedTitle:"13.4 清除浮动",charIndex:6866},{level:2,title:"14 书写顺序",slug:"_14-书写顺序",normalizedTitle:"14 书写顺序",charIndex:7586},{level:2,title:"15 定位",slug:"_15-定位",normalizedTitle:"15 定位",charIndex:7865},{level:3,title:"15.1 定位组成",slug:"_15-1-定位组成",normalizedTitle:"15.1 定位组成",charIndex:7875},{level:3,title:"15.2 定位模式",slug:"_15-2-定位模式",normalizedTitle:"15.2 定位模式",charIndex:7998},{level:4,title:"15.2.1 static静态定位",slug:"_15-2-1-static静态定位",normalizedTitle:"15.2.1 static静态定位",charIndex:8032},{level:4,title:"15.2.2 relative相对定位",slug:"_15-2-2-relative相对定位",normalizedTitle:"15.2.2 relative相对定位",charIndex:8102},{level:4,title:"15.2.3 absolute绝对定位",slug:"_15-2-3-absolute绝对定位",normalizedTitle:"15.2.3 absolute绝对定位",charIndex:8262},{level:4,title:"15.2.4 fixed固定定位",slug:"_15-2-4-fixed固定定位",normalizedTitle:"15.2.4 fixed固定定位",charIndex:8448},{level:4,title:"15.2.5 sticky粘性定位",slug:"_15-2-5-sticky粘性定位",normalizedTitle:"15.2.5 sticky粘性定位",charIndex:8641},{level:3,title:"15.3 边偏移",slug:"_15-3-边偏移",normalizedTitle:"15.3 边偏移",charIndex:8783},{level:3,title:"15.4 子绝父相",slug:"_15-4-子绝父相",normalizedTitle:"15.4 子绝父相",charIndex:8877},{level:3,title:"15.5 定位叠放次序",slug:"_15-5-定位叠放次序",normalizedTitle:"15.5 定位叠放次序",charIndex:8974},{level:3,title:"15.6 定位的扩展",slug:"_15-6-定位的扩展",normalizedTitle:"15.6 定位的扩展",charIndex:9114},{level:2,title:"16 元素的显示与隐藏",slug:"_16-元素的显示与隐藏",normalizedTitle:"16 元素的显示与隐藏",charIndex:9418},{level:3,title:"16.1 display",slug:"_16-1-display",normalizedTitle:"16.1 display",charIndex:9434},{level:3,title:"16.2 visibility",slug:"_16-2-visibility",normalizedTitle:"16.2 visibility",charIndex:9563},{level:3,title:"16.3 overflow",slug:"_16-3-overflow",normalizedTitle:"16.3 overflow",charIndex:9683},{level:2,title:"17 精灵图",slug:"_17-精灵图",normalizedTitle:"17 精灵图",charIndex:9856},{level:3,title:"17.1 精灵图使用",slug:"_17-1-精灵图使用",normalizedTitle:"17.1 精灵图使用",charIndex:9915},{level:2,title:"18 字体图标",slug:"_18-字体图标",normalizedTitle:"18 字体图标",charIndex:10049},{level:3,title:"18.1 字体图标优点",slug:"_18-1-字体图标优点",normalizedTitle:"18.1 字体图标优点",charIndex:10107},{level:3,title:"18.2 字体图标下载",slug:"_18-2-字体图标下载",normalizedTitle:"18.2 字体图标下载",charIndex:10180},{level:3,title:"18.3 字体图标引入",slug:"_18-3-字体图标引入",normalizedTitle:"18.3 字体图标引入",charIndex:10228},{level:3,title:"18.4 字体图标追加",slug:"_18-4-字体图标追加",normalizedTitle:"18.4 字体图标追加",charIndex:10707},{level:2,title:"19 CSS三角",slug:"_19-css三角",normalizedTitle:"19 css三角",charIndex:10765},{level:3,title:"19.1 原理",slug:"_19-1-原理",normalizedTitle:"19.1 原理",charIndex:10778},{level:3,title:"19.2 代码",slug:"_19-2-代码",normalizedTitle:"19.2 代码",charIndex:10820},{level:3,title:"19.3 定位",slug:"_19-3-定位",normalizedTitle:"19.3 定位",charIndex:10950},{level:2,title:"20 用户界面样式",slug:"_20-用户界面样式",normalizedTitle:"20 用户界面样式",charIndex:10989},{level:3,title:"20.1 鼠标样式",slug:"_20-1-鼠标样式",normalizedTitle:"20.1 鼠标样式",charIndex:11022},{level:3,title:"20.2 表单轮廓线",slug:"_20-2-表单轮廓线",normalizedTitle:"20.2 表单轮廓线",charIndex:11084},{level:3,title:"20.3 固定文本域",slug:"_20-3-固定文本域",normalizedTitle:"20.3 固定文本域",charIndex:11127},{level:2,title:"21 vertical-align",slug:"_21-vertical-align",normalizedTitle:"21 vertical-align",charIndex:11168},{level:3,title:"21.1 图片底侧空白间隙",slug:"_21-1-图片底侧空白间隙",normalizedTitle:"21.1 图片底侧空白间隙",charIndex:11339},{level:2,title:"22 溢出文字省略号显示",slug:"_22-溢出文字省略号显示",normalizedTitle:"22 溢出文字省略号显示",charIndex:11399},{level:3,title:"22.1 单行文本溢出",slug:"_22-1-单行文本溢出",normalizedTitle:"22.1 单行文本溢出",charIndex:11416},{level:3,title:"22.2 多行文本溢出",slug:"_22-2-多行文本溢出",normalizedTitle:"22.2 多行文本溢出",charIndex:11537},{level:2,title:"23 布局技巧",slug:"_23-布局技巧",normalizedTitle:"23 布局技巧",charIndex:11830},{level:3,title:"23.1 margin负值运用",slug:"_23-1-margin负值运用",normalizedTitle:"23.1 margin负值运用",charIndex:11842},{level:3,title:"23.2 文字围绕浮动元素",slug:"_23-2-文字围绕浮动元素",normalizedTitle:"23.2 文字围绕浮动元素",charIndex:12033},{level:2,title:"24 CSS初始化",slug:"_24-css初始化",normalizedTitle:"24 css初始化",charIndex:12092},{level:3,title:"24.1 标签内外边距清零",slug:"_24-1-标签内外边距清零",normalizedTitle:"24.1 标签内外边距清零",charIndex:12106},{level:3,title:"24.2 斜体文字不倾斜",slug:"_24-2-斜体文字不倾斜",normalizedTitle:"24.2 斜体文字不倾斜",charIndex:12173},{level:3,title:"24.3 去掉列表格式",slug:"_24-3-去掉列表格式",normalizedTitle:"24.3 去掉列表格式",charIndex:12245},{level:3,title:"24.4 图片初始化",slug:"_24-4-图片初始化",normalizedTitle:"24.4 图片初始化",charIndex:12300},{level:3,title:"24.5 按钮鼠标样式手",slug:"_24-5-按钮鼠标样式手",normalizedTitle:"24.5 按钮鼠标样式手",charIndex:12378},{level:3,title:"24.6 链接初始化",slug:"_24-6-链接初始化",normalizedTitle:"24.6 链接初始化",charIndex:12437},{level:3,title:"24.7 主页面初始化",slug:"_24-7-主页面初始化",normalizedTitle:"24.7 主页面初始化",charIndex:12550},{level:3,title:"24.8 清除浮动",slug:"_24-8-清除浮动",normalizedTitle:"24.8 清除浮动",charIndex:12730},{level:2,title:"25 CSS3新特性",slug:"_25-css3新特性",normalizedTitle:"25 css3新特性",charIndex:12876},{level:3,title:"25.1 CSS3新增选择器",slug:"_25-1-css3新增选择器",normalizedTitle:"25.1 css3新增选择器",charIndex:12926},{level:4,title:"25.1.1 属性选择器",slug:"_25-1-1-属性选择器",normalizedTitle:"25.1.1 属性选择器",charIndex:12944},{level:4,title:"25.1.2 结构伪类选择器",slug:"_25-1-2-结构伪类选择器",normalizedTitle:"25.1.2 结构伪类选择器",charIndex:12994},{level:4,title:"25.1.3 伪元素选择器",slug:"_25-1-3-伪元素选择器",normalizedTitle:"25.1.3 伪元素选择器",charIndex:13337},{level:3,title:"25.2 CSS3盒子模型",slug:"_25-2-css3盒子模型",normalizedTitle:"25.2 css3盒子模型",charIndex:13587},{level:3,title:"25.3 CSS3滤镜filter",slug:"_25-3-css3滤镜filter",normalizedTitle:"25.3 css3滤镜filter",charIndex:13787},{level:3,title:"25.4 CSS3 calc函数",slug:"_25-4-css3-calc函数",normalizedTitle:"25.4 css3 calc函数",charIndex:13889},{level:3,title:"25.5 CSS3过渡",slug:"_25-5-css3过渡",normalizedTitle:"25.5 css3过渡",charIndex:13942},{level:3,title:"25.6 CSS3转换transform",slug:"_25-6-css3转换transform",normalizedTitle:"25.6 css3转换transform",charIndex:14197},{level:4,title:"25.6.1 2D转换",slug:"_25-6-1-2d转换",normalizedTitle:"25.6.1 2d转换",charIndex:14221},{level:5,title:"移动：translate",slug:"移动-translate",normalizedTitle:"移动：translate",charIndex:14285},{level:5,title:"旋转：rotate",slug:"旋转-rotate",normalizedTitle:"旋转：rotate",charIndex:14456},{level:5,title:"设置元素转换中心点",slug:"设置元素转换中心点",normalizedTitle:"设置元素转换中心点",charIndex:14586},{level:5,title:"缩放：scale",slug:"缩放-scale",normalizedTitle:"缩放：scale",charIndex:14702},{level:5,title:"2D转换综合写法",slug:"_2d转换综合写法",normalizedTitle:"2d转换综合写法",charIndex:14884},{level:3,title:"25.7 CSS3动画",slug:"_25-7-css3动画",normalizedTitle:"25.7 css3动画",charIndex:14967},{level:4,title:"25.7.1 keyframes定义动画",slug:"_25-7-1-keyframes定义动画",normalizedTitle:"25.7.1 keyframes定义动画",charIndex:15003},{level:4,title:"25.7.2 元素使用动画",slug:"_25-7-2-元素使用动画",normalizedTitle:"25.7.2 元素使用动画",charIndex:15207},{level:4,title:"25.7.3 动画常见属性",slug:"_25-7-3-动画常见属性",normalizedTitle:"25.7.3 动画常见属性",charIndex:15294},{level:4,title:"25.7.4 动画简写属性",slug:"_25-7-4-动画简写属性",normalizedTitle:"25.7.4 动画简写属性",charIndex:15733},{level:2,title:"26 移动端基础",slug:"_26-移动端基础",normalizedTitle:"26 移动端基础",charIndex:15810},{level:3,title:"26.1 meta视口标签",slug:"_26-1-meta视口标签",normalizedTitle:"26.1 meta视口标签",charIndex:15823},{level:3,title:"26.2 二倍图",slug:"_26-2-二倍图",normalizedTitle:"26.2 二倍图",charIndex:15983},{level:2,title:"27 流式布局float、clear和vertical-align属性将失效",slug:"_27-流式布局float、clear和vertical-align属性将失效",normalizedTitle:"27 流式布局float、clear和vertical-align属性将失效",charIndex:16226},{level:3,title:"27.1 flex布局父项常见属性",slug:"_27-1-flex布局父项常见属性",normalizedTitle:"27.1 flex布局父项常见属性",charIndex:16269},{level:4,title:"27.1.1 flex-direction",slug:"_27-1-1-flex-direction",normalizedTitle:"27.1.1 flex-direction",charIndex:16290},{level:4,title:"27.1.2 justify-content",slug:"_27-1-2-justify-content",normalizedTitle:"27.1.2 justify-content",charIndex:16430},{level:4,title:"27.1.3 flex-warp",slug:"_27-1-3-flex-warp",normalizedTitle:"27.1.3 flex-warp",charIndex:16612},{level:4,title:"27.1.4 align-content",slug:"_27-1-4-align-content",normalizedTitle:"27.1.4 align-content",charIndex:16721},{level:4,title:"27.1.5 align-items",slug:"_27-1-5-align-items",normalizedTitle:"27.1.5 align-items",charIndex:16943},{level:4,title:"27.1.6 flex-flow",slug:"_27-1-6-flex-flow",normalizedTitle:"27.1.6 flex-flow",charIndex:17079},{level:3,title:"27.2 flex布局子项常见属性",slug:"_27-2-flex布局子项常见属性",normalizedTitle:"27.2 flex布局子项常见属性",charIndex:17160},{level:4,title:"27.2.1 flex属性",slug:"_27-2-1-flex属性",normalizedTitle:"27.2.1 flex属性",charIndex:17181},{level:4,title:"27.2.2 align-self",slug:"_27-2-2-align-self",normalizedTitle:"27.2.2 align-self",charIndex:17254},{level:4,title:"27.2.3 order",slug:"_27-2-3-order",normalizedTitle:"27.2.3 order",charIndex:17320},{level:2,title:"28 rem适配布局",slug:"_28-rem适配布局",normalizedTitle:"28 rem适配布局",charIndex:17372},{level:3,title:"28.1 rem基础",slug:"_28-1-rem基础",normalizedTitle:"28.1 rem基础",charIndex:17387},{level:3,title:"28.2 媒体查询",slug:"_28-2-媒体查询",normalizedTitle:"28.2 媒体查询",charIndex:17447},{level:3,title:"28.3 媒体查询引入资源",slug:"_28-3-媒体查询引入资源",normalizedTitle:"28.3 媒体查询引入资源",charIndex:17874},{level:3,title:"28.4 less基础",slug:"_28-4-less基础",normalizedTitle:"28.4 less基础",charIndex:17988},{level:4,title:"28.4.1 less变量",slug:"_28-4-1-less变量",normalizedTitle:"28.4.1 less变量",charIndex:18033},{level:4,title:"28.4.2 less嵌套",slug:"_28-4-2-less嵌套",normalizedTitle:"28.4.2 less嵌套",charIndex:18132},{level:4,title:"28.4.3 less运算",slug:"_28-4-3-less运算",normalizedTitle:"28.4.3 less运算",charIndex:18193},{level:2,title:"29 响应式布局",slug:"_29-响应式布局",normalizedTitle:"29 响应式布局",charIndex:18346},{level:3,title:"29.1 布局容器",slug:"_29-1-布局容器",normalizedTitle:"29.1 布局容器",charIndex:18359},{level:3,title:"29.2 bootstrap使用",slug:"_29-2-bootstrap使用",normalizedTitle:"29.2 bootstrap使用",charIndex:18898},{level:4,title:"29.2.1 创建文件夹结构",slug:"_29-2-1-创建文件夹结构",normalizedTitle:"29.2.1 创建文件夹结构",charIndex:18918},{level:4,title:"29.2.2 创建html骨架结构",slug:"_29-2-2-创建html骨架结构",normalizedTitle:"29.2.2 创建html骨架结构",charIndex:18958},{level:4,title:"29.2.3 引入相关样式文件",slug:"_29-2-3-引入相关样式文件",normalizedTitle:"29.2.3 引入相关样式文件",charIndex:18979},{level:4,title:"29.2.4 书写内容",slug:"_29-2-4-书写内容",normalizedTitle:"29.2.4 书写内容",charIndex:19048},{level:3,title:"29.3 ootstrap布局容器",slug:"_29-3-ootstrap布局容器",normalizedTitle:"29.3 ootstrap布局容器",charIndex:19105},{level:3,title:"29.4 bootstrap栅格系统",slug:"_29-4-bootstrap栅格系统",normalizedTitle:"29.4 bootstrap栅格系统",charIndex:19385},{level:4,title:"29.4.1 列嵌套",slug:"_29-4-1-列嵌套",normalizedTitle:"29.4.1 列嵌套",charIndex:19755},{level:4,title:"29.4.2 列偏移",slug:"_29-4-2-列偏移",normalizedTitle:"29.4.2 列偏移",charIndex:19867},{level:4,title:"29.4.3 列排序",slug:"_29-4-3-列排序",normalizedTitle:"29.4.3 列排序",charIndex:19916},{level:4,title:"29.4.4 响应式工具",slug:"_29-4-4-响应式工具",normalizedTitle:"29.4.4 响应式工具",charIndex:20001}],headersStr:"1 CSS简介 2 语法规范 3 代码风格 3.1 样式格式 3.2 样式大小写 3.3 空格规范 4 选择器 4.1 基础选择器 4.1.1 标签选择器 4.1.2 类选择器 4.1.3 id选择器 4.1.4 通配符选择器 4.2 复合选择器 4.2.1 后代选择器 4.2.2 子选择器 4.2.3 并集选择器 4.2.4 伪类选择器 链接伪类 ：focus伪类选择 5 字体属性 5.1 字体系列 5.2 字体大小 5.3 字体粗细 5.4 文字样式 5.5 字体复合属性 6 文本属性 6.1 文本颜色 6.2 对齐文本 6.3 装饰文本 6.4 文本缩进 6.5 行间距 7 引入方式 7.1 行内样式表（行内式） 7.2 内部样式表（嵌入式） 7.3 外部样式表 8 Emmet语法 8.1 快速生成CSS 8.2 快速格式化代码 9 元素显示模式 9.1 块元素 9.1.1 行内元素 9.1.2 行内块元素 9.1.3 元素显示模式的转换 10 背景 10.1 背景颜色 10.2 背景颜色线性渐变 10.3 背景图片 10.4 背景平铺 10.5 背景图片位置 10.6 背景附着 10.7 背景复合写法 10.8 背景色半透明 11 CSS三大特性 11.1 层叠性 11.2 继承性 11.3 优先级 12 盒子模型 12.1 border边框 12.1.1 content内容 12.1.2 padding内边距 12.1.3 margin外边距 12.1.4 圆角边框 12.1.5 盒子阴影 13 浮动 13.1 浮动语法 13.2 浮动特性 13.3 浮动布局注意点 13.4 清除浮动 14 书写顺序 15 定位 15.1 定位组成 15.2 定位模式 15.2.1 static静态定位 15.2.2 relative相对定位 15.2.3 absolute绝对定位 15.2.4 fixed固定定位 15.2.5 sticky粘性定位 15.3 边偏移 15.4 子绝父相 15.5 定位叠放次序 15.6 定位的扩展 16 元素的显示与隐藏 16.1 display 16.2 visibility 16.3 overflow 17 精灵图 17.1 精灵图使用 18 字体图标 18.1 字体图标优点 18.2 字体图标下载 18.3 字体图标引入 18.4 字体图标追加 19 CSS三角 19.1 原理 19.2 代码 19.3 定位 20 用户界面样式 20.1 鼠标样式 20.2 表单轮廓线 20.3 固定文本域 21 vertical-align 21.1 图片底侧空白间隙 22 溢出文字省略号显示 22.1 单行文本溢出 22.2 多行文本溢出 23 布局技巧 23.1 margin负值运用 23.2 文字围绕浮动元素 24 CSS初始化 24.1 标签内外边距清零 24.2 斜体文字不倾斜 24.3 去掉列表格式 24.4 图片初始化 24.5 按钮鼠标样式手 24.6 链接初始化 24.7 主页面初始化 24.8 清除浮动 25 CSS3新特性 25.1 CSS3新增选择器 25.1.1 属性选择器 25.1.2 结构伪类选择器 25.1.3 伪元素选择器 25.2 CSS3盒子模型 25.3 CSS3滤镜filter 25.4 CSS3 calc函数 25.5 CSS3过渡 25.6 CSS3转换transform 25.6.1 2D转换 移动：translate 旋转：rotate 设置元素转换中心点 缩放：scale 2D转换综合写法 25.7 CSS3动画 25.7.1 keyframes定义动画 25.7.2 元素使用动画 25.7.3 动画常见属性 25.7.4 动画简写属性 26 移动端基础 26.1 meta视口标签 26.2 二倍图 27 流式布局float、clear和vertical-align属性将失效 27.1 flex布局父项常见属性 27.1.1 flex-direction 27.1.2 justify-content 27.1.3 flex-warp 27.1.4 align-content 27.1.5 align-items 27.1.6 flex-flow 27.2 flex布局子项常见属性 27.2.1 flex属性 27.2.2 align-self 27.2.3 order 28 rem适配布局 28.1 rem基础 28.2 媒体查询 28.3 媒体查询引入资源 28.4 less基础 28.4.1 less变量 28.4.2 less嵌套 28.4.3 less运算 29 响应式布局 29.1 布局容器 29.2 bootstrap使用 29.2.1 创建文件夹结构 29.2.2 创建html骨架结构 29.2.3 引入相关样式文件 29.2.4 书写内容 29.3 ootstrap布局容器 29.4 bootstrap栅格系统 29.4.1 列嵌套 29.4.2 列偏移 29.4.3 列排序 29.4.4 响应式工具",content:'# 1 CSS简介\n\n 1. 主要使用场景：优化网页页面\n 2. css层叠样式表，标记语言\n 3. 主要用于设置HTML的文本内容、图片外型、网页布局\n\n\n# 2 语法规范\n\n 1. 规则由选择器和一条或多条声明构成\n 2. 选择器用于指定CSS样式的HTML标签，花括号是对该对象设置的具体样式\n 3. 属性和属性值以“键值对”的形式出现\n\n<html>\n<head>\n    <title>测试</title>\n    <style>\n        h4 {\n            color: cornflowerblue;\n        }\n    </style>\n</head>\n<body>\n    <h4>你喜欢的食物</h4>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3 代码风格\n\n\n# 3.1 样式格式\n\n 1. 紧凑格式\n 2. 展开格式：一行只写一个属性\n\n\n# 3.2 样式大小写\n\n一般使用小写\n\n\n# 3.3 空格规范\n\n 1. 属性值前，冒号后面写一个空格\n 2. 选择器和大括号前写一个空格\n\n\n# 4 选择器\n\n\n# 4.1 基础选择器\n\n# 4.1.1 标签选择器\n\n 1. HTML标签名作为选择器\n 2. 会对所有该标签下的内容进行设定\n\n# 4.1.2 类选择器\n\n 1. 语法标准\n\n<style>\n    .red {\n        color = red；\n    }\n</style>\n<div class=“red”>想要变红色的文字</div>\n\n\n1\n2\n3\n4\n5\n6\n\n 2. 用class属性进行选择\n 3. 可以选择一个或者某几个标签\n 4. 不能用标签的名字选为类名\n 5. 长类名用-连接\n 6. 一个标签可以使用多个类名，多个类名之间用空格隔开\n\n# 4.1.3 id选择器\n\n 1. 通过#定义id，以id属性选择\n 2. 语法标准\n\n<style>\n    #red {\n        color = red；\n    }\n</style>\n<div id=“red”>想要变红色的文字</div>\n\n\n1\n2\n3\n4\n5\n6\n\n 3. 只能调用一次，具有唯一性\n\n# 4.1.4 通配符选择器\n\n 1. 用*，表示选取页面所有标签\n 2. 语法标准\n\n<style>\n    * {\n        color = red；\n    }\n</style>\n<div>想要变红色的文字</div>\n\n\n1\n2\n3\n4\n5\n6\n\n 3. 通配符选择器不需要调用\n\n\n# 4.2 复合选择器\n\n把基础选择器进行组合形成的\n\n# 4.2.1 后代选择器\n\n 1. 又叫包含选择器，只能选择后代\n 2. 语法：父类 后代 {样式说明}\n 3. 后代和父类用空格分开\n 4. 最终选择的是子类\n 5. 后代可以是子类也可以是子类的子类\n 6. 两个都可以是任意的基础选择器\n\n<style>\n    ul.nav li a {\n        color: red;\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n\n\n# 4.2.2 子选择器\n\n 1. 又称子元素选择器，只能选择某元素最近一级子代\n 2. 语法：父类>子类 {样式说明}\n\n<style>\n    ul.nav>a {\n        color: red;\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n\n\n# 4.2.3 并集选择器\n\n 1. 选择多组标签，同时定义相同的样式，用于集体声明\n 2. 语法：用逗号分隔\n 3. 任何形式的选择器都可以作为并集选择器的一部分\n\n# 4.2.4 伪类选择器\n\n 1. 像某些标签添加特殊效果：比如给连接添加特殊效果\n 2. 语法：用冒号表示\n\n# 链接伪类\n\n 1. a:link 选择所有未访问的连接\n 2. a:visited 选择所有已访问的连接\n 3. a:hover 选择鼠标指针位于其上的连接\n 4. a:active 选择活动连接（鼠标按下未弹起的连接）\n 5. 为了确保能够生效，必须使用LVHA的顺序写\n 6. 浏览器中a有固定样式，要改变必须用a来设定\n\n# ：focus伪类选择\n\n 1. 用于获取光标所在的表单元素\n 2. 语法input:focus{样式说明}\n\n\n# 5 字体属性\n\n\n# 5.1 字体系列\n\n 1. 语法标准\n\n<style>\n    div {\n        font-family: "Microsoft Yahei"；\n    }\n</style>\n<div>想要变微软雅黑的文字</div>\n\n\n1\n2\n3\n4\n5\n6\n\n 2. 多个字体之间用空格隔开\n 3. 一个字体有空格时，最好用“”框起来\n 4. 多个字体的作用是前面的字体找不到的时候寻找下一个字体\n\n\n# 5.2 字体大小\n\n 1. {font-size: 20px}\n 2. 标题标签比较特殊，需要单独指定文字大小\n\n\n# 5.3 字体粗细\n\n 1. {font-weight :normal/400}\n 2. 正常=normal=400\n 3. 加粗=bold=700\n 4. 数字在100-900里选\n\n\n# 5.4 文字样式\n\n 1. {font-style: italic}\n 2. italic:倾斜\n 3. normal：正常\n\n\n# 5.5 字体复合属性\n\n 1. {font: font-style font-weight font-size/line-height font-family}\n 2. 顺序有要求，不需要的属性可以省略，但是必须保留font-size和font-family\n\n\n# 6 文本属性\n\n定义文本的外观，比如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等\n\n\n# 6.1 文本颜色\n\n 1. 语法\n\ndiv{\n    color: red;\n}\n\n\n1\n2\n3\n\n 2. 属性内容\n    * 预设值（pink）\n    * 16进制数：#+6个数字\n    * rgb代码\n\n\n# 6.2 对齐文本\n\n 1. text-align属性用于设置元素内文本内容的水平对齐方式\n 2. 语法\n\ndiv{\n    text-align: center;\n}\n\n\n1\n2\n3\n\n\n\n# 6.3 装饰文本\n\n 1. text-decoration属性规定添加到文本的修饰，可以给文本添加下划线、删除线、上划线等\n 2. 语法\n\ndiv{\n    text-decoration: underline;\n}\n\n\n1\n2\n3\n\n 3. 属性内容\n    * none：默认，没有装饰线\n    * underline：下划线\n    * overline：上划线\n    * line-through：删除线\n\n\n# 6.4 文本缩进\n\n 1. text-indent属性用来指定文本首行缩进\n 2. 语法\n\ndiv{\n    text-indent: 2em;\n}\n\n\n1\n2\n3\n\n 3. em是一个相对尺寸，当前元素一个文字大小的距离\n\n\n# 6.5 行间距\n\n 1. line-height属性由于设置行高\n 2. 语法\n\ndiv{\n    line-height: 2em;\n}\n\n\n1\n2\n3\n\n 3. 行高=上间距+文本高度+下间距\n\n\n\n\n# 7 引入方式\n\n\n# 7.1 行内样式表（行内式）\n\n 1. 在标签内部写上style属性\n 2. 语法<div style="color: red"></div>\n 3. 一定要是双引号，写法要符合CSS\n\n\n# 7.2 内部样式表（嵌入式）\n\n 1. css写入html内部，写在< style>标签里\n 2. 理论上< style>可以放在任何地方，但一般放在head里\n 3. 可以控制整个页面\n 4. 代码结构清晰，但并没有完全分离\n\n\n# 7.3 外部样式表\n\n 1. 样式单独写到CSS文件中，HTML引用CSS文件\n 2. 在HTML页面中，使用link标签引入\n 3. 语法<link rel="stylesheet" href="css文件路径">\n\n\n# 8 Emmet语法\n\n\n# 8.1 快速生成CSS\n\n 1. 简写+tab\n\n\n# 8.2 快速格式化代码\n\n 1. shift+alt+f\n\n\n# 9 元素显示模式\n\n 1. 元素显示模式：标签以什么方式显示\n\n\n# 9.1 块元素\n\n 1. 典型块元素：< div> < h1>\n 2. 独占一行\n 3. 宽度、高度、内外边距都可以控制\n 4. 宽度默认是父级的100%\n 5. 是一个容器及盒子，里面可以放行内元素或者块级元素\n 6. 文字类元素内不能使用块元素\n\n\n# 9.1.1 行内元素\n\n 1. 典型行内元素：< a> < span>\n 2. 相邻行内元素在一行上，一行显示多个\n 3. 宽高设置是无效的\n 4. 宽度默认是本身内容的宽度\n 5. 行内元素不能放块元素\n 6. 链接里不能再放链接\n 7. 链接可以放块元素\n\n\n# 9.1.2 行内块元素\n\n 1. 特殊标签： < img/> < input/> < td>\n 2. 相邻行内块元素在一行上，之间会有空白间隙，一行可以显示多个\n 3. 默认宽度是本身内容的宽度\n 4. 宽度、高度、内外边距都可以控制\n\n\n# 9.1.3 元素显示模式的转换\n\n 1. 转换成块元素display:block;\n 2. 转换成行内元素display:inline;\n 3. 转换成行内块元素display:inline-block;\n\n\n# 10 背景\n\n通过CSS背景属性，可以给页面元素添加背景样式\n\n\n# 10.1 背景颜色\n\n 1. 语法 background-color: 颜色值;\n 2. 默认值：transparent（透明）\n\n\n# 10.2 背景颜色线性渐变\n\n 1. CSS3新增属性\n 2. 语法background: -浏览器私有前缀-linear-gradient(起始方向,颜色1,颜色2,....)\n 3. 必须添加浏览器私有前缀\n\n\n# 10.3 背景图片\n\n 1. 实际开发常见于logo或者一些装饰性的小图片或者超大的背景图片\n 2. 优点是非常便于控制位置\n 3. 语法 background-image : none/url();\n\n\n# 10.4 背景平铺\n\n 1. 语法 background-repeat: repeat/no-repeat/repeat-x/repeat-y;\n 2. 默认情况是repeat\n 3. 背景颜色和背景图片可以同时添加，背景颜色位于最下层\n\n\n# 10.5 背景图片位置\n\n 1. 语法 background-position: x y;\n 2. x,y都可以使用方位名词和精确单位\n 3. 方位名词\n    * top\n    * center\n    * bottom\n    * left\n    * right\n 4. 两者都是方位名词，两个名词的顺序无关\n 5. 只指定一个方位名词，另一个默认为center\n 6. 精确单位第一个是x坐标，第二个是y坐标，顺序不能替换\n 7. 如果只指定一个精确单位，一定是x，垂直默认居中\n 8. 参数可以是混合单位。第一个是x坐标，第二个是y坐标，顺序不能替换\n\n\n# 10.6 背景附着\n\n 1. 设置背景图片是固定还是随着页面其余部分滚动\n 2. 语法 background-attachment: scroll/fixed;\n\n\n# 10.7 背景复合写法\n\n 1. 约定顺序：颜色+地址+平铺+滚动+位置\n 2. 语法 background: transparent url() repeat fixed top;\n\n\n# 10.8 背景色半透明\n\n 1. 语法 background: rgba(0,0,0,0.3)\n 2. alpha透明度，0-1之间\n 3. 习惯性把0.3中的0去掉\n 4. 只是设置背景色半透明，对盒子里的内容没有影响\n\n\n# 11 CSS三大特性\n\n\n# 11.1 层叠性\n\n 1. 相同选择器设置相同的样式，后面的会覆盖前面的\n 2. 冲突，后者覆盖\n 3. 不冲突，不层叠\n\n\n# 11.2 继承性\n\n 1. 子标签会集成父标签里的样式\n 2. 子元素可以集成父元素的样式（text-,font-,line-以及color属性）\n\n\n# 11.3 优先级\n\n 1. 选择器相同，则执行层叠性\n 2. 选择器不同，按权重大小\n 3. 权重是4组数字组成，不会进位\n 4. 复合选择器需要权重叠加\n\n\n# 12 盒子模型\n\n\n# 12.1 border边框\n\n 1. 由边框宽度、边框样式、边框颜色组成\n 2. border : border-width // border-style // border-color\n 3. 边框样式\n    * solid：实线边框\n    * dashed：虚线边框\n    * dotted：点线边框\n 4. 边框复合写法 border: 1px solid red;没有编写顺序要求\n 5. 边框分开编辑 border-top编辑上边框\n 6. 表格边框合并 border-collapse:collapse;\n    相邻表格边框合并在一起\n    只对table相关\n 7. 边框会影响盒子实际大小\n    盒子的实际大小 = 盒子高/宽 + 2*边框宽度 + padding\n\n\n# 12.1.1 content内容\n\n装文字、图片、盒子\n\n\n# 12.1.2 padding内边距\n\n 1. 设置盒子边框和内容之间的距离\n 2. padding-top // padding-bottom // padding-left // padding-right\n 3. 内边距复合写法\n 4. 内边距会影响盒子实际大小\n    盒子的实际大小 = 盒子高/宽 + 2*边框宽度 + 各部分padding\n 5. 如果盒子没有指定宽度，是继承的父级的宽度，加padding值的时候不会撑大盒子\n\n\n# 12.1.3 margin外边距\n\n 1. 设置盒子之间的距离\n 2. margin-top // margin-bottom // margin-left // margin-right\n 3. 外边距复合写法\n    与内边距一致\n 4. 块级盒子水平居中:盒子设置宽度，左右外边距设置为auto margin: 0 auto\n 5. 行内元素、行内块元素居中：给父级添加text-align: center;\n 6. 嵌套关系中父子元素中的父元素会取两者最大外边距，解决方法：\n    * 父元素定义上边框\n    * 父元素定义上内边距\n    * 父元素添加overflow: hidden;\n 7. 浏览器中会设置初始内外边距建议清除\n\n* {\n    padding: 0;\n    margin: 0;\n}\n\n\n1\n2\n3\n4\n\n\n\n# 12.1.4 圆角边框\n\n 1. 语法 border-radius: 圆角半径;\n 2. 参数可以用精确数和百分比\n 3. 参数可以写四个，从左上角顺时针旋转\n 4. 可以指定特定角border-top-left-radius: 圆角半径\n\n\n# 12.1.5 盒子阴影\n\n 1. 语法格式 box-shadow: h-shadow v-shadow blur spread color inset\n 2. 参数含义\n 3. 只要前两个参数是必须写的\n 4. 影子不占空间\n\n\n# 13 浮动\n\n 1. 浮动可以改变标签默认的排列方式\n 2. 多个块级元素横向排列用浮动\n\n\n# 13.1 浮动语法\n\n选择器 { float: none|left|right;}\n\n\n# 13.2 浮动特性\n\n 1. 脱标\n    * 浮动的元素在标准流中不占据位置\n    * 浮动元素和标准流的元素不在一个图层上\n 2. 一行显示并且顶部对齐\n    * 浮动的元素互相贴在一起，不会有缝隙\n    * 父级宽度装不下时，另起一行对齐\n 3. 具有行内块元素的特性\n\n\n# 13.3 浮动布局注意点\n\n 1. 浮动和标准流的父元素一起使用\n 2. 一个元素浮动了，理论上兄弟元素也都应该浮动\n 3. 浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流\n\n\n# 13.4 清除浮动\n\n 1. 父盒子无法设置高度的时候需要清除浮动\n 2. 语法 选择器 {clear: left|right|both}\n 3. 清除浮动的方法\n    * 额外标签法：在最后一个浮动元素后写一个空标签，设置清除浮动\n      新标签必须是块级元素\n    * 父元素添加overflow：属性设置hidden|auto|scroll\n      无法显示溢出的部分\n    * :after伪元素法：\n    \n    .clearfix:after {\n        content: "";\n        display: block;\n        height: 0;\n        clear: both;\n        visibility: hidden;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n    * 双微元素清除浮动\n    \n    .clearfix:before,.clearfix:after {\n        content: "";\n        display: table;\n        height: 0;\n    }\n    .clearfix:after {\n        clear: both;\n    }\n    .clearfix {\n        *zoom: 1;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n\n# 14 书写顺序\n\n 1. 布局定位属性：display|position|float|clear|visibility|overflow\n 2. 自身属性：width|height|margin|padding|border|background\n 3. 文本属性：color|font|text-decoration|text-align|vertical-align|white-space|break-word\n 4. 其他属性（CSS3）：content|cursor|border-radius|box-shadow|background\n\n\n# 15 定位\n\n\n# 15.1 定位组成\n\n 1. 定位：将盒子定在某一个位置，所以定位也是在摆放盒子，按照定位的方式移动盒子\n 2. 定位 = 定位模式 + 边偏移\n 3. 定位模式：用于指定一个元素在文档中的定位方式\n 4. 边偏移：决定该元素的最终位置\n\n\n# 15.2 定位模式\n\n通过CSS的position属性来设置\n\n# 15.2.1 static静态定位\n\n仅作了解\n\n 1. 默认定位方式，无定位的意思\n 2. 静态定位按照标准流摆放位置，没有边偏移\n\n# 15.2.2 relative相对定位\n\n 1. 相对定位是元素在移动位置的时候，是相对于它原来的位置来说的\n 2. 语法选择器 { position: relative;}\n 3. 原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待\n 4. 不脱标，继续保持原来位置\n 5. 主要的作用是限制绝对定位\n\n# 15.2.3 absolute绝对定位\n\n重要\n\n 1. 绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的\n 2. 语法选择器 { position: absolute;}\n 3. 如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位\n 4. 如果祖先有定位，则以最近一级的有定位祖先元素为参考点移动位置\n 5. 绝对定位不再占有原来的位置，脱离标准流\n\n# 15.2.4 fixed固定定位\n\n重要\n\n 1. 元素固定到浏览器可视区的某个位置\n 2. 语法选择器 { position: fixed;}\n 3. 以浏览器的可视窗口为参照点移动，与父级和滚动条没有关系\n 4. 固定定位不占有原先的位置\n 5. 技巧：固定在版心右侧位置选择器 { position: fixed;left:50%;margin-left:版心宽度的一半}\n\n# 15.2.5 sticky粘性定位\n\n仅作了解\n\n 1. 某些情况是固定定位，某些情况是相对定位\n 2. 语法选择器 { position: sticky;}\n 3. 以浏览器可视窗口为参照点移动元素\n 4. 占有原先的位置\n 5. 必须添加边偏移中的一个，否则则为相对定位\n\n\n# 15.3 边偏移\n\n边偏移就是定位盒子移动到最终位置\n\n 1. top：顶端偏移量\n 2. bottom：底部偏移量\n 3. left：左侧偏移量\n 4. right：右侧偏移量\n\n\n# 15.4 子绝父相\n\n 1. 子级使用绝对定位，父级则需要使用相对定位\n 2. 子级使用绝对定位，可以放在父级任何地方，不会影响兄弟\n 3. 父级需要加定位限制子级位置，且需要占有位置\n\n\n# 15.5 定位叠放次序\n\n 1. 语法选择器 { z-index: 1;}\n 2. 数值可以是正整数、负整数或者0，默认auto，数值越大，盒子越靠上\n 3. 如果数值相同，按照书写顺序，后来者居上\n 4. 数字后面不能加单位\n 5. 只有定位的盒子才有z-size属性\n\n\n# 15.6 定位的扩展\n\n 1. 绝对定位的盒子居中 选择器 { position: absolute;left:50%;margin-left:-盒子宽度的一半} 选择器 { position: absolute;top:50%;margin-top:-盒子高度度的一半}\n 2. 定位特殊特性\n    * 行内元素添加绝对或者固定定位，可以直接设置高度和宽度\n    * 块级元素添加绝对或者固定定位，默认是内容大小\n    * 脱标的盒子不会除法外边距塌陷\n 3. 绝对定位会完全压住盒子\n    * 浮动会压住标准流盒子，但不会压住标准流的文字\n    * 绝对或者固定定位会压住标准流的文字\n\n\n# 16 元素的显示与隐藏\n\n\n# 16.1 display\n\n 1. display属性用于设置一个元素如何显示\n 2. display:none;隐藏对象，隐藏后元素不占有原先的位置\n 3. display:block;显示对象；转换为块级元素\n 4. 搭配JS可以做很多网页特效\n\n\n# 16.2 visibility\n\n 1. visibility属性用于指定一个元素可见还是隐藏\n 2. visibility:visible;元素可见\n 3. visibility:hidden;元素隐藏，隐藏后元素占有原先的位置\n\n\n# 16.3 overflow\n\n 1. overflow属性指定了内容溢出的元素框时的状态\n 2. overflow:hidden;溢出内容隐藏\n 3. overflow:scroll;溢出内容显示滚动条，不溢出的时候也显示滚动条\n 4. overflow:auto;需要的时候添加滚动条\n 5. 对于定位的盒子要慎用，会切掉框架外的内容\n\n\n# 17 精灵图\n\n 1. 精灵技术：将网页中的一些小背景图像整合到一张大图中，减少服务器的接受和发送请求的次数\n\n\n# 17.1 精灵图使用\n\n 1. 主要针对背景图片使用，把多个小的背景图片整合到一张大图中\n 2. sprite：精灵图或者雪碧图，集成的大图\n 3. 通过移动背景图片的方式选择精灵图中的小图，background-position\n 4. 往上往左移动为负值\n\n\n# 18 字体图标\n\n 1. 主要用于显示网页中通用、常用的一些小图标\n 2. 展示的是一个图标，但本质是文字\n\n\n# 18.1 字体图标优点\n\n 1. 轻量级：一旦加载了，图标会马上渲染出来，减少服务器请求\n 2. 灵活性\n 3. 兼容性：支持所有浏览器\n\n\n# 18.2 字体图标下载\n\n 1. icomoon字体库\n 2. iconfont字体库\n\n\n# 18.3 字体图标引入\n\n 1. 把下载包里面的fonts文件夹放在CSS文件的根目录下\n 2. 字体声明\n\n@font-face {\n  font-family: \'icomoon\';\n  src:  url(\'fonts/icomoon.eot?p4ssmb\');\n  src:  url(\'fonts/icomoon.eot?p4ssmb#iefix\') format(\'embedded-opentype\'),\n    url(\'fonts/icomoon.ttf?p4ssmb\') format(\'truetype\'),\n    url(\'fonts/icomoon.woff?p4ssmb\') format(\'woff\'),\n    url(\'fonts/icomoon.svg?p4ssmb#icomoon\') format(\'svg\');\n  font-weight: normal;\n  font-style: normal;\n  font-display: block;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 18.4 字体图标追加\n\n 1. 把压缩包里的selection.json重新上传，再下载压缩包替代原文件\n\n\n# 19 CSS三角\n\n\n# 19.1 原理\n\n 1. 在宽高都为0的盒子设置border时会产生三角形\n\n\n# 19.2 代码\n\ndiv {\n    width: 0;\n    height: 0;\n    border: 50px solid transparent;\n    border-left-color: pink;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 19.3 定位\n\n 1. 子绝父相\n 2. 要移动border的两倍\n\n\n# 20 用户界面样式\n\n 1. 界面样式：更改用户操作样式\n\n\n# 20.1 鼠标样式\n\n 1. 设置鼠标在对象上时的光标形状\n 2. 语法选择器 {cursor: pointer}\n\n\n# 20.2 表单轮廓线\n\n 1. 取消表单轮廓线 outline: none;\n\n\n# 20.3 固定文本域\n\n 2. 防止拖动文本域resize: none;\n\n\n# 21 vertical-align\n\n 1. 图片和表单的垂直居中\n 2. 设置元素的垂直对齐方式，只针对行内元素或者行内块元素有效\n 3. 语法vertical-align : 参数\n 4. baseline：默认，元素放置在父元素的基线上\n 5. top：顶线对齐\n 6. middle：中线对齐\n 7. bottom：底线对齐\n\n\n# 21.1 图片底侧空白间隙\n\n 1. vertical-align不选择基线对齐\n 2. 把图片转换成块级元素\n\n\n# 22 溢出文字省略号显示\n\n\n# 22.1 单行文本溢出\n\n 1. 强制一行内显示文本white-space: nowrap;\n 2. 超出部分隐藏overflow: hidden;\n 3. 文字用省略号替代超出的部分text-overflow: ellipsis;\n\n\n# 22.2 多行文本溢出\n\n 1. 有比较大兼容性问题，适合webKit浏览器或移动端\n\n{\n    overflow: hidden;\n    text-overflow: ellipsis;\n    /* 弹性伸缩盒子模型显示 */\n    display: -webkit-box;\n    /* 限制在一个块元素显示的文本行数 */\n    -webkit-line-clamp:2;\n    /* 设置或检索伸缩盒对象的子元素排列方式 */\n    -webkit-box-orient: vertical;    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 23 布局技巧\n\n\n# 23.1 margin负值运用\n\n 1. 解决盒子边框变粗的问题：向左移动使右边的盒子边框压住左边盒子边框\n 2. margin-left: -1px;\n 3. 在使用这个技巧时，添加hover属性变化，左边的盒子有边框不能展示\n 4. 添加相对定位\n 5. position: relative;\n 6. 如果盒子里有定位，则提高盒子的层级\n 7. z-index: 1\n\n\n# 23.2 文字围绕浮动元素\n\n 1. 巧妙应用浮动元素不会压住文字的技巧\n 2. 图片添加浮动，文字为标准流\n\n\n# 24 CSS初始化\n\n\n# 24.1 标签内外边距清零\n\n* {\n    margin: 0;\n    padding: 0;\n}\n\n\n1\n2\n3\n4\n\n\n\n# 24.2 斜体文字不倾斜\n\nem,\ni {\n    margin: 0;\n    padding: 0;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 24.3 去掉列表格式\n\nli {\n    list-style: none;\n}\n\n\n1\n2\n3\n\n\n\n# 24.4 图片初始化\n\nimg {\n    border: 0;\n    vertical-align: middle;\n}\n\n\n1\n2\n3\n4\n\n\n\n# 24.5 按钮鼠标样式手\n\nbutton {\n    cursor: pointer;\n}\n\n\n1\n2\n3\n\n\n\n# 24.6 链接初始化\n\na {\n    color: #666;\n    text-decoration: none;\n}\na:hover {\n    color:#c81623\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 24.7 主页面初始化\n\nbody {\n    /* 文字抗锯齿 */\n    -webkit-font-smoothing: antialiased;\n    background-color: #fff;\n    font: 12px/1.5 Microsoft YaHei\n    color: #666;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 24.8 清除浮动\n\n.clearfix:after {\n    visibility: hidden;\n    clear: both;\n    display: block;\n    content: ".";\n    height: 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 25 CSS3新特性\n\n 1. 有兼容性问题，ie9+才支持\n 2. 移动端支持优于PC端\n\n\n# 25.1 CSS3新增选择器\n\n# 25.1.1 属性选择器\n\n 1. 根据元素特定的属性选择元素\n 2. 语法标签名[att]\n\n# 25.1.2 结构伪类选择器\n\n 1. 根据文档结构来选择元素，常用于根据父级选择器里面的子元素\n 2. nth-child(n)可以选择某个父元素的一个或多个特定的子元素\n    * n可以是数字，关键字和公式\n    * n如果是数字，就是选择第n个子元素，序号从1开始\n    * n可以是关键字：even偶数；odd奇数父类选择器 子类选择器:nth-chile(even/odd)\n    * n可以是公式，n是一个从0开始每次+1往后计算的；此处必须是n不能是其他字母\n    * 会把父类的所有孩子都标上序号，执行时先看nth-child(n)，再看子类选择器是否匹配\n 3. nth-of-type(n)会把指定了元素的孩子标上序号，先看子类选择器，再看后面的n\n\n# 25.1.3 伪元素选择器\n\n 1. 利用CSS创建新标签元素，不需要HTML标签，简化HTML结构\n 2. before和after创建一个元素，但属于行内元素\n 3. 新创建的这个元素在文档树中是找不到的，所以我们称为伪元素\n 4. 语法element::before{}\n 5. 里面必须写content属性，里面写文字内容\n 6. before在父元素内容的前面创建元素，after在父元素内容的后面插入元素\n 7. 伪元素选择器和标签选择器一样，权重为1\n 8. 可以用来清除浮动\n\n\n# 25.2 CSS3盒子模型\n\n 1. CSS3中可以通过box-sizing来指定盒子模型，有两个值：content-box;border-box\n 2. box-sizing默认是content-box，盒子大小=width+padding+border\n 3. box-sizing为border-box时，盒子最终大小为width；但有前提：padding+border< width\n\n\n# 25.3 CSS3滤镜filter\n\n 1. filter CSS属性将模糊或颜色偏移等图形效果应用于元素\n 2. 语法filter 函数();\n 3. blur()函数模糊处理，数值越大越模糊\n\n\n# 25.4 CSS3 calc函数\n\n 1. calc()函数让声明一些CSS属性值时执行一些计算\n\n\n# 25.5 CSS3过渡\n\n 1. 过渡动画:从一个状态渐渐得过渡到另一个状态\n 2. 语法transition: 要过渡的属性 花费时间 运动曲线 何时开始\n 3. 属性：想要变化的css属性，宽度高度 背景颜色 内外边距 要想所有属性直接写all\n 4. 花费时间：单位是秒，必须写单位\n 5. 运动曲线：默认是ease\n 6. 何时开始：单位是秒（必须写单位）可以设置延迟触发时间，默认是0s\n 7. 谁来变换给谁加transition，不写在:hover里\n 8. 如果需要多个属性，用逗号分隔\n\n\n# 25.6 CSS3转换transform\n\n# 25.6.1 2D转换\n\n 1. 2D转换是改变标签在二维平面上的位置和形状的一种技术\n 2. 同时写的时候要把位移先写\n\n# 移动：translate\n\n 1. 改变元素在页面中的位置\n 2. 语法transform: translate(x,y) |transform: translateX(n)\n 3. 定义2D转换中的移动，沿着X和Y轴移动元素\n 4. 最大优点：不会影响其他元素的位置\n 5. 百分比单位是相对于自身元素的\n 6. 对行内标签没有效果\n\n# 旋转：rotate\n\n 1. 让元素在2维平面内顺时针旋转或者逆时针旋转\n 2. 语法transform: rotate(度数)\n 3. rotate里面写度数，单位是deg，且不能省略\n 4. 角度为正，顺时针旋转\n 5. 默认旋转中心是元素的中心点\n\n# 设置元素转换中心点\n\n 1. 语法transform-origin: x y;\n 2. 后面的参数x、y要用空格隔开\n 3. x y默认转换的中心点是元素的中心点（50% 50%）\n 4. 还可以给x y设置像素或者方位名词\n\n# 缩放：scale\n\n 1. 控制元素的放大还是缩小\n 2. 语法transform: scale(x,y)\n 3. x、y用逗号隔开\n 4. transform: scale(1,1)不变，transform: scale(2,2)放大一倍\n 5. 如果只写一个参数则默认两个参数一致\n 6. 优势：可以设置转换中心点，默认以中心点缩放。而且不影响其他盒子\n\n# 2D转换综合写法\n\n 1. 格式transform: translate() rotate() scale()\n 2. 顺序会映像转换效果，位移要放在最前面\n\n\n# 25.7 CSS3动画\n\n 1. 先定义动画\n 2. 再使用动画\n\n# 25.7.1 keyframes定义动画\n\n 1. 语法\n\n@keyframes 动画名称 {\n    0% {\n        开始的样式\n    }\n    100%{\n        结束的样式\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 2. 动画序列\n    * 0%是动画开始；100%是动画完成。这中柜子就是动画序列\n    * 可以用from to关键字代替0%和100%\n\n# 25.7.2 元素使用动画\n\n 1. 语法animation-name:动画名称;animation-duration:持续时间;\n 2. 可以添加多个动画用逗号隔开\n\n# 25.7.3 动画常见属性\n\n 1. animation-name：动画名字，必须写\n 2. animation-duration：动画完成一个周期所需的事件秒或者毫秒，必须写\n 3. animation-timing-function：规定动画的速度曲线，默认ease\n    * \n    * steps就是分几步完成动画\n 4. animation-delay：规定何时开始，默认0\n 5. animation-iteration-count：规定动画被播放的次数，默认1；可以选择infinite\n 6. animation-direction：规定动画是否在下一周期你想播放，默认是normal；alternate逆播放\n 7. animation-fill-mode：规定动画结束后状态，保持forwards；回到其实位置backwards\n 8. animation-play-state：规定动画是都正在运行或暂停，默认是running；paused暂停\n\n# 25.7.4 动画简写属性\n\n 1. 语法animation:动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画开始或结束的状态\n\n\n# 26 移动端基础\n\n\n# 26.1 meta视口标签\n\n 1. 语法<meta name="viewport" content="width=device-width, user=scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">\n 2. 属性说明\n\n\n# 26.2 二倍图\n\n 1. 由于视网膜屏技术，设计移动端时要放大2倍来设计，防止模糊\n 2. 背景缩放background-size：规定背景图像的尺寸\n 3. 语法background-size: 背景图片宽度 背景图片高度;\n 4. 只写一个参数是指定的宽度，高度等比例缩放\n 5. cover把背景图像扩展至足够大，使背景图像完全覆盖背景区域，可能有部分背景图片显示不全\n 6. contain把图像扩展至最大尺寸，使其宽度和高度完全适应内容区域，可能由部分内容存在空白\n\n\n# 27 流式布局float、clear和vertical-align属性将失效\n\n\n# 27.1 flex布局父项常见属性\n\n# 27.1.1 flex-direction\n\n 1. 设置主轴的方向，项目的排列方向\n 2. 属性值\n    * row：默认值，从左到右\n    * row-reverse：从右到左\n    * column：从上到下\n    * column-reverse：从下到上\n\n# 27.1.2 justify-content\n\n 1. 设置主轴上的子元素排列方式\n 2. 属性值\n    * flex-start：默认值，从头部开始\n    * flex-end：贴着尾部对齐\n    * center：在株洲居中对齐\n    * space-around：平分剩余空间\n    * space-between：先两边贴边再平分剩余空间\n\n# 27.1.3 flex-warp\n\n 1. 设置子元素是否换行\n 2. flex布局中默认子元素是不换行的，放不下会缩小子元素\n 3. 属性\n    * nowarp：默认，不换行\n    * warp：会换行\n\n# 27.1.4 align-content\n\n 1. 设置侧轴上的子元素排列方式（多行）\n 2. 子项出现换行的情况\n 3. 属性\n    * flex-start：从上到下\n    * flex-end：从下到上\n    * center：挤在一起居中\n    * space-around：子项在册周平分神域空间\n    * space-between：梓州在侧周先分布两头，再平分神域空间\n    * stretch： 默认值，拉伸\n\n# 27.1.5 align-items\n\n 1. 设置侧轴上的子元素排列方式（单行）\n 2. 属性\n    * flex-start：从上到下\n    * flex-end：从下到上\n    * center：挤在一起居中\n    * stretch： 默认值，拉伸\n\n# 27.1.6 flex-flow\n\n 1. flex-direction和flex-warp的连写\n 2. 语法flex-flow: row warp;\n\n\n# 27.2 flex布局子项常见属性\n\n# 27.2.1 flex属性\n\n 1. 定义子项目分配剩余空间，用flex来表示占多少份数\n 2. 语法flex: 份数;\n 3. 默认是0\n\n# 27.2.2 align-self\n\n 1. 控制子项自己在侧轴上的排列方式\n 2. 允许某个项目与其他项目不一样的对其方式\n\n# 27.2.3 order\n\n 1. 定义项目的排列顺序\n 2. 数值越小，排列越靠前，默认是0\n\n\n# 28 rem适配布局\n\n\n# 28.1 rem基础\n\n 1. rem是一个相对单位（root em）\n 2. 其基准是html元素的字体大小\n\n\n# 28.2 媒体查询\n\n 1. 媒体查询（Meida Query）是CSS3新语法\n 2. 使用@media查询，可以针对不用的媒体类型定义不同的样式\n 3. @media可以针对不同的屏幕粗存设置不同的样式\n 4. 重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面\n 5. 语法\n\n@media 媒体类型 关键字 (媒体特性) {\n}\n\n\n1\n2\n\n 6. 媒体类型\n    * all：用于所有设备\n    * print：用于打印机和打印预览\n    * screen：用于电脑屏幕，平板电脑，智能手机\n 7. 关键字\n    * and：且\n    * not：非\n    * only：置顶某个特定媒体类型\n 8. 媒体特性\n    * width：定义输出设备中页面课件区域的宽度\n    * min-width：定义输出设备中页面最小可见区域宽度\n    * max-width：定义输出设备中页面最大可见区域宽度\n\n\n# 28.3 媒体查询引入资源\n\n 1. 写几套css针对不同的屏幕引入\n 2. <link rel="stylesheet" href="#" media="screen and (min-width: 320px)">\n\n\n# 28.4 less基础\n\n 1. less是CSS的扩展语言，也称为CSS预处理器\n\n# 28.4.1 less变量\n\n 1. 语法@变量名:值;\n 2. 变量命名规范\n    * 必须有@为前缀\n    * 不能包含特殊字符串\n    * 不能以数字开头\n    * 大小写敏感\n\n# 28.4.2 less嵌套\n\n 1. 子元素的样式直接写在父元素里面\n 2. 伪类、交际选择器在内层选择器前面加&\n\n# 28.4.3 less运算\n\n 1. 任何数字、颜色或者变量都可以参与运算（加减乘除）\n 2. 除法不能直接使用，需要加括号包含起来\n 3. 运算符左右必须用空格隔开\n 4. 两数运算只有一个有单位，以有单位的为准\n 5. 如果两个数单位不一，最后结果以第一个数的单位为准\n 6. 颜色也可以运算\n\n\n# 29 响应式布局\n\n\n# 29.1 布局容器\n\n 1. 根据屏幕宽度确定布局容器大小，布局容器宽度是确定的\n\n.container {\n    margin:0 auto;\n}\n/* 超小屏幕 */\n@media screen and (max-width:767px) {\n    .container {\n        width: 100%;\n    }\n}\n/* 小屏幕 */\n@media screen and (min-width:768px) {\n    .container {\n        width: 750px;\n    }\n}\n/* 中等屏幕 */\n@media screen and (min-width:992px) {\n    .container {\n        width: 970px;\n    }\n}\n/* 大屏幕下 */\n@media screen and (min-width:1200px) {\n    .container {\n        width: 1170px;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 29.2 bootstrap使用\n\n# 29.2.1 创建文件夹结构\n\n 1. 复制Bootstrap相关文件夹\n\n# 29.2.2 创建html骨架结构\n\n# 29.2.3 引入相关样式文件\n\n<link rel="stylesheet" href="bootstrap/css/文件名">\n\n# 29.2.4 书写内容\n\n 1. bootstrap通过类来控制样式\n 2. 修改样式的时候注意权重问题\n\n\n# 29.3 ootstrap布局容器\n\n 1. bootstrap需要为页面内容和栅格系统包裹一个.container容器\n 2. container类\n    * 响应式布局容器 固定宽度\n    * 大屏（>=1200px）宽度定位1170px\n    * 中屏（>=992px）宽度定位970px\n    * 小屏（>=768px）宽度定位750px\n    * 超小屏100%\n 3. container-fluid类\n    * 流式布局容器 百分百宽度\n    * 占据全部视口（viewport）的容器\n    * 适合于单独做移动端开发\n\n\n# 29.4 bootstrap栅格系统\n\n 1. 将页面布局划分为等宽的列，然后通过列数的定义来模块化页面布局\n 2. bootstrap将container自动分为12列\n 3. * 行（row）必须放在container容器里面\n    * 实现列的平均划分需要给列添加类前缀\n    * 类前缀意思\n      * xs-extra small：超小\n      * sm-small：小\n      * md-medium：中等\n      * lg-large：大\n    * 列（column）大于12，多余的列所在的元素江北作为一个整体另起一行排列\n    * 每一列默认有左右15像素的padding\n    * 可以同事为一列指定对个设备的类名，以便划分不同份数例如class="col-md-4 col-sm-6"\n\n# 29.4.1 列嵌套\n\n 1. 栅格系统内置的栅格系统将内容再次嵌套。可以通过添加一个新的.row元素和一系列.col-sn等元素分割已经存在的列中\n 2. 列嵌套最好加一个行盒子，这样可以取消父元素的padding\n\n# 29.4.2 列偏移\n\n 1. 使用.col-md-offset-份数类可以将列向右侧偏移\n\n# 29.4.3 列排序\n\n 1. 通过使用.col-md-push-份数和.col-md-pull-份数类很容易改变列的顺序\n 2. push往右推，pull往左拉\n\n# 29.4.4 响应式工具\n\n 1. 利用媒体查询功能，使用这些工具类可以方便针对不同设备展示或隐藏页面内容',normalizedContent:'# 1 css简介\n\n 1. 主要使用场景：优化网页页面\n 2. css层叠样式表，标记语言\n 3. 主要用于设置html的文本内容、图片外型、网页布局\n\n\n# 2 语法规范\n\n 1. 规则由选择器和一条或多条声明构成\n 2. 选择器用于指定css样式的html标签，花括号是对该对象设置的具体样式\n 3. 属性和属性值以“键值对”的形式出现\n\n<html>\n<head>\n    <title>测试</title>\n    <style>\n        h4 {\n            color: cornflowerblue;\n        }\n    </style>\n</head>\n<body>\n    <h4>你喜欢的食物</h4>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3 代码风格\n\n\n# 3.1 样式格式\n\n 1. 紧凑格式\n 2. 展开格式：一行只写一个属性\n\n\n# 3.2 样式大小写\n\n一般使用小写\n\n\n# 3.3 空格规范\n\n 1. 属性值前，冒号后面写一个空格\n 2. 选择器和大括号前写一个空格\n\n\n# 4 选择器\n\n\n# 4.1 基础选择器\n\n# 4.1.1 标签选择器\n\n 1. html标签名作为选择器\n 2. 会对所有该标签下的内容进行设定\n\n# 4.1.2 类选择器\n\n 1. 语法标准\n\n<style>\n    .red {\n        color = red；\n    }\n</style>\n<div class=“red”>想要变红色的文字</div>\n\n\n1\n2\n3\n4\n5\n6\n\n 2. 用class属性进行选择\n 3. 可以选择一个或者某几个标签\n 4. 不能用标签的名字选为类名\n 5. 长类名用-连接\n 6. 一个标签可以使用多个类名，多个类名之间用空格隔开\n\n# 4.1.3 id选择器\n\n 1. 通过#定义id，以id属性选择\n 2. 语法标准\n\n<style>\n    #red {\n        color = red；\n    }\n</style>\n<div id=“red”>想要变红色的文字</div>\n\n\n1\n2\n3\n4\n5\n6\n\n 3. 只能调用一次，具有唯一性\n\n# 4.1.4 通配符选择器\n\n 1. 用*，表示选取页面所有标签\n 2. 语法标准\n\n<style>\n    * {\n        color = red；\n    }\n</style>\n<div>想要变红色的文字</div>\n\n\n1\n2\n3\n4\n5\n6\n\n 3. 通配符选择器不需要调用\n\n\n# 4.2 复合选择器\n\n把基础选择器进行组合形成的\n\n# 4.2.1 后代选择器\n\n 1. 又叫包含选择器，只能选择后代\n 2. 语法：父类 后代 {样式说明}\n 3. 后代和父类用空格分开\n 4. 最终选择的是子类\n 5. 后代可以是子类也可以是子类的子类\n 6. 两个都可以是任意的基础选择器\n\n<style>\n    ul.nav li a {\n        color: red;\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n\n\n# 4.2.2 子选择器\n\n 1. 又称子元素选择器，只能选择某元素最近一级子代\n 2. 语法：父类>子类 {样式说明}\n\n<style>\n    ul.nav>a {\n        color: red;\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n\n\n# 4.2.3 并集选择器\n\n 1. 选择多组标签，同时定义相同的样式，用于集体声明\n 2. 语法：用逗号分隔\n 3. 任何形式的选择器都可以作为并集选择器的一部分\n\n# 4.2.4 伪类选择器\n\n 1. 像某些标签添加特殊效果：比如给连接添加特殊效果\n 2. 语法：用冒号表示\n\n# 链接伪类\n\n 1. a:link 选择所有未访问的连接\n 2. a:visited 选择所有已访问的连接\n 3. a:hover 选择鼠标指针位于其上的连接\n 4. a:active 选择活动连接（鼠标按下未弹起的连接）\n 5. 为了确保能够生效，必须使用lvha的顺序写\n 6. 浏览器中a有固定样式，要改变必须用a来设定\n\n# ：focus伪类选择\n\n 1. 用于获取光标所在的表单元素\n 2. 语法input:focus{样式说明}\n\n\n# 5 字体属性\n\n\n# 5.1 字体系列\n\n 1. 语法标准\n\n<style>\n    div {\n        font-family: "microsoft yahei"；\n    }\n</style>\n<div>想要变微软雅黑的文字</div>\n\n\n1\n2\n3\n4\n5\n6\n\n 2. 多个字体之间用空格隔开\n 3. 一个字体有空格时，最好用“”框起来\n 4. 多个字体的作用是前面的字体找不到的时候寻找下一个字体\n\n\n# 5.2 字体大小\n\n 1. {font-size: 20px}\n 2. 标题标签比较特殊，需要单独指定文字大小\n\n\n# 5.3 字体粗细\n\n 1. {font-weight :normal/400}\n 2. 正常=normal=400\n 3. 加粗=bold=700\n 4. 数字在100-900里选\n\n\n# 5.4 文字样式\n\n 1. {font-style: italic}\n 2. italic:倾斜\n 3. normal：正常\n\n\n# 5.5 字体复合属性\n\n 1. {font: font-style font-weight font-size/line-height font-family}\n 2. 顺序有要求，不需要的属性可以省略，但是必须保留font-size和font-family\n\n\n# 6 文本属性\n\n定义文本的外观，比如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等\n\n\n# 6.1 文本颜色\n\n 1. 语法\n\ndiv{\n    color: red;\n}\n\n\n1\n2\n3\n\n 2. 属性内容\n    * 预设值（pink）\n    * 16进制数：#+6个数字\n    * rgb代码\n\n\n# 6.2 对齐文本\n\n 1. text-align属性用于设置元素内文本内容的水平对齐方式\n 2. 语法\n\ndiv{\n    text-align: center;\n}\n\n\n1\n2\n3\n\n\n\n# 6.3 装饰文本\n\n 1. text-decoration属性规定添加到文本的修饰，可以给文本添加下划线、删除线、上划线等\n 2. 语法\n\ndiv{\n    text-decoration: underline;\n}\n\n\n1\n2\n3\n\n 3. 属性内容\n    * none：默认，没有装饰线\n    * underline：下划线\n    * overline：上划线\n    * line-through：删除线\n\n\n# 6.4 文本缩进\n\n 1. text-indent属性用来指定文本首行缩进\n 2. 语法\n\ndiv{\n    text-indent: 2em;\n}\n\n\n1\n2\n3\n\n 3. em是一个相对尺寸，当前元素一个文字大小的距离\n\n\n# 6.5 行间距\n\n 1. line-height属性由于设置行高\n 2. 语法\n\ndiv{\n    line-height: 2em;\n}\n\n\n1\n2\n3\n\n 3. 行高=上间距+文本高度+下间距\n\n\n\n\n# 7 引入方式\n\n\n# 7.1 行内样式表（行内式）\n\n 1. 在标签内部写上style属性\n 2. 语法<div style="color: red"></div>\n 3. 一定要是双引号，写法要符合css\n\n\n# 7.2 内部样式表（嵌入式）\n\n 1. css写入html内部，写在< style>标签里\n 2. 理论上< style>可以放在任何地方，但一般放在head里\n 3. 可以控制整个页面\n 4. 代码结构清晰，但并没有完全分离\n\n\n# 7.3 外部样式表\n\n 1. 样式单独写到css文件中，html引用css文件\n 2. 在html页面中，使用link标签引入\n 3. 语法<link rel="stylesheet" href="css文件路径">\n\n\n# 8 emmet语法\n\n\n# 8.1 快速生成css\n\n 1. 简写+tab\n\n\n# 8.2 快速格式化代码\n\n 1. shift+alt+f\n\n\n# 9 元素显示模式\n\n 1. 元素显示模式：标签以什么方式显示\n\n\n# 9.1 块元素\n\n 1. 典型块元素：< div> < h1>\n 2. 独占一行\n 3. 宽度、高度、内外边距都可以控制\n 4. 宽度默认是父级的100%\n 5. 是一个容器及盒子，里面可以放行内元素或者块级元素\n 6. 文字类元素内不能使用块元素\n\n\n# 9.1.1 行内元素\n\n 1. 典型行内元素：< a> < span>\n 2. 相邻行内元素在一行上，一行显示多个\n 3. 宽高设置是无效的\n 4. 宽度默认是本身内容的宽度\n 5. 行内元素不能放块元素\n 6. 链接里不能再放链接\n 7. 链接可以放块元素\n\n\n# 9.1.2 行内块元素\n\n 1. 特殊标签： < img/> < input/> < td>\n 2. 相邻行内块元素在一行上，之间会有空白间隙，一行可以显示多个\n 3. 默认宽度是本身内容的宽度\n 4. 宽度、高度、内外边距都可以控制\n\n\n# 9.1.3 元素显示模式的转换\n\n 1. 转换成块元素display:block;\n 2. 转换成行内元素display:inline;\n 3. 转换成行内块元素display:inline-block;\n\n\n# 10 背景\n\n通过css背景属性，可以给页面元素添加背景样式\n\n\n# 10.1 背景颜色\n\n 1. 语法 background-color: 颜色值;\n 2. 默认值：transparent（透明）\n\n\n# 10.2 背景颜色线性渐变\n\n 1. css3新增属性\n 2. 语法background: -浏览器私有前缀-linear-gradient(起始方向,颜色1,颜色2,....)\n 3. 必须添加浏览器私有前缀\n\n\n# 10.3 背景图片\n\n 1. 实际开发常见于logo或者一些装饰性的小图片或者超大的背景图片\n 2. 优点是非常便于控制位置\n 3. 语法 background-image : none/url();\n\n\n# 10.4 背景平铺\n\n 1. 语法 background-repeat: repeat/no-repeat/repeat-x/repeat-y;\n 2. 默认情况是repeat\n 3. 背景颜色和背景图片可以同时添加，背景颜色位于最下层\n\n\n# 10.5 背景图片位置\n\n 1. 语法 background-position: x y;\n 2. x,y都可以使用方位名词和精确单位\n 3. 方位名词\n    * top\n    * center\n    * bottom\n    * left\n    * right\n 4. 两者都是方位名词，两个名词的顺序无关\n 5. 只指定一个方位名词，另一个默认为center\n 6. 精确单位第一个是x坐标，第二个是y坐标，顺序不能替换\n 7. 如果只指定一个精确单位，一定是x，垂直默认居中\n 8. 参数可以是混合单位。第一个是x坐标，第二个是y坐标，顺序不能替换\n\n\n# 10.6 背景附着\n\n 1. 设置背景图片是固定还是随着页面其余部分滚动\n 2. 语法 background-attachment: scroll/fixed;\n\n\n# 10.7 背景复合写法\n\n 1. 约定顺序：颜色+地址+平铺+滚动+位置\n 2. 语法 background: transparent url() repeat fixed top;\n\n\n# 10.8 背景色半透明\n\n 1. 语法 background: rgba(0,0,0,0.3)\n 2. alpha透明度，0-1之间\n 3. 习惯性把0.3中的0去掉\n 4. 只是设置背景色半透明，对盒子里的内容没有影响\n\n\n# 11 css三大特性\n\n\n# 11.1 层叠性\n\n 1. 相同选择器设置相同的样式，后面的会覆盖前面的\n 2. 冲突，后者覆盖\n 3. 不冲突，不层叠\n\n\n# 11.2 继承性\n\n 1. 子标签会集成父标签里的样式\n 2. 子元素可以集成父元素的样式（text-,font-,line-以及color属性）\n\n\n# 11.3 优先级\n\n 1. 选择器相同，则执行层叠性\n 2. 选择器不同，按权重大小\n 3. 权重是4组数字组成，不会进位\n 4. 复合选择器需要权重叠加\n\n\n# 12 盒子模型\n\n\n# 12.1 border边框\n\n 1. 由边框宽度、边框样式、边框颜色组成\n 2. border : border-width // border-style // border-color\n 3. 边框样式\n    * solid：实线边框\n    * dashed：虚线边框\n    * dotted：点线边框\n 4. 边框复合写法 border: 1px solid red;没有编写顺序要求\n 5. 边框分开编辑 border-top编辑上边框\n 6. 表格边框合并 border-collapse:collapse;\n    相邻表格边框合并在一起\n    只对table相关\n 7. 边框会影响盒子实际大小\n    盒子的实际大小 = 盒子高/宽 + 2*边框宽度 + padding\n\n\n# 12.1.1 content内容\n\n装文字、图片、盒子\n\n\n# 12.1.2 padding内边距\n\n 1. 设置盒子边框和内容之间的距离\n 2. padding-top // padding-bottom // padding-left // padding-right\n 3. 内边距复合写法\n 4. 内边距会影响盒子实际大小\n    盒子的实际大小 = 盒子高/宽 + 2*边框宽度 + 各部分padding\n 5. 如果盒子没有指定宽度，是继承的父级的宽度，加padding值的时候不会撑大盒子\n\n\n# 12.1.3 margin外边距\n\n 1. 设置盒子之间的距离\n 2. margin-top // margin-bottom // margin-left // margin-right\n 3. 外边距复合写法\n    与内边距一致\n 4. 块级盒子水平居中:盒子设置宽度，左右外边距设置为auto margin: 0 auto\n 5. 行内元素、行内块元素居中：给父级添加text-align: center;\n 6. 嵌套关系中父子元素中的父元素会取两者最大外边距，解决方法：\n    * 父元素定义上边框\n    * 父元素定义上内边距\n    * 父元素添加overflow: hidden;\n 7. 浏览器中会设置初始内外边距建议清除\n\n* {\n    padding: 0;\n    margin: 0;\n}\n\n\n1\n2\n3\n4\n\n\n\n# 12.1.4 圆角边框\n\n 1. 语法 border-radius: 圆角半径;\n 2. 参数可以用精确数和百分比\n 3. 参数可以写四个，从左上角顺时针旋转\n 4. 可以指定特定角border-top-left-radius: 圆角半径\n\n\n# 12.1.5 盒子阴影\n\n 1. 语法格式 box-shadow: h-shadow v-shadow blur spread color inset\n 2. 参数含义\n 3. 只要前两个参数是必须写的\n 4. 影子不占空间\n\n\n# 13 浮动\n\n 1. 浮动可以改变标签默认的排列方式\n 2. 多个块级元素横向排列用浮动\n\n\n# 13.1 浮动语法\n\n选择器 { float: none|left|right;}\n\n\n# 13.2 浮动特性\n\n 1. 脱标\n    * 浮动的元素在标准流中不占据位置\n    * 浮动元素和标准流的元素不在一个图层上\n 2. 一行显示并且顶部对齐\n    * 浮动的元素互相贴在一起，不会有缝隙\n    * 父级宽度装不下时，另起一行对齐\n 3. 具有行内块元素的特性\n\n\n# 13.3 浮动布局注意点\n\n 1. 浮动和标准流的父元素一起使用\n 2. 一个元素浮动了，理论上兄弟元素也都应该浮动\n 3. 浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流\n\n\n# 13.4 清除浮动\n\n 1. 父盒子无法设置高度的时候需要清除浮动\n 2. 语法 选择器 {clear: left|right|both}\n 3. 清除浮动的方法\n    * 额外标签法：在最后一个浮动元素后写一个空标签，设置清除浮动\n      新标签必须是块级元素\n    * 父元素添加overflow：属性设置hidden|auto|scroll\n      无法显示溢出的部分\n    * :after伪元素法：\n    \n    .clearfix:after {\n        content: "";\n        display: block;\n        height: 0;\n        clear: both;\n        visibility: hidden;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n    * 双微元素清除浮动\n    \n    .clearfix:before,.clearfix:after {\n        content: "";\n        display: table;\n        height: 0;\n    }\n    .clearfix:after {\n        clear: both;\n    }\n    .clearfix {\n        *zoom: 1;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n\n# 14 书写顺序\n\n 1. 布局定位属性：display|position|float|clear|visibility|overflow\n 2. 自身属性：width|height|margin|padding|border|background\n 3. 文本属性：color|font|text-decoration|text-align|vertical-align|white-space|break-word\n 4. 其他属性（css3）：content|cursor|border-radius|box-shadow|background\n\n\n# 15 定位\n\n\n# 15.1 定位组成\n\n 1. 定位：将盒子定在某一个位置，所以定位也是在摆放盒子，按照定位的方式移动盒子\n 2. 定位 = 定位模式 + 边偏移\n 3. 定位模式：用于指定一个元素在文档中的定位方式\n 4. 边偏移：决定该元素的最终位置\n\n\n# 15.2 定位模式\n\n通过css的position属性来设置\n\n# 15.2.1 static静态定位\n\n仅作了解\n\n 1. 默认定位方式，无定位的意思\n 2. 静态定位按照标准流摆放位置，没有边偏移\n\n# 15.2.2 relative相对定位\n\n 1. 相对定位是元素在移动位置的时候，是相对于它原来的位置来说的\n 2. 语法选择器 { position: relative;}\n 3. 原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待\n 4. 不脱标，继续保持原来位置\n 5. 主要的作用是限制绝对定位\n\n# 15.2.3 absolute绝对定位\n\n重要\n\n 1. 绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的\n 2. 语法选择器 { position: absolute;}\n 3. 如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位\n 4. 如果祖先有定位，则以最近一级的有定位祖先元素为参考点移动位置\n 5. 绝对定位不再占有原来的位置，脱离标准流\n\n# 15.2.4 fixed固定定位\n\n重要\n\n 1. 元素固定到浏览器可视区的某个位置\n 2. 语法选择器 { position: fixed;}\n 3. 以浏览器的可视窗口为参照点移动，与父级和滚动条没有关系\n 4. 固定定位不占有原先的位置\n 5. 技巧：固定在版心右侧位置选择器 { position: fixed;left:50%;margin-left:版心宽度的一半}\n\n# 15.2.5 sticky粘性定位\n\n仅作了解\n\n 1. 某些情况是固定定位，某些情况是相对定位\n 2. 语法选择器 { position: sticky;}\n 3. 以浏览器可视窗口为参照点移动元素\n 4. 占有原先的位置\n 5. 必须添加边偏移中的一个，否则则为相对定位\n\n\n# 15.3 边偏移\n\n边偏移就是定位盒子移动到最终位置\n\n 1. top：顶端偏移量\n 2. bottom：底部偏移量\n 3. left：左侧偏移量\n 4. right：右侧偏移量\n\n\n# 15.4 子绝父相\n\n 1. 子级使用绝对定位，父级则需要使用相对定位\n 2. 子级使用绝对定位，可以放在父级任何地方，不会影响兄弟\n 3. 父级需要加定位限制子级位置，且需要占有位置\n\n\n# 15.5 定位叠放次序\n\n 1. 语法选择器 { z-index: 1;}\n 2. 数值可以是正整数、负整数或者0，默认auto，数值越大，盒子越靠上\n 3. 如果数值相同，按照书写顺序，后来者居上\n 4. 数字后面不能加单位\n 5. 只有定位的盒子才有z-size属性\n\n\n# 15.6 定位的扩展\n\n 1. 绝对定位的盒子居中 选择器 { position: absolute;left:50%;margin-left:-盒子宽度的一半} 选择器 { position: absolute;top:50%;margin-top:-盒子高度度的一半}\n 2. 定位特殊特性\n    * 行内元素添加绝对或者固定定位，可以直接设置高度和宽度\n    * 块级元素添加绝对或者固定定位，默认是内容大小\n    * 脱标的盒子不会除法外边距塌陷\n 3. 绝对定位会完全压住盒子\n    * 浮动会压住标准流盒子，但不会压住标准流的文字\n    * 绝对或者固定定位会压住标准流的文字\n\n\n# 16 元素的显示与隐藏\n\n\n# 16.1 display\n\n 1. display属性用于设置一个元素如何显示\n 2. display:none;隐藏对象，隐藏后元素不占有原先的位置\n 3. display:block;显示对象；转换为块级元素\n 4. 搭配js可以做很多网页特效\n\n\n# 16.2 visibility\n\n 1. visibility属性用于指定一个元素可见还是隐藏\n 2. visibility:visible;元素可见\n 3. visibility:hidden;元素隐藏，隐藏后元素占有原先的位置\n\n\n# 16.3 overflow\n\n 1. overflow属性指定了内容溢出的元素框时的状态\n 2. overflow:hidden;溢出内容隐藏\n 3. overflow:scroll;溢出内容显示滚动条，不溢出的时候也显示滚动条\n 4. overflow:auto;需要的时候添加滚动条\n 5. 对于定位的盒子要慎用，会切掉框架外的内容\n\n\n# 17 精灵图\n\n 1. 精灵技术：将网页中的一些小背景图像整合到一张大图中，减少服务器的接受和发送请求的次数\n\n\n# 17.1 精灵图使用\n\n 1. 主要针对背景图片使用，把多个小的背景图片整合到一张大图中\n 2. sprite：精灵图或者雪碧图，集成的大图\n 3. 通过移动背景图片的方式选择精灵图中的小图，background-position\n 4. 往上往左移动为负值\n\n\n# 18 字体图标\n\n 1. 主要用于显示网页中通用、常用的一些小图标\n 2. 展示的是一个图标，但本质是文字\n\n\n# 18.1 字体图标优点\n\n 1. 轻量级：一旦加载了，图标会马上渲染出来，减少服务器请求\n 2. 灵活性\n 3. 兼容性：支持所有浏览器\n\n\n# 18.2 字体图标下载\n\n 1. icomoon字体库\n 2. iconfont字体库\n\n\n# 18.3 字体图标引入\n\n 1. 把下载包里面的fonts文件夹放在css文件的根目录下\n 2. 字体声明\n\n@font-face {\n  font-family: \'icomoon\';\n  src:  url(\'fonts/icomoon.eot?p4ssmb\');\n  src:  url(\'fonts/icomoon.eot?p4ssmb#iefix\') format(\'embedded-opentype\'),\n    url(\'fonts/icomoon.ttf?p4ssmb\') format(\'truetype\'),\n    url(\'fonts/icomoon.woff?p4ssmb\') format(\'woff\'),\n    url(\'fonts/icomoon.svg?p4ssmb#icomoon\') format(\'svg\');\n  font-weight: normal;\n  font-style: normal;\n  font-display: block;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 18.4 字体图标追加\n\n 1. 把压缩包里的selection.json重新上传，再下载压缩包替代原文件\n\n\n# 19 css三角\n\n\n# 19.1 原理\n\n 1. 在宽高都为0的盒子设置border时会产生三角形\n\n\n# 19.2 代码\n\ndiv {\n    width: 0;\n    height: 0;\n    border: 50px solid transparent;\n    border-left-color: pink;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 19.3 定位\n\n 1. 子绝父相\n 2. 要移动border的两倍\n\n\n# 20 用户界面样式\n\n 1. 界面样式：更改用户操作样式\n\n\n# 20.1 鼠标样式\n\n 1. 设置鼠标在对象上时的光标形状\n 2. 语法选择器 {cursor: pointer}\n\n\n# 20.2 表单轮廓线\n\n 1. 取消表单轮廓线 outline: none;\n\n\n# 20.3 固定文本域\n\n 2. 防止拖动文本域resize: none;\n\n\n# 21 vertical-align\n\n 1. 图片和表单的垂直居中\n 2. 设置元素的垂直对齐方式，只针对行内元素或者行内块元素有效\n 3. 语法vertical-align : 参数\n 4. baseline：默认，元素放置在父元素的基线上\n 5. top：顶线对齐\n 6. middle：中线对齐\n 7. bottom：底线对齐\n\n\n# 21.1 图片底侧空白间隙\n\n 1. vertical-align不选择基线对齐\n 2. 把图片转换成块级元素\n\n\n# 22 溢出文字省略号显示\n\n\n# 22.1 单行文本溢出\n\n 1. 强制一行内显示文本white-space: nowrap;\n 2. 超出部分隐藏overflow: hidden;\n 3. 文字用省略号替代超出的部分text-overflow: ellipsis;\n\n\n# 22.2 多行文本溢出\n\n 1. 有比较大兼容性问题，适合webkit浏览器或移动端\n\n{\n    overflow: hidden;\n    text-overflow: ellipsis;\n    /* 弹性伸缩盒子模型显示 */\n    display: -webkit-box;\n    /* 限制在一个块元素显示的文本行数 */\n    -webkit-line-clamp:2;\n    /* 设置或检索伸缩盒对象的子元素排列方式 */\n    -webkit-box-orient: vertical;    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 23 布局技巧\n\n\n# 23.1 margin负值运用\n\n 1. 解决盒子边框变粗的问题：向左移动使右边的盒子边框压住左边盒子边框\n 2. margin-left: -1px;\n 3. 在使用这个技巧时，添加hover属性变化，左边的盒子有边框不能展示\n 4. 添加相对定位\n 5. position: relative;\n 6. 如果盒子里有定位，则提高盒子的层级\n 7. z-index: 1\n\n\n# 23.2 文字围绕浮动元素\n\n 1. 巧妙应用浮动元素不会压住文字的技巧\n 2. 图片添加浮动，文字为标准流\n\n\n# 24 css初始化\n\n\n# 24.1 标签内外边距清零\n\n* {\n    margin: 0;\n    padding: 0;\n}\n\n\n1\n2\n3\n4\n\n\n\n# 24.2 斜体文字不倾斜\n\nem,\ni {\n    margin: 0;\n    padding: 0;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 24.3 去掉列表格式\n\nli {\n    list-style: none;\n}\n\n\n1\n2\n3\n\n\n\n# 24.4 图片初始化\n\nimg {\n    border: 0;\n    vertical-align: middle;\n}\n\n\n1\n2\n3\n4\n\n\n\n# 24.5 按钮鼠标样式手\n\nbutton {\n    cursor: pointer;\n}\n\n\n1\n2\n3\n\n\n\n# 24.6 链接初始化\n\na {\n    color: #666;\n    text-decoration: none;\n}\na:hover {\n    color:#c81623\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 24.7 主页面初始化\n\nbody {\n    /* 文字抗锯齿 */\n    -webkit-font-smoothing: antialiased;\n    background-color: #fff;\n    font: 12px/1.5 microsoft yahei\n    color: #666;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 24.8 清除浮动\n\n.clearfix:after {\n    visibility: hidden;\n    clear: both;\n    display: block;\n    content: ".";\n    height: 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 25 css3新特性\n\n 1. 有兼容性问题，ie9+才支持\n 2. 移动端支持优于pc端\n\n\n# 25.1 css3新增选择器\n\n# 25.1.1 属性选择器\n\n 1. 根据元素特定的属性选择元素\n 2. 语法标签名[att]\n\n# 25.1.2 结构伪类选择器\n\n 1. 根据文档结构来选择元素，常用于根据父级选择器里面的子元素\n 2. nth-child(n)可以选择某个父元素的一个或多个特定的子元素\n    * n可以是数字，关键字和公式\n    * n如果是数字，就是选择第n个子元素，序号从1开始\n    * n可以是关键字：even偶数；odd奇数父类选择器 子类选择器:nth-chile(even/odd)\n    * n可以是公式，n是一个从0开始每次+1往后计算的；此处必须是n不能是其他字母\n    * 会把父类的所有孩子都标上序号，执行时先看nth-child(n)，再看子类选择器是否匹配\n 3. nth-of-type(n)会把指定了元素的孩子标上序号，先看子类选择器，再看后面的n\n\n# 25.1.3 伪元素选择器\n\n 1. 利用css创建新标签元素，不需要html标签，简化html结构\n 2. before和after创建一个元素，但属于行内元素\n 3. 新创建的这个元素在文档树中是找不到的，所以我们称为伪元素\n 4. 语法element::before{}\n 5. 里面必须写content属性，里面写文字内容\n 6. before在父元素内容的前面创建元素，after在父元素内容的后面插入元素\n 7. 伪元素选择器和标签选择器一样，权重为1\n 8. 可以用来清除浮动\n\n\n# 25.2 css3盒子模型\n\n 1. css3中可以通过box-sizing来指定盒子模型，有两个值：content-box;border-box\n 2. box-sizing默认是content-box，盒子大小=width+padding+border\n 3. box-sizing为border-box时，盒子最终大小为width；但有前提：padding+border< width\n\n\n# 25.3 css3滤镜filter\n\n 1. filter css属性将模糊或颜色偏移等图形效果应用于元素\n 2. 语法filter 函数();\n 3. blur()函数模糊处理，数值越大越模糊\n\n\n# 25.4 css3 calc函数\n\n 1. calc()函数让声明一些css属性值时执行一些计算\n\n\n# 25.5 css3过渡\n\n 1. 过渡动画:从一个状态渐渐得过渡到另一个状态\n 2. 语法transition: 要过渡的属性 花费时间 运动曲线 何时开始\n 3. 属性：想要变化的css属性，宽度高度 背景颜色 内外边距 要想所有属性直接写all\n 4. 花费时间：单位是秒，必须写单位\n 5. 运动曲线：默认是ease\n 6. 何时开始：单位是秒（必须写单位）可以设置延迟触发时间，默认是0s\n 7. 谁来变换给谁加transition，不写在:hover里\n 8. 如果需要多个属性，用逗号分隔\n\n\n# 25.6 css3转换transform\n\n# 25.6.1 2d转换\n\n 1. 2d转换是改变标签在二维平面上的位置和形状的一种技术\n 2. 同时写的时候要把位移先写\n\n# 移动：translate\n\n 1. 改变元素在页面中的位置\n 2. 语法transform: translate(x,y) |transform: translatex(n)\n 3. 定义2d转换中的移动，沿着x和y轴移动元素\n 4. 最大优点：不会影响其他元素的位置\n 5. 百分比单位是相对于自身元素的\n 6. 对行内标签没有效果\n\n# 旋转：rotate\n\n 1. 让元素在2维平面内顺时针旋转或者逆时针旋转\n 2. 语法transform: rotate(度数)\n 3. rotate里面写度数，单位是deg，且不能省略\n 4. 角度为正，顺时针旋转\n 5. 默认旋转中心是元素的中心点\n\n# 设置元素转换中心点\n\n 1. 语法transform-origin: x y;\n 2. 后面的参数x、y要用空格隔开\n 3. x y默认转换的中心点是元素的中心点（50% 50%）\n 4. 还可以给x y设置像素或者方位名词\n\n# 缩放：scale\n\n 1. 控制元素的放大还是缩小\n 2. 语法transform: scale(x,y)\n 3. x、y用逗号隔开\n 4. transform: scale(1,1)不变，transform: scale(2,2)放大一倍\n 5. 如果只写一个参数则默认两个参数一致\n 6. 优势：可以设置转换中心点，默认以中心点缩放。而且不影响其他盒子\n\n# 2d转换综合写法\n\n 1. 格式transform: translate() rotate() scale()\n 2. 顺序会映像转换效果，位移要放在最前面\n\n\n# 25.7 css3动画\n\n 1. 先定义动画\n 2. 再使用动画\n\n# 25.7.1 keyframes定义动画\n\n 1. 语法\n\n@keyframes 动画名称 {\n    0% {\n        开始的样式\n    }\n    100%{\n        结束的样式\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 2. 动画序列\n    * 0%是动画开始；100%是动画完成。这中柜子就是动画序列\n    * 可以用from to关键字代替0%和100%\n\n# 25.7.2 元素使用动画\n\n 1. 语法animation-name:动画名称;animation-duration:持续时间;\n 2. 可以添加多个动画用逗号隔开\n\n# 25.7.3 动画常见属性\n\n 1. animation-name：动画名字，必须写\n 2. animation-duration：动画完成一个周期所需的事件秒或者毫秒，必须写\n 3. animation-timing-function：规定动画的速度曲线，默认ease\n    * \n    * steps就是分几步完成动画\n 4. animation-delay：规定何时开始，默认0\n 5. animation-iteration-count：规定动画被播放的次数，默认1；可以选择infinite\n 6. animation-direction：规定动画是否在下一周期你想播放，默认是normal；alternate逆播放\n 7. animation-fill-mode：规定动画结束后状态，保持forwards；回到其实位置backwards\n 8. animation-play-state：规定动画是都正在运行或暂停，默认是running；paused暂停\n\n# 25.7.4 动画简写属性\n\n 1. 语法animation:动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画开始或结束的状态\n\n\n# 26 移动端基础\n\n\n# 26.1 meta视口标签\n\n 1. 语法<meta name="viewport" content="width=device-width, user=scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">\n 2. 属性说明\n\n\n# 26.2 二倍图\n\n 1. 由于视网膜屏技术，设计移动端时要放大2倍来设计，防止模糊\n 2. 背景缩放background-size：规定背景图像的尺寸\n 3. 语法background-size: 背景图片宽度 背景图片高度;\n 4. 只写一个参数是指定的宽度，高度等比例缩放\n 5. cover把背景图像扩展至足够大，使背景图像完全覆盖背景区域，可能有部分背景图片显示不全\n 6. contain把图像扩展至最大尺寸，使其宽度和高度完全适应内容区域，可能由部分内容存在空白\n\n\n# 27 流式布局float、clear和vertical-align属性将失效\n\n\n# 27.1 flex布局父项常见属性\n\n# 27.1.1 flex-direction\n\n 1. 设置主轴的方向，项目的排列方向\n 2. 属性值\n    * row：默认值，从左到右\n    * row-reverse：从右到左\n    * column：从上到下\n    * column-reverse：从下到上\n\n# 27.1.2 justify-content\n\n 1. 设置主轴上的子元素排列方式\n 2. 属性值\n    * flex-start：默认值，从头部开始\n    * flex-end：贴着尾部对齐\n    * center：在株洲居中对齐\n    * space-around：平分剩余空间\n    * space-between：先两边贴边再平分剩余空间\n\n# 27.1.3 flex-warp\n\n 1. 设置子元素是否换行\n 2. flex布局中默认子元素是不换行的，放不下会缩小子元素\n 3. 属性\n    * nowarp：默认，不换行\n    * warp：会换行\n\n# 27.1.4 align-content\n\n 1. 设置侧轴上的子元素排列方式（多行）\n 2. 子项出现换行的情况\n 3. 属性\n    * flex-start：从上到下\n    * flex-end：从下到上\n    * center：挤在一起居中\n    * space-around：子项在册周平分神域空间\n    * space-between：梓州在侧周先分布两头，再平分神域空间\n    * stretch： 默认值，拉伸\n\n# 27.1.5 align-items\n\n 1. 设置侧轴上的子元素排列方式（单行）\n 2. 属性\n    * flex-start：从上到下\n    * flex-end：从下到上\n    * center：挤在一起居中\n    * stretch： 默认值，拉伸\n\n# 27.1.6 flex-flow\n\n 1. flex-direction和flex-warp的连写\n 2. 语法flex-flow: row warp;\n\n\n# 27.2 flex布局子项常见属性\n\n# 27.2.1 flex属性\n\n 1. 定义子项目分配剩余空间，用flex来表示占多少份数\n 2. 语法flex: 份数;\n 3. 默认是0\n\n# 27.2.2 align-self\n\n 1. 控制子项自己在侧轴上的排列方式\n 2. 允许某个项目与其他项目不一样的对其方式\n\n# 27.2.3 order\n\n 1. 定义项目的排列顺序\n 2. 数值越小，排列越靠前，默认是0\n\n\n# 28 rem适配布局\n\n\n# 28.1 rem基础\n\n 1. rem是一个相对单位（root em）\n 2. 其基准是html元素的字体大小\n\n\n# 28.2 媒体查询\n\n 1. 媒体查询（meida query）是css3新语法\n 2. 使用@media查询，可以针对不用的媒体类型定义不同的样式\n 3. @media可以针对不同的屏幕粗存设置不同的样式\n 4. 重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面\n 5. 语法\n\n@media 媒体类型 关键字 (媒体特性) {\n}\n\n\n1\n2\n\n 6. 媒体类型\n    * all：用于所有设备\n    * print：用于打印机和打印预览\n    * screen：用于电脑屏幕，平板电脑，智能手机\n 7. 关键字\n    * and：且\n    * not：非\n    * only：置顶某个特定媒体类型\n 8. 媒体特性\n    * width：定义输出设备中页面课件区域的宽度\n    * min-width：定义输出设备中页面最小可见区域宽度\n    * max-width：定义输出设备中页面最大可见区域宽度\n\n\n# 28.3 媒体查询引入资源\n\n 1. 写几套css针对不同的屏幕引入\n 2. <link rel="stylesheet" href="#" media="screen and (min-width: 320px)">\n\n\n# 28.4 less基础\n\n 1. less是css的扩展语言，也称为css预处理器\n\n# 28.4.1 less变量\n\n 1. 语法@变量名:值;\n 2. 变量命名规范\n    * 必须有@为前缀\n    * 不能包含特殊字符串\n    * 不能以数字开头\n    * 大小写敏感\n\n# 28.4.2 less嵌套\n\n 1. 子元素的样式直接写在父元素里面\n 2. 伪类、交际选择器在内层选择器前面加&\n\n# 28.4.3 less运算\n\n 1. 任何数字、颜色或者变量都可以参与运算（加减乘除）\n 2. 除法不能直接使用，需要加括号包含起来\n 3. 运算符左右必须用空格隔开\n 4. 两数运算只有一个有单位，以有单位的为准\n 5. 如果两个数单位不一，最后结果以第一个数的单位为准\n 6. 颜色也可以运算\n\n\n# 29 响应式布局\n\n\n# 29.1 布局容器\n\n 1. 根据屏幕宽度确定布局容器大小，布局容器宽度是确定的\n\n.container {\n    margin:0 auto;\n}\n/* 超小屏幕 */\n@media screen and (max-width:767px) {\n    .container {\n        width: 100%;\n    }\n}\n/* 小屏幕 */\n@media screen and (min-width:768px) {\n    .container {\n        width: 750px;\n    }\n}\n/* 中等屏幕 */\n@media screen and (min-width:992px) {\n    .container {\n        width: 970px;\n    }\n}\n/* 大屏幕下 */\n@media screen and (min-width:1200px) {\n    .container {\n        width: 1170px;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 29.2 bootstrap使用\n\n# 29.2.1 创建文件夹结构\n\n 1. 复制bootstrap相关文件夹\n\n# 29.2.2 创建html骨架结构\n\n# 29.2.3 引入相关样式文件\n\n<link rel="stylesheet" href="bootstrap/css/文件名">\n\n# 29.2.4 书写内容\n\n 1. bootstrap通过类来控制样式\n 2. 修改样式的时候注意权重问题\n\n\n# 29.3 ootstrap布局容器\n\n 1. bootstrap需要为页面内容和栅格系统包裹一个.container容器\n 2. container类\n    * 响应式布局容器 固定宽度\n    * 大屏（>=1200px）宽度定位1170px\n    * 中屏（>=992px）宽度定位970px\n    * 小屏（>=768px）宽度定位750px\n    * 超小屏100%\n 3. container-fluid类\n    * 流式布局容器 百分百宽度\n    * 占据全部视口（viewport）的容器\n    * 适合于单独做移动端开发\n\n\n# 29.4 bootstrap栅格系统\n\n 1. 将页面布局划分为等宽的列，然后通过列数的定义来模块化页面布局\n 2. bootstrap将container自动分为12列\n 3. * 行（row）必须放在container容器里面\n    * 实现列的平均划分需要给列添加类前缀\n    * 类前缀意思\n      * xs-extra small：超小\n      * sm-small：小\n      * md-medium：中等\n      * lg-large：大\n    * 列（column）大于12，多余的列所在的元素江北作为一个整体另起一行排列\n    * 每一列默认有左右15像素的padding\n    * 可以同事为一列指定对个设备的类名，以便划分不同份数例如class="col-md-4 col-sm-6"\n\n# 29.4.1 列嵌套\n\n 1. 栅格系统内置的栅格系统将内容再次嵌套。可以通过添加一个新的.row元素和一系列.col-sn等元素分割已经存在的列中\n 2. 列嵌套最好加一个行盒子，这样可以取消父元素的padding\n\n# 29.4.2 列偏移\n\n 1. 使用.col-md-offset-份数类可以将列向右侧偏移\n\n# 29.4.3 列排序\n\n 1. 通过使用.col-md-push-份数和.col-md-pull-份数类很容易改变列的顺序\n 2. push往右推，pull往左拉\n\n# 29.4.4 响应式工具\n\n 1. 利用媒体查询功能，使用这些工具类可以方便针对不同设备展示或隐藏页面内容',charsets:{cjk:!0},lastUpdated:"2023/03/27, 17:41:36",lastUpdatedTimestamp:1679910096e3},{title:"Vue",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"《Vue》",imgUrl:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200204143633.png",description:"Vue学习笔记"}},title:"Vue",date:"2022-04-10T20:45:02.000Z",permalink:"/note/vue",article:!1,comment:!1,editLink:!1,author:{name:"年华惊风雨",link:"https://github.com/wsy425"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/20.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/15.%20Vue.html",relativePath:"01.前端/20.学习笔记/15. Vue.md",key:"v-6825d8c9",path:"/note/vue/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"HTML",frontmatter:{title:"HTML",date:"2022-04-10T20:26:41.000Z",permalink:"/pages/2eedd5/",categories:["前端","学习笔记"],tags:["HTML"],author:{name:"年华惊风雨",link:"https://github.com/wsy425"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/20.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/05.%20HTML.html",relativePath:"01.前端/20.学习笔记/05. HTML.md",key:"v-1c4a9466",path:"/pages/2eedd5/",headers:[{level:2,title:"1 语法规范",slug:"_1-语法规范",normalizedTitle:"1 语法规范",charIndex:2},{level:2,title:"2 标签",slug:"_2-标签",normalizedTitle:"2 标签",charIndex:50},{level:3,title:"2.1 基本结构标签",slug:"_2-1-基本结构标签",normalizedTitle:"2.1 基本结构标签",charIndex:59},{level:4,title:"2.1.1 根标签",slug:"_2-1-1-根标签",normalizedTitle:"2.1.1 根标签",charIndex:73},{level:4,title:"2.1.2 头部标签",slug:"_2-1-2-头部标签",normalizedTitle:"2.1.2 头部标签",charIndex:102},{level:4,title:"2.1.3 主体标签",slug:"_2-1-3-主体标签",normalizedTitle:"2.1.3 主体标签",charIndex:169},{level:4,title:"2.1.4 vs code一键生成的骨架标签",slug:"_2-1-4-vs-code一键生成的骨架标签",normalizedTitle:"2.1.4 vs code一键生成的骨架标签",charIndex:199},{level:3,title:"2.2 语义标签",slug:"_2-2-语义标签",normalizedTitle:"2.2 语义标签",charIndex:502},{level:4,title:"2.2.1 标题标签",slug:"_2-2-1-标题标签",normalizedTitle:"2.2.1 标题标签",charIndex:514},{level:4,title:"2.2.2 段落标签",slug:"_2-2-2-段落标签",normalizedTitle:"2.2.2 段落标签",charIndex:607},{level:4,title:"2.2.3 换行标签",slug:"_2-2-3-换行标签",normalizedTitle:"2.2.3 换行标签",charIndex:634},{level:3,title:"2.3 文本格式化",slug:"_2-3-文本格式化",normalizedTitle:"2.3 文本格式化",charIndex:692},{level:4,title:"2.3.1 加粗",slug:"_2-3-1-加粗",normalizedTitle:"2.3.1 加粗",charIndex:705},{level:4,title:"2.3.2 斜体",slug:"_2-3-2-斜体",normalizedTitle:"2.3.2 斜体",charIndex:754},{level:4,title:"2.3.3 下划线",slug:"_2-3-3-下划线",normalizedTitle:"2.3.3 下划线",charIndex:795},{level:4,title:"2.3.4 删除线",slug:"_2-3-4-删除线",normalizedTitle:"2.3.4 删除线",charIndex:838},{level:3,title:"2.4 盒子标签",slug:"_2-4-盒子标签",normalizedTitle:"2.4 盒子标签",charIndex:883},{level:4,title:"2.4.1 div",slug:"_2-4-1-div",normalizedTitle:"2.4.1 div",charIndex:895},{level:4,title:"2.4.2 span",slug:"_2-4-2-span",normalizedTitle:"2.4.2 span",charIndex:941},{level:3,title:"2.5 图像标签",slug:"_2-5-图像标签",normalizedTitle:"2.5 图像标签",charIndex:988},{level:4,title:"2.5.1 图像标签属性",slug:"_2-5-1-图像标签属性",normalizedTitle:"2.5.1 图像标签属性",charIndex:1020},{level:4,title:"2.5.2 图像路径",slug:"_2-5-2-图像路径",normalizedTitle:"2.5.2 图像路径",charIndex:1182},{level:5,title:"相对路径",slug:"相对路径",normalizedTitle:"相对路径",charIndex:1196},{level:5,title:"绝对路径",slug:"绝对路径",normalizedTitle:"绝对路径",charIndex:1249},{level:3,title:"2.6 超链接标签",slug:"_2-6-超链接标签",normalizedTitle:"2.6 超链接标签",charIndex:1281},{level:4,title:"2.6.1 语法格式",slug:"_2-6-1-语法格式",normalizedTitle:"2.6.1 语法格式",charIndex:1294},{level:4,title:"2.6.2 链接分类",slug:"_2-6-2-链接分类",normalizedTitle:"2.6.2 链接分类",charIndex:1422},{level:3,title:"2.7 注释标签",slug:"_2-7-注释标签",normalizedTitle:"2.7 注释标签",charIndex:1593},{level:3,title:"2.8 特殊字符",slug:"_2-8-特殊字符",normalizedTitle:"2.8 特殊字符",charIndex:1637},{level:3,title:"2.9 表格标签",slug:"_2-9-表格标签",normalizedTitle:"2.9 表格标签",charIndex:1699},{level:4,title:"2.9.1 表格基本语法",slug:"_2-9-1-表格基本语法",normalizedTitle:"2.9.1 表格基本语法",charIndex:1711},{level:4,title:"2.9.2 表头单元格标签",slug:"_2-9-2-表头单元格标签",normalizedTitle:"2.9.2 表头单元格标签",charIndex:1790},{level:4,title:"2.9.3 表格属性",slug:"_2-9-3-表格属性",normalizedTitle:"2.9.3 表格属性",charIndex:1833},{level:4,title:"2.9.4 表格结构标签",slug:"_2-9-4-表格结构标签",normalizedTitle:"2.9.4 表格结构标签",charIndex:1977},{level:4,title:"2.9.5 合并单元格",slug:"_2-9-5-合并单元格",normalizedTitle:"2.9.5 合并单元格",charIndex:2048},{level:5,title:"合并单元格方式",slug:"合并单元格方式",normalizedTitle:"合并单元格方式",charIndex:2063},{level:5,title:"目标单元格",slug:"目标单元格",normalizedTitle:"目标单元格",charIndex:2129},{level:3,title:"2.10 列表标签",slug:"_2-10-列表标签",normalizedTitle:"2.10 列表标签",charIndex:2162},{level:4,title:"2.10.1 无序列表",slug:"_2-10-1-无序列表",normalizedTitle:"2.10.1 无序列表",charIndex:2184},{level:4,title:"2.10.2 有序列表",slug:"_2-10-2-有序列表",normalizedTitle:"2.10.2 有序列表",charIndex:2360},{level:4,title:"2.10.3 自定义列表",slug:"_2-10-3-自定义列表",normalizedTitle:"2.10.3 自定义列表",charIndex:2536},{level:3,title:"2.11 表单标签",slug:"_2-11-表单标签",normalizedTitle:"2.11 表单标签",charIndex:2689},{level:4,title:"2.11.1 表单域",slug:"_2-11-1-表单域",normalizedTitle:"2.11.1 表单域",charIndex:2702},{level:4,title:"2.11.2 表单控件（表单元素）",slug:"_2-11-2-表单控件-表单元素",normalizedTitle:"2.11.2 表单控件（表单元素）",charIndex:2927},{level:5,title:"input输入表单元素",slug:"input输入表单元素",normalizedTitle:"input输入表单元素",charIndex:2948},{level:5,title:"label标签",slug:"label标签",normalizedTitle:"label标签",charIndex:3326},{level:5,title:"select下拉表单元素",slug:"select下拉表单元素",normalizedTitle:"select下拉表单元素",charIndex:3494},{level:5,title:"textarea 文本域表单元素",slug:"textarea-文本域表单元素",normalizedTitle:"textarea 文本域表单元素",charIndex:3664},{level:4,title:"提示信息",slug:"提示信息",normalizedTitle:"提示信息",charIndex:3773},{level:2,title:"3 Emmet语法",slug:"_3-emmet语法",normalizedTitle:"3 emmet语法",charIndex:3782},{level:3,title:"3.1 快速生成HTML",slug:"_3-1-快速生成html",normalizedTitle:"3.1 快速生成html",charIndex:3796},{level:2,title:"4 HTML5 新标签",slug:"_4-html5-新标签",normalizedTitle:"4 html5 新标签",charIndex:3942},{level:3,title:"4.1 HTML5新增语义化标签",slug:"_4-1-html5新增语义化标签",normalizedTitle:"4.1 html5新增语义化标签",charIndex:3958},{level:3,title:"4.2 HTML5新增多媒体标签",slug:"_4-2-html5新增多媒体标签",normalizedTitle:"4.2 html5新增多媒体标签",charIndex:4167},{level:4,title:"4.2.1 视频标签",slug:"_4-2-1-视频标签",normalizedTitle:"4.2.1 视频标签",charIndex:4220},{level:4,title:"4.2.2 音频标签",slug:"_4-2-2-音频标签",normalizedTitle:"4.2.2 音频标签",charIndex:4674},{level:3,title:"4.3 HTML新增input类型",slug:"_4-3-html新增input类型",normalizedTitle:"4.3 html新增input类型",charIndex:4789},{level:3,title:"4.4 HTML新增表单属性",slug:"_4-4-html新增表单属性",normalizedTitle:"4.4 html新增表单属性",charIndex:4813}],headersStr:"1 语法规范 2 标签 2.1 基本结构标签 2.1.1 根标签 2.1.2 头部标签 2.1.3 主体标签 2.1.4 vs code一键生成的骨架标签 2.2 语义标签 2.2.1 标题标签 2.2.2 段落标签 2.2.3 换行标签 2.3 文本格式化 2.3.1 加粗 2.3.2 斜体 2.3.3 下划线 2.3.4 删除线 2.4 盒子标签 2.4.1 div 2.4.2 span 2.5 图像标签 2.5.1 图像标签属性 2.5.2 图像路径 相对路径 绝对路径 2.6 超链接标签 2.6.1 语法格式 2.6.2 链接分类 2.7 注释标签 2.8 特殊字符 2.9 表格标签 2.9.1 表格基本语法 2.9.2 表头单元格标签 2.9.3 表格属性 2.9.4 表格结构标签 2.9.5 合并单元格 合并单元格方式 目标单元格 2.10 列表标签 2.10.1 无序列表 2.10.2 有序列表 2.10.3 自定义列表 2.11 表单标签 2.11.1 表单域 2.11.2 表单控件（表单元素） input输入表单元素 label标签 select下拉表单元素 textarea 文本域表单元素 提示信息 3 Emmet语法 3.1 快速生成HTML 4 HTML5 新标签 4.1 HTML5新增语义化标签 4.2 HTML5新增多媒体标签 4.2.1 视频标签 4.2.2 音频标签 4.3 HTML新增input类型 4.4 HTML新增表单属性",content:'# 1 语法规范\n\n 1. 尖括号\n 2. 通常是成对出现\n 3. 标签分成包含和并列关系\n\n\n# 2 标签\n\n\n# 2.1 基本结构标签\n\n# 2.1.1 根标签\n\n<html> </html>\n\n# 2.1.2 头部标签\n\n 1. <head> </head>\n 2. 其中必须设置的是标题标签<title> </title>\n\n# 2.1.3 主体标签\n\n<body> </body>\n\n# 2.1.4 vs code一键生成的骨架标签\n\n<!DOCTYPE html>   \x3c!-- 文档类型声明标签，必须写到页面最前--\x3e\n<html lang="en">  \x3c!-- lang语言种类--\x3e\n<head>\n    <meta charset="UTF-8"> \x3c!-- 字符集--\x3e\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title></title>\n</head>\n<body>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2.2 语义标签\n\n# 2.2.1 标题标签\n\n 1. 标题（Heading）是通过< h1> - < h6> 标签来定义的\n 2. <h1> 一级标题 </h1>\n 3. 使用标题标签后独占一行并加粗\n\n# 2.2.2 段落标签\n\n<p>一个段落</p>\n\n# 2.2.3 换行标签\n\n 1. <br/>\n 2. 单标签\n 3. 只是另起一行，不会产生段落之间的大间隙\n\n\n# 2.3 文本格式化\n\n# 2.3.1 加粗\n\n 1. <strong> </strong>\n 2. <b> </b>\n\n# 2.3.2 斜体\n\n 1. <em> </em>\n 2. <i> </i>\n\n# 2.3.3 下划线\n\n 1. <del> </del>\n 2. <s></s>\n\n# 2.3.4 删除线\n\n 1. <ins> </ins>\n 2. <u> </u>\n\n\n# 2.4 盒子标签\n\n# 2.4.1 div\n\n 1. <div> </div>\n 2. 一行只能放一个div\n\n# 2.4.2 span\n\n 1. <span></span>\n 2. 一行可以放很多个\n\n\n# 2.5 图像标签\n\n<img src="图像URL"/>\n\n# 2.5.1 图像标签属性\n\n 1. src：< img>标签的必须属性，用于指定图像文件的路径和文件名\n 2. alt：替换文本，图片不能显示时显示的文本\n 3. title：提示文本，鼠标放到图像上显示的文字\n 4. width：图像宽度像素\n 5. height：图像高度像素\n 6. border：图像边框像素\n\n# 2.5.2 图像路径\n\n# 相对路径\n\n 1. 同一级路径：直接写上文件名\n 2. 上一级路径：../\n 3. 下一级路径：/\n\n# 绝对路径\n\n 1. 本地绝对地址\n 2. 网络绝对地址\n\n\n# 2.6 超链接标签\n\n# 2.6.1 语法格式\n\n 1. <a href="跳转目标" target="目标弹出方式"> </a>\n 2. herf：必须属性，指定链接目标地址\n 3. target：默认为_self、当前页面打开，还可以选择_blank、在新窗口中打开页面\n\n# 2.6.2 链接分类\n\n 1. 外部链接：herf直接写网络绝对地址\n 2. 内部链接：herf写本地相对地址\n 3. 空连接：herf写#\n 4. 下载链接：herf写文件地址\n 5. 锚点链接：快速定位到页面的某个位置\n    * 链接文本：<a herf="#two"> </a>\n    * 目标位置标签<id="two">\n\n\n# 2.7 注释标签\n\n 1. \x3c!-- --\x3e\n 2. 快捷键：ctrl + /\n\n\n# 2.8 特殊字符\n\n特殊字符汇总\n\n 1. 空格：&nbsp；\n 2. 小于号：&lt；\n 3. 大于号：&gt；\n\n\n# 2.9 表格标签\n\n# 2.9.1 表格基本语法\n\n 1. 定义表格：<table></table>\n 2. 定义行：<tr></tr>\n 3. 定义单元格<td></td>\n\n# 2.9.2 表头单元格标签\n\n 1. <th></th>\n 2. 居中加粗显示\n\n# 2.9.3 表格属性\n\n 1. 不常用，一般用css来设置\n 2. align：规定表格相对周围元素的对齐方式\n 3. border：规定边框\n 4. cellpadding：边沿和内容之间的空白\n 5. cellspacing：单元格之间的空白距离\n 6. width：表格宽度\n\n# 2.9.4 表格结构标签\n\n 1. 头部区域标签：<thead></thead>\n 2. 主题区域标签：<tbody></tbody>\n\n# 2.9.5 合并单元格\n\n# 合并单元格方式\n\n 1. 跨行合并：rowapan=“合并单元格个数”\n 2. 跨列合并：colspan=“合并单元格个数”\n\n# 目标单元格\n\n 1. 跨行：最上侧\n 2. 跨列：最左侧\n\n\n# 2.10 列表标签\n\n用于布局网页的\n\n# 2.10.1 无序列表\n\n 1. 无序列表语法格式\n\n<ul>\n    <li>列表项1</li>\n    <li>列表项2</li>\n</ul>\n\n\n1\n2\n3\n4\n\n 2. < ul>标签里只能出现< li>标签，不能出现其他内容\n 3. < li>标签里可以放任何标签，是一个容器\n 4. 无序列表带有样式属性，实际使用的时候用css设置\n\n# 2.10.2 有序列表\n\n 1. 有序列表语法格式\n\n<ol>\n    <li>列表项1</li>\n    <li>列表项2</li>\n</ol>\n\n\n1\n2\n3\n4\n\n 2. < ol>标签里只能出现< li>标签，不能出现其他内容\n 3. < li>标签里可以放任何标签，是一个容器\n 4. 有序列表带有样式属性，实际使用的时候用css设置\n\n# 2.10.3 自定义列表\n\n 1. 自定义列表语法格式\n\n<dl>\n    <dt>名词1</dt>\n    <dd>名词1解释1</dd>\n    <dd>名词1解释1</dd>\n</dl>\n\n\n1\n2\n3\n4\n5\n\n 2. < dl>标签里只能出现< dt>、< dd>标签，不能出现其他内容\n\n\n# 2.11 表单标签\n\n# 2.11.1 表单域\n\n 1. 表单域是包含表单元素的区域，实现用户信息的收集和传递\n 2. 表单域语法格式\n\n<form action="url地址" method="提交方式" name="表单域名称">\n</form>\n\n\n1\n2\n\n 3. 表单域属性\n    * action：用于指定接收并处理表单数据的服务器程序的url地址\n    * method：get/post，设置表单数据的提交方式\n    * name：指定表单的名称\n\n# 2.11.2 表单控件（表单元素）\n\n# input输入表单元素\n\n 1. 语法规范 <input type="属性值"/>\n 2. input为单标签\n 3. type属性必须要写\n    * text:文本，直接显示\n    * password：文本，影藏显示\n    * radio：单选按钮，圆的\n    * checkbox：多选按钮，方的\n    * submit:点击按钮将表单域的元素值送入后台\n    * reset：重置表单域里的元素值\n    * button：普通按钮，启动js脚本\n    * file：文件域按钮，上传文件\n 4. name属性 单选按钮的表单元素name属性一致，才能实现多选一\n 5. value属性 表单元素默认值\n 6. checked属性 单选按钮和复选框的属性，显示默认勾选\n 7. maxlength 规定输入字段中的字符最大长度\n\n# label标签\n\n 1. 点击label标签内的文本时，浏览器自动将光标转到对应的表单元素\n 2. 语法规范\n\n<label for="sex">男</label>\n<input type="radio" name="sex" id="sex"/>\n\n\n1\n2\n\n 3. 核心是label标签的for属性与相关元素的id属性相同\n\n# select下拉表单元素\n\n 1. 语法规范\n\n<select>\n    <option>选项1</option>\n    <option>选项2</option>\n</select>\n\n\n1\n2\n3\n4\n\n 2. select里至少包含一个option\n 3. option里定义selected属性=“selected”默认选定\n\n# textarea 文本域表单元素\n\n 1. 可以定义多行文本输入\n 2. 语法规范 <textarea>默认文字</textarea>\n 3. cols属性设定一行显示的字数\n 4. rows属性设定显示多少行\n\n# 提示信息\n\n\n# 3 Emmet语法\n\n\n# 3.1 快速生成HTML\n\n 1. 生成标签：直接输入标签名+ tab\n 2. 生成多个标签：* tab\n 3. 父子级关系： > tab\n 4. 兄弟级关系： + tab\n 5. 带有类名： .\n    带有id名字： #\n 6. 自增符号： $\n 7. 标签默认文字用{}括起来\n\n\n# 4 HTML5 新标签\n\n\n# 4.1 HTML5新增语义化标签\n\n 1.  头部标签<header>\n 2.  导航标签<nav>\n 3.  内容标签<article>\n 4.  定义文档某个区域<section>\n 5.  侧边栏标签<aside>\n 6.  尾部标签<footer>\n 7.  这种语义化的标签主要是针对搜索引擎\n 8.  新标签页面中可使用多次\n 9.  在IE9中需要把元素转换为块级元素\n 10. 移动端更喜欢用\n\n\n# 4.2 HTML5新增多媒体标签\n\n 1. 音频标签<audio>\n 2. 视频标签<video>\n\n# 4.2.1 视频标签\n\n 1. 只支持三种视频格式：MP4;WebM；Ogg\n 2. 尽量使用MP4\n 3. 语法<video src="文件地址" controls="controls"></video>\n\n<video width="320" height="240" controls>\n    <source src="movie.mp4" type="video/mp4">\n    <source src="movie.ogg" type="video/ogg">\n    <source src="movie.webm" type="video/webm">\n    <object data="movie.mp4" width="320" height="240">\n        <embed src="movie.swf" width="320" height="240">\n    </object> \n</video>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 4. 常见属性\n\n# 4.2.2 音频标签\n\n 1. 只支持三种音频格式：MP3;Wav;Ogg\n 2. 都支持MP3\n 3. 语法<audio src="文件地址" controls="controls"></audio>\n 4. 常见属性\n\n\n# 4.3 HTML新增input类型\n\n\n\n\n# 4.4 HTML新增表单属性\n\n',normalizedContent:'# 1 语法规范\n\n 1. 尖括号\n 2. 通常是成对出现\n 3. 标签分成包含和并列关系\n\n\n# 2 标签\n\n\n# 2.1 基本结构标签\n\n# 2.1.1 根标签\n\n<html> </html>\n\n# 2.1.2 头部标签\n\n 1. <head> </head>\n 2. 其中必须设置的是标题标签<title> </title>\n\n# 2.1.3 主体标签\n\n<body> </body>\n\n# 2.1.4 vs code一键生成的骨架标签\n\n<!doctype html>   \x3c!-- 文档类型声明标签，必须写到页面最前--\x3e\n<html lang="en">  \x3c!-- lang语言种类--\x3e\n<head>\n    <meta charset="utf-8"> \x3c!-- 字符集--\x3e\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title></title>\n</head>\n<body>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2.2 语义标签\n\n# 2.2.1 标题标签\n\n 1. 标题（heading）是通过< h1> - < h6> 标签来定义的\n 2. <h1> 一级标题 </h1>\n 3. 使用标题标签后独占一行并加粗\n\n# 2.2.2 段落标签\n\n<p>一个段落</p>\n\n# 2.2.3 换行标签\n\n 1. <br/>\n 2. 单标签\n 3. 只是另起一行，不会产生段落之间的大间隙\n\n\n# 2.3 文本格式化\n\n# 2.3.1 加粗\n\n 1. <strong> </strong>\n 2. <b> </b>\n\n# 2.3.2 斜体\n\n 1. <em> </em>\n 2. <i> </i>\n\n# 2.3.3 下划线\n\n 1. <del> </del>\n 2. <s></s>\n\n# 2.3.4 删除线\n\n 1. <ins> </ins>\n 2. <u> </u>\n\n\n# 2.4 盒子标签\n\n# 2.4.1 div\n\n 1. <div> </div>\n 2. 一行只能放一个div\n\n# 2.4.2 span\n\n 1. <span></span>\n 2. 一行可以放很多个\n\n\n# 2.5 图像标签\n\n<img src="图像url"/>\n\n# 2.5.1 图像标签属性\n\n 1. src：< img>标签的必须属性，用于指定图像文件的路径和文件名\n 2. alt：替换文本，图片不能显示时显示的文本\n 3. title：提示文本，鼠标放到图像上显示的文字\n 4. width：图像宽度像素\n 5. height：图像高度像素\n 6. border：图像边框像素\n\n# 2.5.2 图像路径\n\n# 相对路径\n\n 1. 同一级路径：直接写上文件名\n 2. 上一级路径：../\n 3. 下一级路径：/\n\n# 绝对路径\n\n 1. 本地绝对地址\n 2. 网络绝对地址\n\n\n# 2.6 超链接标签\n\n# 2.6.1 语法格式\n\n 1. <a href="跳转目标" target="目标弹出方式"> </a>\n 2. herf：必须属性，指定链接目标地址\n 3. target：默认为_self、当前页面打开，还可以选择_blank、在新窗口中打开页面\n\n# 2.6.2 链接分类\n\n 1. 外部链接：herf直接写网络绝对地址\n 2. 内部链接：herf写本地相对地址\n 3. 空连接：herf写#\n 4. 下载链接：herf写文件地址\n 5. 锚点链接：快速定位到页面的某个位置\n    * 链接文本：<a herf="#two"> </a>\n    * 目标位置标签<id="two">\n\n\n# 2.7 注释标签\n\n 1. \x3c!-- --\x3e\n 2. 快捷键：ctrl + /\n\n\n# 2.8 特殊字符\n\n特殊字符汇总\n\n 1. 空格：&nbsp；\n 2. 小于号：&lt；\n 3. 大于号：&gt；\n\n\n# 2.9 表格标签\n\n# 2.9.1 表格基本语法\n\n 1. 定义表格：<table></table>\n 2. 定义行：<tr></tr>\n 3. 定义单元格<td></td>\n\n# 2.9.2 表头单元格标签\n\n 1. <th></th>\n 2. 居中加粗显示\n\n# 2.9.3 表格属性\n\n 1. 不常用，一般用css来设置\n 2. align：规定表格相对周围元素的对齐方式\n 3. border：规定边框\n 4. cellpadding：边沿和内容之间的空白\n 5. cellspacing：单元格之间的空白距离\n 6. width：表格宽度\n\n# 2.9.4 表格结构标签\n\n 1. 头部区域标签：<thead></thead>\n 2. 主题区域标签：<tbody></tbody>\n\n# 2.9.5 合并单元格\n\n# 合并单元格方式\n\n 1. 跨行合并：rowapan=“合并单元格个数”\n 2. 跨列合并：colspan=“合并单元格个数”\n\n# 目标单元格\n\n 1. 跨行：最上侧\n 2. 跨列：最左侧\n\n\n# 2.10 列表标签\n\n用于布局网页的\n\n# 2.10.1 无序列表\n\n 1. 无序列表语法格式\n\n<ul>\n    <li>列表项1</li>\n    <li>列表项2</li>\n</ul>\n\n\n1\n2\n3\n4\n\n 2. < ul>标签里只能出现< li>标签，不能出现其他内容\n 3. < li>标签里可以放任何标签，是一个容器\n 4. 无序列表带有样式属性，实际使用的时候用css设置\n\n# 2.10.2 有序列表\n\n 1. 有序列表语法格式\n\n<ol>\n    <li>列表项1</li>\n    <li>列表项2</li>\n</ol>\n\n\n1\n2\n3\n4\n\n 2. < ol>标签里只能出现< li>标签，不能出现其他内容\n 3. < li>标签里可以放任何标签，是一个容器\n 4. 有序列表带有样式属性，实际使用的时候用css设置\n\n# 2.10.3 自定义列表\n\n 1. 自定义列表语法格式\n\n<dl>\n    <dt>名词1</dt>\n    <dd>名词1解释1</dd>\n    <dd>名词1解释1</dd>\n</dl>\n\n\n1\n2\n3\n4\n5\n\n 2. < dl>标签里只能出现< dt>、< dd>标签，不能出现其他内容\n\n\n# 2.11 表单标签\n\n# 2.11.1 表单域\n\n 1. 表单域是包含表单元素的区域，实现用户信息的收集和传递\n 2. 表单域语法格式\n\n<form action="url地址" method="提交方式" name="表单域名称">\n</form>\n\n\n1\n2\n\n 3. 表单域属性\n    * action：用于指定接收并处理表单数据的服务器程序的url地址\n    * method：get/post，设置表单数据的提交方式\n    * name：指定表单的名称\n\n# 2.11.2 表单控件（表单元素）\n\n# input输入表单元素\n\n 1. 语法规范 <input type="属性值"/>\n 2. input为单标签\n 3. type属性必须要写\n    * text:文本，直接显示\n    * password：文本，影藏显示\n    * radio：单选按钮，圆的\n    * checkbox：多选按钮，方的\n    * submit:点击按钮将表单域的元素值送入后台\n    * reset：重置表单域里的元素值\n    * button：普通按钮，启动js脚本\n    * file：文件域按钮，上传文件\n 4. name属性 单选按钮的表单元素name属性一致，才能实现多选一\n 5. value属性 表单元素默认值\n 6. checked属性 单选按钮和复选框的属性，显示默认勾选\n 7. maxlength 规定输入字段中的字符最大长度\n\n# label标签\n\n 1. 点击label标签内的文本时，浏览器自动将光标转到对应的表单元素\n 2. 语法规范\n\n<label for="sex">男</label>\n<input type="radio" name="sex" id="sex"/>\n\n\n1\n2\n\n 3. 核心是label标签的for属性与相关元素的id属性相同\n\n# select下拉表单元素\n\n 1. 语法规范\n\n<select>\n    <option>选项1</option>\n    <option>选项2</option>\n</select>\n\n\n1\n2\n3\n4\n\n 2. select里至少包含一个option\n 3. option里定义selected属性=“selected”默认选定\n\n# textarea 文本域表单元素\n\n 1. 可以定义多行文本输入\n 2. 语法规范 <textarea>默认文字</textarea>\n 3. cols属性设定一行显示的字数\n 4. rows属性设定显示多少行\n\n# 提示信息\n\n\n# 3 emmet语法\n\n\n# 3.1 快速生成html\n\n 1. 生成标签：直接输入标签名+ tab\n 2. 生成多个标签：* tab\n 3. 父子级关系： > tab\n 4. 兄弟级关系： + tab\n 5. 带有类名： .\n    带有id名字： #\n 6. 自增符号： $\n 7. 标签默认文字用{}括起来\n\n\n# 4 html5 新标签\n\n\n# 4.1 html5新增语义化标签\n\n 1.  头部标签<header>\n 2.  导航标签<nav>\n 3.  内容标签<article>\n 4.  定义文档某个区域<section>\n 5.  侧边栏标签<aside>\n 6.  尾部标签<footer>\n 7.  这种语义化的标签主要是针对搜索引擎\n 8.  新标签页面中可使用多次\n 9.  在ie9中需要把元素转换为块级元素\n 10. 移动端更喜欢用\n\n\n# 4.2 html5新增多媒体标签\n\n 1. 音频标签<audio>\n 2. 视频标签<video>\n\n# 4.2.1 视频标签\n\n 1. 只支持三种视频格式：mp4;webm；ogg\n 2. 尽量使用mp4\n 3. 语法<video src="文件地址" controls="controls"></video>\n\n<video width="320" height="240" controls>\n    <source src="movie.mp4" type="video/mp4">\n    <source src="movie.ogg" type="video/ogg">\n    <source src="movie.webm" type="video/webm">\n    <object data="movie.mp4" width="320" height="240">\n        <embed src="movie.swf" width="320" height="240">\n    </object> \n</video>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 4. 常见属性\n\n# 4.2.2 音频标签\n\n 1. 只支持三种音频格式：mp3;wav;ogg\n 2. 都支持mp3\n 3. 语法<audio src="文件地址" controls="controls"></audio>\n 4. 常见属性\n\n\n# 4.3 html新增input类型\n\n\n\n\n# 4.4 html新增表单属性\n\n',charsets:{cjk:!0},lastUpdated:"2023/03/27, 17:41:36",lastUpdatedTimestamp:1679910096e3},{title:"Elctron",frontmatter:{title:"Elctron",date:"2023-08-08T09:18:02.000Z",permalink:"/pages/74c0eb/",categories:["前端","学习笔记"],tags:["Electron"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/20.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%20Elctron.html",relativePath:"01.前端/20.学习笔记/20. Elctron.md",key:"v-08adb969",path:"/pages/74c0eb/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"ThreeJS",frontmatter:{title:"ThreeJS",date:"2023-08-08T11:41:10.000Z",permalink:"/pages/3bf799/",categories:["前端","学习笔记"],tags:["Web3D","ThreeJS"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/20.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/25.%20ThreeJS.html",relativePath:"01.前端/20.学习笔记/25. ThreeJS.md",key:"v-4251b96e",path:"/pages/3bf799/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"TypeScript笔记",frontmatter:{title:"TypeScript笔记",date:"2020-10-08T13:02:48.000Z",permalink:"/pages/51afd6/",categories:["前端","学习笔记"],tags:["TypeScript"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/20.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/35.TypeScript%E7%AC%94%E8%AE%B0.html",relativePath:"01.前端/20.学习笔记/35.TypeScript笔记.md",key:"v-7554dcb0",path:"/pages/51afd6/",headers:[{level:2,title:"类型注解",slug:"类型注解",normalizedTitle:"类型注解",charIndex:61},{level:3,title:"有哪些基础类型注解？",slug:"有哪些基础类型注解",normalizedTitle:"有哪些基础类型注解？",charIndex:220},{level:3,title:"什么是类型注解和类型推断、类型断言？",slug:"什么是类型注解和类型推断、类型断言",normalizedTitle:"什么是类型注解和类型推断、类型断言？",charIndex:506},{level:3,title:"对象的类型",slug:"对象的类型",normalizedTitle:"对象的类型",charIndex:877},{level:3,title:"函数的类型注解",slug:"函数的类型注解",normalizedTitle:"函数的类型注解",charIndex:1334},{level:3,title:"数组的类型注解",slug:"数组的类型注解",normalizedTitle:"数组的类型注解",charIndex:1825},{level:2,title:"元组",slug:"元组",normalizedTitle:"元组",charIndex:2474},{level:2,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:349},{level:2,title:"ES6 class类中应用TS",slug:"es6-class类中应用ts",normalizedTitle:"es6 class类中应用ts",charIndex:4152},{level:3,title:"class类的修饰器",slug:"class类的修饰器",normalizedTitle:"class类的修饰器",charIndex:4172},{level:3,title:"class类的构造函数中使用类型校验",slug:"class类的构造函数中使用类型校验",normalizedTitle:"class类的构造函数中使用类型校验",charIndex:4796},{level:3,title:"class类的getter、setter和static",slug:"class类的getter、setter和static",normalizedTitle:"class类的getter、setter和static",charIndex:5174},{level:3,title:"class类的只读属性",slug:"class类的只读属性",normalizedTitle:"class类的只读属性",charIndex:5701},{level:3,title:"抽象类",slug:"抽象类",normalizedTitle:"抽象类",charIndex:5970},{level:2,title:"联合类型和类型保护",slug:"联合类型和类型保护",normalizedTitle:"联合类型和类型保护",charIndex:6361},{level:2,title:"枚举",slug:"枚举",normalizedTitle:"枚举",charIndex:7252},{level:2,title:"泛型",slug:"泛型",normalizedTitle:"泛型",charIndex:7925},{level:3,title:"函数中的泛型使用",slug:"函数中的泛型使用",normalizedTitle:"函数中的泛型使用",charIndex:7963},{level:3,title:"class类中使用泛型",slug:"class类中使用泛型",normalizedTitle:"class类中使用泛型",charIndex:8727},{level:2,title:"配置文件tsconfig.json",slug:"配置文件tsconfig-json",normalizedTitle:"配置文件tsconfig.json",charIndex:9796}],headersStr:"类型注解 有哪些基础类型注解？ 什么是类型注解和类型推断、类型断言？ 对象的类型 函数的类型注解 数组的类型注解 元组 接口 ES6 class类中应用TS class类的修饰器 class类的构造函数中使用类型校验 class类的getter、setter和static class类的只读属性 抽象类 联合类型和类型保护 枚举 泛型 函数中的泛型使用 class类中使用泛型 配置文件tsconfig.json",content:"# TypeScript 学习笔记\n\nTypeScript 的类型校验是给程序员看的，在编译后不会存在TS代码。\n\n\n# 类型注解\n\nfunction fn(person: string):void{ // 参数类型是字符串，没有返回值\n    ///...\n}\nfn('str') // 如传递参数非字符串，vscode编辑器中或在编译时将给出错误提示\n\nconst test:number = 1\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 有哪些基础类型注解？\n\n// 基础类型\n:string\n:number\n:boolean\n\n:null  // 只能是null值\n:undefined // 只能是undefined值\n\n:symbol\n\n// 引用类型\n:object // 不常用，多使用接口来给对象进行类型注解\n\n// 其他\n:any  // 任意类型\n:void  // 空，用于函数的无返回值的注解\n:never // 用于标注函数代码永远执行不完（如抛出错误的函数，死循环函数）\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 什么是类型注解和类型推断、类型断言？\n\n类型注解 是显式的标注类型\n\n类型推断 是编辑器根据值来自动推断出类型 (编辑器中鼠标移到变量会显示类型的提示)。\n\n类型断言 是告诉编译器，“相信我，它就是这个类型”。\n\n// 类型注解就是显式的写出类型\nconst myNumber: number = 123\n\n// 类型推断是根据值来推断类型 (鼠标移到变量会显示类型(或直接显示值)的提示)\nconst myString = 'test'\n\n// 类型断言（开发者明确知道是什么类型）\nconst someValue:any = 'abc'\nconst strLength:number = (someValue as string).length // 断言someValue是字符串类型\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 对象的类型\n\n// 对象字面量的类型检查\nconst xiaojiejie: {\n  name: string,\n  age: number\n} = {\n  name: '小红',\n  age: 18\n}\n\n// 标注:object\nconst obj:object = {}\n\n// 使用接口\ninterface Person{\n    name: string\n    age: number\n}\nconst xjj: Person = {\n    name: 'xh',\n    age: 18\n}\n\n// class类的类型检查\nclass Parson { }\nconst xiaobai: Parson = new Parson()\n\n// 函数和返回值的类型检查\nconst fn: ()=> string = () => '123'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 函数的类型注解\n\n// 函数返回值的类型注解 fn(): number {}\nfunction getTotal2(one: number, two: number): number {\n  return one + two\n}\ngetTotal2(1,2)\n\n\n// 无返回值: void\nfunction sayHello(): void {\n  console.log(\"Hello\")\n}\n\n// 永远执行不玩的函数\nfunction setTimer():never {\n  throw new Error()\n  console.log(123)\n}\n\n// 参数是对象时的注解 （也可以用接口）\nfunction add({ one, two }: {one: number, two: number}) {\n  return  one + two\n}\n\nconst total = add({one: 1, two: 2})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 数组的类型注解\n\nconst numberArr: number[] = [1, 2, 3]\nconst stringArr: string[] = ['a', 'b']\nconst undefinedArr: undefined[] = [undefined, undefined]\nconst arr: (number | string | boolean)[] = [1, 'a', true, false] // 用到联合类型\n\n// 类型别名 type alias\ntype lady = { name: string, age: number }\n\nconst xiaojj: lady[] = [\n  {\n    name: 'xiaojj',\n    age: 90\n  },\n  {\n    name: 'j',\n    age: 30\n  }\n]\n\n// 或用类的方式\nclass Ady2 {\n  name: string;\n  age: number;\n}\n\nconst xiaojj2: Ady2[] = [\n  {\n    name: 'xiaojj',\n    age: 90\n  },\n  {\n    name: 'j',\n    age: 30\n  }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 元组\n\n元组，可以理解为：已知元素数量和类型的数组\n\n// 联合类型\nconst xjj:(string | number)[] = ['a',22,'b'] // 规定整个数组当中可以有string或number\n\n// 元组注解 注意这里的注解只有一个中括号\nconst xjj1: [string, number, number] = ['a', 22, 33] // 规定了数组每个元素对应位置的类型\n\n// Note: 在开发中元祖的使用在相对少\n\n\n// CSV的方式定义数据格式； （二维数组时需要多加一个中括号）\nconst xjj2: [string, number, number][] = [\n  ['a', 22, 33],\n  ['a', 22, 33]\n]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 接口\n\n接口，可以理解为对象属性的类型描述。和类型别名类似，不同的是 接口必须是一个对象，而别名可以直接是一个类型，如type Girl = string\n\ninterface Girl { // 接口 （理解：对象属性的类型描述）\n  readonly name: string; // 只读属性 （定义之后不能再修改）\n  age: number;\n  waistline?: number; // 加个问号表示是可选值\n  [propname: string]: any; // 表示可以有不限制属性名的属性，但属性名需要是字符串，值可以是任意类型\n  say(): string; // 函数类型，返回值是string (如无返回值时是 void)。  say()也可以加入参数类型检查，如say(p:number)\n}\n// 和类型别名类似，不同的是 接口必须是一个对象，而别名可以直接是一个类型，如 type Girl = string\n\n// 接口的继承\ninterface Teacher extends Girl {\n  teach(): string;\n}\n\n\nconst girl = {\n  name: '大脚',\n  age: 18,\n  sex: '女',\n  say() {\n    return '欢迎光临'\n  },\n  teach() {\n    return '教'\n  }\n}\n\n\nconst screenResume = ({ name, age, bust, sex }: Girl) => {\n  console.log(name, age, bust, sex)\n}\nconst getResume = ({ name, age, bust, teach}: Teacher) => {\n  teach();\n  console.log(name, age, bust)\n}\nscreenResume(girl)\ngetResume(girl)\n\n\n// 接口在class类中的使用\nclass xiaojjj implements Girl {\n  name = \"xiaojj\"\n  age = 18\n  bust = 98\n  sex = '女'\n  say() {\n    return '欢迎光临'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n可索引的类型\n\ninterface Arr {\n    [index: number]:string   // 表示通过索引访问数据时返回的类型是string\n}\n\nconst myArr:Arr = ['1','2','3']\nconst myStr:string = myArr[1]\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# ES6 class类中应用TS\n\n\n# class类的修饰器\n\n// 类的修饰器：\n// public (公共) 允许内外部使用\n// protected (受保护的) 允许在内部和继承内使用\n// private (私有) 允许在内部使用，但不能在继承中使用\n\n// 类的内部和外部，{}内属于内部，外面是外部\nclass Person {\n   // public 内外都可以使用，可省略，不写时默认public。 protected只允许内部使用\n  name: string // 这里的string注释是TS使用的\n  private age: 18\n  public sayHello() {\n    console.log(this.name + this.age + 'say hello')\n  }\n}\n\nclass Teacher2 extends Person {\n  public sayBye() {\n    console.log(this.name + ' say bye') // protected 可以在继承中使用到\n  }\n}\n\nconst person = new Person();\nperson.name = 'test' // 在类的外部定义\nconsole.log(person.name)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# class类的构造函数中使用类型校验\n\nclass Person2 {\n  constructor(public name: string) {\n    this.name = name\n  }\n}\n\nclass Teacher3 extends Person2{\n  constructor(public age: number) {\n    super('test-name') // 这里传的值是给Person2的构造函数。即使父类没有构造函数，子类的构造函数内也要写super()\n  }\n}\nconst teacher3 = new Teacher3(18)\nconsole.log(teacher3.name)\nconsole.log(teacher3.age)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# class类的getter、setter和static\n\nclass Xjj {\n  constructor(private _age: number) { }\n  get age() {\n    return this._age - 10;\n  }  // 访问器属性，以属性的形式访问age，并可以对属性进行包装\n  set age(age: number) {\n    this._age = age+3;\n   }\n}\n\nconst dj = new Xjj(28);\ndj.age = 25\n\nconsole.log(dj.age)\n\n\n// 静态属性 static。  静态属性指不需要通过实例化，直接通过Girl.prop的方式就可以访问到属性\nclass Girl {\n  static sayLove() {\n    return 'I love you'\n  }\n}\n\n// const girl = new Girl()\nconsole.log(Girl.sayLove())\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# class类的只读属性\n\n// 只读属性\nclass Person {\n  public readonly _name: string // 只读属性\n  constructor(name: string) {\n    this._name = name;\n  }\n}\n\nconst person = new Person('testName');\n// person._name = '222'; // 不能修改只读属性\nconsole.log(person._name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 抽象类\n\n/ 抽象类\nabstract class Girls {\n  abstract skill(); // 注意这里只是定义抽象方法，而不具有方法的实现\n}\n\nclass Waiter extends Girls{ // 继承了抽象类之后要 实现抽象类内的成员\n  skill() {\n    console.log('大爷1')\n  }\n}\n\nclass BaseTeacher extends Girls{\n  skill() {\n    console.log('大爷2')\n  }\n}\n\nclass SeniorTeacher extends Girls{\n  skill() {\n    console.log('大爷3')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 联合类型和类型保护\n\n联合类型 指某个参数可以是多种类型。\n\n类型保护 指参数属于某个类型才有相应的操作。\n\ninterface Waiter {\n  anjiao: boolean\n  say: () => {}\n}\n\ninterface Teacher {\n  anjiao: boolean\n  skill: () => {}\n}\n\nfunction judgeWho(animal: (Waiter | Teacher)) { // 联合类型\n  // 第一种断言方法\n  if (animal.anjiao) {\n    // (animal as Teacher) 的意思是：断言 animal 是 Teacher类型\n    (animal as Teacher).skill()\n  } else {\n    (animal as Waiter).say()\n  }\n\n  // 第二种断言方法\n  if ('skill' in animal) {\n    animal.skill()\n  } else {\n    animal.say()\n  }\n\n  // 第三种类型保护方法是使用typeof来判断 (代码省略)\n}\n\n\nclass NumberObj {\n  count: number\n}\nfunction addObj(first: object | NumberObj, second: object | NumberObj) { // 联合类型\n  if (first instanceof NumberObj && second instanceof NumberObj) { // 类型保护\n    return first.count + second.count;\n  }\n  return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 枚举\n\n// Enum枚举类型   (个人理解枚举：约定一组可选的常量。 使用常量名表示某个值的含义，增强可读性。)\n\n// js写法\n// const Status = {\n//   MASSAGE: 0,\n//   SPA: 1,\n//   DABAOJIAN: 2\n// }\n\n// ts写法\nenum Status {\n  MASSAGE,  // 如果想从1开始，给MASSAGE = 1, 即可\n  SPA,\n  DABAOJIAN\n} // 默认赋值 0 、1、2\n\nconsole.log(Status.MASSAGE, Status[0]) // 0, MASSAGE  可以通过下标反查\n\nfunction getStatus(status: any) {\n  if (status === Status.MASSAGE) {\n    return 'massage'\n  } else if (status === Status.SPA) {\n    return 'spa'\n  } else if (status === Status.DABAOJIAN) {\n    return 'dabaojian'\n  }\n}\n\nconst result = getStatus(Status.SPA)\nconsole.log(result)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 泛型\n\n泛型，最简单的理解：泛指的类型。（类似函数中的形参与实参）\n\n\n# 函数中的泛型使用\n\n\n// function join(first: string | number, second: string | number) {\n//   return `${first}${second}`\n// }\n// join('jspang', 1); // 如果我想第一个参数是字符串，第二个也必须是字符串，这么就用到泛型\n\n\n// 泛型使用，如同定义形参，在调用时指定类型\nfunction join<JSPang>(first: JSPang, second: JSPang) {\n  return `${first}${second}`\n}\n\njoin<string>('jspang', '123');\njoin<number>(11, 22);\n\n// 泛型中数组的使用\nfunction myFun<ANY>(params:ANY[]) { // ANY[] or Array<ANY>\n  return params\n}\nmyFun<string>(['a', 'b'])\n\n\n// 两个类型参数的使用（工作中，常用T表示泛型）\nfunction join2<T,P>(first: T, second: P) {\n  return `${first}${second}`\n}\n\njoin2<string,number>('jspang', 123);\njoin2<number, string>(11, '22');\njoin2(11, '22'); // 泛型也支持类型推断 （鼠标移到函数名有提示）\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# class类中使用泛型\n\n// class SelectGirl {\n//   constructor(private girls: string[] | number[]) { } // private 私有的参数，外部无法修改\n//   getGirl(index: number): string | number {\n//     return this.girls[index]\n//   }\n// }\n\n// 使用泛型\nclass SelectGirl<T> {   // 泛型的约束: <T extends number | string>\n  constructor(private girls: T[]) { } // private 私有的参数，外部无法修改\n  getGirl(index: number): T {\n    return this.girls[index]\n  }\n}\n\n// const selectGirl = new SelectGirl<string>(['大脚', 'xiaohong', 'xiaobai'])\nconst selectGirl = new SelectGirl<number>([101, 102, 103])\nconsole.log(selectGirl.getGirl(1))\n\n\n// 泛型中的继承\ninterface Girl {\n  name: string\n}\nclass SelectGirl2<T extends Girl> { // 泛型T中必须有一个name属性，继承自Girl接口\n  constructor(private girls: T[]) { } // private 私有的参数，外部无法修改\n  getGirl(index: number): string {\n    return this.girls[index].name\n  }\n}\n\nconst selectGirl2 = new SelectGirl2([\n  {name: '大脚1'},\n  {name: '大脚2'},\n  {name: '大脚3'}\n])\n\nconsole.log(selectGirl2.getGirl(1))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 配置文件tsconfig.json\n\n// 此文件由命令 tsc -init 生成\n// 直接运行 tsc 命令就会运用此配置文件\n// 选项详解：https://www.tslang.cn/docs/handbook/compiler-options.html\n{\n  // \"include\": [\"demo15-1.ts\"],              // 要编译的指定文件，不配置此项时运行tsc默认编译全部\n  // \"files\": [\"demo15-1.ts\"],                // 和include类似\n  // \"exclude\": [\"demo15-3.ts\"],              // 要排除编译的指定文件\n  \"compilerOptions\": { // 编译选项\n    /* 基本选项 */\n    // \"incremental\": true,                   /* 启用增量编译 */\n    \"target\": \"es5\",                          /* 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019' or 'ESNEXT'. */\n    \"module\": \"commonjs\",                     /* 指定模块代码生成: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */\n    // \"lib\": [],                             /* 指定要包含在编译中的库文件. */\n    // \"allowJs\": true,                       /* 允许编译javascript文件*/\n    // \"checkJs\": true,                       /* 报告.js文件中的错误。 */\n    // \"jsx\": \"preserve\",                     /* 指定 JSX代码生成: 'preserve', 'react-native', or 'react'. */\n    // \"declaration\": true,                   /* 生成相应的 .d.ts文件 */\n    // \"declarationMap\": true,                /* 为每个相应的 .d.ts文件生成一个sourcemap (编译后代码对源码的映射)*/\n    \"sourceMap\": true,                        /* 生成源文件与输出文件的映射关系文件(.map)。*/\n    // \"outFile\": \"./\",                       /* 将输出文件合并为一个文件. */\n    \"outDir\": \"./build\",                      /* 输出的js文件目录。 */\n    \"rootDir\": \"./src\",                       /* ts源文件目录。 */\n    // \"composite\": true,                     /* 启用 项目编译 */\n    // \"tsBuildInfoFile\": \"./\",               /* 指定用于存储增量编译信息的文件 */\n    // \"removeComments\": true,                /* 不输出注释到编译结果.（删除所有注释，除了以 /!*开头的版权信息。） */\n    // \"noEmit\": true,                        /* 不发出输出.Do not emit outputs. */\n    // \"importHelpers\": true,                 /* 从“tslib”导入发出助手. Import emit helpers from 'tslib'. */\n    // \"downlevelIteration\": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */\n    // \"isolatedModules\": true,               /* 将每个文件作为单独的模块（与“ts.transpileModule”类似） */\n\n    /* 严格的类型检查选项 */\n    \"strict\": true,                           /* 启用所有严格类型检查选项。 打开此选项后，下面这些选项就不需要单独设置*/\n    // \"noImplicitAny\": true,                 /* 对隐含的“any”类型的表达式和声明引发错误. (为false时允许any不用特意声明)*/\n    // \"strictNullChecks\": true,              /* 启用严格的null检查. (为false时允许赋值为null)*/\n    // \"strictFunctionTypes\": true,           /* 启用严格检查函数类型. */\n    // \"strictBindCallApply\": true,           /* 启用函数上严格的“bind”、“call”和“apply”方法. */\n    // \"strictPropertyInitialization\": true,  /* 启用 严格检查类中的属性初始化. */\n    // \"noImplicitThis\": true,                /* 在隐含的“any”类型的“this”表达式上引发错误。 */\n    // \"alwaysStrict\": true,                  /* 以严格模式解析并为每个源文件发出“use strict”。 */\n\n    /* 附加检查。Additional Checks  */\n    // \"noUnusedLocals\": true,                /* 若有未使用的局部变量则抛错 */\n    // \"noUnusedParameters\": true,            /* 若有未使用的参数则抛错。 */\n    // \"noImplicitReturns\": true,             /* 不是函数的所有返回路径都有返回值时报错。*/\n    // \"noFallthroughCasesInSwitch\": true,    /* 报告switch语句的fallthrough错误。（即，不允许switch的case语句贯穿） */\n\n    /* 模块解析选项 */\n    // \"moduleResolution\": \"node\",            /* 决定如何处理模块：'node' (Node.js) or 'classic' (TypeScript pre-1.6). */\n    // \"baseUrl\": \"./\",                       /* 用于解析非绝对模块名称的基础目录。 */\n    // \"paths\": {},                           /* 模块名到基于 baseUrl的路径映射的列表。 */\n    // \"rootDirs\": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */\n    // \"typeRoots\": [],                       /* List of folders to include type definitions from. */\n    // \"types\": [],                           /* 要包含的类型声明文件名列表 */\n    // \"allowSyntheticDefaultImports\": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */\n    \"esModuleInterop\": true                   /* 启用s emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */\n    // \"preserveSymlinks\": true,              /* Do not resolve the real path of symlinks. */\n    // \"allowUmdGlobalAccess\": true,          /* Allow accessing UMD globals from modules. */\n\n    /* Source Map Options */\n    // \"sourceRoot\": \"\",                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */\n    // \"mapRoot\": \"\",                         /* Specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlineSourceMap\": true,               /* Emit a single file with source maps instead of having a separate file. */\n    // \"inlineSources\": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */\n\n    /* Experimental Options */\n    // \"experimentalDecorators\": true,        /* 启用s experimental support for ES7 decorators. */\n    // \"emitDecoratorMetadata\": true,         /* 启用s experimental support for emitting type metadata for decorators. */\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n",normalizedContent:"# typescript 学习笔记\n\ntypescript 的类型校验是给程序员看的，在编译后不会存在ts代码。\n\n\n# 类型注解\n\nfunction fn(person: string):void{ // 参数类型是字符串，没有返回值\n    ///...\n}\nfn('str') // 如传递参数非字符串，vscode编辑器中或在编译时将给出错误提示\n\nconst test:number = 1\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 有哪些基础类型注解？\n\n// 基础类型\n:string\n:number\n:boolean\n\n:null  // 只能是null值\n:undefined // 只能是undefined值\n\n:symbol\n\n// 引用类型\n:object // 不常用，多使用接口来给对象进行类型注解\n\n// 其他\n:any  // 任意类型\n:void  // 空，用于函数的无返回值的注解\n:never // 用于标注函数代码永远执行不完（如抛出错误的函数，死循环函数）\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 什么是类型注解和类型推断、类型断言？\n\n类型注解 是显式的标注类型\n\n类型推断 是编辑器根据值来自动推断出类型 (编辑器中鼠标移到变量会显示类型的提示)。\n\n类型断言 是告诉编译器，“相信我，它就是这个类型”。\n\n// 类型注解就是显式的写出类型\nconst mynumber: number = 123\n\n// 类型推断是根据值来推断类型 (鼠标移到变量会显示类型(或直接显示值)的提示)\nconst mystring = 'test'\n\n// 类型断言（开发者明确知道是什么类型）\nconst somevalue:any = 'abc'\nconst strlength:number = (somevalue as string).length // 断言somevalue是字符串类型\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 对象的类型\n\n// 对象字面量的类型检查\nconst xiaojiejie: {\n  name: string,\n  age: number\n} = {\n  name: '小红',\n  age: 18\n}\n\n// 标注:object\nconst obj:object = {}\n\n// 使用接口\ninterface person{\n    name: string\n    age: number\n}\nconst xjj: person = {\n    name: 'xh',\n    age: 18\n}\n\n// class类的类型检查\nclass parson { }\nconst xiaobai: parson = new parson()\n\n// 函数和返回值的类型检查\nconst fn: ()=> string = () => '123'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 函数的类型注解\n\n// 函数返回值的类型注解 fn(): number {}\nfunction gettotal2(one: number, two: number): number {\n  return one + two\n}\ngettotal2(1,2)\n\n\n// 无返回值: void\nfunction sayhello(): void {\n  console.log(\"hello\")\n}\n\n// 永远执行不玩的函数\nfunction settimer():never {\n  throw new error()\n  console.log(123)\n}\n\n// 参数是对象时的注解 （也可以用接口）\nfunction add({ one, two }: {one: number, two: number}) {\n  return  one + two\n}\n\nconst total = add({one: 1, two: 2})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 数组的类型注解\n\nconst numberarr: number[] = [1, 2, 3]\nconst stringarr: string[] = ['a', 'b']\nconst undefinedarr: undefined[] = [undefined, undefined]\nconst arr: (number | string | boolean)[] = [1, 'a', true, false] // 用到联合类型\n\n// 类型别名 type alias\ntype lady = { name: string, age: number }\n\nconst xiaojj: lady[] = [\n  {\n    name: 'xiaojj',\n    age: 90\n  },\n  {\n    name: 'j',\n    age: 30\n  }\n]\n\n// 或用类的方式\nclass ady2 {\n  name: string;\n  age: number;\n}\n\nconst xiaojj2: ady2[] = [\n  {\n    name: 'xiaojj',\n    age: 90\n  },\n  {\n    name: 'j',\n    age: 30\n  }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 元组\n\n元组，可以理解为：已知元素数量和类型的数组\n\n// 联合类型\nconst xjj:(string | number)[] = ['a',22,'b'] // 规定整个数组当中可以有string或number\n\n// 元组注解 注意这里的注解只有一个中括号\nconst xjj1: [string, number, number] = ['a', 22, 33] // 规定了数组每个元素对应位置的类型\n\n// note: 在开发中元祖的使用在相对少\n\n\n// csv的方式定义数据格式； （二维数组时需要多加一个中括号）\nconst xjj2: [string, number, number][] = [\n  ['a', 22, 33],\n  ['a', 22, 33]\n]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 接口\n\n接口，可以理解为对象属性的类型描述。和类型别名类似，不同的是 接口必须是一个对象，而别名可以直接是一个类型，如type girl = string\n\ninterface girl { // 接口 （理解：对象属性的类型描述）\n  readonly name: string; // 只读属性 （定义之后不能再修改）\n  age: number;\n  waistline?: number; // 加个问号表示是可选值\n  [propname: string]: any; // 表示可以有不限制属性名的属性，但属性名需要是字符串，值可以是任意类型\n  say(): string; // 函数类型，返回值是string (如无返回值时是 void)。  say()也可以加入参数类型检查，如say(p:number)\n}\n// 和类型别名类似，不同的是 接口必须是一个对象，而别名可以直接是一个类型，如 type girl = string\n\n// 接口的继承\ninterface teacher extends girl {\n  teach(): string;\n}\n\n\nconst girl = {\n  name: '大脚',\n  age: 18,\n  sex: '女',\n  say() {\n    return '欢迎光临'\n  },\n  teach() {\n    return '教'\n  }\n}\n\n\nconst screenresume = ({ name, age, bust, sex }: girl) => {\n  console.log(name, age, bust, sex)\n}\nconst getresume = ({ name, age, bust, teach}: teacher) => {\n  teach();\n  console.log(name, age, bust)\n}\nscreenresume(girl)\ngetresume(girl)\n\n\n// 接口在class类中的使用\nclass xiaojjj implements girl {\n  name = \"xiaojj\"\n  age = 18\n  bust = 98\n  sex = '女'\n  say() {\n    return '欢迎光临'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n可索引的类型\n\ninterface arr {\n    [index: number]:string   // 表示通过索引访问数据时返回的类型是string\n}\n\nconst myarr:arr = ['1','2','3']\nconst mystr:string = myarr[1]\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# es6 class类中应用ts\n\n\n# class类的修饰器\n\n// 类的修饰器：\n// public (公共) 允许内外部使用\n// protected (受保护的) 允许在内部和继承内使用\n// private (私有) 允许在内部使用，但不能在继承中使用\n\n// 类的内部和外部，{}内属于内部，外面是外部\nclass person {\n   // public 内外都可以使用，可省略，不写时默认public。 protected只允许内部使用\n  name: string // 这里的string注释是ts使用的\n  private age: 18\n  public sayhello() {\n    console.log(this.name + this.age + 'say hello')\n  }\n}\n\nclass teacher2 extends person {\n  public saybye() {\n    console.log(this.name + ' say bye') // protected 可以在继承中使用到\n  }\n}\n\nconst person = new person();\nperson.name = 'test' // 在类的外部定义\nconsole.log(person.name)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# class类的构造函数中使用类型校验\n\nclass person2 {\n  constructor(public name: string) {\n    this.name = name\n  }\n}\n\nclass teacher3 extends person2{\n  constructor(public age: number) {\n    super('test-name') // 这里传的值是给person2的构造函数。即使父类没有构造函数，子类的构造函数内也要写super()\n  }\n}\nconst teacher3 = new teacher3(18)\nconsole.log(teacher3.name)\nconsole.log(teacher3.age)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# class类的getter、setter和static\n\nclass xjj {\n  constructor(private _age: number) { }\n  get age() {\n    return this._age - 10;\n  }  // 访问器属性，以属性的形式访问age，并可以对属性进行包装\n  set age(age: number) {\n    this._age = age+3;\n   }\n}\n\nconst dj = new xjj(28);\ndj.age = 25\n\nconsole.log(dj.age)\n\n\n// 静态属性 static。  静态属性指不需要通过实例化，直接通过girl.prop的方式就可以访问到属性\nclass girl {\n  static saylove() {\n    return 'i love you'\n  }\n}\n\n// const girl = new girl()\nconsole.log(girl.saylove())\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# class类的只读属性\n\n// 只读属性\nclass person {\n  public readonly _name: string // 只读属性\n  constructor(name: string) {\n    this._name = name;\n  }\n}\n\nconst person = new person('testname');\n// person._name = '222'; // 不能修改只读属性\nconsole.log(person._name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 抽象类\n\n/ 抽象类\nabstract class girls {\n  abstract skill(); // 注意这里只是定义抽象方法，而不具有方法的实现\n}\n\nclass waiter extends girls{ // 继承了抽象类之后要 实现抽象类内的成员\n  skill() {\n    console.log('大爷1')\n  }\n}\n\nclass baseteacher extends girls{\n  skill() {\n    console.log('大爷2')\n  }\n}\n\nclass seniorteacher extends girls{\n  skill() {\n    console.log('大爷3')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 联合类型和类型保护\n\n联合类型 指某个参数可以是多种类型。\n\n类型保护 指参数属于某个类型才有相应的操作。\n\ninterface waiter {\n  anjiao: boolean\n  say: () => {}\n}\n\ninterface teacher {\n  anjiao: boolean\n  skill: () => {}\n}\n\nfunction judgewho(animal: (waiter | teacher)) { // 联合类型\n  // 第一种断言方法\n  if (animal.anjiao) {\n    // (animal as teacher) 的意思是：断言 animal 是 teacher类型\n    (animal as teacher).skill()\n  } else {\n    (animal as waiter).say()\n  }\n\n  // 第二种断言方法\n  if ('skill' in animal) {\n    animal.skill()\n  } else {\n    animal.say()\n  }\n\n  // 第三种类型保护方法是使用typeof来判断 (代码省略)\n}\n\n\nclass numberobj {\n  count: number\n}\nfunction addobj(first: object | numberobj, second: object | numberobj) { // 联合类型\n  if (first instanceof numberobj && second instanceof numberobj) { // 类型保护\n    return first.count + second.count;\n  }\n  return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 枚举\n\n// enum枚举类型   (个人理解枚举：约定一组可选的常量。 使用常量名表示某个值的含义，增强可读性。)\n\n// js写法\n// const status = {\n//   massage: 0,\n//   spa: 1,\n//   dabaojian: 2\n// }\n\n// ts写法\nenum status {\n  massage,  // 如果想从1开始，给massage = 1, 即可\n  spa,\n  dabaojian\n} // 默认赋值 0 、1、2\n\nconsole.log(status.massage, status[0]) // 0, massage  可以通过下标反查\n\nfunction getstatus(status: any) {\n  if (status === status.massage) {\n    return 'massage'\n  } else if (status === status.spa) {\n    return 'spa'\n  } else if (status === status.dabaojian) {\n    return 'dabaojian'\n  }\n}\n\nconst result = getstatus(status.spa)\nconsole.log(result)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 泛型\n\n泛型，最简单的理解：泛指的类型。（类似函数中的形参与实参）\n\n\n# 函数中的泛型使用\n\n\n// function join(first: string | number, second: string | number) {\n//   return `${first}${second}`\n// }\n// join('jspang', 1); // 如果我想第一个参数是字符串，第二个也必须是字符串，这么就用到泛型\n\n\n// 泛型使用，如同定义形参，在调用时指定类型\nfunction join<jspang>(first: jspang, second: jspang) {\n  return `${first}${second}`\n}\n\njoin<string>('jspang', '123');\njoin<number>(11, 22);\n\n// 泛型中数组的使用\nfunction myfun<any>(params:any[]) { // any[] or array<any>\n  return params\n}\nmyfun<string>(['a', 'b'])\n\n\n// 两个类型参数的使用（工作中，常用t表示泛型）\nfunction join2<t,p>(first: t, second: p) {\n  return `${first}${second}`\n}\n\njoin2<string,number>('jspang', 123);\njoin2<number, string>(11, '22');\njoin2(11, '22'); // 泛型也支持类型推断 （鼠标移到函数名有提示）\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# class类中使用泛型\n\n// class selectgirl {\n//   constructor(private girls: string[] | number[]) { } // private 私有的参数，外部无法修改\n//   getgirl(index: number): string | number {\n//     return this.girls[index]\n//   }\n// }\n\n// 使用泛型\nclass selectgirl<t> {   // 泛型的约束: <t extends number | string>\n  constructor(private girls: t[]) { } // private 私有的参数，外部无法修改\n  getgirl(index: number): t {\n    return this.girls[index]\n  }\n}\n\n// const selectgirl = new selectgirl<string>(['大脚', 'xiaohong', 'xiaobai'])\nconst selectgirl = new selectgirl<number>([101, 102, 103])\nconsole.log(selectgirl.getgirl(1))\n\n\n// 泛型中的继承\ninterface girl {\n  name: string\n}\nclass selectgirl2<t extends girl> { // 泛型t中必须有一个name属性，继承自girl接口\n  constructor(private girls: t[]) { } // private 私有的参数，外部无法修改\n  getgirl(index: number): string {\n    return this.girls[index].name\n  }\n}\n\nconst selectgirl2 = new selectgirl2([\n  {name: '大脚1'},\n  {name: '大脚2'},\n  {name: '大脚3'}\n])\n\nconsole.log(selectgirl2.getgirl(1))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 配置文件tsconfig.json\n\n// 此文件由命令 tsc -init 生成\n// 直接运行 tsc 命令就会运用此配置文件\n// 选项详解：https://www.tslang.cn/docs/handbook/compiler-options.html\n{\n  // \"include\": [\"demo15-1.ts\"],              // 要编译的指定文件，不配置此项时运行tsc默认编译全部\n  // \"files\": [\"demo15-1.ts\"],                // 和include类似\n  // \"exclude\": [\"demo15-3.ts\"],              // 要排除编译的指定文件\n  \"compileroptions\": { // 编译选项\n    /* 基本选项 */\n    // \"incremental\": true,                   /* 启用增量编译 */\n    \"target\": \"es5\",                          /* 指定 ecmascript 目标版本: 'es3' (default), 'es5', 'es2015', 'es2016', 'es2017', 'es2018', 'es2019' or 'esnext'. */\n    \"module\": \"commonjs\",                     /* 指定模块代码生成: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'esnext'. */\n    // \"lib\": [],                             /* 指定要包含在编译中的库文件. */\n    // \"allowjs\": true,                       /* 允许编译javascript文件*/\n    // \"checkjs\": true,                       /* 报告.js文件中的错误。 */\n    // \"jsx\": \"preserve\",                     /* 指定 jsx代码生成: 'preserve', 'react-native', or 'react'. */\n    // \"declaration\": true,                   /* 生成相应的 .d.ts文件 */\n    // \"declarationmap\": true,                /* 为每个相应的 .d.ts文件生成一个sourcemap (编译后代码对源码的映射)*/\n    \"sourcemap\": true,                        /* 生成源文件与输出文件的映射关系文件(.map)。*/\n    // \"outfile\": \"./\",                       /* 将输出文件合并为一个文件. */\n    \"outdir\": \"./build\",                      /* 输出的js文件目录。 */\n    \"rootdir\": \"./src\",                       /* ts源文件目录。 */\n    // \"composite\": true,                     /* 启用 项目编译 */\n    // \"tsbuildinfofile\": \"./\",               /* 指定用于存储增量编译信息的文件 */\n    // \"removecomments\": true,                /* 不输出注释到编译结果.（删除所有注释，除了以 /!*开头的版权信息。） */\n    // \"noemit\": true,                        /* 不发出输出.do not emit outputs. */\n    // \"importhelpers\": true,                 /* 从“tslib”导入发出助手. import emit helpers from 'tslib'. */\n    // \"downleveliteration\": true,            /* provide full support for iterables in 'for-of', spread, and destructuring when targeting 'es5' or 'es3'. */\n    // \"isolatedmodules\": true,               /* 将每个文件作为单独的模块（与“ts.transpilemodule”类似） */\n\n    /* 严格的类型检查选项 */\n    \"strict\": true,                           /* 启用所有严格类型检查选项。 打开此选项后，下面这些选项就不需要单独设置*/\n    // \"noimplicitany\": true,                 /* 对隐含的“any”类型的表达式和声明引发错误. (为false时允许any不用特意声明)*/\n    // \"strictnullchecks\": true,              /* 启用严格的null检查. (为false时允许赋值为null)*/\n    // \"strictfunctiontypes\": true,           /* 启用严格检查函数类型. */\n    // \"strictbindcallapply\": true,           /* 启用函数上严格的“bind”、“call”和“apply”方法. */\n    // \"strictpropertyinitialization\": true,  /* 启用 严格检查类中的属性初始化. */\n    // \"noimplicitthis\": true,                /* 在隐含的“any”类型的“this”表达式上引发错误。 */\n    // \"alwaysstrict\": true,                  /* 以严格模式解析并为每个源文件发出“use strict”。 */\n\n    /* 附加检查。additional checks  */\n    // \"nounusedlocals\": true,                /* 若有未使用的局部变量则抛错 */\n    // \"nounusedparameters\": true,            /* 若有未使用的参数则抛错。 */\n    // \"noimplicitreturns\": true,             /* 不是函数的所有返回路径都有返回值时报错。*/\n    // \"nofallthroughcasesinswitch\": true,    /* 报告switch语句的fallthrough错误。（即，不允许switch的case语句贯穿） */\n\n    /* 模块解析选项 */\n    // \"moduleresolution\": \"node\",            /* 决定如何处理模块：'node' (node.js) or 'classic' (typescript pre-1.6). */\n    // \"baseurl\": \"./\",                       /* 用于解析非绝对模块名称的基础目录。 */\n    // \"paths\": {},                           /* 模块名到基于 baseurl的路径映射的列表。 */\n    // \"rootdirs\": [],                        /* list of root folders whose combined content represents the structure of the project at runtime. */\n    // \"typeroots\": [],                       /* list of folders to include type definitions from. */\n    // \"types\": [],                           /* 要包含的类型声明文件名列表 */\n    // \"allowsyntheticdefaultimports\": true,  /* allow default imports from modules with no default export. this does not affect code emit, just typechecking. */\n    \"esmoduleinterop\": true                   /* 启用s emit interoperability between commonjs and es modules via creation of namespace objects for all imports. implies 'allowsyntheticdefaultimports'. */\n    // \"preservesymlinks\": true,              /* do not resolve the real path of symlinks. */\n    // \"allowumdglobalaccess\": true,          /* allow accessing umd globals from modules. */\n\n    /* source map options */\n    // \"sourceroot\": \"\",                      /* specify the location where debugger should locate typescript files instead of source locations. */\n    // \"maproot\": \"\",                         /* specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlinesourcemap\": true,               /* emit a single file with source maps instead of having a separate file. */\n    // \"inlinesources\": true,                 /* emit the source alongside the sourcemaps within a single file; requires '--inlinesourcemap' or '--sourcemap' to be set. */\n\n    /* experimental options */\n    // \"experimentaldecorators\": true,        /* 启用s experimental support for es7 decorators. */\n    // \"emitdecoratormetadata\": true,         /* 启用s experimental support for emitting type metadata for decorators. */\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"ABP故障诊断系统开发文档",frontmatter:{title:"ABP故障诊断系统开发文档",date:"2022-03-27T21:31:48.000Z",permalink:"/pages/196903/",categories:["前端","开发文档"],tags:["Angular","开发文档"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/40.%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/00.ABP%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3.html",relativePath:"01.前端/40.开发文档/00.ABP故障诊断系统开发文档.md",key:"v-495f2cc9",path:"/pages/196903/",headers:[{level:2,title:"1 项目基础内容",slug:"_1-项目基础内容",normalizedTitle:"1 项目基础内容",charIndex:665},{level:3,title:"1.1 启动项目",slug:"_1-1-启动项目",normalizedTitle:"1.1 启动项目",charIndex:678},{level:4,title:"1.1.1 项目模板下载",slug:"_1-1-1-项目模板下载",normalizedTitle:"1.1.1 项目模板下载",charIndex:690},{level:4,title:"1.1.2 项目配置修改",slug:"_1-1-2-项目配置修改",normalizedTitle:"1.1.2 项目配置修改",charIndex:924},{level:3,title:"1.2 项目目录介绍",slug:"_1-2-项目目录介绍",normalizedTitle:"1.2 项目目录介绍",charIndex:1956},{level:4,title:"1.2.1 前端项目目录介绍",slug:"_1-2-1-前端项目目录介绍",normalizedTitle:"1.2.1 前端项目目录介绍",charIndex:1970},{level:4,title:"1.2.2 后端项目目录介绍",slug:"_1-2-2-后端项目目录介绍",normalizedTitle:"1.2.2 后端项目目录介绍",charIndex:2682},{level:5,title:"C#",slug:"c",normalizedTitle:"c#",charIndex:523},{level:3,title:"1.3 项目需求分析",slug:"_1-3-项目需求分析",normalizedTitle:"1.3 项目需求分析",charIndex:3079},{level:4,title:"1.3.1 前端项目需求",slug:"_1-3-1-前端项目需求",normalizedTitle:"1.3.1 前端项目需求",charIndex:3093},{level:4,title:"1.3.2 后端项目需求",slug:"_1-3-2-后端项目需求",normalizedTitle:"1.3.2 后端项目需求",charIndex:3334},{level:3,title:"1.4 UI设计",slug:"_1-4-ui设计",normalizedTitle:"1.4 ui设计",charIndex:3399},{level:4,title:"1.4.1 页面分配",slug:"_1-4-1-页面分配",normalizedTitle:"1.4.1 页面分配",charIndex:3500},{level:5,title:"风格确定",slug:"风格确定",normalizedTitle:"风格确定",charIndex:3606},{level:5,title:"具体页面参考",slug:"具体页面参考",normalizedTitle:"具体页面参考",charIndex:3682},{level:5,title:"页面设计",slug:"页面设计",normalizedTitle:"页面设计",charIndex:3864},{level:5,title:"主题颜色",slug:"主题颜色",normalizedTitle:"主题颜色",charIndex:4147},{level:2,title:"2 Angular页面开发基础",slug:"_2-angular页面开发基础",normalizedTitle:"2 angular页面开发基础",charIndex:4482},{level:3,title:"2.1 监测主界面生成",slug:"_2-1-监测主界面生成",normalizedTitle:"2.1 监测主界面生成",charIndex:4502},{level:4,title:"2.1.1 Angular页面包含内容",slug:"_2-1-1-angular页面包含内容",normalizedTitle:"2.1.1 angular页面包含内容",charIndex:4559},{level:4,title:"2.1.2Angular Cli生成命令",slug:"_2-1-2angular-cli生成命令",normalizedTitle:"2.1.2angular cli生成命令",charIndex:4735},{level:5,title:"生成dashboard.module.ts文件",slug:"生成dashboard-module-ts文件",normalizedTitle:"生成dashboard.module.ts文件",charIndex:4759},{level:5,title:"生成dashboard.component的三个文件",slug:"生成dashboard-component的三个文件",normalizedTitle:"生成dashboard.component的三个文件",charIndex:4904},{level:5,title:"生成dashboard-routing.module.ts文件",slug:"生成dashboard-routing-module-ts文件",normalizedTitle:"生成dashboard-routing.module.ts文件",charIndex:5098},{level:4,title:"2.1.3 angular各文件之间的依赖、引入、声明补充",slug:"_2-1-3-angular各文件之间的依赖、引入、声明补充",normalizedTitle:"2.1.3 angular各文件之间的依赖、引入、声明补充",charIndex:5228},{level:5,title:"dashboard.module.ts",slug:"dashboard-module-ts",normalizedTitle:"dashboard.module.ts",charIndex:4761},{level:5,title:"dashboard-routing.module.ts",slug:"dashboard-routing-module-ts",normalizedTitle:"dashboard-routing.module.ts",charIndex:5100},{level:5,title:"app.module.ts",slug:"app-module-ts",normalizedTitle:"app.module.ts",charIndex:6061},{level:5,title:"app-routing.module.ts",slug:"app-routing-module-ts",normalizedTitle:"app-routing.module.ts",charIndex:6191},{level:5,title:"route.provider.ts",slug:"route-provider-ts",normalizedTitle:"route.provider.ts",charIndex:2313},{level:3,title:"2.2 页面尺寸响应式基础",slug:"_2-2-页面尺寸响应式基础",normalizedTitle:"2.2 页面尺寸响应式基础",charIndex:6674},{level:3,title:"2.3 引入ui库",slug:"_2-3-引入ui库",normalizedTitle:"2.3 引入ui库",charIndex:7316},{level:4,title:"2.3.1 安装NG-ZORRO",slug:"_2-3-1-安装ng-zorro",normalizedTitle:"2.3.1 安装ng-zorro",charIndex:7527},{level:4,title:"2.3.2 全局配置",slug:"_2-3-2-全局配置",normalizedTitle:"2.3.2 全局配置",charIndex:7614},{level:4,title:"2.3.3 模块配置",slug:"_2-3-3-模块配置",normalizedTitle:"2.3.3 模块配置",charIndex:7725},{level:4,title:"2.3.4 自定义主题",slug:"_2-3-4-自定义主题",normalizedTitle:"2.3.4 自定义主题",charIndex:8248},{level:2,title:"3 登录页面开发",slug:"_3-登录页面开发",normalizedTitle:"3 登录页面开发",charIndex:8690},{level:3,title:"3.1 登录页面布局开发",slug:"_3-1-登录页面布局开发",normalizedTitle:"3.1 登录页面布局开发",charIndex:8703},{level:4,title:"3.1.1 登录页面模块划分",slug:"_3-1-1-登录页面模块划分",normalizedTitle:"3.1.1 登录页面模块划分",charIndex:8719},{level:4,title:"3.1.2 登录页面生成",slug:"_3-1-2-登录页面生成",normalizedTitle:"3.1.2 登录页面生成",charIndex:8916},{level:4,title:"3.1.3 loginlayout组件开发",slug:"_3-1-3-loginlayout组件开发",normalizedTitle:"3.1.3 loginlayout组件开发",charIndex:8968},{level:5,title:"整体布局",slug:"整体布局",normalizedTitle:"整体布局",charIndex:8895},{level:5,title:"图片翻转",slug:"图片翻转",normalizedTitle:"图片翻转",charIndex:9022},{level:4,title:"3.2.4 login-form组件开发",slug:"_3-2-4-login-form组件开发",normalizedTitle:"3.2.4 login-form组件开发",charIndex:11756},{level:5,title:"表单",slug:"表单",normalizedTitle:"表单",charIndex:4382},{level:5,title:"修改ui库样式",slug:"修改ui库样式",normalizedTitle:"修改ui库样式",charIndex:4367},{level:5,title:"伪类选择器添加图形",slug:"伪类选择器添加图形",normalizedTitle:"伪类选择器添加图形",charIndex:13302},{level:4,title:"3.2.5 sign-up-form组件",slug:"_3-2-5-sign-up-form组件",normalizedTitle:"3.2.5 sign-up-form组件",charIndex:13507},{level:4,title:"3.2.6 reset-modal组件",slug:"_3-2-6-reset-modal组件",normalizedTitle:"3.2.6 reset-modal组件",charIndex:13603},{level:3,title:"3.2 登录页面业务逻辑",slug:"_3-2-登录页面业务逻辑",normalizedTitle:"3.2 登录页面业务逻辑",charIndex:13740},{level:4,title:"3.2.1 打开重置密码弹窗",slug:"_3-2-1-打开重置密码弹窗",normalizedTitle:"3.2.1 打开重置密码弹窗",charIndex:13756},{level:4,title:"3.2.2 确定表单内容",slug:"_3-2-2-确定表单内容",normalizedTitle:"3.2.2 确定表单内容",charIndex:14572},{level:4,title:"3.2.3 表单验证逻辑",slug:"_3-2-3-表单验证逻辑",normalizedTitle:"3.2.3 表单验证逻辑",charIndex:14722},{level:5,title:"angular自带的表单验证",slug:"angular自带的表单验证",normalizedTitle:"angular自带的表单验证",charIndex:14738},{level:5,title:"自定义的表单验证",slug:"自定义的表单验证",normalizedTitle:"自定义的表单验证",charIndex:15270},{level:4,title:"3.2.4 表单提交逻辑",slug:"_3-2-4-表单提交逻辑",normalizedTitle:"3.2.4 表单提交逻辑",charIndex:16097},{level:5,title:"表单数据回收",slug:"表单数据回收",normalizedTitle:"表单数据回收",charIndex:16113},{level:5,title:"数据提交与返回状态处理",slug:"数据提交与返回状态处理",normalizedTitle:"数据提交与返回状态处理",charIndex:16411},{level:4,title:"3.2.5 提示信息服务",slug:"_3-2-5-提示信息服务",normalizedTitle:"3.2.5 提示信息服务",charIndex:17306},{level:4,title:"3.2.6 登录获取保存token",slug:"_3-2-6-登录获取保存token",normalizedTitle:"3.2.6 登录获取保存token",charIndex:17886},{level:2,title:"4 导航栏与主界面布局开发",slug:"_4-导航栏与主界面布局开发",normalizedTitle:"4 导航栏与主界面布局开发",charIndex:19152},{level:3,title:"4.1 导航栏开发",slug:"_4-1-导航栏开发",normalizedTitle:"4.1 导航栏开发",charIndex:19208},{level:4,title:"4.1.1 导航栏布局开发",slug:"_4-1-1-导航栏布局开发",normalizedTitle:"4.1.1 导航栏布局开发",charIndex:19221},{level:4,title:"4.1.2 导航栏名称区开发",slug:"_4-1-2-导航栏名称区开发",normalizedTitle:"4.1.2 导航栏名称区开发",charIndex:19370},{level:4,title:"4.1.3 导航栏路由区开发",slug:"_4-1-3-导航栏路由区开发",normalizedTitle:"4.1.3 导航栏路由区开发",charIndex:19466},{level:4,title:"4.1.4 导航栏菜单区开发",slug:"_4-1-4-导航栏菜单区开发",normalizedTitle:"4.1.4 导航栏菜单区开发",charIndex:19569},{level:3,title:"4.2 主界面布局开发",slug:"_4-2-主界面布局开发",normalizedTitle:"4.2 主界面布局开发",charIndex:19636},{level:4,title:"4.2.1 左侧特殊显示区",slug:"_4-2-1-左侧特殊显示区",normalizedTitle:"4.2.1 左侧特殊显示区",charIndex:19782},{level:5,title:"传感器仪表盘",slug:"传感器仪表盘",normalizedTitle:"传感器仪表盘",charIndex:19810},{level:5,title:"统计饼图",slug:"统计饼图",normalizedTitle:"统计饼图",charIndex:19831},{level:5,title:"文字显示区",slug:"文字显示区",normalizedTitle:"文字显示区",charIndex:19847},{level:4,title:"4.2.2 中间主体显示区",slug:"_4-2-2-中间主体显示区",normalizedTitle:"4.2.2 中间主体显示区",charIndex:20216},{level:4,title:"4.2.3 右侧多功能区",slug:"_4-2-3-右侧多功能区",normalizedTitle:"4.2.3 右侧多功能区",charIndex:20414},{level:5,title:"全部传感器信息",slug:"全部传感器信息",normalizedTitle:"全部传感器信息",charIndex:20503},{level:5,title:"单个传感器信息",slug:"单个传感器信息",normalizedTitle:"单个传感器信息",charIndex:20476},{level:2,title:"5 fabric二维图像显示服务",slug:"_5-fabric二维图像显示服务",normalizedTitle:"5 fabric二维图像显示服务",charIndex:20709},{level:3,title:"5.1 canvas初始化",slug:"_5-1-canvas初始化",normalizedTitle:"5.1 canvas初始化",charIndex:20788},{level:3,title:"5.2 设置背景图片",slug:"_5-2-设置背景图片",normalizedTitle:"5.2 设置背景图片",charIndex:21480},{level:3,title:"5.3 传感器增删改查与选中",slug:"_5-3-传感器增删改查与选中",normalizedTitle:"5.3 传感器增删改查与选中",charIndex:21685},{level:4,title:"5.3.1 选中传感器",slug:"_5-3-1-选中传感器",normalizedTitle:"5.3.1 选中传感器",charIndex:21703},{level:4,title:"5.3.2 查找传感器",slug:"_5-3-2-查找传感器",normalizedTitle:"5.3.2 查找传感器",charIndex:21853},{level:4,title:"5.3.3 添加传感器",slug:"_5-3-3-添加传感器",normalizedTitle:"5.3.3 添加传感器",charIndex:22014},{level:4,title:"5.3.4 删除传感器",slug:"_5-3-4-删除传感器",normalizedTitle:"5.3.4 删除传感器",charIndex:22168},{level:4,title:"5.3.5 修改传感器",slug:"_5-3-5-修改传感器",normalizedTitle:"5.3.5 修改传感器",charIndex:22301},{level:3,title:"5.4 鼠标传感器事件",slug:"_5-4-鼠标传感器事件",normalizedTitle:"5.4 鼠标传感器事件",charIndex:22404},{level:4,title:"5.4.1 双击选中事件",slug:"_5-4-1-双击选中事件",normalizedTitle:"5.4.1 双击选中事件",charIndex:22419},{level:4,title:"5.4.2 滑动触发名字事件",slug:"_5-4-2-滑动触发名字事件",normalizedTitle:"5.4.2 滑动触发名字事件",charIndex:22566},{level:3,title:"5.5 保存canvas信息",slug:"_5-5-保存canvas信息",normalizedTitle:"5.5 保存canvas信息",charIndex:22789},{level:3,title:"5.6 读取保存canvas信息",slug:"_5-6-读取保存canvas信息",normalizedTitle:"5.6 读取保存canvas信息",charIndex:22903},{level:2,title:"6 sensor-info 传感器信息处理服务",slug:"_6-sensor-info-传感器信息处理服务",normalizedTitle:"6 sensor-info 传感器信息处理服务",charIndex:23086},{level:3,title:"6.1 从项目获取传感器信息",slug:"_6-1-从项目获取传感器信息",normalizedTitle:"6.1 从项目获取传感器信息",charIndex:23216},{level:3,title:"6.2 传感器信息整理存储",slug:"_6-2-传感器信息整理存储",normalizedTitle:"6.2 传感器信息整理存储",charIndex:23321},{level:3,title:"6.3 确定当前输出信息源",slug:"_6-3-确定当前输出信息源",normalizedTitle:"6.3 确定当前输出信息源",charIndex:23450},{level:3,title:"6.4 更新传感器信息",slug:"_6-4-更新传感器信息",normalizedTitle:"6.4 更新传感器信息",charIndex:23681},{level:2,title:"7 algorithm阈值算法处理服务",slug:"_7-algorithm阈值算法处理服务",normalizedTitle:"7 algorithm阈值算法处理服务",charIndex:23871},{level:3,title:"7.1 ParamsList类",slug:"_7-1-paramslist类",normalizedTitle:"7.1 paramslist类",charIndex:24e3},{level:3,title:"7.2 单个传感器阈值判断",slug:"_7-2-单个传感器阈值判断",normalizedTitle:"7.2 单个传感器阈值判断",charIndex:24350},{level:3,title:"7.3 诊断结果、决策去重累计显示",slug:"_7-3-诊断结果、决策去重累计显示",normalizedTitle:"7.3 诊断结果、决策去重累计显示",charIndex:24515},{level:3,title:"7.4 数据总处理",slug:"_7-4-数据总处理",normalizedTitle:"7.4 数据总处理",charIndex:24654},{level:2,title:"8 signalR实时数据接收服务",slug:"_8-signalr实时数据接收服务",normalizedTitle:"8 signalr实时数据接收服务",charIndex:25156},{level:3,title:"8.1 定期固化上传error信息",slug:"_8-1-定期固化上传error信息",normalizedTitle:"8.1 定期固化上传error信息",charIndex:25178},{level:3,title:"8.2 连接signalR与持续监听的数据",slug:"_8-2-连接signalr与持续监听的数据",normalizedTitle:"8.2 连接signalr与持续监听的数据",charIndex:25251},{level:3,title:"8.3 constructor(){}",slug:"_8-3-constructor",normalizedTitle:"8.3 constructor(){}",charIndex:25685},{level:3,title:"8.4 输出数据源选择",slug:"_8-4-输出数据源选择",normalizedTitle:"8.4 输出数据源选择",charIndex:25769},{level:2,title:"9 个人信息设置",slug:"_9-个人信息设置",normalizedTitle:"9 个人信息设置",charIndex:26035},{level:2,title:"10 主视图设置",slug:"_10-主视图设置",normalizedTitle:"10 主视图设置",charIndex:26048},{level:2,title:"11 传感器信息修改",slug:"_11-传感器信息修改",normalizedTitle:"11 传感器信息修改",charIndex:26061},{level:2,title:"12 历史数据查看与下载",slug:"_12-历史数据查看与下载",normalizedTitle:"12 历史数据查看与下载",charIndex:26076}],headersStr:"1 项目基础内容 1.1 启动项目 1.1.1 项目模板下载 1.1.2 项目配置修改 1.2 项目目录介绍 1.2.1 前端项目目录介绍 1.2.2 后端项目目录介绍 C# 1.3 项目需求分析 1.3.1 前端项目需求 1.3.2 后端项目需求 1.4 UI设计 1.4.1 页面分配 风格确定 具体页面参考 页面设计 主题颜色 2 Angular页面开发基础 2.1 监测主界面生成 2.1.1 Angular页面包含内容 2.1.2Angular Cli生成命令 生成dashboard.module.ts文件 生成dashboard.component的三个文件 生成dashboard-routing.module.ts文件 2.1.3 angular各文件之间的依赖、引入、声明补充 dashboard.module.ts dashboard-routing.module.ts app.module.ts app-routing.module.ts route.provider.ts 2.2 页面尺寸响应式基础 2.3 引入ui库 2.3.1 安装NG-ZORRO 2.3.2 全局配置 2.3.3 模块配置 2.3.4 自定义主题 3 登录页面开发 3.1 登录页面布局开发 3.1.1 登录页面模块划分 3.1.2 登录页面生成 3.1.3 loginlayout组件开发 整体布局 图片翻转 3.2.4 login-form组件开发 表单 修改ui库样式 伪类选择器添加图形 3.2.5 sign-up-form组件 3.2.6 reset-modal组件 3.2 登录页面业务逻辑 3.2.1 打开重置密码弹窗 3.2.2 确定表单内容 3.2.3 表单验证逻辑 angular自带的表单验证 自定义的表单验证 3.2.4 表单提交逻辑 表单数据回收 数据提交与返回状态处理 3.2.5 提示信息服务 3.2.6 登录获取保存token 4 导航栏与主界面布局开发 4.1 导航栏开发 4.1.1 导航栏布局开发 4.1.2 导航栏名称区开发 4.1.3 导航栏路由区开发 4.1.4 导航栏菜单区开发 4.2 主界面布局开发 4.2.1 左侧特殊显示区 传感器仪表盘 统计饼图 文字显示区 4.2.2 中间主体显示区 4.2.3 右侧多功能区 全部传感器信息 单个传感器信息 5 fabric二维图像显示服务 5.1 canvas初始化 5.2 设置背景图片 5.3 传感器增删改查与选中 5.3.1 选中传感器 5.3.2 查找传感器 5.3.3 添加传感器 5.3.4 删除传感器 5.3.5 修改传感器 5.4 鼠标传感器事件 5.4.1 双击选中事件 5.4.2 滑动触发名字事件 5.5 保存canvas信息 5.6 读取保存canvas信息 6 sensor-info 传感器信息处理服务 6.1 从项目获取传感器信息 6.2 传感器信息整理存储 6.3 确定当前输出信息源 6.4 更新传感器信息 7 algorithm阈值算法处理服务 7.1 ParamsList类 7.2 单个传感器阈值判断 7.3 诊断结果、决策去重累计显示 7.4 数据总处理 8 signalR实时数据接收服务 8.1 定期固化上传error信息 8.2 连接signalR与持续监听的数据 8.3 constructor(){} 8.4 输出数据源选择 9 个人信息设置 10 主视图设置 11 传感器信息修改 12 历史数据查看与下载",content:"> 本系列旨在以实验室大屏智能监测系统为原型，将开发中使用的技术归纳梳理，记录从头开发类似项目的过程。原型项目实际开发过程中存在很多试错勉强能用的代码，在本次开发过程中尽可能考虑周全，在了解各技术原理的基础上选择合适的方式开发\n\n本系列主要分成前端与后端两个部分。前端技术栈主要包含：Angular，NG-ZORRO，ECharts，fabric，signalR。后端技术栈主要包含：cs，Python，后端使用的框架包括ASP.Net Core，ABP，IdentityServer，部署技术使用Docker，操作系统包括Windows和Linux，后端开发主要框架为ABP。同时本系列预计还包括系统开发前的功能梳理、UI设计以及系统开发后的打包上线部分。\n\n> 本系列旨在以实验室大屏智能监测系统为原型，将开发中使用的技术归纳梳理，记录从头开发类似项目的过程。原型项目实际开发过程中存在很多试错勉强能用的代码，在本次开发过程中尽可能考虑周全，在了解各技术原理的基础上选择合适的方式开发\n\n本系列主要分成前端与后端两个部分。前端技术栈主要包含：Angular，NG-ZORRO，ECharts，fabric，signalR。后端技术栈主要包含：C#，Python，后端使用的框架包括ASP.Net Core，ABP，IdentityServer，部署技术使用Docker，操作系统包括Windows和Linux，后端开发主要框架为ABP。同时本系列预计还包括系统开发前的功能梳理、UI设计以及系统开发后的打包上线部分。\n\n\n# 1 项目基础内容\n\n\n# 1.1 启动项目\n\n# 1.1.1 项目模板下载\n\n 1. dotnet tool install -g Volo.Abp.Cli下载abp框架，需要dotnet。这部分下载可以使用蒋师兄的装机代码从chocolatey上下载\n 2. abp new 项目名称 -u angular -dbms MySQL -csf建立一个包含abp内容的前端模板，以及使用MySQL为数据库的后端模板\n\n\n\n下载完毕后会生成两个文件夹，angular是前端文件夹，aspnet-core是后端文件夹\n\n# 1.1.2 项目配置修改\n\n 1. docker run --name 容器名 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=数据库密码 -d mysql:latest通过docker启动数据库，其中3306:3306前一个是本机访问mysql的端口，后一个是docker镜像内部端口，不建议改\n 2. 修改后端中数据库连接配置\n\n在 HTTPApi.Host文件夹里的appsetting.json修改以下内容\n\n \"ConnectionStrings\": {\n    \"Default\": \"Server=localhost;Port=3306;Database=数据库名称;Uid=root;Pwd=数据库密码;\"\n  },\n\n\n1\n2\n3\n\n\n在DbMigrator里的appsetting.json数据库修改以下内容\n\n\"ConnectionStrings\": {\n    \"Default\": \"Server=localhost;Port=3306;Database=数据库名称;Uid=root;Pwd=数据库密码;\"\n  },\n\n\n1\n2\n3\n\n 3. cd Dashboard.DbMigrator然后执行dotnet run迁移数据库\n\n\n\n 4. 启动HTTPApi.Host就可以开启Swagger，证明后端已开启\n\n\n\n 5. 进去前端文件夹yarn从package.json中下载依赖项\n 6. yarn satrt开启项目，在本机4200端口就可以看到启动的前端网页\n\n\n\n> 如果你和我一样有其他的angular项目，就需要修改一下端口。因为Angular项目的默认端口都是4200，会存在冲突问题。\n\n 7. 在前端src/enviroments里的两个ts文件做同样的修改\n\nconst baseUrl = 'http://localhost:你希望的端口号';\n\n\n1\n\n\n 8. 在package.json文件中修改\"start\": \"ng serve --open --port 你希望的端口号\",\n\n 9. 保存之后你会发现你的前端报错了，这是因为后端写的端口号是原先默认的4200，所有我们需要对后端做同样的处理。找到之前修改过的两个appsetting.json文件，将其中的4200改成你修改后的端口号，重新启动项目。前端网页刷新后又会显示原先的页面，证明你已经将端口号修改好了\n\n\n# 1.2 项目目录介绍\n\n# 1.2.1 前端项目目录介绍\n\n\n\n> 本人对webpack打包还有前端自动化测试方面的内容一知半解，所以这里只介绍一些与内容直接相关的文件\n\n * node_modules\n\n是你yarn之后下载下来的依赖项，开发过程中可以不用管，你对这个文件夹的修改一般只会来自npm包下载和卸载，不要手动去修改里面的内容\n\n * src：前端开发的内容都在里面\n\n * app：前端开发的组件，服务等实际的页面内容和页面逻辑\n   \n   * home：abp帮你写好的首页组件\n   \n   * shared：一般多个组件共用的东西放在里面，比如之后会用到的服务和UI库的自定义主题\n   \n   * app的三个文件:app的路由设置，组件依赖注入和app这个挂载自身ts\n   \n   * route.provider.ts：abp提供的导航栏中的路由设置\n\n * assets：静态文件存储的地方，一般放一些项目所需的图片、json文件\n\n * environments：项目的环境配置，可以在这里设置项目所用到的所有后端url以及自身的输入端口。其中prod是打包后使用的环境配置，另一个是开发阶段使用的环境配置\n\n * index.html：整个项目的入口文件，主要用来修改网页head的内容\n\n * main.ts：整个项目的ts文件，基本没改过\n\n * styles.scss：项目的总scss文件\n\n * package.json：其他的文件基本都是angular自己生成的，不会做修改。比较重要的就是这个文件，你所有的npm包操作都会反应到这个文件里，这里会记载该项目的依赖项，以及你项目开启，打包的命令。\n\n# 1.2.2 后端项目目录介绍\n\n后端项目大方向分为两个部分，一部分为C#语言包含的后端逻辑功能，一部分为Python语言包含的数据诊断与发送功能\n\n# C#\n\n 1. 首先是权限管理后端，其项目文件目录结构如下所示：\n    \n    其中src为源文件文件夹，test为功能测试文件夹。使用Rider打开*.sln项目，目录结构如下所示：\n    \n    其中：\n    \n    * Application：后端逻辑实现，实体间映射目录\n    * Contracts：接口定义以及权限定义目录\n    * Domain：实体定义、权限种子数据、密码格式设置目录\n    * Shared：本地化配置文件目录\n    * EFCore：后端与MySQL数据表联系建立\n    * DbMigrations：EF数据库管理迁移目录\n    * Host：项目模块配置以及项目启动项\n\n\n# 1.3 项目需求分析\n\n# 1.3.1 前端项目需求\n\n 1.  登录、注册界面\n 2.  通过signalR获取数据，进行阈值判断，并显示状态信息\n 3.  切换数据源\n 4.  通过监视的状态信息，直接反馈到二维平面图上\n 5.  系统基础的登录、注销、权限管理\n 6.  生成报告单，并提供打印功能\n 7.  通过二维平面图获取单个数据的长期信息和诊断信息\n 8.  系统基础的查看数据库，下载数据库信息\n 9.  提供设置算法参数，并绘制算法结果图接口\n 10. 界面平面图与报警信息的前端修改\n\n# 1.3.2 后端项目需求\n\n 1. 用户登录\n 2. 实时数据\n 3. 配置文件\n 4. 算法接入\n 5. 检测报告输出\n\n\n# 1.4 UI设计\n\n> 不是专业做UI设计的，但一般做前端开发应该先在脑子里有大致的页面分配，主要页面布局，每个功能在哪个部分实现。这里为了全面展示一个系统的开发流程，就做了比较细致的UI设计。\n\n# 1.4.1 页面分配\n\n首先根据需求确定页面的个数，这里因为有原型系统，所以这里很确定一共是4个界面：登录和注册、主监视界面、检测报告界面和统计分析界面。还有一个权限管理界面，主要是应用abp框架自带的。\n\n# 风格确定\n\n页面首先应该确定颜色风格，可以先在dribbble上搜索相关的设计方案，比如我这里就搜索了dashboard，这里参考了下面这个\n\n\n\n# 具体页面参考\n\n像比较具体且通用的页面，如登录等可以在b站上搜索一下例子。一是可以快速了解流行的页面样式；二是这种一般是纯HTML和CSS写成的，各种框架都可以应用；三是这种一般会带着你写，让你更容易理解和修改代码。\n\n我这里参考了\n\n\n\n\n\n这两个登录界面，我主要关注的前端样式up有总监日记、山羊の前端小窝、阿阳热爱前端，还有一个设计类的up主子牧说。\n\n# 页面设计\n\n我这里使用的figma，主要考虑到它可以直接导出css样式，可以有效减少前端的工作。另外就是可以多人协作，发送连接给别人就可以共享，比较方便。figma的操作还是比较简单的，有些基础的原理可以参考原先邓师兄的PS教程。如果需要可以看一下UI教程 | 手把手教你用Figma做UI界面设计_哔哩哔哩_bilibili，基本你需要什么到里面找就可以了\n\n最后的设计方案\n\n![登录界面](https://pic.imgdb.cn/item/61bf258a2ab3f51d91a1c27a.jpg\n\n设计的连接在这里Dashboard – Figma\n\n# 主题颜色\n\n背景色#F2F7FF\n\n主题色#9590C7\n\n装饰色 #C4D3F9 #51459E #F2F7FF\n\n状态色 #84E8F4 #FCBE30 #41B674 文字色 #000000 #9CA0AB #FFFFFF\n\n> 本篇文章内容全部是前端开发内容，主要包括监测主界面生成、项目初始化开发与登录界面的开发。\n> 主要的技术点有：Angular新页面生成、ui库依赖使用、响应式布局基础、Angular组件、登录界面CSS、修改ui库样式、Angular表单、Angular http请求、Angular/ABP用户登录、Angular服务\n> 因为系列是前端开发的第一篇文章，命令行与CSS都会介绍得比较详细，后续文章没有很特殊的不会再做介绍\n\n\n# 2 Angular页面开发基础\n\n\n# 2.1 监测主界面生成\n\n> 介绍如何一步步在Angular中生成一个新页面，了解Angular的依赖注入\n\n# 2.1.1 Angular页面包含内容\n\n参考home文件夹，可以发现angular一个页面需要至少有5个文件，其中有component存在的html、scss、ts属于home组件的内容。home.module.ts是保存home页面使用的组件的文件。home-routing.module.ts是app通过路由确定到home页面的文件。\n\n\n\n# 2.1.2Angular Cli生成命令\n\n# 生成dashboard.module.ts文件\n\n我们直接在醒目的路径下使用ng generate module dashboard，就会生成一个叫dashboard的文件夹，里面包含一个dashboard.module.ts文件。使用命令生成的module会自动生成一些依赖内容。\n\n# 生成dashboard.component的三个文件\n\n使用cd src\\app\\dashboard命令，转到对应的dashboard文件夹，再使用ng generate component dashboardLayout生成一个dashboardLayout组件。这里为了方便理解使用了不同的组件名称，为了方便一个页面多组件之后查看我也一般会把一个页面的根组件命名为Layout\n\n# 生成dashboard-routing.module.ts文件\n\n在dashboard目录下，使用ng generate module dashboardRouting生成dashboard-routing.module.ts，可以把其从文件夹中取出来\n\n# 2.1.3 angular各文件之间的依赖、引入、声明补充\n\n# dashboard.module.ts\n\n将dashboard-routing.module引入\n\nimport { DashboardRoutingModule } from './dashboard-routing.module';\n\n@NgModule({\n  declarations: [\n    DashboardLayoutComponent\n  ],\n  imports: [\n    CommonModule,\n    DashboardRoutingModule,\n  ]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这里的DashboardLayoutComponent是生成的时候会自动补充的\n\n# dashboard-routing.module.ts\n\n按照home-routing.module.ts修改\n\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { DashboardLayoutComponent } from './dashboard-layout/dashboard-layout.component';\n\nconst routes: Routes = [{ path: '', component: DashboardLayoutComponent }];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule],\n})\nexport class DashboardRoutingModule { }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# app.module.ts\n\n将dashboard import进来\n\n@NgModule({\n  imports: [\n      此处省略\n    DashboardModule,\n  ],\n    此处省略\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# app-routing.module.ts\n\n添加app路由\n\n{\n    path: 'dashboard',\n    pathMatch: 'full',\n    loadChildren: () => import('./dashboard/dashboard.module').then(m => m.DashboardModule),\n  },\n\n\n1\n2\n3\n4\n5\n\n\n完成以上步骤就可以通过理由跳转到新的页面了\n\n# route.provider.ts\n\n这里添加主页上的跳转按钮，修改初始样式。这里为了方便后续布局使用的是空样式\n\nroutesService.add([\n      {\n        path: '/dashboard',\n        name: '::监视主屏',\n        iconClass: 'fas fa-home',\n        order: 1,\n        layout: eLayoutType.empty\n      },\n    ]);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2.2 页面尺寸响应式基础\n\n> 这种监测大屏不存在响应式适配手机的需求，只需要适配不同分辨率的显示屏以及pad。所以这里没有考虑手机的适配，基本按照16:9等比例缩放。以后可以做手机适配的优化\n\n在这样的前提下，项目使用rem对宽高、字体大小进行限值，通过设备窗口对项目HTML的font-size进行调节即可。\n\n我们在main.ts里添加如下内容即可\n\nfunction remSize() {\n  const deviceWidth = document.body.clientWidth\n  // 在1920px宽的设计稿里10px=1rem\n  document.documentElement.style.fontSize = (deviceWidth / 192) + 'px'\n}\n//已启动项目就执行remSize\nremSize()\n//项目窗口变化就执行remSize\nwindow.onresize = () => {\n  remSize()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在dashboard-layout.component.html里验证响应式，\n\n<div style=\"font-size: 3rem;height: 96rem;width: 96rem;background-color: aqua;\">\n    新页面测试代码\n</div>\n\n\n1\n2\n3\n\n\n\n\n该方块会一直是一个占据半边宽度的正方形\n\n\n# 2.3 引入ui库\n\n> 原本是准备使用Vue、React都可以使用的Element ui的，但其适配Angular的版本是8以前的，目前Angular已经更新到12了。所以使用了官方推荐且适配较好的NG-ZORRO。\n> 各类ui库都会提供大量的交互组件，避免你从头开发。在开发具体页面前建议先看一下使用的ui库都提供了哪些组件，组件效果是什么样的，这样可以在你拿到页面需求的时候能快速反应有没有现成的组件可用。\n\n# 2.3.1 安装NG-ZORRO\n\nyarn add ng-zorro-antd\n\nng add ng-zorro-antd\n\n使用上述命令后会自动配置一些需要的内容\n\n# 2.3.2 全局配置\n\n在angular.json中添加\"src/theme.less\"\n\n\"styles\": [\n              \"src/theme.less\",\n    此后省略\n\n\n1\n2\n3\n\n\n# 2.3.3 模块配置\n\n在全局配置的NG-ZORRO无法直接使用，还是需要在对应的模块进行配置。这里为了检验NG-ZORRO引入成功在dashboard.module.ts文件中引入NzButtonModule\n\nimport { NzButtonModule } from 'ng-zorro-antd/button';\n@NgModule({\n  declarations: [\n    DashboardLayoutComponent\n  ],\n  imports: [\n    CommonModule,\n    DashboardRoutingModule,\n    NzButtonModule\n  ]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在dashboard-layout.component.html里测试NG-ZORRO的使用\n\n<button nz-button nzType=\"primary\">Primary Button</button>\n\n\n1\n\n\n\n\n这里截的图是修改主题色之后的，原本应该是蓝色。按钮自带颜色，有点击动效证明ng-zorro的NzButtonModule可以使用了\n\n# 2.3.4 自定义主题\n\n在theme.less文件中可以自定义主题\n\n@import \"../node_modules/ng-zorro-antd/ng-zorro-antd.less\";\n\n@primary-color: #9590C7;\n@info-color:#9CA0AB;\n@body-background:#F2F7FF;\n@error-color:#FC5B5D;\n@warning-color:#FCBE30;\n@processing-color:#84E8F4;\n@success-color:#41B674;\n@normal-color:#51459E;\n@text-color:#9CA0AB;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这里根据ui设计定义了一下颜色，后续可能还会根据需要进行调整。像vue比较常用的element ui是可以可视化定义主题的，会比ng-zorro要更好用一些。\n\n这个网址可以看到所有可以自定义的内容\n\n\n# 3 登录页面开发\n\n\n# 3.1 登录页面布局开发\n\n# 3.1.1 登录页面模块划分\n\n根据业务逻辑将登录页面划分成了四个部分，1是登录的表单，2是注册的表单，3是用来遮盖的翻转图片，4是点击后浮动到页面上的重置密码弹窗。于是将登录页面划分成了四个组件：reset-modal负责重置密码弹窗、login-form负责登录表单、sign-up-form负责注册表单、loginlayout是登录页面的根，负责整体布局和遮盖翻转图片逻辑\n\n\n\n\n\n# 3.1.2 登录页面生成\n\n按照前文主页面生成的方法生成登录页面，一并生成登录表单与注册表单组件\n\n# 3.1.3 loginlayout组件开发\n\n> 该组件要实现的功能是登录页面整体布局：登录框水平垂直居中，图片翻转遮盖\n\n# 整体布局\n\n页面通过.backgroud的div实现设计图背景颜色和后续子元素.container div页面水平垂直居中\n\n.background {\n    //flex布局，子元素水平垂直居中\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    //背景颜色\n    background-color: #C4D3F9;\n    //保证页面大小占满屏幕\n    width: 100%;\n    height: 100%;\n}\n.container {\n    //登录页面核心部分颜色，大小，阴影\n    background-color: #F2F7FF;\n    width: 115rem;\n    height: 60rem;\n    box-shadow: 0.5rem 1rem 1rem 0.2rem rgba(0, 0, 0, 0.3);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n通过.cover的div放置遮挡用的图片，以及上面的文字。与.container组成子绝父相\n\n.container {\n    position: relative;\n}\n.container .cover{\n    //确定图片初始位置\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 80rem;\n    height: 100%;\n    z-index: 98;\n    //图片层样式，颜色后续可以删掉\n    background-color: aquamarine;\n    filter: drop-shadow(0.5rem 0px 1rem rgba(0, 0, 0, 0.25));\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n通过.forms的div嵌套两个div，分别嵌入两个组件，将用于翻转图片的内容放在组件外面。这里设置background-color是为了在初步构建代码时直观看到各个盒子的位置\n\n.forms .signupform{\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 35rem;\n    height: 100%;\n    background-color: blueviolet;\n  }\n.forms .loginform{\n    position: absolute;\n    top: 0;\n    left: 80rem;\n    width: 35rem;\n    height: 100%;\n    background-color: blueviolet;\n\n}\n.forms .signupform, .forms .loginform {\n\t//flex布局，子元素水平垂直居中\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 图片翻转\n\n> 图片翻转是通过一个不在页面上显示的#flip的checkbox完成的\n\n.cover整体翻转。.container #flip:checked是选择#flip这个元素被选中；~ 选择前面选择元素的后续兄弟元素；这样再.cover就是#flip这个元素被选中时.cover元素要执行的CSS样式了\n\n.container {\n    //元素距离视图的距离，翻转时z轴最高高度\n    perspective: 280rem;\n}\n\n.container .cover{\n    //动画样式相关设置\n    transition: all 0.8s ease;\n    //翻转轴位置\n    transform-origin: 71.875%;\n    transform-style: preserve-3d;\n  }\n\n.container #flip:checked ~ .cover{\n    transform: rotateY(180deg);\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n但这样直接翻转会导致，图片和上面的文字翻转后颠倒。所以要把.cover分成两个面，分别显示。本来应该使用backface-visibility: hidden;来隐藏背面，但不知为何我的浏览器显示有这个样式，但没有这个效果。所以只能退而求其次，使背面元素display:none不渲染\n\n//正面设置\n.container .cover .front {\n\twidth: 100%;\n    height: 100%;\n    background-image: url(~src/assets/login.jpg);\n    background-size: 100% 100%;\n    background-repeat:no-repeat;\n}\n.container #flip:checked ~ .cover .front {\n    display:none\n}\n//背面设置\n.container .cover .back{\n    width: 100%;\n    height: 100%;\n    background-image: url(~src/assets/login.jpg);\n    background-size: 100% 100%;\n    background-repeat:no-repeat;\n    transform: rotateY(180deg);\n    display:none\n}\n.container #flip:checked ~ .cover .back {\n    display:flex\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n还有一些文字样式就不一一介绍了\n\n# 3.2.4 login-form组件开发\n\n表单组件在NG-ZZORO有相应的组件了，使用和前文一样的方法把NzFormModule配置进来。但为了更好的自定义样式，没有引入NzInputModule和NzButtonModule，而是自己写的样式\n\n# 表单\n\n在对应的module导入import { FormsModule, ReactiveFormsModule } from '@angular/forms';\n\n对应ts中引入import { FormBuilder, FormControl, FormGroup, Validators } from '@angular/forms';并定义表单\n\nloginForm = new FormGroup({\n\tuserName: new FormControl('', [Validators.required]),\n    password: new FormControl('', [Validators.required]),\n})\n\n\n1\n2\n3\n4\n\n\n<form nz-form [formGroup]=\"loginForm\">\n\t<nz-form-item>\n\t\t<nz-form-control nzErrorTip=\"用户名不能为空\">\n\t\t\t<input type=\"text\" formControlName=\"userName\" placeholder=\"用户名\" />\n\t\t</nz-form-control>\n\t</nz-form-item>\n  \n\t<nz-form-item>\n\t\t<nz-form-control nzErrorTip=\"密码至少6位且包含小写字母与数字\">\n\t\t\t<input type=\"password\" formControlName=\"password\"\t\t\t</nz-form-control>\n\t</nz-form-item>\n\n  <button>登录</button>\n</form>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n[formGroup]设置整个表单名称，在ts需要定义这个名称，后续也用这个名称接收整个表单数据\n\nformControlName设置单个输入对应的键，实现双向绑定\n\n# 修改ui库样式\n\n除去在自定义主题里修改ui库里的样式，我们遇到具体的ui库样式不合要求时可以直接不配置ui库，比如下面的input，也可以使用ng-deep修改，比如下面的.ant-form-item-explain.ant-form-item-explain-error。\n\ninput{\n\twidth: 100%;\n\toutline: none;\n\tborder: 0;\n    border-bottom: 0.25rem solid rgba(81, 69, 158, 0.58);\n    background-color: transparent;\n}\n:host ::ng-deep .ant-form-item-explain.ant-form-item-explain-error{\n\tfont-size: 1.2rem;\n    color: #F9896B;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n遇到引入ui库导致的样式不合适时，使用F12，查看是哪个部分的样式在起作用，用浏览器更改后有效果，就可以复制其css选择器，在前面添上\n\n深度选择器\n\n:host ::ng-deep就可以在本文件作用域下修改ui组件库样式，添上**::ng-deep**就会使修改的样式全局生效\n\n# 伪类选择器添加图形\n\n在登录两个字下面添加了一个小方块儿，使用伪类选择器也是常规操作了\n\n.name::before{\n\tcontent: \"\";\n\tposition: absolute;\n\tleft: 0;\n\tbottom: 0rem;\n\theight: 0.5rem;\n\twidth: 3rem;\n\tbackground-color: #B1ABED;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 3.2.5 sign-up-form组件\n\n这个组件内容与login-form组件基本一致，就是添加了一个email输入。后续考虑是否将两个合并到一个里面去，使用传参来动态修改组件内容\n\n# 3.2.6 reset-modal组件\n\n由于这个组件的点击文字分配在了登录按钮之上，所以把该组件作为login-form组件的子组件开发。组件内容与sign-up-form组件一致，其部分样式与在login-form打开弹窗里定义，在介绍业务逻辑时进行纤细说明。\n\n\n# 3.2 登录页面业务逻辑\n\n# 3.2.1 打开重置密码弹窗\n\n这部分使用NG-ZORRO提供的服务，将弹窗里的内容抽象成一个组件打开\n\n首先要在拥有打开弹窗逻辑的组件里引入依赖import { NzModalService } from 'ng-zorro-antd/modal';\n\n然后在对应打开弹窗的地方绑定事件逻辑，并编写处理的逻辑\n\nresetModal() {\n\tconst modal = this.modal.create({\n        //定义弹窗标题\n\t\tnzTitle: '找回密码',\n        //定义弹窗主体的组件\n\t\tnzContent: ResetModalComponent,\n        //定义弹窗尾部\n\t\tnzFooter: [\n        //定义取消按钮，点击后摧毁弹窗\n\t\t\t{\n\t\t\t\tlabel: '取消',\n\t\t\t\tonClick: () => modal.destroy()\n\t\t\t},\n\t\t//定义确认按钮，点击确认后执行组件里的reset方法\n\t\t\t{\n\t\t\t\tlabel: '确认',\n\t\t\t\ttype: 'primary',\n\t\t\t\tloading: false,\n\t\t\t\tonClick(component): void {\n\t\t\t\t\tthis.loading = true;// 让提交按钮显示加载动画，防止重复提交\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tthis.loading = false\n\t\t\t\t\t}, 3000)\n\t\t\t\tcomponent.reset();\n\t\t\t\t}\n\t\t\t},\n\t\t],\n\t\tnzWidth: 40 * this.rem\n    });\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 3.2.2 确定表单内容\n\n这个方面需要和后端进行协同，首先要弄清楚登录、注册、找回密码都需要向后端传输哪些信息。这些信息里哪些是用户输入的，这一部分需要在界面上提供输入；哪些是系统自动传输的，这一部分需要自己在前端代码中定义。而且沟通的时候也要确定好数据的类型和要求，方便后续进行表单验证。\n\n# 3.2.3 表单验证逻辑\n\n# angular自带的表单验证\n\nangular自带的表单验证可以验证常规的邮箱、电话号码和正则表达式，在创建表单组的时候定义其需要验证的逻辑即可。以注册表单为例，实例化FormControl对象时传入的第一个参数是这个量的初始值，第二个参数是采取的表单验证逻辑。Validators.required是这个量不能为空，Validators.email是这个量格式为邮箱，Validators.pattern则是这个量要满足后面的正则表达式\n\nsignupForm = new FormGroup({\n    userName: new FormControl(null, [Validators.required]),\n    email: new FormControl(null, [Validators.required, Validators.email]),\n    password: new FormControl(null, [Validators.required, Validators.pattern(/^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{6,10}$/)]),\n})\n\n\n1\n2\n3\n4\n5\n\n\n# 自定义的表单验证\n\n业务上存在angular自带的表单验证无法覆盖的内容，比如重置密码的时候第二次输入的密码应该与第一次一致。这个时候就需要自定义一个表单验证逻辑。这里就定义了一个新的表单验证逻辑confirmValidator，为了能够展示不同的两种信息所以设计了两种状态值error和required。\n\nconfirmValidator = (control: FormControl): { [s: string]: boolean } => {\n\tif (!control.value) {\n\t\treturn { error: true, required: true };\n    } else if (control.value !== this.resetForm.controls.password.value) {\n\t\treturn { confirm: true, error: true };\n    }\n    return {};\n};\n\nresetForm = new FormGroup({\n\tuserName: new FormControl(null, [Validators.required]),\n\temail: new FormControl(null, [Validators.required, Validators.email]),\n    password: new FormControl(null, [Validators.required, Validators.pattern(/^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{6,10}$/)]),\n    password1: new FormControl(null, [this.confirmValidator]),\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 3.2.4 表单提交逻辑\n\n# 表单数据回收\n\n因为和后端定义的关于权限部分的http请求全部使用post，所以这里都使用直接定义对象来回收表单数据，将表单组的对应值直接幅值到后端定义的对象中。这里因为this.resetForm是一个观察对象，和vue里的ref类似，需要使用value来获取值。\n\nlet resetForm = {\n\tusername: this.resetForm.value.userName,\n\tuserEmail: this.resetForm.value.email,\n\tnewPassword: this.resetForm.value.password,\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 数据提交与返回状态处理\n\nangular的自己封装了http请求的服务，不需要像vue那样引入，只要在组件里注入import { HttpClient, HttpHeaders } from '@angular/common/http';的依赖就可以使用。对于post请求需要定义请求头。\n\n由于很多地方都需要用到后端的网址，为了应对项目落地调试时频繁修改IP的问题，这里将后端的IP定义在environment里面，通过import { accountUrl } from 'src/environments/environment'来使用\n\n请求返回的内容是与后端协商确定的，根据statusCode的不同来确定后续启用的逻辑，这里成功就提示成功并关闭弹窗；不成功则提示错误信息，保留弹窗\n\ninterface responseProps {\n      statusCode: number\n      message: string\n}\n\nconst httpOptions = { headers: new HttpHeaders({ 'Content-Type': 'application/json' }) }\nlet api = accountUrl + '/api/app/reset-password'\nthis.http.post(api, resetForm, httpOptions).subscribe((response: responseProps) => {\n\tif (response.statusCode === 200) {\n\t\tthis.alert.MessageAlert('success', response.message, 3000)\n\t\tthis.nzModalRef.destroy(true);\n\t} else {\n\t\tthis.alert.MessageAlert('error', response.message, 3000)\n\t}\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 3.2.5 提示信息服务\n\n由于浏览器自带的alert很丑，且必须手动关闭会阻塞代码运行。结合NG-ZORRO封装的全局信息提示，项目创建了一个提示的服务，供全局使用\n\n使用ng generate service alert命令创建提示信息服务，将\n\nNG-ZORRO封装的全局信息提示注入import { NzMessageService } from 'ng-zorro-antd/message';，并且在构造函数里定义private message: NzMessageService。\n\nMessageAlert(type: string, message: string, duration: number): void {\n\tthis.message.create(type, `${message}`, { nzDuration: duration });\n}\n\n\n1\n2\n3\n\n\n这样在其他组件里注入这个服务import { AlertService } from 'src/app/service/alert.service'，构造函数里定义private *alert*: AlertService，就可以直接使用this.alert.MessageAlert('success', response.message, 3000)\n\n# 3.2.6 登录获取保存token\n\n一般来说登录之后后端会返回token，你需要将其保存在LocalStorage或者sessionStorage里面。但Angular与abp给你做了封装只要拿过来用就可以了。\n\n首先是要设置好登录的方式，以及给后端传的值。这部分内容在environment.ts和environment.prod.ts里设置。前者是开发的时候使用的，后者是打包的时候使用，在不涉及打包上线的时候后者完全不起作用。但为了防止你到了打包上线的时候忘记修改，最好两个一起修改\n\noAuthConfig: {\n    //验证信息往哪里传\n\tissuer: accountUrl,\n    //获取token的api\n    tokenEndpoint: accountUrl + '/connect/token',\n\t//使用token方法验证，abp默认的是跳转到后端页面上验证\n\trequestAccessToken: true,\n    //这是后端需要给你的前端设备标识和密码\n    clientId: 'Dashboard_App',\n    dummyClientSecret: '1q2w3e*',\n    //这个是目前还没做https的授权那一套先给他关掉，免得报不安全\n    requireHttps: false,\n    //你前端设备名称，是什么不重要\n    scope: 'offline_access Dashboard',\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n然后将登录相关的服务注入import { OAuthService } from 'angular-oauth2-oidc'; import { AuthService } from '@abp/ng.core';。构造函数定义，之后直接使用接口就可以了\n\nthis.authService.login(user).toPromise()\n\t.then(data => {\n\t\tthis.alert.MessageAlert('success', \"恭喜您登录成功！\", 1000)\n\t\tsetTimeout(() => {\n\t\t\tthis.router.navigateByUrl('/dashboard');\n\t\t}, 1000)\n\t})\n\t.catch(() => {\n\t\tthis.alert.MessageAlert('error', \"您输入的用户名或密码不正确！\", 3000)\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果你发现你登录之后在LocalStorage里多出了很多信息证明登录获取保存token就成功了。但我们做的时候出现了一些问题，本来不注销账号刷新页面是token是会一直保留的，但我们当时出现了token不保留的bug，打印后端返回的数据后发现，只是返回了token但没有返回用户信息，修改后端代码后解决。\n\n\n# 4 导航栏与主界面布局开发\n\n三个主要的功能界面共用同一导航栏，所以将导航栏的开发放在share目录下\n\n\n# 4.1 导航栏开发\n\n# 4.1.1 导航栏布局开发\n\n导航栏(.nav)从左到右分为名称区(.title)、路由区(.router)和菜单区(.menu)。通过NG-ZORRO的Grid栅格布局，使其分别占据页面的8/24、5/25、8/24。通过nzJustify=\"space-between\"使其合理分隔显示\n\n# 4.1.2 导航栏名称区开发\n\n名称区功能很简单，显示名称与当前时间。在组件初始化钩子函数里添加了一个1秒刷新一次的定时器用于给界面显示当前时间，html中直接使用插值语法更新显示时间\n\n# 4.1.3 导航栏路由区开发\n\n通过routerLink=\"/dashboard\"控制路由跳转，如果直接通过a标签的url跳转会出现系统页面直接刷新全部重启的问题。这会导致与后端数据接收通道的断开。\n\n# 4.1.4 导航栏菜单区开发\n\n菜单区分为算法、文件、设置和用户头像4个主体，每个主体分别存在各自的下拉菜单，实现不同的功能\n\n\n# 4.2 主界面布局开发\n\n主界面通过dashboard-layout文件夹来实现主界面布局分配，首先<app-nav></app-nav>将导航栏引入，其余按照设计图将主界面纵向分成三个部分：左侧特殊显示区（.left）、中间主体显示区（.middle）、右侧多功能区（.right）\n\n# 4.2.1 左侧特殊显示区\n\n左侧特殊显示区从上至下分为传感器仪表盘（.mainMonitor）、统计饼图（.pieChart）、文字显示区（.Word）\n\n# 传感器仪表盘\n\n以2X2矩阵形式排布4个传感器的信息，通过[index]参数输入绑定不同的传感器以复用status-panel组件\n\nstatus-panel组件从上至下分为状态颜色块（.status）、数字（.value）、描述（.description）\n\n# 统计饼图\n\n通过statistics组件引入一个echarts图，通过[options]=\"chartOption\"在ts文件中设置图中显示内容\n\n# 文字显示区\n\n通过description组件完成布局，在description组件里使用cardtab，将显示内容通过tab标签切换为异常参数列表（abnormal-parameters）、诊断结果（diagnostic-results）、操作建议（recommendation）\n\n# 4.2.2 中间主体显示区\n\n中间显示区包括一个类导航部分以及下方的fabric的canvas。类导航区左侧是一个通过this.fabricService.editMode参数标志canvas状态显示提示，中间是一个切换数据源的tab、右侧是用来切换右侧多功能区的按钮。下方canvas通过tab和[source]=\"source\"达到复用main-view组件显示3个不同转向架的效果。\n\n# 4.2.3 右侧多功能区\n\n通过*ngIf\"与this.fabricService.function参数判断右侧多功能区渲染单个传感器信息（single-parameter）还是全部传感器信息（overall-parameters）\n\n# 全部传感器信息\n\noverall-parameters组件通过一个自动列表将所有传感器的信息（状态、名称、数值、单位）渲染出来\n\n# 单个传感器信息\n\nsingle-parameter组件分为传感器信息绑定显示区、时域图（time-domain-chart组件）、频域图组件（frequency-domain-chart）和两个功能按钮组成\n\n\n# 5 fabric二维图像显示服务\n\nFabric.js 是一个提供多种二维图像交互显示的库，项目中用以显示传感器的二维位置以及一系列传感器相关的交互\n\n\n# 5.1 canvas初始化\n\ninitialize(*source*: string, *width*: number, *height*: number){}方法用以初始化canvas，在main-view组件初始化中调用并传入数据源、canvas需要的自适应长宽，通过*ngFor=\"let i of this.sensor.sourceList\"与*ngIf=\"source == i\"选择当前渲染的canvas\n\n因为使用Circle类作为传感器，需要该类增加一个name属性，于是在constructor中添加以下代码。\n\nconstructor(public sensor: SensorInfoService, private http: HttpClient, private alert: AlertService) {\n\tthis.editMode = false\n    // 获取之前添加的name信息\n\tfabric.Circle.prototype.toObject = ((toObject) => {\n\t\treturn function () {\n            return fabric.util.object.extend(toObject.call(this), {\n                name: this.name\n            });\n        };\n    })(fabric.Circle.prototype.toObject);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 5.2 设置背景图片\n\nsetBackground(*imgSrc*: string, *width*: number, *height*: number){}方法用于设置背景图片，目前在single-parameter组件中被imageSetting按钮事件调用。之后考虑在该按钮产生的弹窗组件被调用。\n\n函数中首先根据自适应要求调整长宽，将图片设置为canvas背景并渲染，生成对应Image实例\n\n\n# 5.3 传感器增删改查与选中\n\n# 5.3.1 选中传感器\n\nselectSensor(*element*){}方法用以将传感器选中，使其他组件得知当前选中的传感器且在视觉上特殊显示。通过该服务的target存储选中的传感器，并在选中传感器方法中恢复之前target目标的显示以及突出显示当前target，重新渲染canvas。\n\n# 5.3.2 查找传感器\n\ninquireSensor(*name*: string){}通过遍历canvas里的object，比照name属性，调用selectSensor(element)以选中传感器。在single-parameter组件中被inquireSensor按钮事件调用，通过返回值进行查询结果提示。\n\n# 5.3.3 添加传感器\n\naddSensor(*name*?: string) {}方法用以增加传感器，并选中刚创建的传感器。在single-parameter组件中被createSensor按钮事件调用。在确定当前数据源传感器信息存在该传感器ID以及查询该传感器不存在于canvas中后调用该方法。\n\n# 5.3.4 删除传感器\n\ndeleteSensor(){}方法用以删除传感器，因为选中的传感器信息存储于fabric服务中，直接通过this.target获取，所以不用传入参数。在single-parameter组件中被deleteSensor按钮事件调用。\n\n# 5.3.5 修改传感器\n\nmodifySensor(*name*: string){}方法用以修改传感器的name属性，在single-parameter组件中被saveSensor按钮事件调用。\n\n\n# 5.4 鼠标传感器事件\n\n# 5.4.1 双击选中事件\n\nthis.canvas.on('mouse:dblclick', (*options*) =>{}双击选中时间不仅要调用选中传感器的selectSensor(*options*.target)，同时要把editMode调整为false，从编辑状态改为查看状态\n\n# 5.4.2 滑动触发名字事件\n\nthis.canvas.on('mouse:over', (*options*) => {}因为背景图片也是一个对象所以要判断对象类型。在判断对象类型后添加一个sensorName和sensorParam的Text类实例对象显示传感器ID与中文名，重新渲染canvas\n\nthis.canvas.on('mouse:out', (*options*) =>{}删除之前添加的实例对象，重新渲染canvas\n\n\n# 5.5 保存canvas信息\n\nsaveCanvas(){}首先确定保存时的显示设备尺寸是否标准，之后可能存在的多余文字显示与选中状态移除，然后存入浏览器的localStorage中。后续存入后端数据库则在别的地方实现\n\n\n# 5.6 读取保存canvas信息\n\nreadCanvas(*source*){}首先判断浏览器localStorage是否存在该数据源的canvas信息，如果不存在读取项目自带的JSON，否则则读取浏览器中JSON。\n\n由于从项目或者后端获取的JSON存在显示设备尺寸不一的情况，adaptiveJson(*json*) {}用以读取内容后自适应屏幕尺寸。\n\n\n# 6 sensor-info 传感器信息处理服务\n\n为了能够动态配置存储使用传感器的一系列相关信息（中文名、单位、报警信息等）开发了sensor-info服务，该服务作为整个项目的底层为后续数据接收的signalR、界面渲染、以及传感器信息修改提供基础\n\n\n# 6.1 从项目获取传感器信息\n\nreset(){}目前是从前端项目的打包文件里获取，将全部传感器信息存放在sensorInfo中，将数据源列表存在sourceList中，之后调用getInfo(){}\n\n\n# 6.2 传感器信息整理存储\n\ngetInfo(){}将不同数据源的传感器信息、状态传感器列表、算法传感器列表、高频传感器列表变为对象分别存在sensorDict、statusList、algorithmList、highFrequencyList中\n\n\n# 6.3 确定当前输出信息源\n\nsetSource(source:string) {}通过传入的source确定用于输出的source、currentSensorDict、currentStatusList、currentAlgorithmList、currentHighFrequencyList。在组件DashboardLayoutComponent中通过switchSource(source){}触发已获得tab切换时同时切换其他地方数据源的功能\n\n\n# 6.4 更新传感器信息\n\nrefesh(info:Object){}通过传入的info改变sensorInfo与sourceList，然后调用getInfo()重新存储传感器信息，并将传感器信息固化存储在服务器中。在SensorInfoModalComponent组件中通过子组件上传事件触发的refreshSensorInfo(*info*: Object) {}触发\n\n\n# 7 algorithm阈值算法处理服务\n\n为了分离数据接收的signalR服务和各传感器的阈值报警分析，开发了AlgorithmService服务，该服务需要SensorInfoService提供服务，并给后续的SignalRService提供服务\n\n\n# 7.1 ParamsList类\n\ninterface ParamsList {\n  paraName: string;  //传感器型号\n  chineseName: string; //传感器中文名\n  time: string; //时间\n  unit: string; //传感器单元\n  numericalValue: number; //当前时刻传感器数据\n  statusBar: string; //传感器状态（颜色）\n  description: string; //报警信息\n  result: any; //诊断结果\n  operation: any; //操作建议\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n将传感器信息按照ParamsList类存储\n\n\n# 7.2 单个传感器阈值判断\n\njudgeStatus(*value*: number, *ID*: string, *SensorDict*: Object) {}迭代输入ID对应的传感器的报警列表，根据limitType对输入的值与limitValue进行对比，返回一个列表[传感器状态,报警信息,诊断结果,操作建议]\n\n\n# 7.3 诊断结果、决策去重累计显示\n\njudgeAdd(*showList*: any, *addList*: any, *num*: number) {}showList是用于存储显示的列表，addList是需要增加进去的列表，num是showList能够存储的个数\n\n\n# 7.4 数据总处理\n\ndataProcess(*key*, *value*: number, *time*: string, *SensorDict*: Object, *statusList*: Array<string>,*dataList*: ParamsList[], *panelData*: Object, *errorList*: ParamsList[],*errorIDList*: Object, *resultList*: Array<string>, *operationList*:Array<string>, *ERROR*: Array<string>) {}\n\nkey为传感器型号，value为当前传感器值，time为时间，SensorDict为传感器信息字典，statusList为常现传感器列表，dataList为全部传感器信息列表，panelData为常现传感器数据列表，errorList报警信息数据列表，errorIDList报警传感器列表，resultList诊断结果显示列表，operationList操作建议显示列表，ERROR为历史故障信息列表\n\n\n# 8 signalR实时数据接收服务\n\n\n# 8.1 定期固化上传error信息\n\nuploadERROR() {}通过http的post请求把存储的ERROR传给后端，并且将其清零\n\n\n# 8.2 连接signalR与持续监听的数据\n\nconnect() {}目前只有传感器数据传输通过for (const source of this.sensor.sourceList) {}迭代数据源，连接到对应数据源的signalR通道，迭代每次传来的数据中的传感器ID，调用algorithm.dataProcess(key, RawData[key], RawData[\"Time\"],this.sensor.sensorDict[source], this.sensor.statusList[source] , dataList, panelData,errorList, errorIDList, resultList, operationList,this.ERROR)，并将数据存入sensorData、ListOfData、PanelData、errorID、ListOfError、ListOfResult、ListOfOperation\n\n\n# 8.3 constructor(){}\n\n构造器中首先获取之前存在浏览器中的固化历史抱紧信息，然后建立signalR的hub，然后调用connect() {}\n\n\n# 8.4 输出数据源选择\n\nsetSource(*source*) {}通过传入的source，切换用于输出的currentSensorData、currentListOfData、currentPanelData、currentErrorID、currentListOfError、currentListOfResult、currentListOfOperation。在组件DashboardLayoutComponent中通过switchSource(source){}触发已获得tab切换时同时切换其他地方数据源的功能\n\n\n# 9 个人信息设置\n\n\n# 10 主视图设置\n\n\n# 11 传感器信息修改\n\n\n# 12 历史数据查看与下载",normalizedContent:"> 本系列旨在以实验室大屏智能监测系统为原型，将开发中使用的技术归纳梳理，记录从头开发类似项目的过程。原型项目实际开发过程中存在很多试错勉强能用的代码，在本次开发过程中尽可能考虑周全，在了解各技术原理的基础上选择合适的方式开发\n\n本系列主要分成前端与后端两个部分。前端技术栈主要包含：angular，ng-zorro，echarts，fabric，signalr。后端技术栈主要包含：cs，python，后端使用的框架包括asp.net core，abp，identityserver，部署技术使用docker，操作系统包括windows和linux，后端开发主要框架为abp。同时本系列预计还包括系统开发前的功能梳理、ui设计以及系统开发后的打包上线部分。\n\n> 本系列旨在以实验室大屏智能监测系统为原型，将开发中使用的技术归纳梳理，记录从头开发类似项目的过程。原型项目实际开发过程中存在很多试错勉强能用的代码，在本次开发过程中尽可能考虑周全，在了解各技术原理的基础上选择合适的方式开发\n\n本系列主要分成前端与后端两个部分。前端技术栈主要包含：angular，ng-zorro，echarts，fabric，signalr。后端技术栈主要包含：c#，python，后端使用的框架包括asp.net core，abp，identityserver，部署技术使用docker，操作系统包括windows和linux，后端开发主要框架为abp。同时本系列预计还包括系统开发前的功能梳理、ui设计以及系统开发后的打包上线部分。\n\n\n# 1 项目基础内容\n\n\n# 1.1 启动项目\n\n# 1.1.1 项目模板下载\n\n 1. dotnet tool install -g volo.abp.cli下载abp框架，需要dotnet。这部分下载可以使用蒋师兄的装机代码从chocolatey上下载\n 2. abp new 项目名称 -u angular -dbms mysql -csf建立一个包含abp内容的前端模板，以及使用mysql为数据库的后端模板\n\n\n\n下载完毕后会生成两个文件夹，angular是前端文件夹，aspnet-core是后端文件夹\n\n# 1.1.2 项目配置修改\n\n 1. docker run --name 容器名 -p 3306:3306 -e mysql_root_password=数据库密码 -d mysql:latest通过docker启动数据库，其中3306:3306前一个是本机访问mysql的端口，后一个是docker镜像内部端口，不建议改\n 2. 修改后端中数据库连接配置\n\n在 httpapi.host文件夹里的appsetting.json修改以下内容\n\n \"connectionstrings\": {\n    \"default\": \"server=localhost;port=3306;database=数据库名称;uid=root;pwd=数据库密码;\"\n  },\n\n\n1\n2\n3\n\n\n在dbmigrator里的appsetting.json数据库修改以下内容\n\n\"connectionstrings\": {\n    \"default\": \"server=localhost;port=3306;database=数据库名称;uid=root;pwd=数据库密码;\"\n  },\n\n\n1\n2\n3\n\n 3. cd dashboard.dbmigrator然后执行dotnet run迁移数据库\n\n\n\n 4. 启动httpapi.host就可以开启swagger，证明后端已开启\n\n\n\n 5. 进去前端文件夹yarn从package.json中下载依赖项\n 6. yarn satrt开启项目，在本机4200端口就可以看到启动的前端网页\n\n\n\n> 如果你和我一样有其他的angular项目，就需要修改一下端口。因为angular项目的默认端口都是4200，会存在冲突问题。\n\n 7. 在前端src/enviroments里的两个ts文件做同样的修改\n\nconst baseurl = 'http://localhost:你希望的端口号';\n\n\n1\n\n\n 8. 在package.json文件中修改\"start\": \"ng serve --open --port 你希望的端口号\",\n\n 9. 保存之后你会发现你的前端报错了，这是因为后端写的端口号是原先默认的4200，所有我们需要对后端做同样的处理。找到之前修改过的两个appsetting.json文件，将其中的4200改成你修改后的端口号，重新启动项目。前端网页刷新后又会显示原先的页面，证明你已经将端口号修改好了\n\n\n# 1.2 项目目录介绍\n\n# 1.2.1 前端项目目录介绍\n\n\n\n> 本人对webpack打包还有前端自动化测试方面的内容一知半解，所以这里只介绍一些与内容直接相关的文件\n\n * node_modules\n\n是你yarn之后下载下来的依赖项，开发过程中可以不用管，你对这个文件夹的修改一般只会来自npm包下载和卸载，不要手动去修改里面的内容\n\n * src：前端开发的内容都在里面\n\n * app：前端开发的组件，服务等实际的页面内容和页面逻辑\n   \n   * home：abp帮你写好的首页组件\n   \n   * shared：一般多个组件共用的东西放在里面，比如之后会用到的服务和ui库的自定义主题\n   \n   * app的三个文件:app的路由设置，组件依赖注入和app这个挂载自身ts\n   \n   * route.provider.ts：abp提供的导航栏中的路由设置\n\n * assets：静态文件存储的地方，一般放一些项目所需的图片、json文件\n\n * environments：项目的环境配置，可以在这里设置项目所用到的所有后端url以及自身的输入端口。其中prod是打包后使用的环境配置，另一个是开发阶段使用的环境配置\n\n * index.html：整个项目的入口文件，主要用来修改网页head的内容\n\n * main.ts：整个项目的ts文件，基本没改过\n\n * styles.scss：项目的总scss文件\n\n * package.json：其他的文件基本都是angular自己生成的，不会做修改。比较重要的就是这个文件，你所有的npm包操作都会反应到这个文件里，这里会记载该项目的依赖项，以及你项目开启，打包的命令。\n\n# 1.2.2 后端项目目录介绍\n\n后端项目大方向分为两个部分，一部分为c#语言包含的后端逻辑功能，一部分为python语言包含的数据诊断与发送功能\n\n# c#\n\n 1. 首先是权限管理后端，其项目文件目录结构如下所示：\n    \n    其中src为源文件文件夹，test为功能测试文件夹。使用rider打开*.sln项目，目录结构如下所示：\n    \n    其中：\n    \n    * application：后端逻辑实现，实体间映射目录\n    * contracts：接口定义以及权限定义目录\n    * domain：实体定义、权限种子数据、密码格式设置目录\n    * shared：本地化配置文件目录\n    * efcore：后端与mysql数据表联系建立\n    * dbmigrations：ef数据库管理迁移目录\n    * host：项目模块配置以及项目启动项\n\n\n# 1.3 项目需求分析\n\n# 1.3.1 前端项目需求\n\n 1.  登录、注册界面\n 2.  通过signalr获取数据，进行阈值判断，并显示状态信息\n 3.  切换数据源\n 4.  通过监视的状态信息，直接反馈到二维平面图上\n 5.  系统基础的登录、注销、权限管理\n 6.  生成报告单，并提供打印功能\n 7.  通过二维平面图获取单个数据的长期信息和诊断信息\n 8.  系统基础的查看数据库，下载数据库信息\n 9.  提供设置算法参数，并绘制算法结果图接口\n 10. 界面平面图与报警信息的前端修改\n\n# 1.3.2 后端项目需求\n\n 1. 用户登录\n 2. 实时数据\n 3. 配置文件\n 4. 算法接入\n 5. 检测报告输出\n\n\n# 1.4 ui设计\n\n> 不是专业做ui设计的，但一般做前端开发应该先在脑子里有大致的页面分配，主要页面布局，每个功能在哪个部分实现。这里为了全面展示一个系统的开发流程，就做了比较细致的ui设计。\n\n# 1.4.1 页面分配\n\n首先根据需求确定页面的个数，这里因为有原型系统，所以这里很确定一共是4个界面：登录和注册、主监视界面、检测报告界面和统计分析界面。还有一个权限管理界面，主要是应用abp框架自带的。\n\n# 风格确定\n\n页面首先应该确定颜色风格，可以先在dribbble上搜索相关的设计方案，比如我这里就搜索了dashboard，这里参考了下面这个\n\n\n\n# 具体页面参考\n\n像比较具体且通用的页面，如登录等可以在b站上搜索一下例子。一是可以快速了解流行的页面样式；二是这种一般是纯html和css写成的，各种框架都可以应用；三是这种一般会带着你写，让你更容易理解和修改代码。\n\n我这里参考了\n\n\n\n\n\n这两个登录界面，我主要关注的前端样式up有总监日记、山羊の前端小窝、阿阳热爱前端，还有一个设计类的up主子牧说。\n\n# 页面设计\n\n我这里使用的figma，主要考虑到它可以直接导出css样式，可以有效减少前端的工作。另外就是可以多人协作，发送连接给别人就可以共享，比较方便。figma的操作还是比较简单的，有些基础的原理可以参考原先邓师兄的ps教程。如果需要可以看一下ui教程 | 手把手教你用figma做ui界面设计_哔哩哔哩_bilibili，基本你需要什么到里面找就可以了\n\n最后的设计方案\n\n![登录界面](https://pic.imgdb.cn/item/61bf258a2ab3f51d91a1c27a.jpg\n\n设计的连接在这里dashboard – figma\n\n# 主题颜色\n\n背景色#f2f7ff\n\n主题色#9590c7\n\n装饰色 #c4d3f9 #51459e #f2f7ff\n\n状态色 #84e8f4 #fcbe30 #41b674 文字色 #000000 #9ca0ab #ffffff\n\n> 本篇文章内容全部是前端开发内容，主要包括监测主界面生成、项目初始化开发与登录界面的开发。\n> 主要的技术点有：angular新页面生成、ui库依赖使用、响应式布局基础、angular组件、登录界面css、修改ui库样式、angular表单、angular http请求、angular/abp用户登录、angular服务\n> 因为系列是前端开发的第一篇文章，命令行与css都会介绍得比较详细，后续文章没有很特殊的不会再做介绍\n\n\n# 2 angular页面开发基础\n\n\n# 2.1 监测主界面生成\n\n> 介绍如何一步步在angular中生成一个新页面，了解angular的依赖注入\n\n# 2.1.1 angular页面包含内容\n\n参考home文件夹，可以发现angular一个页面需要至少有5个文件，其中有component存在的html、scss、ts属于home组件的内容。home.module.ts是保存home页面使用的组件的文件。home-routing.module.ts是app通过路由确定到home页面的文件。\n\n\n\n# 2.1.2angular cli生成命令\n\n# 生成dashboard.module.ts文件\n\n我们直接在醒目的路径下使用ng generate module dashboard，就会生成一个叫dashboard的文件夹，里面包含一个dashboard.module.ts文件。使用命令生成的module会自动生成一些依赖内容。\n\n# 生成dashboard.component的三个文件\n\n使用cd src\\app\\dashboard命令，转到对应的dashboard文件夹，再使用ng generate component dashboardlayout生成一个dashboardlayout组件。这里为了方便理解使用了不同的组件名称，为了方便一个页面多组件之后查看我也一般会把一个页面的根组件命名为layout\n\n# 生成dashboard-routing.module.ts文件\n\n在dashboard目录下，使用ng generate module dashboardrouting生成dashboard-routing.module.ts，可以把其从文件夹中取出来\n\n# 2.1.3 angular各文件之间的依赖、引入、声明补充\n\n# dashboard.module.ts\n\n将dashboard-routing.module引入\n\nimport { dashboardroutingmodule } from './dashboard-routing.module';\n\n@ngmodule({\n  declarations: [\n    dashboardlayoutcomponent\n  ],\n  imports: [\n    commonmodule,\n    dashboardroutingmodule,\n  ]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这里的dashboardlayoutcomponent是生成的时候会自动补充的\n\n# dashboard-routing.module.ts\n\n按照home-routing.module.ts修改\n\nimport { ngmodule } from '@angular/core';\nimport { routes, routermodule } from '@angular/router';\nimport { dashboardlayoutcomponent } from './dashboard-layout/dashboard-layout.component';\n\nconst routes: routes = [{ path: '', component: dashboardlayoutcomponent }];\n\n@ngmodule({\n  imports: [routermodule.forchild(routes)],\n  exports: [routermodule],\n})\nexport class dashboardroutingmodule { }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# app.module.ts\n\n将dashboard import进来\n\n@ngmodule({\n  imports: [\n      此处省略\n    dashboardmodule,\n  ],\n    此处省略\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# app-routing.module.ts\n\n添加app路由\n\n{\n    path: 'dashboard',\n    pathmatch: 'full',\n    loadchildren: () => import('./dashboard/dashboard.module').then(m => m.dashboardmodule),\n  },\n\n\n1\n2\n3\n4\n5\n\n\n完成以上步骤就可以通过理由跳转到新的页面了\n\n# route.provider.ts\n\n这里添加主页上的跳转按钮，修改初始样式。这里为了方便后续布局使用的是空样式\n\nroutesservice.add([\n      {\n        path: '/dashboard',\n        name: '::监视主屏',\n        iconclass: 'fas fa-home',\n        order: 1,\n        layout: elayouttype.empty\n      },\n    ]);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2.2 页面尺寸响应式基础\n\n> 这种监测大屏不存在响应式适配手机的需求，只需要适配不同分辨率的显示屏以及pad。所以这里没有考虑手机的适配，基本按照16:9等比例缩放。以后可以做手机适配的优化\n\n在这样的前提下，项目使用rem对宽高、字体大小进行限值，通过设备窗口对项目html的font-size进行调节即可。\n\n我们在main.ts里添加如下内容即可\n\nfunction remsize() {\n  const devicewidth = document.body.clientwidth\n  // 在1920px宽的设计稿里10px=1rem\n  document.documentelement.style.fontsize = (devicewidth / 192) + 'px'\n}\n//已启动项目就执行remsize\nremsize()\n//项目窗口变化就执行remsize\nwindow.onresize = () => {\n  remsize()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在dashboard-layout.component.html里验证响应式，\n\n<div style=\"font-size: 3rem;height: 96rem;width: 96rem;background-color: aqua;\">\n    新页面测试代码\n</div>\n\n\n1\n2\n3\n\n\n\n\n该方块会一直是一个占据半边宽度的正方形\n\n\n# 2.3 引入ui库\n\n> 原本是准备使用vue、react都可以使用的element ui的，但其适配angular的版本是8以前的，目前angular已经更新到12了。所以使用了官方推荐且适配较好的ng-zorro。\n> 各类ui库都会提供大量的交互组件，避免你从头开发。在开发具体页面前建议先看一下使用的ui库都提供了哪些组件，组件效果是什么样的，这样可以在你拿到页面需求的时候能快速反应有没有现成的组件可用。\n\n# 2.3.1 安装ng-zorro\n\nyarn add ng-zorro-antd\n\nng add ng-zorro-antd\n\n使用上述命令后会自动配置一些需要的内容\n\n# 2.3.2 全局配置\n\n在angular.json中添加\"src/theme.less\"\n\n\"styles\": [\n              \"src/theme.less\",\n    此后省略\n\n\n1\n2\n3\n\n\n# 2.3.3 模块配置\n\n在全局配置的ng-zorro无法直接使用，还是需要在对应的模块进行配置。这里为了检验ng-zorro引入成功在dashboard.module.ts文件中引入nzbuttonmodule\n\nimport { nzbuttonmodule } from 'ng-zorro-antd/button';\n@ngmodule({\n  declarations: [\n    dashboardlayoutcomponent\n  ],\n  imports: [\n    commonmodule,\n    dashboardroutingmodule,\n    nzbuttonmodule\n  ]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在dashboard-layout.component.html里测试ng-zorro的使用\n\n<button nz-button nztype=\"primary\">primary button</button>\n\n\n1\n\n\n\n\n这里截的图是修改主题色之后的，原本应该是蓝色。按钮自带颜色，有点击动效证明ng-zorro的nzbuttonmodule可以使用了\n\n# 2.3.4 自定义主题\n\n在theme.less文件中可以自定义主题\n\n@import \"../node_modules/ng-zorro-antd/ng-zorro-antd.less\";\n\n@primary-color: #9590c7;\n@info-color:#9ca0ab;\n@body-background:#f2f7ff;\n@error-color:#fc5b5d;\n@warning-color:#fcbe30;\n@processing-color:#84e8f4;\n@success-color:#41b674;\n@normal-color:#51459e;\n@text-color:#9ca0ab;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这里根据ui设计定义了一下颜色，后续可能还会根据需要进行调整。像vue比较常用的element ui是可以可视化定义主题的，会比ng-zorro要更好用一些。\n\n这个网址可以看到所有可以自定义的内容\n\n\n# 3 登录页面开发\n\n\n# 3.1 登录页面布局开发\n\n# 3.1.1 登录页面模块划分\n\n根据业务逻辑将登录页面划分成了四个部分，1是登录的表单，2是注册的表单，3是用来遮盖的翻转图片，4是点击后浮动到页面上的重置密码弹窗。于是将登录页面划分成了四个组件：reset-modal负责重置密码弹窗、login-form负责登录表单、sign-up-form负责注册表单、loginlayout是登录页面的根，负责整体布局和遮盖翻转图片逻辑\n\n\n\n\n\n# 3.1.2 登录页面生成\n\n按照前文主页面生成的方法生成登录页面，一并生成登录表单与注册表单组件\n\n# 3.1.3 loginlayout组件开发\n\n> 该组件要实现的功能是登录页面整体布局：登录框水平垂直居中，图片翻转遮盖\n\n# 整体布局\n\n页面通过.backgroud的div实现设计图背景颜色和后续子元素.container div页面水平垂直居中\n\n.background {\n    //flex布局，子元素水平垂直居中\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    //背景颜色\n    background-color: #c4d3f9;\n    //保证页面大小占满屏幕\n    width: 100%;\n    height: 100%;\n}\n.container {\n    //登录页面核心部分颜色，大小，阴影\n    background-color: #f2f7ff;\n    width: 115rem;\n    height: 60rem;\n    box-shadow: 0.5rem 1rem 1rem 0.2rem rgba(0, 0, 0, 0.3);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n通过.cover的div放置遮挡用的图片，以及上面的文字。与.container组成子绝父相\n\n.container {\n    position: relative;\n}\n.container .cover{\n    //确定图片初始位置\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 80rem;\n    height: 100%;\n    z-index: 98;\n    //图片层样式，颜色后续可以删掉\n    background-color: aquamarine;\n    filter: drop-shadow(0.5rem 0px 1rem rgba(0, 0, 0, 0.25));\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n通过.forms的div嵌套两个div，分别嵌入两个组件，将用于翻转图片的内容放在组件外面。这里设置background-color是为了在初步构建代码时直观看到各个盒子的位置\n\n.forms .signupform{\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 35rem;\n    height: 100%;\n    background-color: blueviolet;\n  }\n.forms .loginform{\n    position: absolute;\n    top: 0;\n    left: 80rem;\n    width: 35rem;\n    height: 100%;\n    background-color: blueviolet;\n\n}\n.forms .signupform, .forms .loginform {\n\t//flex布局，子元素水平垂直居中\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 图片翻转\n\n> 图片翻转是通过一个不在页面上显示的#flip的checkbox完成的\n\n.cover整体翻转。.container #flip:checked是选择#flip这个元素被选中；~ 选择前面选择元素的后续兄弟元素；这样再.cover就是#flip这个元素被选中时.cover元素要执行的css样式了\n\n.container {\n    //元素距离视图的距离，翻转时z轴最高高度\n    perspective: 280rem;\n}\n\n.container .cover{\n    //动画样式相关设置\n    transition: all 0.8s ease;\n    //翻转轴位置\n    transform-origin: 71.875%;\n    transform-style: preserve-3d;\n  }\n\n.container #flip:checked ~ .cover{\n    transform: rotatey(180deg);\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n但这样直接翻转会导致，图片和上面的文字翻转后颠倒。所以要把.cover分成两个面，分别显示。本来应该使用backface-visibility: hidden;来隐藏背面，但不知为何我的浏览器显示有这个样式，但没有这个效果。所以只能退而求其次，使背面元素display:none不渲染\n\n//正面设置\n.container .cover .front {\n\twidth: 100%;\n    height: 100%;\n    background-image: url(~src/assets/login.jpg);\n    background-size: 100% 100%;\n    background-repeat:no-repeat;\n}\n.container #flip:checked ~ .cover .front {\n    display:none\n}\n//背面设置\n.container .cover .back{\n    width: 100%;\n    height: 100%;\n    background-image: url(~src/assets/login.jpg);\n    background-size: 100% 100%;\n    background-repeat:no-repeat;\n    transform: rotatey(180deg);\n    display:none\n}\n.container #flip:checked ~ .cover .back {\n    display:flex\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n还有一些文字样式就不一一介绍了\n\n# 3.2.4 login-form组件开发\n\n表单组件在ng-zzoro有相应的组件了，使用和前文一样的方法把nzformmodule配置进来。但为了更好的自定义样式，没有引入nzinputmodule和nzbuttonmodule，而是自己写的样式\n\n# 表单\n\n在对应的module导入import { formsmodule, reactiveformsmodule } from '@angular/forms';\n\n对应ts中引入import { formbuilder, formcontrol, formgroup, validators } from '@angular/forms';并定义表单\n\nloginform = new formgroup({\n\tusername: new formcontrol('', [validators.required]),\n    password: new formcontrol('', [validators.required]),\n})\n\n\n1\n2\n3\n4\n\n\n<form nz-form [formgroup]=\"loginform\">\n\t<nz-form-item>\n\t\t<nz-form-control nzerrortip=\"用户名不能为空\">\n\t\t\t<input type=\"text\" formcontrolname=\"username\" placeholder=\"用户名\" />\n\t\t</nz-form-control>\n\t</nz-form-item>\n  \n\t<nz-form-item>\n\t\t<nz-form-control nzerrortip=\"密码至少6位且包含小写字母与数字\">\n\t\t\t<input type=\"password\" formcontrolname=\"password\"\t\t\t</nz-form-control>\n\t</nz-form-item>\n\n  <button>登录</button>\n</form>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n[formgroup]设置整个表单名称，在ts需要定义这个名称，后续也用这个名称接收整个表单数据\n\nformcontrolname设置单个输入对应的键，实现双向绑定\n\n# 修改ui库样式\n\n除去在自定义主题里修改ui库里的样式，我们遇到具体的ui库样式不合要求时可以直接不配置ui库，比如下面的input，也可以使用ng-deep修改，比如下面的.ant-form-item-explain.ant-form-item-explain-error。\n\ninput{\n\twidth: 100%;\n\toutline: none;\n\tborder: 0;\n    border-bottom: 0.25rem solid rgba(81, 69, 158, 0.58);\n    background-color: transparent;\n}\n:host ::ng-deep .ant-form-item-explain.ant-form-item-explain-error{\n\tfont-size: 1.2rem;\n    color: #f9896b;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n遇到引入ui库导致的样式不合适时，使用f12，查看是哪个部分的样式在起作用，用浏览器更改后有效果，就可以复制其css选择器，在前面添上\n\n深度选择器\n\n:host ::ng-deep就可以在本文件作用域下修改ui组件库样式，添上**::ng-deep**就会使修改的样式全局生效\n\n# 伪类选择器添加图形\n\n在登录两个字下面添加了一个小方块儿，使用伪类选择器也是常规操作了\n\n.name::before{\n\tcontent: \"\";\n\tposition: absolute;\n\tleft: 0;\n\tbottom: 0rem;\n\theight: 0.5rem;\n\twidth: 3rem;\n\tbackground-color: #b1abed;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 3.2.5 sign-up-form组件\n\n这个组件内容与login-form组件基本一致，就是添加了一个email输入。后续考虑是否将两个合并到一个里面去，使用传参来动态修改组件内容\n\n# 3.2.6 reset-modal组件\n\n由于这个组件的点击文字分配在了登录按钮之上，所以把该组件作为login-form组件的子组件开发。组件内容与sign-up-form组件一致，其部分样式与在login-form打开弹窗里定义，在介绍业务逻辑时进行纤细说明。\n\n\n# 3.2 登录页面业务逻辑\n\n# 3.2.1 打开重置密码弹窗\n\n这部分使用ng-zorro提供的服务，将弹窗里的内容抽象成一个组件打开\n\n首先要在拥有打开弹窗逻辑的组件里引入依赖import { nzmodalservice } from 'ng-zorro-antd/modal';\n\n然后在对应打开弹窗的地方绑定事件逻辑，并编写处理的逻辑\n\nresetmodal() {\n\tconst modal = this.modal.create({\n        //定义弹窗标题\n\t\tnztitle: '找回密码',\n        //定义弹窗主体的组件\n\t\tnzcontent: resetmodalcomponent,\n        //定义弹窗尾部\n\t\tnzfooter: [\n        //定义取消按钮，点击后摧毁弹窗\n\t\t\t{\n\t\t\t\tlabel: '取消',\n\t\t\t\tonclick: () => modal.destroy()\n\t\t\t},\n\t\t//定义确认按钮，点击确认后执行组件里的reset方法\n\t\t\t{\n\t\t\t\tlabel: '确认',\n\t\t\t\ttype: 'primary',\n\t\t\t\tloading: false,\n\t\t\t\tonclick(component): void {\n\t\t\t\t\tthis.loading = true;// 让提交按钮显示加载动画，防止重复提交\n\t\t\t\t\tsettimeout(() => {\n\t\t\t\t\t\tthis.loading = false\n\t\t\t\t\t}, 3000)\n\t\t\t\tcomponent.reset();\n\t\t\t\t}\n\t\t\t},\n\t\t],\n\t\tnzwidth: 40 * this.rem\n    });\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 3.2.2 确定表单内容\n\n这个方面需要和后端进行协同，首先要弄清楚登录、注册、找回密码都需要向后端传输哪些信息。这些信息里哪些是用户输入的，这一部分需要在界面上提供输入；哪些是系统自动传输的，这一部分需要自己在前端代码中定义。而且沟通的时候也要确定好数据的类型和要求，方便后续进行表单验证。\n\n# 3.2.3 表单验证逻辑\n\n# angular自带的表单验证\n\nangular自带的表单验证可以验证常规的邮箱、电话号码和正则表达式，在创建表单组的时候定义其需要验证的逻辑即可。以注册表单为例，实例化formcontrol对象时传入的第一个参数是这个量的初始值，第二个参数是采取的表单验证逻辑。validators.required是这个量不能为空，validators.email是这个量格式为邮箱，validators.pattern则是这个量要满足后面的正则表达式\n\nsignupform = new formgroup({\n    username: new formcontrol(null, [validators.required]),\n    email: new formcontrol(null, [validators.required, validators.email]),\n    password: new formcontrol(null, [validators.required, validators.pattern(/^(?![0-9]+$)(?![a-za-z]+$)[0-9a-za-z]{6,10}$/)]),\n})\n\n\n1\n2\n3\n4\n5\n\n\n# 自定义的表单验证\n\n业务上存在angular自带的表单验证无法覆盖的内容，比如重置密码的时候第二次输入的密码应该与第一次一致。这个时候就需要自定义一个表单验证逻辑。这里就定义了一个新的表单验证逻辑confirmvalidator，为了能够展示不同的两种信息所以设计了两种状态值error和required。\n\nconfirmvalidator = (control: formcontrol): { [s: string]: boolean } => {\n\tif (!control.value) {\n\t\treturn { error: true, required: true };\n    } else if (control.value !== this.resetform.controls.password.value) {\n\t\treturn { confirm: true, error: true };\n    }\n    return {};\n};\n\nresetform = new formgroup({\n\tusername: new formcontrol(null, [validators.required]),\n\temail: new formcontrol(null, [validators.required, validators.email]),\n    password: new formcontrol(null, [validators.required, validators.pattern(/^(?![0-9]+$)(?![a-za-z]+$)[0-9a-za-z]{6,10}$/)]),\n    password1: new formcontrol(null, [this.confirmvalidator]),\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 3.2.4 表单提交逻辑\n\n# 表单数据回收\n\n因为和后端定义的关于权限部分的http请求全部使用post，所以这里都使用直接定义对象来回收表单数据，将表单组的对应值直接幅值到后端定义的对象中。这里因为this.resetform是一个观察对象，和vue里的ref类似，需要使用value来获取值。\n\nlet resetform = {\n\tusername: this.resetform.value.username,\n\tuseremail: this.resetform.value.email,\n\tnewpassword: this.resetform.value.password,\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 数据提交与返回状态处理\n\nangular的自己封装了http请求的服务，不需要像vue那样引入，只要在组件里注入import { httpclient, httpheaders } from '@angular/common/http';的依赖就可以使用。对于post请求需要定义请求头。\n\n由于很多地方都需要用到后端的网址，为了应对项目落地调试时频繁修改ip的问题，这里将后端的ip定义在environment里面，通过import { accounturl } from 'src/environments/environment'来使用\n\n请求返回的内容是与后端协商确定的，根据statuscode的不同来确定后续启用的逻辑，这里成功就提示成功并关闭弹窗；不成功则提示错误信息，保留弹窗\n\ninterface responseprops {\n      statuscode: number\n      message: string\n}\n\nconst httpoptions = { headers: new httpheaders({ 'content-type': 'application/json' }) }\nlet api = accounturl + '/api/app/reset-password'\nthis.http.post(api, resetform, httpoptions).subscribe((response: responseprops) => {\n\tif (response.statuscode === 200) {\n\t\tthis.alert.messagealert('success', response.message, 3000)\n\t\tthis.nzmodalref.destroy(true);\n\t} else {\n\t\tthis.alert.messagealert('error', response.message, 3000)\n\t}\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 3.2.5 提示信息服务\n\n由于浏览器自带的alert很丑，且必须手动关闭会阻塞代码运行。结合ng-zorro封装的全局信息提示，项目创建了一个提示的服务，供全局使用\n\n使用ng generate service alert命令创建提示信息服务，将\n\nng-zorro封装的全局信息提示注入import { nzmessageservice } from 'ng-zorro-antd/message';，并且在构造函数里定义private message: nzmessageservice。\n\nmessagealert(type: string, message: string, duration: number): void {\n\tthis.message.create(type, `${message}`, { nzduration: duration });\n}\n\n\n1\n2\n3\n\n\n这样在其他组件里注入这个服务import { alertservice } from 'src/app/service/alert.service'，构造函数里定义private *alert*: alertservice，就可以直接使用this.alert.messagealert('success', response.message, 3000)\n\n# 3.2.6 登录获取保存token\n\n一般来说登录之后后端会返回token，你需要将其保存在localstorage或者sessionstorage里面。但angular与abp给你做了封装只要拿过来用就可以了。\n\n首先是要设置好登录的方式，以及给后端传的值。这部分内容在environment.ts和environment.prod.ts里设置。前者是开发的时候使用的，后者是打包的时候使用，在不涉及打包上线的时候后者完全不起作用。但为了防止你到了打包上线的时候忘记修改，最好两个一起修改\n\noauthconfig: {\n    //验证信息往哪里传\n\tissuer: accounturl,\n    //获取token的api\n    tokenendpoint: accounturl + '/connect/token',\n\t//使用token方法验证，abp默认的是跳转到后端页面上验证\n\trequestaccesstoken: true,\n    //这是后端需要给你的前端设备标识和密码\n    clientid: 'dashboard_app',\n    dummyclientsecret: '1q2w3e*',\n    //这个是目前还没做https的授权那一套先给他关掉，免得报不安全\n    requirehttps: false,\n    //你前端设备名称，是什么不重要\n    scope: 'offline_access dashboard',\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n然后将登录相关的服务注入import { oauthservice } from 'angular-oauth2-oidc'; import { authservice } from '@abp/ng.core';。构造函数定义，之后直接使用接口就可以了\n\nthis.authservice.login(user).topromise()\n\t.then(data => {\n\t\tthis.alert.messagealert('success', \"恭喜您登录成功！\", 1000)\n\t\tsettimeout(() => {\n\t\t\tthis.router.navigatebyurl('/dashboard');\n\t\t}, 1000)\n\t})\n\t.catch(() => {\n\t\tthis.alert.messagealert('error', \"您输入的用户名或密码不正确！\", 3000)\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果你发现你登录之后在localstorage里多出了很多信息证明登录获取保存token就成功了。但我们做的时候出现了一些问题，本来不注销账号刷新页面是token是会一直保留的，但我们当时出现了token不保留的bug，打印后端返回的数据后发现，只是返回了token但没有返回用户信息，修改后端代码后解决。\n\n\n# 4 导航栏与主界面布局开发\n\n三个主要的功能界面共用同一导航栏，所以将导航栏的开发放在share目录下\n\n\n# 4.1 导航栏开发\n\n# 4.1.1 导航栏布局开发\n\n导航栏(.nav)从左到右分为名称区(.title)、路由区(.router)和菜单区(.menu)。通过ng-zorro的grid栅格布局，使其分别占据页面的8/24、5/25、8/24。通过nzjustify=\"space-between\"使其合理分隔显示\n\n# 4.1.2 导航栏名称区开发\n\n名称区功能很简单，显示名称与当前时间。在组件初始化钩子函数里添加了一个1秒刷新一次的定时器用于给界面显示当前时间，html中直接使用插值语法更新显示时间\n\n# 4.1.3 导航栏路由区开发\n\n通过routerlink=\"/dashboard\"控制路由跳转，如果直接通过a标签的url跳转会出现系统页面直接刷新全部重启的问题。这会导致与后端数据接收通道的断开。\n\n# 4.1.4 导航栏菜单区开发\n\n菜单区分为算法、文件、设置和用户头像4个主体，每个主体分别存在各自的下拉菜单，实现不同的功能\n\n\n# 4.2 主界面布局开发\n\n主界面通过dashboard-layout文件夹来实现主界面布局分配，首先<app-nav></app-nav>将导航栏引入，其余按照设计图将主界面纵向分成三个部分：左侧特殊显示区（.left）、中间主体显示区（.middle）、右侧多功能区（.right）\n\n# 4.2.1 左侧特殊显示区\n\n左侧特殊显示区从上至下分为传感器仪表盘（.mainmonitor）、统计饼图（.piechart）、文字显示区（.word）\n\n# 传感器仪表盘\n\n以2x2矩阵形式排布4个传感器的信息，通过[index]参数输入绑定不同的传感器以复用status-panel组件\n\nstatus-panel组件从上至下分为状态颜色块（.status）、数字（.value）、描述（.description）\n\n# 统计饼图\n\n通过statistics组件引入一个echarts图，通过[options]=\"chartoption\"在ts文件中设置图中显示内容\n\n# 文字显示区\n\n通过description组件完成布局，在description组件里使用cardtab，将显示内容通过tab标签切换为异常参数列表（abnormal-parameters）、诊断结果（diagnostic-results）、操作建议（recommendation）\n\n# 4.2.2 中间主体显示区\n\n中间显示区包括一个类导航部分以及下方的fabric的canvas。类导航区左侧是一个通过this.fabricservice.editmode参数标志canvas状态显示提示，中间是一个切换数据源的tab、右侧是用来切换右侧多功能区的按钮。下方canvas通过tab和[source]=\"source\"达到复用main-view组件显示3个不同转向架的效果。\n\n# 4.2.3 右侧多功能区\n\n通过*ngif\"与this.fabricservice.function参数判断右侧多功能区渲染单个传感器信息（single-parameter）还是全部传感器信息（overall-parameters）\n\n# 全部传感器信息\n\noverall-parameters组件通过一个自动列表将所有传感器的信息（状态、名称、数值、单位）渲染出来\n\n# 单个传感器信息\n\nsingle-parameter组件分为传感器信息绑定显示区、时域图（time-domain-chart组件）、频域图组件（frequency-domain-chart）和两个功能按钮组成\n\n\n# 5 fabric二维图像显示服务\n\nfabric.js 是一个提供多种二维图像交互显示的库，项目中用以显示传感器的二维位置以及一系列传感器相关的交互\n\n\n# 5.1 canvas初始化\n\ninitialize(*source*: string, *width*: number, *height*: number){}方法用以初始化canvas，在main-view组件初始化中调用并传入数据源、canvas需要的自适应长宽，通过*ngfor=\"let i of this.sensor.sourcelist\"与*ngif=\"source == i\"选择当前渲染的canvas\n\n因为使用circle类作为传感器，需要该类增加一个name属性，于是在constructor中添加以下代码。\n\nconstructor(public sensor: sensorinfoservice, private http: httpclient, private alert: alertservice) {\n\tthis.editmode = false\n    // 获取之前添加的name信息\n\tfabric.circle.prototype.toobject = ((toobject) => {\n\t\treturn function () {\n            return fabric.util.object.extend(toobject.call(this), {\n                name: this.name\n            });\n        };\n    })(fabric.circle.prototype.toobject);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 5.2 设置背景图片\n\nsetbackground(*imgsrc*: string, *width*: number, *height*: number){}方法用于设置背景图片，目前在single-parameter组件中被imagesetting按钮事件调用。之后考虑在该按钮产生的弹窗组件被调用。\n\n函数中首先根据自适应要求调整长宽，将图片设置为canvas背景并渲染，生成对应image实例\n\n\n# 5.3 传感器增删改查与选中\n\n# 5.3.1 选中传感器\n\nselectsensor(*element*){}方法用以将传感器选中，使其他组件得知当前选中的传感器且在视觉上特殊显示。通过该服务的target存储选中的传感器，并在选中传感器方法中恢复之前target目标的显示以及突出显示当前target，重新渲染canvas。\n\n# 5.3.2 查找传感器\n\ninquiresensor(*name*: string){}通过遍历canvas里的object，比照name属性，调用selectsensor(element)以选中传感器。在single-parameter组件中被inquiresensor按钮事件调用，通过返回值进行查询结果提示。\n\n# 5.3.3 添加传感器\n\naddsensor(*name*?: string) {}方法用以增加传感器，并选中刚创建的传感器。在single-parameter组件中被createsensor按钮事件调用。在确定当前数据源传感器信息存在该传感器id以及查询该传感器不存在于canvas中后调用该方法。\n\n# 5.3.4 删除传感器\n\ndeletesensor(){}方法用以删除传感器，因为选中的传感器信息存储于fabric服务中，直接通过this.target获取，所以不用传入参数。在single-parameter组件中被deletesensor按钮事件调用。\n\n# 5.3.5 修改传感器\n\nmodifysensor(*name*: string){}方法用以修改传感器的name属性，在single-parameter组件中被savesensor按钮事件调用。\n\n\n# 5.4 鼠标传感器事件\n\n# 5.4.1 双击选中事件\n\nthis.canvas.on('mouse:dblclick', (*options*) =>{}双击选中时间不仅要调用选中传感器的selectsensor(*options*.target)，同时要把editmode调整为false，从编辑状态改为查看状态\n\n# 5.4.2 滑动触发名字事件\n\nthis.canvas.on('mouse:over', (*options*) => {}因为背景图片也是一个对象所以要判断对象类型。在判断对象类型后添加一个sensorname和sensorparam的text类实例对象显示传感器id与中文名，重新渲染canvas\n\nthis.canvas.on('mouse:out', (*options*) =>{}删除之前添加的实例对象，重新渲染canvas\n\n\n# 5.5 保存canvas信息\n\nsavecanvas(){}首先确定保存时的显示设备尺寸是否标准，之后可能存在的多余文字显示与选中状态移除，然后存入浏览器的localstorage中。后续存入后端数据库则在别的地方实现\n\n\n# 5.6 读取保存canvas信息\n\nreadcanvas(*source*){}首先判断浏览器localstorage是否存在该数据源的canvas信息，如果不存在读取项目自带的json，否则则读取浏览器中json。\n\n由于从项目或者后端获取的json存在显示设备尺寸不一的情况，adaptivejson(*json*) {}用以读取内容后自适应屏幕尺寸。\n\n\n# 6 sensor-info 传感器信息处理服务\n\n为了能够动态配置存储使用传感器的一系列相关信息（中文名、单位、报警信息等）开发了sensor-info服务，该服务作为整个项目的底层为后续数据接收的signalr、界面渲染、以及传感器信息修改提供基础\n\n\n# 6.1 从项目获取传感器信息\n\nreset(){}目前是从前端项目的打包文件里获取，将全部传感器信息存放在sensorinfo中，将数据源列表存在sourcelist中，之后调用getinfo(){}\n\n\n# 6.2 传感器信息整理存储\n\ngetinfo(){}将不同数据源的传感器信息、状态传感器列表、算法传感器列表、高频传感器列表变为对象分别存在sensordict、statuslist、algorithmlist、highfrequencylist中\n\n\n# 6.3 确定当前输出信息源\n\nsetsource(source:string) {}通过传入的source确定用于输出的source、currentsensordict、currentstatuslist、currentalgorithmlist、currenthighfrequencylist。在组件dashboardlayoutcomponent中通过switchsource(source){}触发已获得tab切换时同时切换其他地方数据源的功能\n\n\n# 6.4 更新传感器信息\n\nrefesh(info:object){}通过传入的info改变sensorinfo与sourcelist，然后调用getinfo()重新存储传感器信息，并将传感器信息固化存储在服务器中。在sensorinfomodalcomponent组件中通过子组件上传事件触发的refreshsensorinfo(*info*: object) {}触发\n\n\n# 7 algorithm阈值算法处理服务\n\n为了分离数据接收的signalr服务和各传感器的阈值报警分析，开发了algorithmservice服务，该服务需要sensorinfoservice提供服务，并给后续的signalrservice提供服务\n\n\n# 7.1 paramslist类\n\ninterface paramslist {\n  paraname: string;  //传感器型号\n  chinesename: string; //传感器中文名\n  time: string; //时间\n  unit: string; //传感器单元\n  numericalvalue: number; //当前时刻传感器数据\n  statusbar: string; //传感器状态（颜色）\n  description: string; //报警信息\n  result: any; //诊断结果\n  operation: any; //操作建议\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n将传感器信息按照paramslist类存储\n\n\n# 7.2 单个传感器阈值判断\n\njudgestatus(*value*: number, *id*: string, *sensordict*: object) {}迭代输入id对应的传感器的报警列表，根据limittype对输入的值与limitvalue进行对比，返回一个列表[传感器状态,报警信息,诊断结果,操作建议]\n\n\n# 7.3 诊断结果、决策去重累计显示\n\njudgeadd(*showlist*: any, *addlist*: any, *num*: number) {}showlist是用于存储显示的列表，addlist是需要增加进去的列表，num是showlist能够存储的个数\n\n\n# 7.4 数据总处理\n\ndataprocess(*key*, *value*: number, *time*: string, *sensordict*: object, *statuslist*: array<string>,*datalist*: paramslist[], *paneldata*: object, *errorlist*: paramslist[],*erroridlist*: object, *resultlist*: array<string>, *operationlist*:array<string>, *error*: array<string>) {}\n\nkey为传感器型号，value为当前传感器值，time为时间，sensordict为传感器信息字典，statuslist为常现传感器列表，datalist为全部传感器信息列表，paneldata为常现传感器数据列表，errorlist报警信息数据列表，erroridlist报警传感器列表，resultlist诊断结果显示列表，operationlist操作建议显示列表，error为历史故障信息列表\n\n\n# 8 signalr实时数据接收服务\n\n\n# 8.1 定期固化上传error信息\n\nuploaderror() {}通过http的post请求把存储的error传给后端，并且将其清零\n\n\n# 8.2 连接signalr与持续监听的数据\n\nconnect() {}目前只有传感器数据传输通过for (const source of this.sensor.sourcelist) {}迭代数据源，连接到对应数据源的signalr通道，迭代每次传来的数据中的传感器id，调用algorithm.dataprocess(key, rawdata[key], rawdata[\"time\"],this.sensor.sensordict[source], this.sensor.statuslist[source] , datalist, paneldata,errorlist, erroridlist, resultlist, operationlist,this.error)，并将数据存入sensordata、listofdata、paneldata、errorid、listoferror、listofresult、listofoperation\n\n\n# 8.3 constructor(){}\n\n构造器中首先获取之前存在浏览器中的固化历史抱紧信息，然后建立signalr的hub，然后调用connect() {}\n\n\n# 8.4 输出数据源选择\n\nsetsource(*source*) {}通过传入的source，切换用于输出的currentsensordata、currentlistofdata、currentpaneldata、currenterrorid、currentlistoferror、currentlistofresult、currentlistofoperation。在组件dashboardlayoutcomponent中通过switchsource(source){}触发已获得tab切换时同时切换其他地方数据源的功能\n\n\n# 9 个人信息设置\n\n\n# 10 主视图设置\n\n\n# 11 传感器信息修改\n\n\n# 12 历史数据查看与下载",charsets:{cjk:!0},lastUpdated:"2023/07/31, 19:25:37",lastUpdatedTimestamp:1690802737e3},{title:"Electron-vue桌面端开发总结",frontmatter:{title:"Electron-vue桌面端开发总结",date:"2023-07-31T17:10:10.000Z",permalink:"/pages/a1eaa9/",categories:["前端","开发文档"],tags:["Vue","Electron","NodeJS"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/40.%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/05.Electron-vue%E6%A1%8C%E9%9D%A2%E7%AB%AF%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93.html",relativePath:"01.前端/40.开发文档/05.Electron-vue桌面端开发总结.md",key:"v-1804787e",path:"/pages/a1eaa9/",headers:[{level:2,title:"1 网络文件下载至指定地点",slug:"_1-网络文件下载至指定地点",normalizedTitle:"1 网络文件下载至指定地点",charIndex:2},{level:3,title:"1.1 使渲染进程使用NodeJS",slug:"_1-1-使渲染进程使用nodejs",normalizedTitle:"1.1 使渲染进程使用nodejs",charIndex:20},{level:3,title:"1.2 使用NodeJS的fs模块与axios请求网络文件并保存",slug:"_1-2-使用nodejs的fs模块与axios请求网络文件并保存",normalizedTitle:"1.2 使用nodejs的fs模块与axios请求网络文件并保存",charIndex:288},{level:2,title:"2 渲染进程开启新窗口",slug:"_2-渲染进程开启新窗口",normalizedTitle:"2 渲染进程开启新窗口",charIndex:635},{level:3,title:"2.1 配置新窗口路由",slug:"_2-1-配置新窗口路由",normalizedTitle:"2.1 配置新窗口路由",charIndex:651},{level:3,title:"2.2 渲染进程向主进程通信",slug:"_2-2-渲染进程向主进程通信",normalizedTitle:"2.2 渲染进程向主进程通信",charIndex:799},{level:3,title:"2.3 主进程打开新窗口",slug:"_2-3-主进程打开新窗口",normalizedTitle:"2.3 主进程打开新窗口",charIndex:1150},{level:2,title:"3 文件监听",slug:"_3-文件监听",normalizedTitle:"3 文件监听",charIndex:1979},{level:3,title:"3.1 文件夹文件监听",slug:"_3-1-文件夹文件监听",normalizedTitle:"3.1 文件夹文件监听",charIndex:1990},{level:3,title:"3.2 文件夹文件信息获取",slug:"_3-2-文件夹文件信息获取",normalizedTitle:"3.2 文件夹文件信息获取",charIndex:2295},{level:3,title:"3.3 文件夹叠套获取文件信息",slug:"_3-3-文件夹叠套获取文件信息",normalizedTitle:"3.3 文件夹叠套获取文件信息",charIndex:3188},{level:3,title:"3.4 文件夹文件更新状态判断",slug:"_3-4-文件夹文件更新状态判断",normalizedTitle:"3.4 文件夹文件更新状态判断",charIndex:4339},{level:4,title:"3.4.1 筛选文件变更事件",slug:"_3-4-1-筛选文件变更事件",normalizedTitle:"3.4.1 筛选文件变更事件",charIndex:4358},{level:4,title:"3.4.2 文件变更分类且更新文件状态",slug:"_3-4-2-文件变更分类且更新文件状态",normalizedTitle:"3.4.2 文件变更分类且更新文件状态",charIndex:5546},{level:2,title:"4 搜索注册表并且启动对应软件",slug:"_4-搜索注册表并且启动对应软件",normalizedTitle:"4 搜索注册表并且启动对应软件",charIndex:7344},{level:3,title:"4.1 搜索注册表并固化",slug:"_4-1-搜索注册表并固化",normalizedTitle:"4.1 搜索注册表并固化",charIndex:7364},{level:4,title:"4.1.1 搜索注册表并保存bat",slug:"_4-1-1-搜索注册表并保存bat",normalizedTitle:"4.1.1 搜索注册表并保存bat",charIndex:7380},{level:4,title:"4.1.2 渲染进程执行bat文件",slug:"_4-1-2-渲染进程执行bat文件",normalizedTitle:"4.1.2 渲染进程执行bat文件",charIndex:7874},{level:3,title:"4.2 读取固化的注册表内容并记录在前端",slug:"_4-2-读取固化的注册表内容并记录在前端",normalizedTitle:"4.2 读取固化的注册表内容并记录在前端",charIndex:8651},{level:4,title:"4.2.1 前端用于维护的应用信息",slug:"_4-2-1-前端用于维护的应用信息",normalizedTitle:"4.2.1 前端用于维护的应用信息",charIndex:8675},{level:4,title:"4.2.2 读取固化注册表并修改softwareStats",slug:"_4-2-2-读取固化注册表并修改softwarestats",normalizedTitle:"4.2.2 读取固化注册表并修改softwarestats",charIndex:9348},{level:2,title:"4.3 启动软件",slug:"_4-3-启动软件",normalizedTitle:"4.3 启动软件",charIndex:10048}],headersStr:"1 网络文件下载至指定地点 1.1 使渲染进程使用NodeJS 1.2 使用NodeJS的fs模块与axios请求网络文件并保存 2 渲染进程开启新窗口 2.1 配置新窗口路由 2.2 渲染进程向主进程通信 2.3 主进程打开新窗口 3 文件监听 3.1 文件夹文件监听 3.2 文件夹文件信息获取 3.3 文件夹叠套获取文件信息 3.4 文件夹文件更新状态判断 3.4.1 筛选文件变更事件 3.4.2 文件变更分类且更新文件状态 4 搜索注册表并且启动对应软件 4.1 搜索注册表并固化 4.1.1 搜索注册表并保存bat 4.1.2 渲染进程执行bat文件 4.2 读取固化的注册表内容并记录在前端 4.2.1 前端用于维护的应用信息 4.2.2 读取固化注册表并修改softwareStats 4.3 启动软件",content:'# 1 网络文件下载至指定地点\n\n\n# 1.1 使渲染进程使用NodeJS\n\n 1. 在vue.config 里添加相关内容将electronBuilder作为一个插件进行参数配置\n\npluginOptions:{\n    electronBuilder:{\n      nodeIntegration:true\n    }\n  }\n\n\n1\n2\n3\n4\n5\n\n 2. background.js的createWindow方法中的webPreferences添加webSecurity:false。将浏览器安全策略关闭，使electron中的浏览器能够使用NodeJS\n\n\n# 1.2 使用NodeJS的fs模块与axios请求网络文件并保存\n\n 1. 组件引入fsimport fs from \'fs\'\n 2. 将node_modules里axios/lib的http.js内容覆盖xhr.js，为了能够使用后端axios流形式下载\n 3. axios请求后fs下载到指定地址\n\naxios({\n  method:\'get\',\n  url:this.res.data.data[0].middleURL,\n  responseType:\'stream\'\n}).then((response)=>{\n  response.data.pipe(fs.createWriteStream(\'E:/code/dog.jpg\'))\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2 渲染进程开启新窗口\n\n\n# 2.1 配置新窗口路由\n\n其中router必须是Hash形式，否则会报错\n\nconst router = createRouter({\n  //必须是hash形式\n  history: createWebHashHistory(),\n  routes,\n});\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.2 渲染进程向主进程通信\n\n不需要考虑vue组件的问题，子组件也可以直接与主进程通讯\n\n渲染进程\n\nimport { ipcRenderer } from "electron";\nconst CreateWindow = function(){\n\tipcRenderer.send("sumbit", "子进程给主进程发送数据");\n}\n\n\n1\n2\n3\n4\n\n\n主进程\n\nimport { ipcMain } from \'electron\'\nipcMain.on(\'sumbit\',(event,arg)=>{\n  event.reply(\'reply\',"主进程回复")\n  console.log(event)\n  console.log(arg)\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.3 主进程打开新窗口\n\n需要根据构建和打包的工具进行调整，但原则就是开发的时候获取localhost:端口,生产的时候获取Electron的代理\n\nipcMain.on(\'sumbit\',(event,arg)=>{\n  event.reply(\'reply\',"主进程回复")\n  console.log(event)\n  console.log(arg)\n  let modal = new BrowserWindow({\n    width: 800,\n    height: 600,\n    webPreferences: {\n      nodeIntegration: process.env.ELECTRON_NODE_INTEGRATION,\n      contextIsolation: !process.env.ELECTRON_NODE_INTEGRATION,\n      webSecurity:false\n    }\n  })\n  //开发环境\n  if (process.env.WEBPACK_DEV_SERVER_URL) {\n    modal.loadURL(process.env.WEBPACK_DEV_SERVER_URL+ "login")\n  } else {\n  //生产环境\n    createProtocol(\'app\')\n    // Load the index.html when not in development\n    modal.loadURL(\'app://./index.html/#/login\')\n  }\n  modal.on("closed", () => {\n    modal = null;\n  });\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 3 文件监听\n\n\n# 3.1 文件夹文件监听\n\n 1. 增加、删除和修改文件名的事件为rename，文件修改的事件为change\n 2. 其中~文件以及.文件需要判断处理，不是所有的都执行后续的文件信息获取函数\n\nfs.watch(folderUrl.value, (eventType, filename) => {\n  changeEvent.value = eventType;\n  changeFile.value = filename;\n  console.log(eventType, filename);\n//   执行文件状态读取函数\n  ReadLocal();\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.2 文件夹文件信息获取\n\n 1. 读取文件夹里的所有文件，遍历文件获取其文件信息\n\nconst ReadLocal = function () {\n  fs.readdir(folderUrl.value + "/", (err, files) => {\n    if (err) console.warn(err);\n    else {\n      FileData.value = [];\n      files.forEach((file) => {\n        fs.stat(folderUrl.value + "/" + file, (err, stats) => {\n          if (err) console.warn(err);\n          else {\n            const filedata = {\n              name: file,\n              url: folderUrl.value + file,\n              ctime: stats.ctime,\n              atime: stats.atime,\n              mtime: stats.mtime,\n              ctimeMs: stats.ctimeMs,\n              mtimeMs: stats.mtimeMs,\n              size: stats.size,\n              directory: stats.isDirectory(),\n            };\n            FileData.value.push(filedata);\n          }\n        });\n      });\n    }\n  });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 3.3 文件夹叠套获取文件信息\n\n通过递归的方法从文件夹层层向下\n\nReadLocal(FileData, folderUrl.value);\n\n// 读取本地文件状态\nconst ReadLocal = function (object, folder) {\n  fs.readdir(folder + "\\\\", (err, files) => {\n    if (err) console.warn(err);\n    else {\n      files.forEach((file) => {\n        if (file[0] != "." && file[0] != "~") {\n          FileStatus(object, folder, file);\n        }\n      });\n    }\n  });\n};\n// 文件状态扫描\nconst FileStatus = function (object, folder, file) {\n  fs.stat(folder + "\\\\" + file, (err, stats) => {\n    if (err) console.warn(err);\n    if (stats.isDirectory()) {\n      object[file] = {};\n      ReadLocal(object[file], folder + "\\\\" + file);\n    } else {\n      const filedata = {\n        name: file,\n        url: folder + "\\\\" + file,\n        ctime: stats.ctime,\n        atime: stats.atime,\n        mtime: stats.mtime,\n        ctimeMs: stats.ctimeMs,\n        mtimeMs: stats.mtimeMs,\n        size: stats.size,\n        directory: stats.isDirectory(),\n      };\n      object[file] = filedata;\n      FileDataList.value.push(filedata);\n    }\n  });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 3.4 文件夹文件更新状态判断\n\n# 3.4.1 筛选文件变更事件\n\n因为fs.watch()在新建一个文档时会被多次调用，且其实根据地址下的文件名来更新的，存在.开头的不需要同步的文件夹、文件，以及.tmp、.TMP结尾的过程文件更改也会被调用，所以需要在文件监听这里添加过滤机制\n\n 1. pointIndex - slashIndex > 1各级文件夹下以.开头的文件忽略\n 2. filename[slashIndex + 1] != "~"各级文件夹下以~开头的文件忽略\n 3. !filename.endsWith(".tmp") && !filename.endsWith(".TMP")以.tmp、.TMP结尾的过程文件忽略\n 4. now - time > interval || changeFile.value != filename 间隔时间过短且变更的文件名与上一次一致的忽略\n\n// 文件更新频率过高忽略\nconst interval = 100;\nlet time = new Date().getTime();\n// 文件监听\nfs.watch(folderUrl.value, { recursive: true }, (eventType, filename) => {\n  // console.log(FileDataList.value);\n  let now = new Date().getTime();\n  let slashIndex = filename.lastIndexOf("\\\\");\n  let pointIndex = filename.lastIndexOf(".");\n  if (\n    pointIndex - slashIndex > 1 &&\n    filename[slashIndex + 1] != "~" &&\n    !filename.endsWith(".tmp") &&\n    !filename.endsWith(".TMP")\n  ) {\n    if (now - time > interval || changeFile.value != filename) {\n      time = now;\n      changeEvent.value = eventType;\n      changeFile.value = filename;\n      // console.log(eventType);\n      // console.log(filename);\n      StatusUpdate(filename);\n    }\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 3.4.2 文件变更分类且更新文件状态\n\n 1. 如果找不到该文件证明被删除；将文件信息从FileDataList中删除\n 2. 找得到文件且该文件路径已经存储在FileDataList中，证明文件被修改；将文件信息更新至FileDataList中\n 3. 找得到文件但改文件路径未被存储在FileDataList中，证明文件新增;将文件信息添加到FileDataList中\n\n注意\n\n由于目前的文件变更分类依靠文件地址，存在文件重命名无法分辨的问题。文件重命名会被辨识为原文件被删除，新增了该名后的文件\n以后考虑要从后端获取文件的ID，与文件地址混合判断\n\nconst StatusUpdate = function (file) {\n  let url = folderUrl.value + "\\\\" + file;\n  fs.stat(url, (err, stats) => {\n    if (err) {\n      console.log("删除了" + file + "文件");\n      for (let index = 0; index < FileDataList.value.length; index++) {\n        if (FileDataList.value[index]["url"] == url) {\n          FileDataList.value.splice(index, 1);\n          console.log(FileDataList.value);\n        }\n      }\n    } else {\n      const filedata = {\n        name: file.split("\\\\").pop(),\n        url: url,\n        ctime: stats.ctime,\n        atime: stats.atime,\n        mtime: stats.mtime,\n        ctimeMs: stats.ctimeMs,\n        mtimeMs: stats.mtimeMs,\n        size: stats.size,\n        directory: stats.isDirectory(),\n      };\n      for (let index = 0; index < FileDataList.value.length; index++) {\n        if (FileDataList.value[index]["url"] == filedata["url"]) {\n          if (FileDataList.value[index]["mtimeMs"] != filedata["mtimeMs"]) {\n            console.log("修改了" + file + "文件");\n            FileDataList.value[index]["mtime"] = filedata["mtime"];\n            FileDataList.value[index]["mtimeMs"] = filedata["mtimeMs"];\n            FileDataList.value[index]["size"] = filedata["size"];\n          }\n          break;\n        }\n        if (!FileDataList.value[index + 1]) {\n          console.log("新增了" + file + "文件");\n          FileDataList.value.push(filedata);\n        }\n      }\n    }\n  });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 4 搜索注册表并且启动对应软件\n\n\n# 4.1 搜索注册表并固化\n\n# 4.1.1 搜索注册表并保存bat\n\n 1. 从卸载目录里面寻找软件是否安装，以及安装的信息\n 2. %1第一个参数是保存至本地的文件路径+文件名\n 3. %2第二个参数是对应软件的注册表key\n\n@echo off\n@REM 将之前的固化注册表信息清空\ntype nul > %1\n@REM ·连接需要查找的注册表键\nset str=HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\%2\n@REM ·reg query %str% 用来获取注册表指定软件的安装信息\n@REM ·for /f "tokens=1,2*" %%i in 按照行循环，并且按照空格将一行的内容分割成3分，忽略第二个空格后的所有空格\nfor /f "tokens=1,2*" %%i in (\'reg query %str%\') do (\n    @REM ·将3个部分用,隔开逐行写入固化注册表文件\n    echo %%i,%%j,%%k>>%1\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 4.1.2 渲染进程执行bat文件\n\n 1. exec执行bat时通过空格进行参数的分割\n 2. exec执行时需要bat的绝对路径而非相对路径\n 3. 这里使用process.cwd()能够通过开发环境，但不能通过生产环境\n\nimport { exec } from "child_process";\nconst GetRegistration = function (software) {\n  const url = folder.value + software["DisplayName"] + ".txt";\n  console.log("__dirname" + __dirname);\n  console.log("__filename" + __filename);\n  console.log("process.cwd()" + process.cwd());\n  exec(\n    process.cwd() + "/public/reg1.bat " + url + " " + software["ID"],\n    (error, stdout, stderr) => {\n      if (error) {\n        console.error("error: " + error);\n        return;\n      }\n      console.log("stdout: " + stdout);\n      console.log("stderr: " + typeof stderr);\n      ReadRegFile(url, software);\n    }\n  );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 4.2 读取固化的注册表内容并记录在前端\n\n# 4.2.1 前端用于维护的应用信息\n\nconst softwareStats = ref({\n  AECmate: {\n    DisplayName: "AECMate",\n    Name: "AnyBuidingCAD.exe",\n    ID: "{61CDF82A-16BB-4FD5-9B8A-5B12C8349D8E}",\n    Version: "",\n    InstallLocation: "",\n    Install: false,\n  },\n  Revit: {\n    DisplayName: "Revit",\n    Name: "Revit.exe",\n    ID: "{61CDF82A-16BB-4FD5-9B8A-5B12C8349D8E1}",\n    Version: "",\n    InstallLocation: "",\n    Install: false,\n  },\n  Wukong: {\n    DisplayName: "Wukong",\n    Name: "WuKong.exe",\n    ID: "{85B05B30-FA7A-4698-80F3-022F489ABAEE}",\n    Version: "",\n    InstallLocation: "",\n    Install: false,\n  },\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 4.2.2 读取固化注册表并修改softwareStats\n\nconst ReadRegFile = function (url, software) {\n  fs.readFile(url, "utf-8", (err, result) => {\n    //通过判断文件是否存在确定应用是否安装\n    if (err) {\n      console.error("error: " + err);\n      software["Install"] = false;\n    } else {\n      software["Install"] = true;\n      //将信息按照行分割\n      let list = result.split("\\r\\n");\n      //行信息遍历获取需要的\n      list.forEach((item) => {\n        if (item.includes("InstallLocation")) {\n          software["InstallLocation"] = item.split(",")[2];\n        }\n        if (item.includes("Version")) {\n          software["Version"] = item.split(",")[2];\n        }\n      });\n    }\n  });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 4.3 启动软件\n\n 1. 通过`"${}"`将字符串强制用""包裹，这样可以避免运行路径里面存在空格导致无法执行的问题\n\nconst StartSoftware = function (software) {\n  exec(\n    `"${software["InstallLocation"] + software["Name"]}"`,\n    (error, stdout, stderr) => {\n      if (error) {\n        console.error("error: " + error);\n        return;\n      }\n      console.log("stdout: " + stdout);\n      console.log("stderr: " + typeof stderr);\n    }\n  );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',normalizedContent:'# 1 网络文件下载至指定地点\n\n\n# 1.1 使渲染进程使用nodejs\n\n 1. 在vue.config 里添加相关内容将electronbuilder作为一个插件进行参数配置\n\npluginoptions:{\n    electronbuilder:{\n      nodeintegration:true\n    }\n  }\n\n\n1\n2\n3\n4\n5\n\n 2. background.js的createwindow方法中的webpreferences添加websecurity:false。将浏览器安全策略关闭，使electron中的浏览器能够使用nodejs\n\n\n# 1.2 使用nodejs的fs模块与axios请求网络文件并保存\n\n 1. 组件引入fsimport fs from \'fs\'\n 2. 将node_modules里axios/lib的http.js内容覆盖xhr.js，为了能够使用后端axios流形式下载\n 3. axios请求后fs下载到指定地址\n\naxios({\n  method:\'get\',\n  url:this.res.data.data[0].middleurl,\n  responsetype:\'stream\'\n}).then((response)=>{\n  response.data.pipe(fs.createwritestream(\'e:/code/dog.jpg\'))\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2 渲染进程开启新窗口\n\n\n# 2.1 配置新窗口路由\n\n其中router必须是hash形式，否则会报错\n\nconst router = createrouter({\n  //必须是hash形式\n  history: createwebhashhistory(),\n  routes,\n});\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.2 渲染进程向主进程通信\n\n不需要考虑vue组件的问题，子组件也可以直接与主进程通讯\n\n渲染进程\n\nimport { ipcrenderer } from "electron";\nconst createwindow = function(){\n\tipcrenderer.send("sumbit", "子进程给主进程发送数据");\n}\n\n\n1\n2\n3\n4\n\n\n主进程\n\nimport { ipcmain } from \'electron\'\nipcmain.on(\'sumbit\',(event,arg)=>{\n  event.reply(\'reply\',"主进程回复")\n  console.log(event)\n  console.log(arg)\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.3 主进程打开新窗口\n\n需要根据构建和打包的工具进行调整，但原则就是开发的时候获取localhost:端口,生产的时候获取electron的代理\n\nipcmain.on(\'sumbit\',(event,arg)=>{\n  event.reply(\'reply\',"主进程回复")\n  console.log(event)\n  console.log(arg)\n  let modal = new browserwindow({\n    width: 800,\n    height: 600,\n    webpreferences: {\n      nodeintegration: process.env.electron_node_integration,\n      contextisolation: !process.env.electron_node_integration,\n      websecurity:false\n    }\n  })\n  //开发环境\n  if (process.env.webpack_dev_server_url) {\n    modal.loadurl(process.env.webpack_dev_server_url+ "login")\n  } else {\n  //生产环境\n    createprotocol(\'app\')\n    // load the index.html when not in development\n    modal.loadurl(\'app://./index.html/#/login\')\n  }\n  modal.on("closed", () => {\n    modal = null;\n  });\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 3 文件监听\n\n\n# 3.1 文件夹文件监听\n\n 1. 增加、删除和修改文件名的事件为rename，文件修改的事件为change\n 2. 其中~文件以及.文件需要判断处理，不是所有的都执行后续的文件信息获取函数\n\nfs.watch(folderurl.value, (eventtype, filename) => {\n  changeevent.value = eventtype;\n  changefile.value = filename;\n  console.log(eventtype, filename);\n//   执行文件状态读取函数\n  readlocal();\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.2 文件夹文件信息获取\n\n 1. 读取文件夹里的所有文件，遍历文件获取其文件信息\n\nconst readlocal = function () {\n  fs.readdir(folderurl.value + "/", (err, files) => {\n    if (err) console.warn(err);\n    else {\n      filedata.value = [];\n      files.foreach((file) => {\n        fs.stat(folderurl.value + "/" + file, (err, stats) => {\n          if (err) console.warn(err);\n          else {\n            const filedata = {\n              name: file,\n              url: folderurl.value + file,\n              ctime: stats.ctime,\n              atime: stats.atime,\n              mtime: stats.mtime,\n              ctimems: stats.ctimems,\n              mtimems: stats.mtimems,\n              size: stats.size,\n              directory: stats.isdirectory(),\n            };\n            filedata.value.push(filedata);\n          }\n        });\n      });\n    }\n  });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 3.3 文件夹叠套获取文件信息\n\n通过递归的方法从文件夹层层向下\n\nreadlocal(filedata, folderurl.value);\n\n// 读取本地文件状态\nconst readlocal = function (object, folder) {\n  fs.readdir(folder + "\\\\", (err, files) => {\n    if (err) console.warn(err);\n    else {\n      files.foreach((file) => {\n        if (file[0] != "." && file[0] != "~") {\n          filestatus(object, folder, file);\n        }\n      });\n    }\n  });\n};\n// 文件状态扫描\nconst filestatus = function (object, folder, file) {\n  fs.stat(folder + "\\\\" + file, (err, stats) => {\n    if (err) console.warn(err);\n    if (stats.isdirectory()) {\n      object[file] = {};\n      readlocal(object[file], folder + "\\\\" + file);\n    } else {\n      const filedata = {\n        name: file,\n        url: folder + "\\\\" + file,\n        ctime: stats.ctime,\n        atime: stats.atime,\n        mtime: stats.mtime,\n        ctimems: stats.ctimems,\n        mtimems: stats.mtimems,\n        size: stats.size,\n        directory: stats.isdirectory(),\n      };\n      object[file] = filedata;\n      filedatalist.value.push(filedata);\n    }\n  });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 3.4 文件夹文件更新状态判断\n\n# 3.4.1 筛选文件变更事件\n\n因为fs.watch()在新建一个文档时会被多次调用，且其实根据地址下的文件名来更新的，存在.开头的不需要同步的文件夹、文件，以及.tmp、.tmp结尾的过程文件更改也会被调用，所以需要在文件监听这里添加过滤机制\n\n 1. pointindex - slashindex > 1各级文件夹下以.开头的文件忽略\n 2. filename[slashindex + 1] != "~"各级文件夹下以~开头的文件忽略\n 3. !filename.endswith(".tmp") && !filename.endswith(".tmp")以.tmp、.tmp结尾的过程文件忽略\n 4. now - time > interval || changefile.value != filename 间隔时间过短且变更的文件名与上一次一致的忽略\n\n// 文件更新频率过高忽略\nconst interval = 100;\nlet time = new date().gettime();\n// 文件监听\nfs.watch(folderurl.value, { recursive: true }, (eventtype, filename) => {\n  // console.log(filedatalist.value);\n  let now = new date().gettime();\n  let slashindex = filename.lastindexof("\\\\");\n  let pointindex = filename.lastindexof(".");\n  if (\n    pointindex - slashindex > 1 &&\n    filename[slashindex + 1] != "~" &&\n    !filename.endswith(".tmp") &&\n    !filename.endswith(".tmp")\n  ) {\n    if (now - time > interval || changefile.value != filename) {\n      time = now;\n      changeevent.value = eventtype;\n      changefile.value = filename;\n      // console.log(eventtype);\n      // console.log(filename);\n      statusupdate(filename);\n    }\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 3.4.2 文件变更分类且更新文件状态\n\n 1. 如果找不到该文件证明被删除；将文件信息从filedatalist中删除\n 2. 找得到文件且该文件路径已经存储在filedatalist中，证明文件被修改；将文件信息更新至filedatalist中\n 3. 找得到文件但改文件路径未被存储在filedatalist中，证明文件新增;将文件信息添加到filedatalist中\n\n注意\n\n由于目前的文件变更分类依靠文件地址，存在文件重命名无法分辨的问题。文件重命名会被辨识为原文件被删除，新增了该名后的文件\n以后考虑要从后端获取文件的id，与文件地址混合判断\n\nconst statusupdate = function (file) {\n  let url = folderurl.value + "\\\\" + file;\n  fs.stat(url, (err, stats) => {\n    if (err) {\n      console.log("删除了" + file + "文件");\n      for (let index = 0; index < filedatalist.value.length; index++) {\n        if (filedatalist.value[index]["url"] == url) {\n          filedatalist.value.splice(index, 1);\n          console.log(filedatalist.value);\n        }\n      }\n    } else {\n      const filedata = {\n        name: file.split("\\\\").pop(),\n        url: url,\n        ctime: stats.ctime,\n        atime: stats.atime,\n        mtime: stats.mtime,\n        ctimems: stats.ctimems,\n        mtimems: stats.mtimems,\n        size: stats.size,\n        directory: stats.isdirectory(),\n      };\n      for (let index = 0; index < filedatalist.value.length; index++) {\n        if (filedatalist.value[index]["url"] == filedata["url"]) {\n          if (filedatalist.value[index]["mtimems"] != filedata["mtimems"]) {\n            console.log("修改了" + file + "文件");\n            filedatalist.value[index]["mtime"] = filedata["mtime"];\n            filedatalist.value[index]["mtimems"] = filedata["mtimems"];\n            filedatalist.value[index]["size"] = filedata["size"];\n          }\n          break;\n        }\n        if (!filedatalist.value[index + 1]) {\n          console.log("新增了" + file + "文件");\n          filedatalist.value.push(filedata);\n        }\n      }\n    }\n  });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 4 搜索注册表并且启动对应软件\n\n\n# 4.1 搜索注册表并固化\n\n# 4.1.1 搜索注册表并保存bat\n\n 1. 从卸载目录里面寻找软件是否安装，以及安装的信息\n 2. %1第一个参数是保存至本地的文件路径+文件名\n 3. %2第二个参数是对应软件的注册表key\n\n@echo off\n@rem 将之前的固化注册表信息清空\ntype nul > %1\n@rem ·连接需要查找的注册表键\nset str=hkey_local_machine\\software\\microsoft\\windows\\currentversion\\uninstall\\%2\n@rem ·reg query %str% 用来获取注册表指定软件的安装信息\n@rem ·for /f "tokens=1,2*" %%i in 按照行循环，并且按照空格将一行的内容分割成3分，忽略第二个空格后的所有空格\nfor /f "tokens=1,2*" %%i in (\'reg query %str%\') do (\n    @rem ·将3个部分用,隔开逐行写入固化注册表文件\n    echo %%i,%%j,%%k>>%1\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 4.1.2 渲染进程执行bat文件\n\n 1. exec执行bat时通过空格进行参数的分割\n 2. exec执行时需要bat的绝对路径而非相对路径\n 3. 这里使用process.cwd()能够通过开发环境，但不能通过生产环境\n\nimport { exec } from "child_process";\nconst getregistration = function (software) {\n  const url = folder.value + software["displayname"] + ".txt";\n  console.log("__dirname" + __dirname);\n  console.log("__filename" + __filename);\n  console.log("process.cwd()" + process.cwd());\n  exec(\n    process.cwd() + "/public/reg1.bat " + url + " " + software["id"],\n    (error, stdout, stderr) => {\n      if (error) {\n        console.error("error: " + error);\n        return;\n      }\n      console.log("stdout: " + stdout);\n      console.log("stderr: " + typeof stderr);\n      readregfile(url, software);\n    }\n  );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 4.2 读取固化的注册表内容并记录在前端\n\n# 4.2.1 前端用于维护的应用信息\n\nconst softwarestats = ref({\n  aecmate: {\n    displayname: "aecmate",\n    name: "anybuidingcad.exe",\n    id: "{61cdf82a-16bb-4fd5-9b8a-5b12c8349d8e}",\n    version: "",\n    installlocation: "",\n    install: false,\n  },\n  revit: {\n    displayname: "revit",\n    name: "revit.exe",\n    id: "{61cdf82a-16bb-4fd5-9b8a-5b12c8349d8e1}",\n    version: "",\n    installlocation: "",\n    install: false,\n  },\n  wukong: {\n    displayname: "wukong",\n    name: "wukong.exe",\n    id: "{85b05b30-fa7a-4698-80f3-022f489abaee}",\n    version: "",\n    installlocation: "",\n    install: false,\n  },\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 4.2.2 读取固化注册表并修改softwarestats\n\nconst readregfile = function (url, software) {\n  fs.readfile(url, "utf-8", (err, result) => {\n    //通过判断文件是否存在确定应用是否安装\n    if (err) {\n      console.error("error: " + err);\n      software["install"] = false;\n    } else {\n      software["install"] = true;\n      //将信息按照行分割\n      let list = result.split("\\r\\n");\n      //行信息遍历获取需要的\n      list.foreach((item) => {\n        if (item.includes("installlocation")) {\n          software["installlocation"] = item.split(",")[2];\n        }\n        if (item.includes("version")) {\n          software["version"] = item.split(",")[2];\n        }\n      });\n    }\n  });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 4.3 启动软件\n\n 1. 通过`"${}"`将字符串强制用""包裹，这样可以避免运行路径里面存在空格导致无法执行的问题\n\nconst startsoftware = function (software) {\n  exec(\n    `"${software["installlocation"] + software["name"]}"`,\n    (error, stdout, stderr) => {\n      if (error) {\n        console.error("error: " + error);\n        return;\n      }\n      console.log("stdout: " + stdout);\n      console.log("stderr: " + typeof stderr);\n    }\n  );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',charsets:{cjk:!0},lastUpdated:"2023/07/31, 19:25:37",lastUpdatedTimestamp:1690802737e3},{title:"操作系统",frontmatter:{title:"操作系统",date:"2022-04-11T16:38:39.000Z",permalink:"/pages/8b9558/",categories:["计算机基础","操作系统"],tags:["操作系统"],author:{name:"年华惊风雨",link:"https://github.com/wsy425"}},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/05.%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/05.%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html",relativePath:"02.计算机基础/05. 操作系统/05. 操作系统.md",key:"v-a030fbc4",path:"/pages/8b9558/",headers:[{level:2,title:"1 概述",slug:"_1-概述",normalizedTitle:"1 概述",charIndex:2},{level:3,title:"1.1 操作系统的概念",slug:"_1-1-操作系统的概念",normalizedTitle:"1.1 操作系统的概念",charIndex:11},{level:4,title:"1.1.1 操作系统的定义",slug:"_1-1-1-操作系统的定义",normalizedTitle:"1.1.1 操作系统的定义",charIndex:26},{level:4,title:"1.1.2 操作系统的功能和目标",slug:"_1-1-2-操作系统的功能和目标",normalizedTitle:"1.1.2 操作系统的功能和目标",charIndex:113},{level:3,title:"1.2 操作系统的特征",slug:"_1-2-操作系统的特征",normalizedTitle:"1.2 操作系统的特征",charIndex:255},{level:4,title:"1.2.1 并发",slug:"_1-2-1-并发",normalizedTitle:"1.2.1 并发",charIndex:270},{level:4,title:"1.2.2 共享",slug:"_1-2-2-共享",normalizedTitle:"1.2.2 共享",charIndex:356},{level:4,title:"1.2.3 虚拟",slug:"_1-2-3-虚拟",normalizedTitle:"1.2.3 虚拟",charIndex:422},{level:4,title:"1.2.4 异步",slug:"_1-2-4-异步",normalizedTitle:"1.2.4 异步",charIndex:471},{level:3,title:"1.3 操作系统的发展和分类",slug:"_1-3-操作系统的发展和分类",normalizedTitle:"1.3 操作系统的发展和分类",charIndex:562},{level:4,title:"1.3.1 手工操作阶段",slug:"_1-3-1-手工操作阶段",normalizedTitle:"1.3.1 手工操作阶段",charIndex:580},{level:4,title:"1.3.2 单道批处理系统",slug:"_1-3-2-单道批处理系统",normalizedTitle:"1.3.2 单道批处理系统",charIndex:620},{level:4,title:"1.3.3 多道批处理系统",slug:"_1-3-3-多道批处理系统",normalizedTitle:"1.3.3 多道批处理系统",charIndex:694},{level:4,title:"1.3.4 分时操作系统",slug:"_1-3-4-分时操作系统",normalizedTitle:"1.3.4 分时操作系统",charIndex:746},{level:4,title:"1.3.5 实时操作系统",slug:"_1-3-5-实时操作系统",normalizedTitle:"1.3.5 实时操作系统",charIndex:816},{level:3,title:"1.4 操作系统的运行机制和体系结构",slug:"_1-4-操作系统的运行机制和体系结构",normalizedTitle:"1.4 操作系统的运行机制和体系结构",charIndex:910},{level:4,title:"1.4.1 运行机制",slug:"_1-4-1-运行机制",normalizedTitle:"1.4.1 运行机制",charIndex:952},{level:5,title:"两种指令",slug:"两种指令",normalizedTitle:"两种指令",charIndex:966},{level:5,title:"两种处理器状态",slug:"两种处理器状态",normalizedTitle:"两种处理器状态",charIndex:1005},{level:5,title:"两种程",slug:"两种程",normalizedTitle:"两种程",charIndex:1065},{level:4,title:"1.4.2 操作系统内核",slug:"_1-4-2-操作系统内核",normalizedTitle:"1.4.2 操作系统内核",charIndex:1176},{level:4,title:"1.4.3 操作系统体系结构",slug:"_1-4-3-操作系统体系结构",normalizedTitle:"1.4.3 操作系统体系结构",charIndex:1403},{level:3,title:"1.5 中断和异常",slug:"_1-5-中断和异常",normalizedTitle:"1.5 中断和异常",charIndex:1575},{level:4,title:"1.5.1 内中断",slug:"_1-5-1-内中断",normalizedTitle:"1.5.1 内中断",charIndex:1674},{level:5,title:"分类1",slug:"分类1",normalizedTitle:"分类1",charIndex:1730},{level:5,title:"分类2",slug:"分类2",normalizedTitle:"分类2",charIndex:1786},{level:4,title:"1.5.2 外中断",slug:"_1-5-2-外中断",normalizedTitle:"1.5.2 外中断",charIndex:1871},{level:5,title:"外设请求",slug:"外设请求",normalizedTitle:"外设请求",charIndex:1920},{level:5,title:"人工干预",slug:"人工干预",normalizedTitle:"人工干预",charIndex:1928},{level:5,title:"处理过程",slug:"处理过程",normalizedTitle:"处理过程",charIndex:1936},{level:3,title:"1.6 系统调用",slug:"_1-6-系统调用",normalizedTitle:"1.6 系统调用",charIndex:2069},{level:4,title:"1.6.1 系统调用过程",slug:"_1-6-1-系统调用过程",normalizedTitle:"1.6.1 系统调用过程",charIndex:2166},{level:2,title:"2 进程",slug:"_2-进程",normalizedTitle:"2 进程",charIndex:2308},{level:3,title:"2.1 进程概述",slug:"_2-1-进程概述",normalizedTitle:"2.1 进程概述",charIndex:2317},{level:4,title:"2.1.1 进程的定义",slug:"_2-1-1-进程的定义",normalizedTitle:"2.1.1 进程的定义",charIndex:2329},{level:4,title:"2.1.2 进程的组成",slug:"_2-1-2-进程的组成",normalizedTitle:"2.1.2 进程的组成",charIndex:2662},{level:4,title:"2.1.3 进程的组织",slug:"_2-1-3-进程的组织",normalizedTitle:"2.1.3 进程的组织",charIndex:2998},{level:4,title:"2.1.4 进程的特征",slug:"_2-1-4-进程的特征",normalizedTitle:"2.1.4 进程的特征",charIndex:3178},{level:3,title:"2.2 进程状态",slug:"_2-2-进程状态",normalizedTitle:"2.2 进程状态",charIndex:3391},{level:4,title:"2.2.1 进程的状态",slug:"_2-2-1-进程的状态",normalizedTitle:"2.2.1 进程的状态",charIndex:3403},{level:4,title:"2.2.2 进程状态的装换",slug:"_2-2-2-进程状态的装换",normalizedTitle:"2.2.2 进程状态的装换",charIndex:3665},{level:3,title:"2.3 进程控制",slug:"_2-3-进程控制",normalizedTitle:"2.3 进程控制",charIndex:3877},{level:4,title:"2.3.1 进程的创建",slug:"_2-3-1-进程的创建",normalizedTitle:"2.3.1 进程的创建",charIndex:4066},{level:4,title:"2.3.2 进程的终止",slug:"_2-3-2-进程的终止",normalizedTitle:"2.3.2 进程的终止",charIndex:4299},{level:4,title:"2.3.3 进程的阻塞",slug:"_2-3-3-进程的阻塞",normalizedTitle:"2.3.3 进程的阻塞",charIndex:4485},{level:4,title:"2.3.4 进程的阻塞",slug:"_2-3-4-进程的阻塞",normalizedTitle:"2.3.4 进程的阻塞",charIndex:4651},{level:4,title:"2.3.5 进程的切换",slug:"_2-3-5-进程的切换",normalizedTitle:"2.3.5 进程的切换",charIndex:4774},{level:3,title:"2.4 进程通信",slug:"_2-4-进程通信",normalizedTitle:"2.4 进程通信",charIndex:4958},{level:4,title:"2.4.1 共享存储",slug:"_2-4-1-共享存储",normalizedTitle:"2.4.1 共享存储",charIndex:5052},{level:4,title:"2.4.2 管道通信",slug:"_2-4-2-管道通信",normalizedTitle:"2.4.2 管道通信",charIndex:5147},{level:4,title:"2.4.3 消息传递",slug:"_2-4-3-消息传递",normalizedTitle:"2.4.3 消息传递",charIndex:5381},{level:3,title:"2.5 线程",slug:"_2-5-线程",normalizedTitle:"2.5 线程",charIndex:5502},{level:4,title:"2.5.1 线程作用",slug:"_2-5-1-线程作用",normalizedTitle:"2.5.1 线程作用",charIndex:5622},{level:4,title:"2.5.2 线程属性",slug:"_2-5-2-线程属性",normalizedTitle:"2.5.2 线程属性",charIndex:5884},{level:4,title:"2.5.3 线程的实现方式",slug:"_2-5-3-线程的实现方式",normalizedTitle:"2.5.3 线程的实现方式",charIndex:6161},{level:5,title:"用户级线程（ULT）",slug:"用户级线程-ult",normalizedTitle:"用户级线程（ult）",charIndex:6178},{level:5,title:"内核级线程（KLT）",slug:"内核级线程-klt",normalizedTitle:"内核级线程（klt）",charIndex:6278},{level:4,title:"2.5.4 多线程模型",slug:"_2-5-4-多线程模型",normalizedTitle:"2.5.4 多线程模型",charIndex:6361}],headersStr:"1 概述 1.1 操作系统的概念 1.1.1 操作系统的定义 1.1.2 操作系统的功能和目标 1.2 操作系统的特征 1.2.1 并发 1.2.2 共享 1.2.3 虚拟 1.2.4 异步 1.3 操作系统的发展和分类 1.3.1 手工操作阶段 1.3.2 单道批处理系统 1.3.3 多道批处理系统 1.3.4 分时操作系统 1.3.5 实时操作系统 1.4 操作系统的运行机制和体系结构 1.4.1 运行机制 两种指令 两种处理器状态 两种程 1.4.2 操作系统内核 1.4.3 操作系统体系结构 1.5 中断和异常 1.5.1 内中断 分类1 分类2 1.5.2 外中断 外设请求 人工干预 处理过程 1.6 系统调用 1.6.1 系统调用过程 2 进程 2.1 进程概述 2.1.1 进程的定义 2.1.2 进程的组成 2.1.3 进程的组织 2.1.4 进程的特征 2.2 进程状态 2.2.1 进程的状态 2.2.2 进程状态的装换 2.3 进程控制 2.3.1 进程的创建 2.3.2 进程的终止 2.3.3 进程的阻塞 2.3.4 进程的阻塞 2.3.5 进程的切换 2.4 进程通信 2.4.1 共享存储 2.4.2 管道通信 2.4.3 消息传递 2.5 线程 2.5.1 线程作用 2.5.2 线程属性 2.5.3 线程的实现方式 用户级线程（ULT） 内核级线程（KLT） 2.5.4 多线程模型",content:"# 1 概述\n\n\n# 1.1 操作系统的概念\n\n# 1.1.1 操作系统的定义\n\n 1. 负责管理协调硬件、软件等计算机资源的工作\n 2. 为上层的应用程序、用户提供简单易用的服务\n 3. 操作系统是系统软件而不是硬件\n\n# 1.1.2 操作系统的功能和目标\n\n 1. 作为系统资源的管理者 功能：处理机管理；存储器管理；文件管理；设备管理 目标：安全、高效\n 2. 作为用户和计算机硬件的接口 功能：命令借口；程序接口；GUI 目标：方便用户使用\n 3. 作为最接近硬件的层次 实现对硬件机器的扩展\n\n\n# 1.2 操作系统的特征\n\n# 1.2.1 并发\n\n指两个或多个时间在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的 操作系统的并发性：计算机系统中同时存在着多个运行着的程序\n\n# 1.2.2 共享\n\n资源共享：系统中的资源可供内存中多个并发执行的进程共同使用\n\n 1. 互斥共享方式\n 2. 同时共享方式\n\n# 1.2.3 虚拟\n\n把一个物理上的实体变为若干个逻辑上的对应物 空分复用技术；时分复用技术\n\n# 1.2.4 异步\n\n在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的而是走走停停，以不可预知的速度向前推进 只有系统拥有并发性才会导致异步性\n\n\n# 1.3 操作系统的发展和分类\n\n# 1.3.1 手工操作阶段\n\n用户独占全集、人机速度锚段导致资源利用率极低\n\n# 1.3.2 单道批处理系统\n\n引入脱机输入/输出（用磁带完成），并监督程序负责控制作业的输入、输出 缓解了人机速度矛盾，内存仅有一道程序运行\n\n# 1.3.3 多道批处理系统\n\n多道程序并发执行，共享计算机资源 没有人机交互功能，用户响应时间长\n\n# 1.3.4 分时操作系统\n\n计算机以时间片为单位轮流为各个用户/作业服务，各个用户通过终端与计算机进行交互 不能优先处理一些紧急任务\n\n# 1.3.5 实时操作系统\n\n能够优先响应一些紧急任务，具有及时性和可靠性\n\n 1. 硬实时系统：必须在绝对严格的规定时间内完成处理\n 2. 软实时操作系统：能接受偶尔违反时间规定\n\n\n# 1.4 操作系统的运行机制和体系结构\n\n指令：处理器能识别、执行的最基本命令\n\n# 1.4.1 运行机制\n\n# 两种指令\n\n 1. 特权指令：不允许用户程序使用\n 2. 非特权指令：\n\n# 两种处理器状态\n\n 1. 用户态（目态）：只能执行非特权指令\n 2. 核心态（管态）：特权和非特权指令都可以执行\n\n# 两种程\n\n 1. 内核程序：操作系统的内核程序书系统的管理者\n    * 既可以执行特权指令也可以执行非特权指令\n    * 运行在核心态\n 2. 应用程序\n    * 只能执行非特权指令\n    * 运行在用户态\n\n# 1.4.2 操作系统内核\n\n 1. 内核是计算机上配置的底层程序，是操作系统最基本、最核心的部分\n 2. 时钟管理：实现计时功能\n 3. 中断处理：负责实现中断机制\n 4. 原语\n    * 一种特殊的程序\n    * 处于操作系统最底层，最接近硬件的部分\n    * 运行具有原子性，只能一气呵成不能被中断\n    * 运行时间较短、调用频繁\n 5. 对系统资源进行管理的功能\n    * 进程管理\n    * 存储器管理\n    * 设备管理\n\n# 1.4.3 操作系统体系结构\n\n 1. 大内核：将操作系统的主要功能模块都作为系统内核，运行在核心态\n    * 优点：高性能\n    * 缺点：内核代码庞大，结构混乱，难以维护\n 2. 微内核：只把最基本的功能保留在内核\n    * 优点：内核功能少，结构清晰，方便维护\n    * 缺点：需要频繁地在核心态和用户态之间切换，性能低\n\n\n# 1.5 中断和异常\n\n 1. 发生中断就一位置需要操作系统介入，开展管理工作\n 2. 中断发生时CPU立即进入核心态，使操作系统获得计算机的控制权\n 3. 中断使用户态到核心态切换的唯一途径\n\n# 1.5.1 内中断\n\n 1. 也成异常、例外、陷入\n 2. 信号的来源：CPU内部，与当前执行的指令有关\n\n# 分类1\n\n 1. 自愿中断，又称指令中断\n 2. 强迫中断：\n    * 硬件故障\n    * 软件中断\n\n# 分类2\n\n 1. 陷阱、陷入（trap）：有意而为之的异常\n 2. 故障（fault）：由错误条件引起的\n 3. 终止（abort）：不可恢复的致命操作造成的结果\n\n# 1.5.2 外中断\n\n 1. 简称中断\n 2. 信号的来源：CPU外部与当前执行的指令无关\n\n# 外设请求\n\n# 人工干预\n\n# 处理过程\n\n 1. 执行完每个指令之后，CPU都要检测当前是否有外部中断信号\n 2. 如果检测到外部中断信号，则需要保护被中断进程的CPU环境\n 3. 根据中断信号类型转入响应的中断处理程序\n 4. 恢复原进程的CPU环境并推出中断，返回原进程继续往下执行\n\n\n# 1.6 系统调用\n\n 1. 系统调用是操作系统提供给应用程序使用的接口\n 2. 应用程序通过系统调用请求操作系统的服务可以保证系统的稳定性和安全性\n 3. 系统调用的相关处理在核心态进行\n\n# 1.6.1 系统调用过程\n\n 1. 传递系统调用参数\n 2. 执行陷入指令\n 3. 执行系统调用响应服务程序\n 4. 返回用户程序\n 5. 发生系统调用请求实在用户态，但对系统调用的相应处理在核心态下进行\n 6. 陷入指令是唯一一个只能在用户态执行，而不能在核心态执行的指令\n\n\n# 2 进程\n\n\n# 2.1 进程概述\n\n# 2.1.1 进程的定义\n\n 1. 程序：一个指令序列\n 2. 进程实体（进程映像）\n    * 进程控制块（PCB）：系统为每个运行的程序配置的一个数据结构，用来描述进程的各种信息\n    * 程序段\n    * 数据段\n 3. PCB是进程存在的唯一标志\n 4. 创建进程实质上是创建进程实体中的PCB；撤销进程实质上是撤销进程实体中的PCB\n 5. 进程定义：强调动态性\n    * 进程是程序的一次执行过程\n    * 进程是一个程序及其数据在处理机上顺序执行时所发生的活动\n    * 进程是具有独立功能的程序在数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位\n    * 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位\n\n# 2.1.2 进程的组成\n\n 1. 进程（进程实体）由程序段、数据段、PCB三个部分组成\n 2. 程序段：存放要执行的代码\n 3. 数据段：存放程序运行时使用、产生的运算数据\n 4. PCB：包含操作系统对其进行管理所需的各种信息\n    * 进程描述信息\n      * 进程标识符PID：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，用于区分不同的进程\n      * 用户标识符UID\n    * 进程控制和管理信息\n      * 进程当前状态\n      * 进程优先级\n    * 资源分配清单\n      * 程序段指针\n      * 数据段指针\n      * 键盘\n      * 鼠标\n    * 处理机相关信息：各种寄存器值\n\n# 2.1.3 进程的组织\n\n 1. 进程的组成讨论的是一个进程内部由那些部分构成的问题；而进程的组织讨论的是多个进程之间的组织方式问题\n 2. 链接方式\n    * 按照进程状态将PCB分为多个队列\n    * 操作系统持有指向各个队列的指针\n 3. 索引方式\n    * 根据进程状态的不同，建立几张索引表\n    * 操作系统持有指向各个索引表的指针\n\n# 2.1.4 进程的特征\n\n 1. 动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的\n 2. 并发性：内存中有多个进程实体，各进程可并发执行\n 3. 独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位\n 4. 异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题\n 5. 结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成\n\n\n# 2.2 进程状态\n\n# 2.2.1 进程的状态\n\n 1. 运行态：战友CPU，并在CPU上运行\n    * 在单核处理机环境下，每一个时刻最多只有一个进程处于运行态\n 2. 就绪态：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行\n    * 进程已经拥有了除处理机之外的所有需要资源，一旦你获得处理机可以立即进入运行态开始运行\n 3. 阻塞态（等待态）：因等待某一事件而暂时不能运行\n 4. 创建态：进程正在被创建，操作系统为进程分配资源、初始化PCB\n 5. 终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB\n\n# 2.2.2 进程状态的装换\n\n 1. 就绪态———运行态：进程被调度\n 2. 运行态———就绪态：时间片到，或CPU被其他搞优先级的进程抢占\n 3. 运行态———阻塞态：等待系统资源分配，或等待某时间发生（主动行为）\n 4. 阻塞态———就绪态：资源分配到位，等待的时间发生（被动行为）\n 5. 创建态———就绪态：系统完成创建进程相关工作\n 6. 运行态———终止态：进程运行结束，或运行过程中遇到不可修复的错误\n\n\n# 2.3 进程控制\n\n 1. 进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新锦成、撤销已有进程、实现进程状态转换等功能\n 2. 用原语实现进程控制\n 3. 原语的特点是执行期间不允许中断，只能一气呵成\n 4. 这种不可被中断的操作称为原子操作，采用“关中断指令”和“开中断指令”实现\n 5. 原语运行在核心态\n 6. 关/开中断指令只允许在核心态下执行\n\n# 2.3.1 进程的创建\n\n 1. 创建原语\n    * 申请空白PCB\n    * 为新进程分配所需资源\n    * 初始化PCB\n    * 将PCB插入就绪队列\n 2. 引起进程创建的时间\n    * 用户登录：分时系统中，用户登录成功，系统会建立一个新的进程\n    * 作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程\n    * 提供服务：用户向操作系统提出某些请求时\n    * 应用请求：由用户进程主动请求创建一个子进程\n\n# 2.3.2 进程的终止\n\n 1. 撤销原语\n    * 从PCB集合中找到终止进程的PCB\n    * 若进程正在运行，立即剥夺CPU，将CPU分配给其他进程\n    * 终止其所有紫禁城\n    * 将该进程拥有的所有资源归还给父进程或操作系统\n    * 删除PCB\n 2. 引起进程终止的事件\n    * 正常结束\n    * 异常结束\n    * 外界干预\n\n# 2.3.3 进程的阻塞\n\n 1. 阻塞原语\n    * 找到要阻塞的进程对应的PCB\n    * 保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行\n    * 将PCB插入响应时间的等待队列\n 2. 引起进程阻塞的事件\n    * 需要等待系统分配某种资源\n    * 需要等待相互合作的其他进程完成工作\n\n# 2.3.4 进程的阻塞\n\n 1. 唤醒原语\n    * 在事件等待队列中找到PCB\n    * 将PCB从等待队列移除，设置进程为就绪态\n    * 将PCB插入就绪队列，等待被调度\n 2. 引起进程唤醒的事件\n    * 等待事件的发生\n\n# 2.3.5 进程的切换\n\n 1. 切换原语\n    * 将运行环境信息存入PCB\n    * PCB移入相应队列\n    * 选择另一个进程执行，并更新其PCB\n    * 根据PCB恢复新进程所需的运行环境\n 2. 引起进程切换的事件\n    * 当前进程时间片到\n    * 由更高优先级的进程到达\n    * 当前进程主动阻塞\n    * 当前进程终止\n\n\n# 2.4 进程通信\n\n 1. 进程通信指的进程之间的信息交换\n 2. 进程是分配系统资源的单位，因此各进程用欧的内存地址空间相互独立\n 3. 一个进程不能直接访问另一个进程的地址空间\n\n# 2.4.1 共享存储\n\n 1. 两个进程对共享空间的访问必须是互斥的\n 2. 给予数据结构的共享：速度慢、限制多，低级通信方式\n 3. 给予存储区的共享：速度快、限制少，高级通信方式\n\n# 2.4.2 管道通信\n\n 1. 管道：用于连接读写进程的共享文件，其实就是在内存中开辟一个大小固定的缓冲区\n 2. 管道只能采用半双工通信。要实现双向同事通信，需要设置两个管道\n 3. 各进程要互斥地访问管道\n 4. 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用江北阻塞，等待读进程将数据取走；当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞\n 5. 数据一旦被读出，就从管道中被抛弃。读进程最多只有一个\n\n# 2.4.3 消息传递\n\n 1. 进程间的数据交换以格式化消息为单位。通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换\n 2. 直接通信方式：消息直接挂到接收进程的消息缓冲队列上\n 3. 间接通信方式：消息先发送到中间实体\n\n\n# 2.5 线程\n\n 1. 线程：基本的CPU执行单元，也是程序执行流的最小单位\n 2. 引入线程之后，不仅进程之间可以并发，进程内个线程之间也可以并发。提高了系统的并发度\n 3. 引入线程后，进程只作为除CPU之外的系统资源的分配单元\n\n# 2.5.1 线程作用\n\n 1. 资源分配、调度\n    * 传统进程机制中，进程是资源分配、调度的基本单位\n    * 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位\n 2. 并发性\n    * 传统进程机制中，只能进程间并发\n    * 引入线程后，各线程间也能并发，提升了并发度\n 3. 系统开销\n    * 传统的进程并发，需要切换进程的运行环境，系统开销很大\n    * 线程间并发，如果是统一进程内的线程切换，则不需要切换进程环境，系统开销小\n    * 引入线程后，并发所带来的的系统开销减小\n\n# 2.5.2 线程属性\n\n 1.  线程是处理机调度的单位\n 2.  多CPU计算机中，各个线程克占用不同的CPU\n 3.  每个线程都有一个线程ID、线程控制块（TCB）\n 4.  线程也有就绪、足额、运行三种基本状态\n 5.  线程几乎不拥有系统资源\n 6.  统一进程的不同线程间共享进程的资源\n 7.  由于共享内存地址空间，统一进程中的线程建通信甚至无需系统干预\n 8.  统一进程中的线程切换，不会引入进程切换\n 9.  不同进程中的线程切换，会引入进程切换\n 10. 切换同进程内的线程，系统开销很小\n 11. 切换进程，系统开销很大\n\n# 2.5.3 线程的实现方式\n\n# 用户级线程（ULT）\n\n 1. 用户级线程由应用程序通过线程库实现\n 2. 所有线程管理工作都由应用程序负责（包括线程切换）\n 3. 用户级线程中，线程切换可以在用户态下完成，无需操作系统干预\n\n# 内核级线程（KLT）\n\n 1. 内核级线程的管理工作由操作系统内核完成\n 2. 内核级线程的切换必须在核心态下才能完成\n 3. 内核级线程才是处理机分配的单位\n\n# 2.5.4 多线程模型\n\n 1. 多对一模型：多个用户级线程映射到一个内核级线程\n    * 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高\n    * 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发性不高。多个线程不可在多核处理机上并行运行\n 2. 一对一模型：一个用户级线程映射到一个内核级线程\n    * 优点：当一个用户级线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行\n    * 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态。线程管理的成本高，开销大\n 3. 多对多模型：n用户线程映射到m各内核级线程（n>=m）\n    * 集二者所长",normalizedContent:"# 1 概述\n\n\n# 1.1 操作系统的概念\n\n# 1.1.1 操作系统的定义\n\n 1. 负责管理协调硬件、软件等计算机资源的工作\n 2. 为上层的应用程序、用户提供简单易用的服务\n 3. 操作系统是系统软件而不是硬件\n\n# 1.1.2 操作系统的功能和目标\n\n 1. 作为系统资源的管理者 功能：处理机管理；存储器管理；文件管理；设备管理 目标：安全、高效\n 2. 作为用户和计算机硬件的接口 功能：命令借口；程序接口；gui 目标：方便用户使用\n 3. 作为最接近硬件的层次 实现对硬件机器的扩展\n\n\n# 1.2 操作系统的特征\n\n# 1.2.1 并发\n\n指两个或多个时间在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的 操作系统的并发性：计算机系统中同时存在着多个运行着的程序\n\n# 1.2.2 共享\n\n资源共享：系统中的资源可供内存中多个并发执行的进程共同使用\n\n 1. 互斥共享方式\n 2. 同时共享方式\n\n# 1.2.3 虚拟\n\n把一个物理上的实体变为若干个逻辑上的对应物 空分复用技术；时分复用技术\n\n# 1.2.4 异步\n\n在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的而是走走停停，以不可预知的速度向前推进 只有系统拥有并发性才会导致异步性\n\n\n# 1.3 操作系统的发展和分类\n\n# 1.3.1 手工操作阶段\n\n用户独占全集、人机速度锚段导致资源利用率极低\n\n# 1.3.2 单道批处理系统\n\n引入脱机输入/输出（用磁带完成），并监督程序负责控制作业的输入、输出 缓解了人机速度矛盾，内存仅有一道程序运行\n\n# 1.3.3 多道批处理系统\n\n多道程序并发执行，共享计算机资源 没有人机交互功能，用户响应时间长\n\n# 1.3.4 分时操作系统\n\n计算机以时间片为单位轮流为各个用户/作业服务，各个用户通过终端与计算机进行交互 不能优先处理一些紧急任务\n\n# 1.3.5 实时操作系统\n\n能够优先响应一些紧急任务，具有及时性和可靠性\n\n 1. 硬实时系统：必须在绝对严格的规定时间内完成处理\n 2. 软实时操作系统：能接受偶尔违反时间规定\n\n\n# 1.4 操作系统的运行机制和体系结构\n\n指令：处理器能识别、执行的最基本命令\n\n# 1.4.1 运行机制\n\n# 两种指令\n\n 1. 特权指令：不允许用户程序使用\n 2. 非特权指令：\n\n# 两种处理器状态\n\n 1. 用户态（目态）：只能执行非特权指令\n 2. 核心态（管态）：特权和非特权指令都可以执行\n\n# 两种程\n\n 1. 内核程序：操作系统的内核程序书系统的管理者\n    * 既可以执行特权指令也可以执行非特权指令\n    * 运行在核心态\n 2. 应用程序\n    * 只能执行非特权指令\n    * 运行在用户态\n\n# 1.4.2 操作系统内核\n\n 1. 内核是计算机上配置的底层程序，是操作系统最基本、最核心的部分\n 2. 时钟管理：实现计时功能\n 3. 中断处理：负责实现中断机制\n 4. 原语\n    * 一种特殊的程序\n    * 处于操作系统最底层，最接近硬件的部分\n    * 运行具有原子性，只能一气呵成不能被中断\n    * 运行时间较短、调用频繁\n 5. 对系统资源进行管理的功能\n    * 进程管理\n    * 存储器管理\n    * 设备管理\n\n# 1.4.3 操作系统体系结构\n\n 1. 大内核：将操作系统的主要功能模块都作为系统内核，运行在核心态\n    * 优点：高性能\n    * 缺点：内核代码庞大，结构混乱，难以维护\n 2. 微内核：只把最基本的功能保留在内核\n    * 优点：内核功能少，结构清晰，方便维护\n    * 缺点：需要频繁地在核心态和用户态之间切换，性能低\n\n\n# 1.5 中断和异常\n\n 1. 发生中断就一位置需要操作系统介入，开展管理工作\n 2. 中断发生时cpu立即进入核心态，使操作系统获得计算机的控制权\n 3. 中断使用户态到核心态切换的唯一途径\n\n# 1.5.1 内中断\n\n 1. 也成异常、例外、陷入\n 2. 信号的来源：cpu内部，与当前执行的指令有关\n\n# 分类1\n\n 1. 自愿中断，又称指令中断\n 2. 强迫中断：\n    * 硬件故障\n    * 软件中断\n\n# 分类2\n\n 1. 陷阱、陷入（trap）：有意而为之的异常\n 2. 故障（fault）：由错误条件引起的\n 3. 终止（abort）：不可恢复的致命操作造成的结果\n\n# 1.5.2 外中断\n\n 1. 简称中断\n 2. 信号的来源：cpu外部与当前执行的指令无关\n\n# 外设请求\n\n# 人工干预\n\n# 处理过程\n\n 1. 执行完每个指令之后，cpu都要检测当前是否有外部中断信号\n 2. 如果检测到外部中断信号，则需要保护被中断进程的cpu环境\n 3. 根据中断信号类型转入响应的中断处理程序\n 4. 恢复原进程的cpu环境并推出中断，返回原进程继续往下执行\n\n\n# 1.6 系统调用\n\n 1. 系统调用是操作系统提供给应用程序使用的接口\n 2. 应用程序通过系统调用请求操作系统的服务可以保证系统的稳定性和安全性\n 3. 系统调用的相关处理在核心态进行\n\n# 1.6.1 系统调用过程\n\n 1. 传递系统调用参数\n 2. 执行陷入指令\n 3. 执行系统调用响应服务程序\n 4. 返回用户程序\n 5. 发生系统调用请求实在用户态，但对系统调用的相应处理在核心态下进行\n 6. 陷入指令是唯一一个只能在用户态执行，而不能在核心态执行的指令\n\n\n# 2 进程\n\n\n# 2.1 进程概述\n\n# 2.1.1 进程的定义\n\n 1. 程序：一个指令序列\n 2. 进程实体（进程映像）\n    * 进程控制块（pcb）：系统为每个运行的程序配置的一个数据结构，用来描述进程的各种信息\n    * 程序段\n    * 数据段\n 3. pcb是进程存在的唯一标志\n 4. 创建进程实质上是创建进程实体中的pcb；撤销进程实质上是撤销进程实体中的pcb\n 5. 进程定义：强调动态性\n    * 进程是程序的一次执行过程\n    * 进程是一个程序及其数据在处理机上顺序执行时所发生的活动\n    * 进程是具有独立功能的程序在数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位\n    * 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位\n\n# 2.1.2 进程的组成\n\n 1. 进程（进程实体）由程序段、数据段、pcb三个部分组成\n 2. 程序段：存放要执行的代码\n 3. 数据段：存放程序运行时使用、产生的运算数据\n 4. pcb：包含操作系统对其进行管理所需的各种信息\n    * 进程描述信息\n      * 进程标识符pid：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的id，用于区分不同的进程\n      * 用户标识符uid\n    * 进程控制和管理信息\n      * 进程当前状态\n      * 进程优先级\n    * 资源分配清单\n      * 程序段指针\n      * 数据段指针\n      * 键盘\n      * 鼠标\n    * 处理机相关信息：各种寄存器值\n\n# 2.1.3 进程的组织\n\n 1. 进程的组成讨论的是一个进程内部由那些部分构成的问题；而进程的组织讨论的是多个进程之间的组织方式问题\n 2. 链接方式\n    * 按照进程状态将pcb分为多个队列\n    * 操作系统持有指向各个队列的指针\n 3. 索引方式\n    * 根据进程状态的不同，建立几张索引表\n    * 操作系统持有指向各个索引表的指针\n\n# 2.1.4 进程的特征\n\n 1. 动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的\n 2. 并发性：内存中有多个进程实体，各进程可并发执行\n 3. 独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位\n 4. 异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题\n 5. 结构性：每个进程都会配置一个pcb。结构上看，进程由程序段、数据段、pcb组成\n\n\n# 2.2 进程状态\n\n# 2.2.1 进程的状态\n\n 1. 运行态：战友cpu，并在cpu上运行\n    * 在单核处理机环境下，每一个时刻最多只有一个进程处于运行态\n 2. 就绪态：已经具备运行条件，但由于没有空闲cpu，而暂时不能运行\n    * 进程已经拥有了除处理机之外的所有需要资源，一旦你获得处理机可以立即进入运行态开始运行\n 3. 阻塞态（等待态）：因等待某一事件而暂时不能运行\n 4. 创建态：进程正在被创建，操作系统为进程分配资源、初始化pcb\n 5. 终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销pcb\n\n# 2.2.2 进程状态的装换\n\n 1. 就绪态———运行态：进程被调度\n 2. 运行态———就绪态：时间片到，或cpu被其他搞优先级的进程抢占\n 3. 运行态———阻塞态：等待系统资源分配，或等待某时间发生（主动行为）\n 4. 阻塞态———就绪态：资源分配到位，等待的时间发生（被动行为）\n 5. 创建态———就绪态：系统完成创建进程相关工作\n 6. 运行态———终止态：进程运行结束，或运行过程中遇到不可修复的错误\n\n\n# 2.3 进程控制\n\n 1. 进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新锦成、撤销已有进程、实现进程状态转换等功能\n 2. 用原语实现进程控制\n 3. 原语的特点是执行期间不允许中断，只能一气呵成\n 4. 这种不可被中断的操作称为原子操作，采用“关中断指令”和“开中断指令”实现\n 5. 原语运行在核心态\n 6. 关/开中断指令只允许在核心态下执行\n\n# 2.3.1 进程的创建\n\n 1. 创建原语\n    * 申请空白pcb\n    * 为新进程分配所需资源\n    * 初始化pcb\n    * 将pcb插入就绪队列\n 2. 引起进程创建的时间\n    * 用户登录：分时系统中，用户登录成功，系统会建立一个新的进程\n    * 作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程\n    * 提供服务：用户向操作系统提出某些请求时\n    * 应用请求：由用户进程主动请求创建一个子进程\n\n# 2.3.2 进程的终止\n\n 1. 撤销原语\n    * 从pcb集合中找到终止进程的pcb\n    * 若进程正在运行，立即剥夺cpu，将cpu分配给其他进程\n    * 终止其所有紫禁城\n    * 将该进程拥有的所有资源归还给父进程或操作系统\n    * 删除pcb\n 2. 引起进程终止的事件\n    * 正常结束\n    * 异常结束\n    * 外界干预\n\n# 2.3.3 进程的阻塞\n\n 1. 阻塞原语\n    * 找到要阻塞的进程对应的pcb\n    * 保护进程运行现场，将pcb状态信息设置为“阻塞态”，暂时停止进程运行\n    * 将pcb插入响应时间的等待队列\n 2. 引起进程阻塞的事件\n    * 需要等待系统分配某种资源\n    * 需要等待相互合作的其他进程完成工作\n\n# 2.3.4 进程的阻塞\n\n 1. 唤醒原语\n    * 在事件等待队列中找到pcb\n    * 将pcb从等待队列移除，设置进程为就绪态\n    * 将pcb插入就绪队列，等待被调度\n 2. 引起进程唤醒的事件\n    * 等待事件的发生\n\n# 2.3.5 进程的切换\n\n 1. 切换原语\n    * 将运行环境信息存入pcb\n    * pcb移入相应队列\n    * 选择另一个进程执行，并更新其pcb\n    * 根据pcb恢复新进程所需的运行环境\n 2. 引起进程切换的事件\n    * 当前进程时间片到\n    * 由更高优先级的进程到达\n    * 当前进程主动阻塞\n    * 当前进程终止\n\n\n# 2.4 进程通信\n\n 1. 进程通信指的进程之间的信息交换\n 2. 进程是分配系统资源的单位，因此各进程用欧的内存地址空间相互独立\n 3. 一个进程不能直接访问另一个进程的地址空间\n\n# 2.4.1 共享存储\n\n 1. 两个进程对共享空间的访问必须是互斥的\n 2. 给予数据结构的共享：速度慢、限制多，低级通信方式\n 3. 给予存储区的共享：速度快、限制少，高级通信方式\n\n# 2.4.2 管道通信\n\n 1. 管道：用于连接读写进程的共享文件，其实就是在内存中开辟一个大小固定的缓冲区\n 2. 管道只能采用半双工通信。要实现双向同事通信，需要设置两个管道\n 3. 各进程要互斥地访问管道\n 4. 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用江北阻塞，等待读进程将数据取走；当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞\n 5. 数据一旦被读出，就从管道中被抛弃。读进程最多只有一个\n\n# 2.4.3 消息传递\n\n 1. 进程间的数据交换以格式化消息为单位。通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换\n 2. 直接通信方式：消息直接挂到接收进程的消息缓冲队列上\n 3. 间接通信方式：消息先发送到中间实体\n\n\n# 2.5 线程\n\n 1. 线程：基本的cpu执行单元，也是程序执行流的最小单位\n 2. 引入线程之后，不仅进程之间可以并发，进程内个线程之间也可以并发。提高了系统的并发度\n 3. 引入线程后，进程只作为除cpu之外的系统资源的分配单元\n\n# 2.5.1 线程作用\n\n 1. 资源分配、调度\n    * 传统进程机制中，进程是资源分配、调度的基本单位\n    * 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位\n 2. 并发性\n    * 传统进程机制中，只能进程间并发\n    * 引入线程后，各线程间也能并发，提升了并发度\n 3. 系统开销\n    * 传统的进程并发，需要切换进程的运行环境，系统开销很大\n    * 线程间并发，如果是统一进程内的线程切换，则不需要切换进程环境，系统开销小\n    * 引入线程后，并发所带来的的系统开销减小\n\n# 2.5.2 线程属性\n\n 1.  线程是处理机调度的单位\n 2.  多cpu计算机中，各个线程克占用不同的cpu\n 3.  每个线程都有一个线程id、线程控制块（tcb）\n 4.  线程也有就绪、足额、运行三种基本状态\n 5.  线程几乎不拥有系统资源\n 6.  统一进程的不同线程间共享进程的资源\n 7.  由于共享内存地址空间，统一进程中的线程建通信甚至无需系统干预\n 8.  统一进程中的线程切换，不会引入进程切换\n 9.  不同进程中的线程切换，会引入进程切换\n 10. 切换同进程内的线程，系统开销很小\n 11. 切换进程，系统开销很大\n\n# 2.5.3 线程的实现方式\n\n# 用户级线程（ult）\n\n 1. 用户级线程由应用程序通过线程库实现\n 2. 所有线程管理工作都由应用程序负责（包括线程切换）\n 3. 用户级线程中，线程切换可以在用户态下完成，无需操作系统干预\n\n# 内核级线程（klt）\n\n 1. 内核级线程的管理工作由操作系统内核完成\n 2. 内核级线程的切换必须在核心态下才能完成\n 3. 内核级线程才是处理机分配的单位\n\n# 2.5.4 多线程模型\n\n 1. 多对一模型：多个用户级线程映射到一个内核级线程\n    * 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高\n    * 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发性不高。多个线程不可在多核处理机上并行运行\n 2. 一对一模型：一个用户级线程映射到一个内核级线程\n    * 优点：当一个用户级线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行\n    * 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态。线程管理的成本高，开销大\n 3. 多对多模型：n用户线程映射到m各内核级线程（n>=m）\n    * 集二者所长",charsets:{cjk:!0},lastUpdated:"2023/03/27, 17:41:36",lastUpdatedTimestamp:1679910096e3},{title:"Git",frontmatter:{title:"Git",date:"2022-04-11T16:46:26.000Z",permalink:"/pages/184fd9/",categories:["计算机基础","Git"],tags:["Git"],author:{name:"年华惊风雨",link:"https://github.com/wsy425"}},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%20Git/00.%20Git.html",relativePath:"02.计算机基础/10. Git/00. Git.md",key:"v-5512e450",path:"/pages/184fd9/",headers:[{level:2,title:"1 git原理",slug:"_1-git原理",normalizedTitle:"1 git原理",charIndex:2},{level:3,title:"1.1 snapshot",slug:"_1-1-snapshot",normalizedTitle:"1.1 snapshot",charIndex:14},{level:3,title:"1.2 可撤销s",slug:"_1-2-可撤销s",normalizedTitle:"1.2 可撤销s",charIndex:49},{level:3,title:"1.3 本地操作",slug:"_1-3-本地操作",normalizedTitle:"1.3 本地操作",charIndex:81},{level:2,title:"2 git clone和git push",slug:"_2-git-clone和git-push",normalizedTitle:"2 git clone和git push",charIndex:108},{level:3,title:"2.1 git clone",slug:"_2-1-git-clone",normalizedTitle:"2.1 git clone",charIndex:133},{level:3,title:"2.2 git push",slug:"_2-2-git-push",normalizedTitle:"2.2 git push",charIndex:185},{level:2,title:"3 Git文件四大状态",slug:"_3-git文件四大状态",normalizedTitle:"3 git文件四大状态",charIndex:236},{level:3,title:"3.1 untrack 未记录",slug:"_3-1-untrack-未记录",normalizedTitle:"3.1 untrack 未记录",charIndex:252},{level:3,title:"3.2 modified 修改过",slug:"_3-2-modified-修改过",normalizedTitle:"3.2 modified 修改过",charIndex:322},{level:3,title:"3.3 staged 暂存",slug:"_3-3-staged-暂存",normalizedTitle:"3.3 staged 暂存",charIndex:435},{level:3,title:"3.4 committed 已提交",slug:"_3-4-committed-已提交",normalizedTitle:"3.4 committed 已提交",charIndex:512},{level:3,title:"3.5 总结",slug:"_3-5-总结",normalizedTitle:"3.5 总结",charIndex:578},{level:2,title:"4 gitignore",slug:"_4-gitignore",normalizedTitle:"4 gitignore",charIndex:616},{level:3,title:"4.1 作用",slug:"_4-1-作用",normalizedTitle:"4.1 作用",charIndex:632},{level:3,title:"4.2 使用方法",slug:"_4-2-使用方法",normalizedTitle:"4.2 使用方法",charIndex:669},{level:3,title:"4.3 gitignore文件语法",slug:"_4-3-gitignore文件语法",normalizedTitle:"4.3 gitignore文件语法",charIndex:741},{level:4,title:"4.3.1 #表示注释",slug:"_4-3-1-表示注释",normalizedTitle:"4.3.1 #表示注释",charIndex:762},{level:4,title:"4.3.2 /忽略整个文件夹",slug:"_4-3-2-忽略整个文件夹",normalizedTitle:"4.3.2 /忽略整个文件夹",charIndex:777},{level:4,title:"4.3.3 ！表示取反",slug:"_4-3-3-表示取反",normalizedTitle:"4.3.3 ！表示取反",charIndex:824},{level:4,title:"4.3.4 glob模式匹配",slug:"_4-3-4-glob模式匹配",normalizedTitle:"4.3.4 glob模式匹配",charIndex:869},{level:2,title:"5 git diff",slug:"_5-git-diff",normalizedTitle:"5 git diff",charIndex:975},{level:3,title:"5.1 git diff + 文件路径",slug:"_5-1-git-diff-文件路径",normalizedTitle:"5.1 git diff + 文件路径",charIndex:1006},{level:3,title:"5.2 git diff --cached",slug:"_5-2-git-diff-cached",normalizedTitle:"5.2 git diff --cached",charIndex:1052},{level:3,title:"5.3 其他不常用用法",slug:"_5-3-其他不常用用法",normalizedTitle:"5.3 其他不常用用法",charIndex:1096},{level:2,title:"6 git log",slug:"_6-git-log",normalizedTitle:"6 git log",charIndex:1319},{level:3,title:"6.1 git log -p",slug:"_6-1-git-log-p",normalizedTitle:"6.1 git log -p",charIndex:1455},{level:3,title:"6.2 git log --start",slug:"_6-2-git-log-start",normalizedTitle:"6.2 git log --start",charIndex:1541},{level:3,title:"6.3 git log --pretty",slug:"_6-3-git-log-pretty",normalizedTitle:"6.3 git log --pretty",charIndex:1594},{level:2,title:"7 git恢复相关",slug:"_7-git恢复相关",normalizedTitle:"7 git恢复相关",charIndex:1826},{level:3,title:"7.1 git中删除文件",slug:"_7-1-git中删除文件",normalizedTitle:"7.1 git中删除文件",charIndex:1840},{level:3,title:"7.2 git中删除记录",slug:"_7-2-git中删除记录",normalizedTitle:"7.2 git中删除记录",charIndex:1940},{level:3,title:"7.3 删除暂存区文件",slug:"_7-3-删除暂存区文件",normalizedTitle:"7.3 删除暂存区文件",charIndex:2109},{level:3,title:"7.4 回滚commit版本",slug:"_7-4-回滚commit版本",normalizedTitle:"7.4 回滚commit版本",charIndex:2167},{level:3,title:"7.5 回滚文件版本",slug:"_7-5-回滚文件版本",normalizedTitle:"7.5 回滚文件版本",charIndex:2231},{level:2,title:"8 git分支(branch)",slug:"_8-git分支-branch",normalizedTitle:"8 git分支(branch)",charIndex:2295},{level:3,title:"8.1 git结构",slug:"_8-1-git结构",normalizedTitle:"8.1 git结构",charIndex:2315},{level:3,title:"8.2 创建分支",slug:"_8-2-创建分支",normalizedTitle:"8.2 创建分支",charIndex:2369},{level:3,title:"8.3 HEAD指针",slug:"_8-3-head指针",normalizedTitle:"8.3 head指针",charIndex:2418},{level:3,title:"8.4 分支合并",slug:"_8-4-分支合并",normalizedTitle:"8.4 分支合并",charIndex:2495},{level:4,title:"8.4.1 快速合并(fast-forward)",slug:"_8-4-1-快速合并-fast-forward",normalizedTitle:"8.4.1 快速合并(fast-forward)",charIndex:2559},{level:4,title:"8.4.2 创建新commit",slug:"_8-4-2-创建新commit",normalizedTitle:"8.4.2 创建新commit",charIndex:2664},{level:3,title:"8.5 合并分支冲突",slug:"_8-5-合并分支冲突",normalizedTitle:"8.5 合并分支冲突",charIndex:2796},{level:4,title:"8.5.1 查看冲突",slug:"_8-5-1-查看冲突",normalizedTitle:"8.5.1 查看冲突",charIndex:2810},{level:4,title:"8.5.2 手动解决",slug:"_8-5-2-手动解决",normalizedTitle:"8.5.2 手动解决",charIndex:2834},{level:4,title:"8.5.3 放弃合并",slug:"_8-5-3-放弃合并",normalizedTitle:"8.5.3 放弃合并",charIndex:2877},{level:4,title:"8.5.4 git合并工具",slug:"_8-5-4-git合并工具",normalizedTitle:"8.5.4 git合并工具",charIndex:2910},{level:4,title:"8.5.5 IDE工具",slug:"_8-5-5-ide工具",normalizedTitle:"8.5.5 ide工具",charIndex:2952},{level:2,title:"9 远程分支",slug:"_9-远程分支",normalizedTitle:"9 远程分支",charIndex:2968},{level:3,title:"9.1 origin指针",slug:"_9-1-origin指针",normalizedTitle:"9.1 origin指针",charIndex:2979},{level:3,title:"9.2 操作命令",slug:"_9-2-操作命令",normalizedTitle:"9.2 操作命令",charIndex:3020},{level:4,title:"9.2.1 代码拉取",slug:"_9-2-1-代码拉取",normalizedTitle:"9.2.1 代码拉取",charIndex:3032},{level:4,title:"9.2.2 代码推送",slug:"_9-2-2-代码推送",normalizedTitle:"9.2.2 代码推送",charIndex:3135},{level:2,title:"10 git rebase",slug:"_10-git-rebase",normalizedTitle:"10 git rebase",charIndex:3272},{level:3,title:"10.1 rebase简介",slug:"_10-1-rebase简介",normalizedTitle:"10.1 rebase简介",charIndex:3290},{level:4,title:"10.1.1 onto参数",slug:"_10-1-1-onto参数",normalizedTitle:"10.1.1 onto参数",charIndex:3423},{level:3,title:"10.2 实践网站",slug:"_10-2-实践网站",normalizedTitle:"10.2 实践网站",charIndex:3556},{level:3,title:"10.3 使用禁忌",slug:"_10-3-使用禁忌",normalizedTitle:"10.3 使用禁忌",charIndex:3579},{level:2,title:"11 git show",slug:"_11-git-show",normalizedTitle:"11 git show",charIndex:3627},{level:3,title:"11.1 查看某个commit下的改动",slug:"_11-1-查看某个commit下的改动",normalizedTitle:"11.1 查看某个commit下的改动",charIndex:3654},{level:3,title:"11.2 查看分支下的改动",slug:"_11-2-查看分支下的改动",normalizedTitle:"11.2 查看分支下的改动",charIndex:3783},{level:2,title:"12 git reflog",slug:"_12-git-reflog",normalizedTitle:"12 git reflog",charIndex:3911},{level:2,title:"13 区间选择",slug:"_13-区间选择",normalizedTitle:"13 区间选择",charIndex:4086},{level:3,title:"13.1 双点",slug:"_13-1-双点",normalizedTitle:"13.1 双点",charIndex:4098},{level:4,title:"13.1.1 常用",slug:"_13-1-1-常用",normalizedTitle:"13.1.1 常用",charIndex:4169},{level:3,title:"13.2 三点",slug:"_13-2-三点",normalizedTitle:"13.2 三点",charIndex:4237},{level:3,title:"13.3 多点",slug:"_13-3-多点",normalizedTitle:"13.3 多点",charIndex:4353},{level:2,title:"14 交互式工具",slug:"_14-交互式工具",normalizedTitle:"14 交互式工具",charIndex:4422},{level:3,title:"14.1 交互式暂存",slug:"_14-1-交互式暂存",normalizedTitle:"14.1 交互式暂存",charIndex:4535},{level:3,title:"14.2 查看改动",slug:"_14-2-查看改动",normalizedTitle:"14.2 查看改动",charIndex:4648},{level:3,title:"14.3 取消暂存",slug:"_14-3-取消暂存",normalizedTitle:"14.3 取消暂存",charIndex:4732},{level:3,title:"14.4 暂存补丁",slug:"_14-4-暂存补丁",normalizedTitle:"14.4 暂存补丁",charIndex:4794},{level:2,title:"15 stash储藏",slug:"_15-stash储藏",normalizedTitle:"15 stash储藏",charIndex:4939},{level:3,title:"15.1 储藏",slug:"_15-1-储藏",normalizedTitle:"15.1 储藏",charIndex:5003},{level:3,title:"15.2 还原",slug:"_15-2-还原",normalizedTitle:"15.2 还原",charIndex:5190},{level:2,title:"16 查找",slug:"_16-查找",normalizedTitle:"16 查找",charIndex:5340},{level:3,title:"16.1 代码函数搜索",slug:"_16-1-代码函数搜索",normalizedTitle:"16.1 代码函数搜索",charIndex:5350},{level:3,title:"16.2 日志搜索",slug:"_16-2-日志搜索",normalizedTitle:"16.2 日志搜索",charIndex:5510}],headersStr:"1 git原理 1.1 snapshot 1.2 可撤销s 1.3 本地操作 2 git clone和git push 2.1 git clone 2.2 git push 3 Git文件四大状态 3.1 untrack 未记录 3.2 modified 修改过 3.3 staged 暂存 3.4 committed 已提交 3.5 总结 4 gitignore 4.1 作用 4.2 使用方法 4.3 gitignore文件语法 4.3.1 #表示注释 4.3.2 /忽略整个文件夹 4.3.3 ！表示取反 4.3.4 glob模式匹配 5 git diff 5.1 git diff + 文件路径 5.2 git diff --cached 5.3 其他不常用用法 6 git log 6.1 git log -p 6.2 git log --start 6.3 git log --pretty 7 git恢复相关 7.1 git中删除文件 7.2 git中删除记录 7.3 删除暂存区文件 7.4 回滚commit版本 7.5 回滚文件版本 8 git分支(branch) 8.1 git结构 8.2 创建分支 8.3 HEAD指针 8.4 分支合并 8.4.1 快速合并(fast-forward) 8.4.2 创建新commit 8.5 合并分支冲突 8.5.1 查看冲突 8.5.2 手动解决 8.5.3 放弃合并 8.5.4 git合并工具 8.5.5 IDE工具 9 远程分支 9.1 origin指针 9.2 操作命令 9.2.1 代码拉取 9.2.2 代码推送 10 git rebase 10.1 rebase简介 10.1.1 onto参数 10.2 实践网站 10.3 使用禁忌 11 git show 11.1 查看某个commit下的改动 11.2 查看分支下的改动 12 git reflog 13 区间选择 13.1 双点 13.1.1 常用 13.2 三点 13.3 多点 14 交互式工具 14.1 交互式暂存 14.2 查看改动 14.3 取消暂存 14.4 暂存补丁 15 stash储藏 15.1 储藏 15.2 还原 16 查找 16.1 代码函数搜索 16.2 日志搜索",content:'# 1 git原理\n\n\n# 1.1 snapshot\n\n直接将发生变更的文件记录一个快照\n\n\n# 1.2 可撤销s\n\n几乎所有提交快照的操作都是可撤销的\n\n\n# 1.3 本地操作\n\n大多数的操作可以本地进行\n\n\n# 2 git clone和git push\n\n\n# 2.1 git clone\n\ngit clone + SSH协议（+你想定义的下载文件夹名字）\n\n\n# 2.2 git push\n\n在push之前一定要先git pull使本地文件夹与远程仓库同步\n\n\n# 3 Git文件四大状态\n\n\n# 3.1 untrack 未记录\n\n 1. 新创建的没有记录名称的文件\n 2. 用 git add来记录，使文件变为staged状态\n\n\n# 3.2 modified 修改过\n\n 1. 已经记录单最近发生了修改的文件\n 2. 用git add来记录，使文件变为staged状态\n 3. 用git restore来取消文件登记信息，使文件变为untrack状态\n\n\n# 3.3 staged 暂存\n\n 1. 文件在git系统中记录的是最新状态\n 2. 用git commit来提交，是文件变为committed状态\n\n\n# 3.4 committed 已提交\n\n 1. 文件提交到本地git仓库中\n 2. 用git push将文件推送至远程仓库中\n\n\n# 3.5 总结\n\n 1. git status查看文件状态\n 2. \n\n\n# 4 gitignore\n\n\n# 4.1 作用\n\n使用git add .的时候避开一些不上传的文件\n\n\n# 4.2 使用方法\n\n 1. 在git目录下创建一个.gitignore文件\n 2. 参考gitignore文件模板，修改成为自己的文件\n\n\n# 4.3 gitignore文件语法\n\n# 4.3.1 #表示注释\n\n# 4.3.2 /忽略整个文件夹\n\nscr/build/忽略了整个scr/build的内容\n\n# 4.3.3 ！表示取反\n\n！main.go保留main.go文件，与上一条搭配使用\n\n# 4.3.4 glob模式匹配\n\n 1. *表示一切字符串，*.txt表示过滤一切txt文件\n 2. [] 表示方括号中任何一个字符，[0-9]表示匹配0-9中任意一个数字\n 3. ？表示匹配任何一个字符\n\n\n# 5 git diff\n\n查看当前工作区与暂存区的差别\n\n\n# 5.1 git diff + 文件路径\n\n加上文件名，查看一下某一个文件具体的改动\n\n\n# 5.2 git diff --cached\n\n查看暂存区和本地git仓库的差别\n\n\n# 5.3 其他不常用用法\n\n 1. git diff <commitid> 比较工作区和某一个提交的差别\n 2. git diff <commitid> <filepath> 比较工作区和某一个提交某一个文件的差别\n 3. git diff --cached <commitid> 比较暂存区和某一个提交的差别\n 4. git diff --cached <commitid> <filepath> 比较暂存区和某一个提交某一个文件的差别\n\n\n# 6 git log\n\n查看之前的提交记录\n\n 1. commit id git log后commit后面跟着的一长串 git对commit id有自动补全功能，赋值前几位就可以了\n 2. 提交信息 每次commit -m之后后面输入的字符串，是比较关键的提示信息\n\n\n# 6.1 git log -p\n\n展示出每一个commit中的改动，相当于同时做git diff git log -p -n：查最近几条的提交记录及commit改动\n\n\n# 6.2 git log --start\n\n在查看提交记录的基础上查看每次commit有多少改动量\n\n\n# 6.3 git log --pretty\n\npretty支持让我们自己DIY想看到的log展示 官方提供了oneline、short、full、fuller几种模板 可以自己定义，例如定义log日志当中应该包含commitid，提交时间，作者以及comment。那么定义出一种格式：%h - %ad - %an - %s命令行则为 git log --pretty=format:"%h - %ad - %an - %s" 官方提供了pretty参数表格\n\n\n# 7 git恢复相关\n\n\n# 7.1 git中删除文件\n\ngit rm 将文件从git以及文件系统当中一起移除（本地仓库、暂存、本地都删） 提交后从下一个提交开始这个文件就不会被存储一份了 留下添加文件和删除文件两条记录\n\n\n# 7.2 git中删除记录\n\ngit commit --amend 在删除文件后使用该指令在当前commit上修补而不是提交新的commit，这样就不会留下记录了\n\n * 如果记录已经push到远程，使用该指令会导致和远程记录不吻合，需要使用git push -f强行push，但这会覆盖远程commit，可能会导致其他人代码紊乱\n\n\n# 7.3 删除暂存区文件\n\ngit rm --cached 尚未commit的文件仅删除暂存区，保留本地文件\n\n\n# 7.4 回滚commit版本\n\ngit reset --soft HEAD^ 所有文件状态返回某一个commit的版本\n\n\n# 7.5 回滚文件版本\n\ngit checkout -- filename 将文件恢复到之前提交的状态（本地和暂存都是）\n\n\n# 8 git分支(branch)\n\n\n# 8.1 git结构\n\n在git当中我们使用的分支其实是一个一个在commit当中切换的指针 例子：\n\n\n# 8.2 创建分支\n\ngit branch XXX git checkout -b XXX\n\n\n# 8.3 HEAD指针\n\n指向当前代码仓库的位置 可以移动到任意结点上 移动HEAD指针 git checkout (commit id/分支名)\n\n\n# 8.4 分支合并\n\ngit checkout master git merge test 将test合并到master上\n\n# 8.4.1 快速合并(fast-forward)\n\ntest分支是从master分支当中切出去的，后来master分支就再也没有进行过改动 合并的时候，其实只需要移动master指针到test分支上即可\n\n# 8.4.2 创建新commit\n\ntest分支是从master分支当中切出去后来master分支有改动 由于不是直接上下游关系了，所以git创建了一个新的commit用来合并两个分支的代码 合并之后应该删除没用的分支 git branch -d test\n\n\n# 8.5 合并分支冲突\n\n# 8.5.1 查看冲突\n\ngit diff\n\n# 8.5.2 手动解决\n\n把提示行去掉 留下想要的代码，重新add、commit\n\n# 8.5.3 放弃合并\n\ngit merge --abort\n\n# 8.5.4 git合并工具\n\ngit merge tool 不好用，一般不用\n\n# 8.5.5 IDE工具\n\n\n# 9 远程分支\n\n\n# 9.1 origin指针\n\n和master指针性质一样，代表远程远程仓库\n\n\n# 9.2 操作命令\n\n# 9.2.1 代码拉取\n\ngit fetch:将远程改动同步到本地（针对远程的所有改动），如果有多个远程的话要指定远程名称 git pull只针对当前分支对应的远程分支，而且多了一步merge合并操作\n\n# 9.2.2 代码推送\n\n本地的分支是不会自动和远程同步的 git push origin test git branch --set-upstream-to master origin/master：将本地分支和远程建立映射 映射之后就可以直接使用git push\n\n\n# 10 git rebase\n\n\n# 10.1 rebase简介\n\n提取我们在A分支上的改动，然后应用在B分支的代码上\n\ngit checkout bugFix\ngit rebase master\ngit checkout master\ngit merge bugFix\n\n\n1\n2\n3\n4\n\n\n\n\n# 10.1.1 onto参数\n\n确定rebase的范围 git rebase --onto master feature bugFix git执行这条命令的时候会先找到feature和bugFix的共同祖先，然后将共同祖先之后的部分rebase到master\n\n\n# 10.2 实践网站\n\n图形化演示网站\n\n\n# 10.3 使用禁忌\n\n如果还有其他分支依赖了当前分支，我们这时候不可以使用rebase\n\n\n# 11 git show\n\n查看代码层面的改动\n\n\n# 11.1 查看某个commit下的改动\n\ngit show commit_id commit id的查找 git log --stat列举每个commit具体到文件级别的改动 git log --pretty=online将git提交记录压缩成一行\n\n\n# 11.2 查看分支下的改动\n\ngit show test查看test分支下最后一个提交节点的改动 git show test^查看test分支下最后一个节点的父节点改动 git show test~3查看test分支下最后一个节点的前第三个父节点\n\n\n# 12 git reflog\n\nreflog = reference log 查看引用日志 第一列表示commit id；第二列表示分支；第三列表示相对位置，相对于现在HEAD指针的位置；最后一列记录HEAD指针移动情况 可以通过这个方式查找git log无法查找在现在HEAD指针之后提交过的commit id，然后checkout指针恢复\n\n\n# 13 区间选择\n\n\n# 13.1 双点\n\ngit log master..experiment 筛选出在experiment当中但是不在master当中的提交\n\n# 13.1.1 常用\n\ngit log origin/master..HEAD 比较的是当前节点以及远程push的分支之间的差别\n\n\n# 13.2 三点\n\ngit log master...experiment 展示这两个分支各自独有的提交 git log --left-right master...experiment 用箭头表明这些提交分别被哪个分支独有\n\n\n# 13.3 多点\n\ngit log A B ^C git log A B --not C 查看在A或和B当中，但是不在C当中的提交\n\n\n# 14 交互式工具\n\ngit add -i 会出现八个选项：\n\n 1. status\n 2. update\n 3. revert\n 4. add\n 5. patch\n 6. diff\n 7. quit\n 8. help\n\n\n# 14.1 交互式暂存\n\n 1. 在git add -i后选择4（add）\n 2. 选择代表需要添加文件的序号\n 3. 选择过后该序号前会出现*\n 4. 敲击回车会返回上层菜单\n 5. 选择7退出后git状态会随之改变\n\n\n# 14.2 查看改动\n\n 1. 在git add- i后选择6（diff）\n 2. 选择代表要看改动文件的序号\n 3. 等效于git diff --cached\n\n\n# 14.3 取消暂存\n\n 1. 在git add -i后选择3（revert）\n 2. 选择代表向撤销暂存文件的序号\n\n\n# 14.4 暂存补丁\n\n可以通过这个功能把文件一部分添加进git，另一部分改动先保留在本地\n\n 1. 在git add -i后选择5（patch）\n 2. 选择代表需要补丁暂存文件的序号\n 3. git会把改动一个部分一个部分地询问\n 4. 输入y则表示加入git暂存；n表示不加入\n\n\n# 15 stash储藏\n\n将改动的内容储藏起来避免checkout的时候出现问题被覆盖，也避免其被commit并push\n\n\n# 15.1 储藏\n\n 1. git stash 把我们本地所有没有commit的内容都暂存了起来，这样方便我们进行checkout或者是其他一些操作，而不会起冲突或者是其他的影响\n 2. git stash --keep-index 只暂存没有add到暂存区的内容\n 3. git stash -u stash的时候将新创建并且还没有被git管理的文件也一并储藏起来\n\n\n# 15.2 还原\n\n 1. git stash apply 记录仍将保留 可以选择应用的记录 git stash apply stash@{2}\n 2. git stash pop 应用后记录会被删除 只能还原栈顶的记录\n 3. git stash apply --index 暂存文件的复原\n\n\n# 16 查找\n\n\n# 16.1 代码函数搜索\n\n 1. 展示函数出现过的位置 git grep 函数名\n 2. 展示函数出现过的具体位置 git grep -n 函数名 可以显示函数出现位置的行数\n 3. 查找某一个版本的代码 git grep 函数名 git commit/tag号码 可以避免使用IDE工具checkout的步骤\n\n\n# 16.2 日志搜索\n\ngit log -L :函数名:文件名 可以查找文件名下该函数的变更，会展示出代码变更时间、对应的具体代码和修改人',normalizedContent:'# 1 git原理\n\n\n# 1.1 snapshot\n\n直接将发生变更的文件记录一个快照\n\n\n# 1.2 可撤销s\n\n几乎所有提交快照的操作都是可撤销的\n\n\n# 1.3 本地操作\n\n大多数的操作可以本地进行\n\n\n# 2 git clone和git push\n\n\n# 2.1 git clone\n\ngit clone + ssh协议（+你想定义的下载文件夹名字）\n\n\n# 2.2 git push\n\n在push之前一定要先git pull使本地文件夹与远程仓库同步\n\n\n# 3 git文件四大状态\n\n\n# 3.1 untrack 未记录\n\n 1. 新创建的没有记录名称的文件\n 2. 用 git add来记录，使文件变为staged状态\n\n\n# 3.2 modified 修改过\n\n 1. 已经记录单最近发生了修改的文件\n 2. 用git add来记录，使文件变为staged状态\n 3. 用git restore来取消文件登记信息，使文件变为untrack状态\n\n\n# 3.3 staged 暂存\n\n 1. 文件在git系统中记录的是最新状态\n 2. 用git commit来提交，是文件变为committed状态\n\n\n# 3.4 committed 已提交\n\n 1. 文件提交到本地git仓库中\n 2. 用git push将文件推送至远程仓库中\n\n\n# 3.5 总结\n\n 1. git status查看文件状态\n 2. \n\n\n# 4 gitignore\n\n\n# 4.1 作用\n\n使用git add .的时候避开一些不上传的文件\n\n\n# 4.2 使用方法\n\n 1. 在git目录下创建一个.gitignore文件\n 2. 参考gitignore文件模板，修改成为自己的文件\n\n\n# 4.3 gitignore文件语法\n\n# 4.3.1 #表示注释\n\n# 4.3.2 /忽略整个文件夹\n\nscr/build/忽略了整个scr/build的内容\n\n# 4.3.3 ！表示取反\n\n！main.go保留main.go文件，与上一条搭配使用\n\n# 4.3.4 glob模式匹配\n\n 1. *表示一切字符串，*.txt表示过滤一切txt文件\n 2. [] 表示方括号中任何一个字符，[0-9]表示匹配0-9中任意一个数字\n 3. ？表示匹配任何一个字符\n\n\n# 5 git diff\n\n查看当前工作区与暂存区的差别\n\n\n# 5.1 git diff + 文件路径\n\n加上文件名，查看一下某一个文件具体的改动\n\n\n# 5.2 git diff --cached\n\n查看暂存区和本地git仓库的差别\n\n\n# 5.3 其他不常用用法\n\n 1. git diff <commitid> 比较工作区和某一个提交的差别\n 2. git diff <commitid> <filepath> 比较工作区和某一个提交某一个文件的差别\n 3. git diff --cached <commitid> 比较暂存区和某一个提交的差别\n 4. git diff --cached <commitid> <filepath> 比较暂存区和某一个提交某一个文件的差别\n\n\n# 6 git log\n\n查看之前的提交记录\n\n 1. commit id git log后commit后面跟着的一长串 git对commit id有自动补全功能，赋值前几位就可以了\n 2. 提交信息 每次commit -m之后后面输入的字符串，是比较关键的提示信息\n\n\n# 6.1 git log -p\n\n展示出每一个commit中的改动，相当于同时做git diff git log -p -n：查最近几条的提交记录及commit改动\n\n\n# 6.2 git log --start\n\n在查看提交记录的基础上查看每次commit有多少改动量\n\n\n# 6.3 git log --pretty\n\npretty支持让我们自己diy想看到的log展示 官方提供了oneline、short、full、fuller几种模板 可以自己定义，例如定义log日志当中应该包含commitid，提交时间，作者以及comment。那么定义出一种格式：%h - %ad - %an - %s命令行则为 git log --pretty=format:"%h - %ad - %an - %s" 官方提供了pretty参数表格\n\n\n# 7 git恢复相关\n\n\n# 7.1 git中删除文件\n\ngit rm 将文件从git以及文件系统当中一起移除（本地仓库、暂存、本地都删） 提交后从下一个提交开始这个文件就不会被存储一份了 留下添加文件和删除文件两条记录\n\n\n# 7.2 git中删除记录\n\ngit commit --amend 在删除文件后使用该指令在当前commit上修补而不是提交新的commit，这样就不会留下记录了\n\n * 如果记录已经push到远程，使用该指令会导致和远程记录不吻合，需要使用git push -f强行push，但这会覆盖远程commit，可能会导致其他人代码紊乱\n\n\n# 7.3 删除暂存区文件\n\ngit rm --cached 尚未commit的文件仅删除暂存区，保留本地文件\n\n\n# 7.4 回滚commit版本\n\ngit reset --soft head^ 所有文件状态返回某一个commit的版本\n\n\n# 7.5 回滚文件版本\n\ngit checkout -- filename 将文件恢复到之前提交的状态（本地和暂存都是）\n\n\n# 8 git分支(branch)\n\n\n# 8.1 git结构\n\n在git当中我们使用的分支其实是一个一个在commit当中切换的指针 例子：\n\n\n# 8.2 创建分支\n\ngit branch xxx git checkout -b xxx\n\n\n# 8.3 head指针\n\n指向当前代码仓库的位置 可以移动到任意结点上 移动head指针 git checkout (commit id/分支名)\n\n\n# 8.4 分支合并\n\ngit checkout master git merge test 将test合并到master上\n\n# 8.4.1 快速合并(fast-forward)\n\ntest分支是从master分支当中切出去的，后来master分支就再也没有进行过改动 合并的时候，其实只需要移动master指针到test分支上即可\n\n# 8.4.2 创建新commit\n\ntest分支是从master分支当中切出去后来master分支有改动 由于不是直接上下游关系了，所以git创建了一个新的commit用来合并两个分支的代码 合并之后应该删除没用的分支 git branch -d test\n\n\n# 8.5 合并分支冲突\n\n# 8.5.1 查看冲突\n\ngit diff\n\n# 8.5.2 手动解决\n\n把提示行去掉 留下想要的代码，重新add、commit\n\n# 8.5.3 放弃合并\n\ngit merge --abort\n\n# 8.5.4 git合并工具\n\ngit merge tool 不好用，一般不用\n\n# 8.5.5 ide工具\n\n\n# 9 远程分支\n\n\n# 9.1 origin指针\n\n和master指针性质一样，代表远程远程仓库\n\n\n# 9.2 操作命令\n\n# 9.2.1 代码拉取\n\ngit fetch:将远程改动同步到本地（针对远程的所有改动），如果有多个远程的话要指定远程名称 git pull只针对当前分支对应的远程分支，而且多了一步merge合并操作\n\n# 9.2.2 代码推送\n\n本地的分支是不会自动和远程同步的 git push origin test git branch --set-upstream-to master origin/master：将本地分支和远程建立映射 映射之后就可以直接使用git push\n\n\n# 10 git rebase\n\n\n# 10.1 rebase简介\n\n提取我们在a分支上的改动，然后应用在b分支的代码上\n\ngit checkout bugfix\ngit rebase master\ngit checkout master\ngit merge bugfix\n\n\n1\n2\n3\n4\n\n\n\n\n# 10.1.1 onto参数\n\n确定rebase的范围 git rebase --onto master feature bugfix git执行这条命令的时候会先找到feature和bugfix的共同祖先，然后将共同祖先之后的部分rebase到master\n\n\n# 10.2 实践网站\n\n图形化演示网站\n\n\n# 10.3 使用禁忌\n\n如果还有其他分支依赖了当前分支，我们这时候不可以使用rebase\n\n\n# 11 git show\n\n查看代码层面的改动\n\n\n# 11.1 查看某个commit下的改动\n\ngit show commit_id commit id的查找 git log --stat列举每个commit具体到文件级别的改动 git log --pretty=online将git提交记录压缩成一行\n\n\n# 11.2 查看分支下的改动\n\ngit show test查看test分支下最后一个提交节点的改动 git show test^查看test分支下最后一个节点的父节点改动 git show test~3查看test分支下最后一个节点的前第三个父节点\n\n\n# 12 git reflog\n\nreflog = reference log 查看引用日志 第一列表示commit id；第二列表示分支；第三列表示相对位置，相对于现在head指针的位置；最后一列记录head指针移动情况 可以通过这个方式查找git log无法查找在现在head指针之后提交过的commit id，然后checkout指针恢复\n\n\n# 13 区间选择\n\n\n# 13.1 双点\n\ngit log master..experiment 筛选出在experiment当中但是不在master当中的提交\n\n# 13.1.1 常用\n\ngit log origin/master..head 比较的是当前节点以及远程push的分支之间的差别\n\n\n# 13.2 三点\n\ngit log master...experiment 展示这两个分支各自独有的提交 git log --left-right master...experiment 用箭头表明这些提交分别被哪个分支独有\n\n\n# 13.3 多点\n\ngit log a b ^c git log a b --not c 查看在a或和b当中，但是不在c当中的提交\n\n\n# 14 交互式工具\n\ngit add -i 会出现八个选项：\n\n 1. status\n 2. update\n 3. revert\n 4. add\n 5. patch\n 6. diff\n 7. quit\n 8. help\n\n\n# 14.1 交互式暂存\n\n 1. 在git add -i后选择4（add）\n 2. 选择代表需要添加文件的序号\n 3. 选择过后该序号前会出现*\n 4. 敲击回车会返回上层菜单\n 5. 选择7退出后git状态会随之改变\n\n\n# 14.2 查看改动\n\n 1. 在git add- i后选择6（diff）\n 2. 选择代表要看改动文件的序号\n 3. 等效于git diff --cached\n\n\n# 14.3 取消暂存\n\n 1. 在git add -i后选择3（revert）\n 2. 选择代表向撤销暂存文件的序号\n\n\n# 14.4 暂存补丁\n\n可以通过这个功能把文件一部分添加进git，另一部分改动先保留在本地\n\n 1. 在git add -i后选择5（patch）\n 2. 选择代表需要补丁暂存文件的序号\n 3. git会把改动一个部分一个部分地询问\n 4. 输入y则表示加入git暂存；n表示不加入\n\n\n# 15 stash储藏\n\n将改动的内容储藏起来避免checkout的时候出现问题被覆盖，也避免其被commit并push\n\n\n# 15.1 储藏\n\n 1. git stash 把我们本地所有没有commit的内容都暂存了起来，这样方便我们进行checkout或者是其他一些操作，而不会起冲突或者是其他的影响\n 2. git stash --keep-index 只暂存没有add到暂存区的内容\n 3. git stash -u stash的时候将新创建并且还没有被git管理的文件也一并储藏起来\n\n\n# 15.2 还原\n\n 1. git stash apply 记录仍将保留 可以选择应用的记录 git stash apply stash@{2}\n 2. git stash pop 应用后记录会被删除 只能还原栈顶的记录\n 3. git stash apply --index 暂存文件的复原\n\n\n# 16 查找\n\n\n# 16.1 代码函数搜索\n\n 1. 展示函数出现过的位置 git grep 函数名\n 2. 展示函数出现过的具体位置 git grep -n 函数名 可以显示函数出现位置的行数\n 3. 查找某一个版本的代码 git grep 函数名 git commit/tag号码 可以避免使用ide工具checkout的步骤\n\n\n# 16.2 日志搜索\n\ngit log -l :函数名:文件名 可以查找文件名下该函数的变更，会展示出代码变更时间、对应的具体代码和修改人',charsets:{cjk:!0},lastUpdated:"2023/03/27, 17:41:36",lastUpdatedTimestamp:1679910096e3},{title:"Python语法",frontmatter:{title:"Python语法",date:"2022-04-11T16:50:09.000Z",permalink:"/pages/42ad71/",categories:["其他技术","Python"],tags:["Python"],author:{name:"年华惊风雨",link:"https://github.com/wsy425"}},regularPath:"/03.%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/00.%20Python/00.%20Python%E8%AF%AD%E6%B3%95.html",relativePath:"03.其他技术/00. Python/00. Python语法.md",key:"v-7675c675",path:"/pages/42ad71/",headers:[{level:2,title:"1 变量",slug:"_1-变量",normalizedTitle:"1 变量",charIndex:2},{level:2,title:"2 运算符",slug:"_2-运算符",normalizedTitle:"2 运算符",charIndex:153},{level:3,title:"2.1 数字运算符",slug:"_2-1-数字运算符",normalizedTitle:"2.1 数字运算符",charIndex:163},{level:3,title:"2.2 逻辑运算法",slug:"_2-2-逻辑运算法",normalizedTitle:"2.2 逻辑运算法",charIndex:226},{level:2,title:"3 数字",slug:"_3-数字",normalizedTitle:"3 数字",charIndex:452},{level:3,title:"3.1 整数（int）",slug:"_3-1-整数-int",normalizedTitle:"3.1 整数（int）",charIndex:461},{level:3,title:"3.2 浮点数（float）",slug:"_3-2-浮点数-float",normalizedTitle:"3.2 浮点数（float）",charIndex:477},{level:3,title:"3.3 str()",slug:"_3-3-str",normalizedTitle:"3.3 str()",charIndex:505},{level:2,title:"4 字符串",slug:"_4-字符串",normalizedTitle:"4 字符串",charIndex:542},{level:3,title:"4.1 拼接字符串",slug:"_4-1-拼接字符串",normalizedTitle:"4.1 拼接字符串",charIndex:552},{level:3,title:"4.2 字符串索引",slug:"_4-2-字符串索引",normalizedTitle:"4.2 字符串索引",charIndex:643},{level:3,title:"4.3 常用函数",slug:"_4-3-常用函数",normalizedTitle:"4.3 常用函数",charIndex:902},{level:3,title:"4.4 历遍字符串",slug:"_4-4-历遍字符串",normalizedTitle:"4.4 历遍字符串",charIndex:1077},{level:2,title:"5 列表",slug:"_5-列表",normalizedTitle:"5 列表",charIndex:1124},{level:3,title:"5.1 创建列表",slug:"_5-1-创建列表",normalizedTitle:"5.1 创建列表",charIndex:1158},{level:3,title:"5.2 访问列表",slug:"_5-2-访问列表",normalizedTitle:"5.2 访问列表",charIndex:1238},{level:3,title:"5.3 修改元素",slug:"_5-3-修改元素",normalizedTitle:"5.3 修改元素",charIndex:1304},{level:3,title:"5.4 添加元素",slug:"_5-4-添加元素",normalizedTitle:"5.4 添加元素",charIndex:1346},{level:3,title:"5.5 删除",slug:"_5-5-删除",normalizedTitle:"5.5 删除",charIndex:1491},{level:3,title:"5.6 使用列表的一部分",slug:"_5-6-使用列表的一部分",normalizedTitle:"5.6 使用列表的一部分",charIndex:1607},{level:3,title:"5.7 组织列表",slug:"_5-7-组织列表",normalizedTitle:"5.7 组织列表",charIndex:1771},{level:3,title:"5.8 历遍列表",slug:"_5-8-历遍列表",normalizedTitle:"5.8 历遍列表",charIndex:1989},{level:2,title:"6 元组",slug:"_6-元组",normalizedTitle:"6 元组",charIndex:2078},{level:3,title:"6.1 创建元组",slug:"_6-1-创建元组",normalizedTitle:"6.1 创建元组",charIndex:2095},{level:3,title:"6.2 元组操作",slug:"_6-2-元组操作",normalizedTitle:"6.2 元组操作",charIndex:2216},{level:3,title:"6.3 遍历元组",slug:"_6-3-遍历元组",normalizedTitle:"6.3 遍历元组",charIndex:2242},{level:3,title:"6.4 多个变量解压元组",slug:"_6-4-多个变量解压元组",normalizedTitle:"6.4 多个变量解压元组",charIndex:2262},{level:3,title:"6.5 修改元组变量",slug:"_6-5-修改元组变量",normalizedTitle:"6.5 修改元组变量",charIndex:2335},{level:2,title:"7 字典",slug:"_7-字典",normalizedTitle:"7 字典",charIndex:2403},{level:3,title:"7.1 创建字典",slug:"_7-1-创建字典",normalizedTitle:"7.1 创建字典",charIndex:2457},{level:3,title:"7.2 访问字典",slug:"_7-2-访问字典",normalizedTitle:"7.2 访问字典",charIndex:2543},{level:3,title:"7.3 插入新的字典对应",slug:"_7-3-插入新的字典对应",normalizedTitle:"7.3 插入新的字典对应",charIndex:2704},{level:3,title:"7.4 删除键——对值",slug:"_7-4-删除键-对值",normalizedTitle:"7.4 删除键——对值",charIndex:2822},{level:3,title:"7.5 历遍字典",slug:"_7-5-历遍字典",normalizedTitle:"7.5 历遍字典",charIndex:2856},{level:3,title:"7.6 嵌套",slug:"_7-6-嵌套",normalizedTitle:"7.6 嵌套",charIndex:2992},{level:2,title:"8 集合",slug:"_8-集合",normalizedTitle:"8 集合",charIndex:3841},{level:3,title:"8.1 创建集合",slug:"_8-1-创建集合",normalizedTitle:"8.1 创建集合",charIndex:3885},{level:3,title:"8.2 插入元素",slug:"_8-2-插入元素",normalizedTitle:"8.2 插入元素",charIndex:4011},{level:3,title:"8.3 删除元素",slug:"_8-3-删除元素",normalizedTitle:"8.3 删除元素",charIndex:4117},{level:3,title:"8.4 支持的集合操作",slug:"_8-4-支持的集合操作",normalizedTitle:"8.4 支持的集合操作",charIndex:4251},{level:3,title:"8.5 其他常用函数",slug:"_8-5-其他常用函数",normalizedTitle:"8.5 其他常用函数",charIndex:4411},{level:2,title:"9 输入输出",slug:"_9-输入输出",normalizedTitle:"9 输入输出",charIndex:4466},{level:3,title:"9.1 输入",slug:"_9-1-输入",normalizedTitle:"9.1 输入",charIndex:4477},{level:3,title:"9.2 输出",slug:"_9-2-输出",normalizedTitle:"9.2 输出",charIndex:4516},{level:2,title:"10 if",slug:"_10-if",normalizedTitle:"10 if",charIndex:4593},{level:3,title:"10.1 条件测试",slug:"_10-1-条件测试",normalizedTitle:"10.1 条件测试",charIndex:4603},{level:4,title:"10.1.1 检查是否相等",slug:"_10-1-1-检查是否相等",normalizedTitle:"10.1.1 检查是否相等",charIndex:4639},{level:4,title:"10.1.2 检查是否不相等",slug:"_10-1-2-检查是否不相等",normalizedTitle:"10.1.2 检查是否不相等",charIndex:4707},{level:4,title:"10.1.3 比较数字",slug:"_10-1-3-比较数字",normalizedTitle:"10.1.3 比较数字",charIndex:4731},{level:4,title:"10.1.4 检查多个条件",slug:"_10-1-4-检查多个条件",normalizedTitle:"10.1.4 检查多个条件",charIndex:4765},{level:4,title:"10.1.5 检查特定值是否在/不在",slug:"_10-1-5-检查特定值是否在-不在",normalizedTitle:"10.1.5 检查特定值是否在/不在",charIndex:4804},{level:4,title:"10.1.6 布尔表达式",slug:"_10-1-6-布尔表达式",normalizedTitle:"10.1.6 布尔表达式",charIndex:4852},{level:3,title:"10.2 语句结构",slug:"_10-2-语句结构",normalizedTitle:"10.2 语句结构",charIndex:4869},{level:4,title:"10.2.1 if-else",slug:"_10-2-1-if-else",normalizedTitle:"10.2.1 if-else",charIndex:4882},{level:4,title:"10.2.2 if-elif-else",slug:"_10-2-2-if-elif-else",normalizedTitle:"10.2.2 if-elif-else",charIndex:4900},{level:4,title:"10.2.3 多个elif",slug:"_10-2-3-多个elif",normalizedTitle:"10.2.3 多个elif",charIndex:4923},{level:4,title:"10.2.4 省略else",slug:"_10-2-4-省略else",normalizedTitle:"10.2.4 省略else",charIndex:4940},{level:2,title:"11 while循环",slug:"_11-while循环",normalizedTitle:"11 while循环",charIndex:4958},{level:3,title:"11.1 使用while循环",slug:"_11-1-使用while循环",normalizedTitle:"11.1 使用while循环",charIndex:4973},{level:3,title:"11.2 使用break退出循环",slug:"_11-2-使用break退出循环",normalizedTitle:"11.2 使用break退出循环",charIndex:5097},{level:3,title:"11.3 使用continue继续",slug:"_11-3-使用continue继续",normalizedTitle:"11.3 使用continue继续",charIndex:5395},{level:2,title:"12 迭代器",slug:"_12-迭代器",normalizedTitle:"12 迭代器",charIndex:5578},{level:3,title:"12.1 容器迭代器",slug:"_12-1-容器迭代器",normalizedTitle:"12.1 容器迭代器",charIndex:5622},{level:3,title:"12.2 自定义迭代器",slug:"_12-2-自定义迭代器",normalizedTitle:"12.2 自定义迭代器",charIndex:5816},{level:2,title:"13 生成器",slug:"_13-生成器",normalizedTitle:"13 生成器",charIndex:6212},{level:3,title:"13.1 括号创建法",slug:"_13-1-括号创建法",normalizedTitle:"13.1 括号创建法",charIndex:6270},{level:3,title:"13.2 函数创建法",slug:"_13-2-函数创建法",normalizedTitle:"13.2 函数创建法",charIndex:6408},{level:2,title:"14 函数",slug:"_14-函数",normalizedTitle:"14 函数",charIndex:6677},{level:3,title:"14.1 定义函数",slug:"_14-1-定义函数",normalizedTitle:"14.1 定义函数",charIndex:6687},{level:3,title:"14.2 传递实参",slug:"_14-2-传递实参",normalizedTitle:"14.2 传递实参",charIndex:6828},{level:4,title:"14.2.1 位置实参",slug:"_14-2-1-位置实参",normalizedTitle:"14.2.1 位置实参",charIndex:6841},{level:4,title:"14.2.2 关键字实参",slug:"_14-2-2-关键字实参",normalizedTitle:"14.2.2 关键字实参",charIndex:7095},{level:4,title:"14.2.3 默认值",slug:"_14-2-3-默认值",normalizedTitle:"14.2.3 默认值",charIndex:7353},{level:3,title:"14.3 返回值",slug:"_14-3-返回值",normalizedTitle:"14.3 返回值",charIndex:7587},{level:4,title:"14.3.1 返回简单值",slug:"_14-3-1-返回简单值",normalizedTitle:"14.3.1 返回简单值",charIndex:7599},{level:4,title:"14.3.2 令实参变成可选的",slug:"_14-3-2-令实参变成可选的",normalizedTitle:"14.3.2 令实参变成可选的",charIndex:7818},{level:4,title:"14.3.3 返回字典",slug:"_14-3-3-返回字典",normalizedTitle:"14.3.3 返回字典",charIndex:8079},{level:4,title:"14.3.4 结合使用函数和while",slug:"_14-3-4-结合使用函数和while",normalizedTitle:"14.3.4 结合使用函数和while",charIndex:8289},{level:3,title:"14.4 传递列表",slug:"_14-4-传递列表",normalizedTitle:"14.4 传递列表",charIndex:8811},{level:4,title:"14.4.1 禁止函数修改列表",slug:"_14-4-1-禁止函数修改列表",normalizedTitle:"14.4.1 禁止函数修改列表",charIndex:9016},{level:3,title:"14.4.2 传递任意数量的实参",slug:"_14-4-2-传递任意数量的实参",normalizedTitle:"14.4.2 传递任意数量的实参",charIndex:9109},{level:4,title:"14.4.3 位置实参和任意数量实参结合",slug:"_14-4-3-位置实参和任意数量实参结合",normalizedTitle:"14.4.3 位置实参和任意数量实参结合",charIndex:9409},{level:3,title:"14.5  将函数存储在模块中",slug:"_14-5-将函数存储在模块中",normalizedTitle:"14.5  将函数存储在模块中",charIndex:null},{level:2,title:"15 类",slug:"_15-类",normalizedTitle:"15 类",charIndex:9687},{level:3,title:"15.1 创建和使用类",slug:"_15-1-创建和使用类",normalizedTitle:"15.1 创建和使用类",charIndex:9752},{level:4,title:"15.1.1 创建类",slug:"_15-1-1-创建类",normalizedTitle:"15.1.1 创建类",charIndex:9767},{level:4,title:"15.1.2 根据类创建实例",slug:"_15-1-2-根据类创建实例",normalizedTitle:"15.1.2 根据类创建实例",charIndex:10238},{level:5,title:"访问属性",slug:"访问属性",normalizedTitle:"访问属性",charIndex:10256},{level:5,title:"调用方法",slug:"调用方法",normalizedTitle:"调用方法",charIndex:10067},{level:3,title:"15.2 使用类和实例",slug:"_15-2-使用类和实例",normalizedTitle:"15.2 使用类和实例",charIndex:10933},{level:4,title:"15.2.1 给属性指定默认值",slug:"_15-2-1-给属性指定默认值",normalizedTitle:"15.2.1 给属性指定默认值",charIndex:10948},{level:4,title:"15.2.2 修改属性值",slug:"_15-2-2-修改属性值",normalizedTitle:"15.2.2 修改属性值",charIndex:11516},{level:5,title:"直接修改属性值",slug:"直接修改属性值",normalizedTitle:"直接修改属性值",charIndex:11532},{level:5,title:"通过方法修改属性的值",slug:"通过方法修改属性的值",normalizedTitle:"通过方法修改属性的值",charIndex:12111},{level:3,title:"15.3 继承",slug:"_15-3-继承",normalizedTitle:"15.3 继承",charIndex:12782},{level:4,title:"15.3.1 子类的方法_int_()",slug:"_15-3-1-子类的方法-int",normalizedTitle:"15.3.1 子类的方法_int_()",charIndex:null},{level:4,title:"15.3.2 给子类定义属性和方法",slug:"_15-3-2-给子类定义属性和方法",normalizedTitle:"15.3.2 给子类定义属性和方法",charIndex:13736},{level:4,title:"15.3.3 重写父类的方法",slug:"_15-3-3-重写父类的方法",normalizedTitle:"15.3.3 重写父类的方法",charIndex:14700},{level:4,title:"15.3.4 将实例用作属性",slug:"_15-3-4-将实例用作属性",normalizedTitle:"15.3.4 将实例用作属性",charIndex:15285},{level:3,title:"15.4 导入类",slug:"_15-4-导入类",normalizedTitle:"15.4 导入类",charIndex:16027},{level:4,title:"15.4.1 导入单个类",slug:"_15-4-1-导入单个类",normalizedTitle:"15.4.1 导入单个类",charIndex:16039},{level:4,title:"15.4.2 从一个模块中导入多个类",slug:"_15-4-2-从一个模块中导入多个类",normalizedTitle:"15.4.2 从一个模块中导入多个类",charIndex:16081},{level:4,title:"15.4.3 导入整个模块",slug:"_15-4-3-导入整个模块",normalizedTitle:"15.4.3 导入整个模块",charIndex:16142},{level:4,title:"15.4.4 导入模块中的所有类",slug:"_15-4-4-导入模块中的所有类",normalizedTitle:"15.4.4 导入模块中的所有类",charIndex:16176},{level:4,title:"15.4.5 在一个模块中导入另一个模块",slug:"_15-4-5-在一个模块中导入另一个模块",normalizedTitle:"15.4.5 在一个模块中导入另一个模块",charIndex:16228},{level:2,title:"16 文件和异常",slug:"_16-文件和异常",normalizedTitle:"16 文件和异常",charIndex:16253},{level:3,title:"16.1 读取文件数据",slug:"_16-1-读取文件数据",normalizedTitle:"16.1 读取文件数据",charIndex:16266},{level:4,title:"16.1.1 读取整个文件",slug:"_16-1-1-读取整个文件",normalizedTitle:"16.1.1 读取整个文件",charIndex:16281},{level:4,title:"16.1.2 文件路径",slug:"_16-1-2-文件路径",normalizedTitle:"16.1.2 文件路径",charIndex:16523},{level:4,title:"16.1.3 逐行读取",slug:"_16-1-3-逐行读取",normalizedTitle:"16.1.3 逐行读取",charIndex:16765},{level:4,title:"16.1.4 创建包含文件各行内容的列表",slug:"_16-1-4-创建包含文件各行内容的列表",normalizedTitle:"16.1.4 创建包含文件各行内容的列表",charIndex:16912},{level:3,title:"16.2 写入文件",slug:"_16-2-写入文件",normalizedTitle:"16.2 写入文件",charIndex:17118},{level:4,title:"16.2.1 写入空文件",slug:"_16-2-1-写入空文件",normalizedTitle:"16.2.1 写入空文件",charIndex:17131},{level:4,title:"16.2.2 写入多行",slug:"_16-2-2-写入多行",normalizedTitle:"16.2.2 写入多行",charIndex:17443},{level:4,title:"16.2.3 附加到文件",slug:"_16-2-3-附加到文件",normalizedTitle:"16.2.3 附加到文件",charIndex:17669},{level:3,title:"16.3 异常",slug:"_16-3-异常",normalizedTitle:"16.3 异常",charIndex:17960},{level:4,title:"16.3.1 try-except代码块",slug:"_16-3-1-try-except代码块",normalizedTitle:"16.3.1 try-except代码块",charIndex:18045},{level:4,title:"16.3.2 使用异常避免崩溃",slug:"_16-3-2-使用异常避免崩溃",normalizedTitle:"16.3.2 使用异常避免崩溃",charIndex:18221},{level:4,title:"16.3.3 不报错",slug:"_16-3-3-不报错",normalizedTitle:"16.3.3 不报错",charIndex:18665},{level:3,title:"16.4 存储数据",slug:"_16-4-存储数据",normalizedTitle:"16.4 存储数据",charIndex:18747},{level:4,title:"16.4.1 json.dump()和json.load()",slug:"_16-4-1-json-dump-和json-load",normalizedTitle:"16.4.1 json.dump()和json.load()",charIndex:18760},{level:4,title:"16.4.2 保存和读取用户生成的数据",slug:"_16-4-2-保存和读取用户生成的数据",normalizedTitle:"16.4.2 保存和读取用户生成的数据",charIndex:19103},{level:4,title:"16.4.3 重构",slug:"_16-4-3-重构",normalizedTitle:"16.4.3 重构",charIndex:19584},{level:2,title:"17 测试代码",slug:"_17-测试代码",normalizedTitle:"17 测试代码",charIndex:20438},{level:3,title:"17.1 测试函数",slug:"_17-1-测试函数",normalizedTitle:"17.1 测试函数",charIndex:20450},{level:3,title:"17.2 断言方法",slug:"_17-2-断言方法",normalizedTitle:"17.2 断言方法",charIndex:20982},{level:3,title:"17.3 测试类",slug:"_17-3-测试类",normalizedTitle:"17.3 测试类",charIndex:21374}],headersStr:"1 变量 2 运算符 2.1 数字运算符 2.2 逻辑运算法 3 数字 3.1 整数（int） 3.2 浮点数（float） 3.3 str() 4 字符串 4.1 拼接字符串 4.2 字符串索引 4.3 常用函数 4.4 历遍字符串 5 列表 5.1 创建列表 5.2 访问列表 5.3 修改元素 5.4 添加元素 5.5 删除 5.6 使用列表的一部分 5.7 组织列表 5.8 历遍列表 6 元组 6.1 创建元组 6.2 元组操作 6.3 遍历元组 6.4 多个变量解压元组 6.5 修改元组变量 7 字典 7.1 创建字典 7.2 访问字典 7.3 插入新的字典对应 7.4 删除键——对值 7.5 历遍字典 7.6 嵌套 8 集合 8.1 创建集合 8.2 插入元素 8.3 删除元素 8.4 支持的集合操作 8.5 其他常用函数 9 输入输出 9.1 输入 9.2 输出 10 if 10.1 条件测试 10.1.1 检查是否相等 10.1.2 检查是否不相等 10.1.3 比较数字 10.1.4 检查多个条件 10.1.5 检查特定值是否在/不在 10.1.6 布尔表达式 10.2 语句结构 10.2.1 if-else 10.2.2 if-elif-else 10.2.3 多个elif 10.2.4 省略else 11 while循环 11.1 使用while循环 11.2 使用break退出循环 11.3 使用continue继续 12 迭代器 12.1 容器迭代器 12.2 自定义迭代器 13 生成器 13.1 括号创建法 13.2 函数创建法 14 函数 14.1 定义函数 14.2 传递实参 14.2.1 位置实参 14.2.2 关键字实参 14.2.3 默认值 14.3 返回值 14.3.1 返回简单值 14.3.2 令实参变成可选的 14.3.3 返回字典 14.3.4 结合使用函数和while 14.4 传递列表 14.4.1 禁止函数修改列表 14.4.2 传递任意数量的实参 14.4.3 位置实参和任意数量实参结合 14.5  将函数存储在模块中 15 类 15.1 创建和使用类 15.1.1 创建类 15.1.2 根据类创建实例 访问属性 调用方法 15.2 使用类和实例 15.2.1 给属性指定默认值 15.2.2 修改属性值 直接修改属性值 通过方法修改属性的值 15.3 继承 15.3.1 子类的方法_int_() 15.3.2 给子类定义属性和方法 15.3.3 重写父类的方法 15.3.4 将实例用作属性 15.4 导入类 15.4.1 导入单个类 15.4.2 从一个模块中导入多个类 15.4.3 导入整个模块 15.4.4 导入模块中的所有类 15.4.5 在一个模块中导入另一个模块 16 文件和异常 16.1 读取文件数据 16.1.1 读取整个文件 16.1.2 文件路径 16.1.3 逐行读取 16.1.4 创建包含文件各行内容的列表 16.2 写入文件 16.2.1 写入空文件 16.2.2 写入多行 16.2.3 附加到文件 16.3 异常 16.3.1 try-except代码块 16.3.2 使用异常避免崩溃 16.3.3 不报错 16.4 存储数据 16.4.1 json.dump()和json.load() 16.4.2 保存和读取用户生成的数据 16.4.3 重构 17 测试代码 17.1 测试函数 17.2 断言方法 17.3 测试类",content:"# 1 变量\n\n 1. 变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头\n 2. 变量名不能包含空格，但可使用下划线来分隔其中的单词\n 3. Python关键字和函数名不能用作变量名\n 4. python支持三元表达式\"yahoo!\" if 3 > 2 else 2\n\n\n# 2 运算符\n\n\n# 2.1 数字运算符\n\n 1. + - * /加减乘除,其中除法一定得到浮点数\n 2. // % **整除，取余，乘方\n\n\n# 2.2 逻辑运算法\n\n 1. and or not 与、或、非（优先级not>and>or）\n 2. == > < >= <= !=判断相等、大于、小于、大于等于、小于等于、不等于\n 3. is判断两个引用是否指向同一对象（判断地址）；==判断两个引用指向的具体内容是否相等（判断内容）\n 4. in判断元素是否存在列表、字典的键、元组、集合中 元素不在字典的键中会报错\n 5. bool()执行函数将0视为False，其他所有值视为True\n\n\n# 3 数字\n\n\n# 3.1 整数（int）\n\n\n# 3.2 浮点数（float）\n\n带小数点的数字\n\n\n# 3.3 str()\n\n将得字符串转换为字符串，这样才能print\n\n\n# 4 字符串\n\n\n# 4.1 拼接字符串\n\n 1. +字符串1+字符串2\n 2. 直接写在一起字符串1字符串2\n 3. 以指定字符连接序列元素形成新字符串连接用的字符.join(要被连接的序列)\n\n\n# 4.2 字符串索引\n\n 1. 获得索引对应值：字符串名[索引值]\n 2. 计算字符串长度：len(字符串名)\n 3. 获得值对应索引：\n    * 被检测字符串名.find(检测的字符串，开始检测索引，结束检测索引)默认从头检测到尾，返回最先检测到的值，检测不到返回-1\n    * 被检测字符串名.index(检测的字符串，开始检测索引，结束检测索引)默认从头检测到尾，返回最先检测到的值，检测不到报异常\n    * 被检测字符串名.rfind(检测的字符串，开始检测索引，结束检测索引)返回最后检测到的值\n\n\n# 4.3 常用函数\n\n 1. 每个单词首字母大写其余小写字符串名.title()\n 2. 使用制表符或换行符来添加空白 \\t:制表符，一个tab \\n:换行符，换行\n 3. 删除空白\n    * rstrip():暂时删除字符串末尾空白\n    * lstrip():暂时删除字符串开头空白\n    * strip():暂时删除字符串两端空白\n\n\n# 4.4 历遍字符串\n\nfor i , n in enumerate(s):\n\n\n1\n\n\n\n# 5 列表\n\n 1. 定义：由一系列按特定顺序排列的元素组成\n\n\n# 5.1 创建列表\n\n 1. 空列表列表名 = []\n 2. 赋值列表列表名 = [元素1 , 元素2]\n 3. 乘法赋值列表名 = [元素]*列表长度\n\n\n# 5.2 访问列表\n\n 1. 通过索引访问值列表名[索引值]\n 2. 索引从0开始,负数可以反向索引\n 3. 通过值访问索引\n\n\n# 5.3 修改元素\n\n 1. 直接赋值列表名[希望赋值的索引] = 赋予的值\n\n\n# 5.4 添加元素\n\n 1. 末尾添加元素列表名称.append(添加的元素)\n 2. 在列表中插入元素列表名称.insert(插入元素索引值，元素)\n 3. 在列表末尾添加多个元素被添加列表名称.extend(保存添加元素的列表)\n 4. 加法运算相当于extend列表1+列表2\n\n\n# 5.5 删除\n\n 1. del语句del 列表名[要删除元素的索引]\n 2. 出栈，可得到索引元素值出栈元素值 = 列表名.pop(索引) 不写索引默认为末尾元素\n 3. 根据值删除元素列表名.remove(要删除元素值)\n\n\n# 5.6 使用列表的一部分\n\n 1. 切片\n    * 列表名[切片开始:切片结束:切片步距]\n    * 切片左闭右开\n    * 可以另步距为-1实现倒叙\n 2. 复制\n    * 不能直接用==，这样复制地址内容没有备份\n    * 要用切片复制存储列表 = 被复制列表[:]\n    * 被复制列表.copy()\n\n\n# 5.7 组织列表\n\n 1. 永久性按照字母顺序排序\n    * 列表名.sort(key=None , reverse=False)\n    * key：用来进行比较的元素，默认第一个\n    * reverse默认为True，降序\n 2. 临时性按照字母顺序排序 列表名.sorted(key=None , reverse=False)\n 3. 永久性反转列表列表名.reverse()\n 4. 得到列表长度len(列表名)\n\n\n# 5.8 历遍列表\n\n 1. 历遍元素 for 后续代表元素名称 in 列表名:\n 2. 同时历遍索引和元素 for i, value in enumerate(列表名)\n\n\n# 6 元组\n\n不可变的列表\n\n\n# 6.1 创建元组\n\n 1. 空元组 元组名 = ()\n 2. 一个元素的元组 元组名 = (元素1,) 一个元素的元组必须加\",\"，因为小括号有优先级问题，否则会被认为是单个元素\n 3. 普通赋值元组 元组名 = (元素1,元素2)\n\n\n# 6.2 元组操作\n\n支持列表中绝大部分操作\n\n\n# 6.3 遍历元组\n\n和列表一样\n\n\n# 6.4 多个变量解压元组\n\na, *b , c = (1,2,3,4) 标星号表示b为一个list，其他变量一一对应后所剩的变量都是b的\n\n\n# 6.5 修改元组变量\n\n 1. 重新定义，不能单独修改一个值\n 2. 元组本身不能改变，但元组内可变元素（列表等）是可以改变的\n\n\n# 7 字典\n\n存储key和value的键值对。我们用{}表示一个dict，用:分隔key和value\n\n\n# 7.1 创建字典\n\n 1. 创建空字典 字典名 = {}\n 2. 赋值创建字典 字典名 = {键:值}\n 3. 键必须为不可变对象，list和dict都不可以作键\n\n\n# 7.2 访问字典\n\n 1. 检索方式，查找不到key会报错 值 = 字典名[查找的键]\n 2. get方式查找不到会返回None 值 = 字典名.get(查找的键)\n 3. 返回所有键 所有键的列表 = list(字典名.keys())\n 4. 返回所有值 所有键的列表 = list(字典名.values())\n\n\n# 7.3 插入新的字典对应\n\n 1. 为不存在的key插入value，存在不覆盖 字典名.setdefault(键,值)\n 2. 为不存在的key插入value，存在覆盖 字典名.update({键:值}) 字典名[键] = 值\n\n\n# 7.4 删除键——对值\n\ndel 字典名[键] 只能传入键\n\n\n# 7.5 历遍字典\n\n 1. 历遍所有键——值对 for key,value in 字典名.items():\n 2. 历遍字典中的所有键 for key in 字典名.keys():\n 3. 历遍字典中的所有值 for value in 字典名.values():\n\n\n# 7.6 嵌套\n\n 1. 字典列表\n\nalien_0 = {'color':'green' , 'points':5}\nalien_1 = {'color':'yellow' , 'points':10}\nalien_2 = {'color':'red' , 'points':15}\naliens = [alien_0 , alien_1 , alien_2]\nfor alien in aliens:\n    if alien['color'] == 'green':\n        print(alien['points'])\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 2. 字典中存储列表\n\nfavorite_languages = {'jen':['python' , 'ruby'] , 'sarah':['ruby' , 'go'] , 'edward':['c']}\nfor name,languages in favorite_languages.item():\n    for language in  languages:\n        print(language)\n\n\n1\n2\n3\n4\n\n 3. 字典中存储字典\n\nusers = {\n    'aeinstein': {'first': 'albert' , 'last': 'einstein' ,'location':'princeton'},\n    'mcurie': {'first': 'marie' , 'last': 'curie' , 'location': 'paris'}\n    }\nfor username,user_info in users.item():\n    print(\"\\nUsername: \" + username)\n    for key,value in user_info:\n        print(key + value)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 8 集合\n\n用来存储不重复元素的容器，当中的元素都是不同的，相同的元素会被删除\n\n\n# 8.1 创建集合\n\n 1. 创建空集合 集合名 = set() 不能用{}创建空集合，会与字典冲突\n 2. 赋值创建集合 集合名 = set(元素) 集合名 = {元素}\n 3. set当中的元素也必须是不可变对象，因此list不能传入set\n\n\n# 8.2 插入元素\n\n 1. 添加单个元素，存在则不操作 集合名.add(元素)\n 2. 添加多个元素，保证集合内元素不重复 集合名.update(元素) 这里元素可以是列表，元组，字典等，会自动展开元素\n\n\n# 8.3 删除元素\n\n 1. 移除元素，不存在则报错 集合名.remove(要移除的元素)\n 2. 移除元素，不存在不会报错 集合名.discard(要移除的元素)\n 3. 随机删除一个元素 集合名.pop() pop过程中会对集合无序排列，删除左边第一个元素\n\n\n# 8.4 支持的集合操作\n\n 1. 交集 集合1 & 集合2\n 2. 并集 集合1 | 集合2\n 3. 差集 被求差集合 - 集合2\n 4. 对称集 对称保留集合 ^ 集合2 将前一个集合去掉两集合的交集\n 5. 超集、子集判断 集合1 >= 集合2判断1是否为2的超集 集合1 <= 集合2判断1是否为2的子集\n\n\n# 8.5 其他常用函数\n\n 1. 计算个数 len(集合名)\n 2. 清空集合 集合名.clear()\n\n\n# 9 输入输出\n\n\n# 9.1 输入\n\n 1. input(要输出的量)\n 2. 传入字符串\n\n\n# 9.2 输出\n\n 1. print(要输出的量)\n 2. 默认输出自动换行\n 3. print(要输出的量,end=' ')更换字符结尾替代换行\n\n\n# 10 if\n\n\n# 10.1 条件测试\n\n条件测试：值为True或Flase的表达式\n\n# 10.1.1 检查是否相等\n\n 1. 使用==\n 2. 直接使用时考虑大小写\n 3. 加上.lower()时就可全部变为小写判断\n\n# 10.1.2 检查是否不相等\n\n使用!=\n\n# 10.1.3 比较数字\n\n可以包含等于、不等于、大于、小于等\n\n# 10.1.4 检查多个条件\n\n 1. and表示和\n 2. or表示或\n\n# 10.1.5 检查特定值是否在/不在\n\n 1. in表示在\n 2. not in表示不在\n\n# 10.1.6 布尔表达式\n\n\n# 10.2 语句结构\n\n# 10.2.1 if-else\n\n# 10.2.2 if-elif-else\n\n# 10.2.3 多个elif\n\n# 10.2.4 省略else\n\n\n# 11 while循环\n\n\n# 11.1 使用while循环\n\ncurrent_number = 1\nwhile current_number <= 5:\n    print(current_number)    current_number += 1\n\n\n1\n2\n3\n\n\n\n# 11.2 使用break退出循环\n\nprompt = \"\\nPlease enter the name of a city you have visited:\"\nprompt += \"\\n(Enter 'quit' when you are finished.) \"\nwhile True:\n    city = input(prompt)\n    if city == 'quit':\n        break\n    else:\n        print(\"I'd love to go to \" + city.title() + \"!\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 11.3 使用continue继续\n\ncurrent_number = 0\nwhile current_number < 10:\n    current_number += 1\n    if current_number % 2 == 0:\n        continue\n    print(current_number)\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 12 迭代器\n\niterator，永远指向当前的位置，永远知道下一个位置在哪里\n\n\n# 12.1 容器迭代器\n\n 1. 使用关键字获取迭代器 迭代器名 = iter(可迭代对象) 可迭代对象指list、tuple、dict类型\n 2. 调用迭代器\n    * 获取的元素 = next(迭代器名) 获得迭代器中下一个元素\n    * for 获取的元素 in 迭代器名\n 3. 调用迭代器超过元素个数会引发超界，Python抛出Stoplteration的error\n\n\n# 12.2 自定义迭代器\n\nclass PowTwo:\n    生成2的幂的迭代器\n\n    def __init__(self, max = 0):\n        self.max = max\n\n    def __iter__(self):\n        self.n = 0\n        return self\n\n    def __next__(self):\n        if self.n <= self.max:\n            result = 2 ** self.n\n            self.n += 1\n            return result\n        else:\n            raise StopIteration\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 13 生成器\n\n生成器的概念和迭代器相辅相成，迭代器是生成一个遍历数据的迭代工具，而生成器则是数据生成工具\n\n\n# 13.1 括号创建法\n\n 1. 生成器名称 = (元素循环内操作 for i in range(元素个数))\n 2. 和用循环生成list几乎没什么差别，只是使用（）\n 3. 循环生成list的时候会运行整个循环，但创建生成器的时候只有每次调用的时候才会触发一次循环\n\n\n# 13.2 函数创建法\n\n 1. 看上起定义一个函数，但返回的不是一个值而是生成器\n\ndef 生成器名称(生成器生成个数):\n    for i in range(生成器生成个数):\n        yield f(i) #此处可以是关于i的任意函数\n\n\n1\n2\n3\n\n 2. 关键词yield\n    * 与return的相同点：会将之后的内容返回给调用方\n    * 不同点：当我们下一次再次执行的时候，会继续从上次yield处开始往下执行\n 3. 关键词yield from 返回一个迭代器或者是生成器执行next之后的结果\n\n\n# 14 函数\n\n\n# 14.1 定义函数\n\ndef greet_user(username):\n    print('Hello' + username.title() + '!')\n\ngreet_user()\n\n\n1\n2\n3\n4\n\n\n输入的username是一个形参，如果直接输入信息则为实参\n\n\n# 14.2 传递实参\n\n# 14.2.1 位置实参\n\n一种函数调用中的实参与函数定义中的形参的关联方式，基于实参的顺序\n\ndef describe_pet(animal_type , pet_name):\n    print(\"\\nI have a\" + animal_type + ',')\n    print('My' + animal_type + \"'s name is\" + pet_name.title() + '.')\n\ndescribe_pet('hamster' , 'harry')\n\n\n1\n2\n3\n4\n5\n\n\n# 14.2.2 关键字实参\n\n传递给函数名称——值对\n\ndef describe_pet(animal_type , pet_name):\n    print(\"\\nI have a\" + animal_type + ',')\n    print('My' + animal_type + \"'s name is\" + pet_name.title() + '.')\n\ndescribe_pet(animal_type ='hamster' , pet_name = 'harry')\n\n\n1\n2\n3\n4\n5\n\n\n# 14.2.3 默认值\n\n定义函数时可以设置默认值\n\ndef describe_pet(animal_type , pet_name = 'harry'):\n    print(\"\\nI have a\" + animal_type + ',')\n    print('My' + animal_type + \"'s name is\" + pet_name.title() + '.')\n\ndescribe_pet('hamster')\n\n\n1\n2\n3\n4\n5\n\n\n\n# 14.3 返回值\n\n# 14.3.1 返回简单值\n\ndef get_formatted_name(first_name, last_name):\n    full_name = first_name + ' ' + last_name\n    return full_name.title()\n\nmusician = get_formatted_name('jimi', 'hendrix')\nprint(musician)\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 14.3.2 令实参变成可选的\n\ndef get_formatted_name(first_name, last_name , middle_name = ''):\n    full_name = first_name + ' ' + middle_name + ' ' + last_name\n    return full_name.title()\n\nmusician = get_formatted_name('jimi', 'hendrix')\nprint(musician)\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 14.3.3 返回字典\n\ndef build_person(first_name, last_name):\n    person = {'first': first_name, 'last': last_name}\n    return person\n\nmusician = get_formatted_name('jimi', 'hendrix')\nprint(musician)\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 14.3.4 结合使用函数和while\n\ndef get_formatted_name(first_name, last_name):\n    full_name = first_name + ' ' + last_name\n    return full_name.title()\nwhile True:\n    print(\"\\nPlease tell me your name:\")\n    print(\"(enter 'q' at any time to quit)\")\n    f_name = input(\"First name: \")\n    if f_name == 'q':\n        break\n    l_name = input(\"Last name: \"\n    if l_name == 'q':\n        break\n    formatted_name = get_formatted_name(f_name, l_name)\n    print(\"\\nHello, \" + formatted_name + \"!\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 14.4 传递列表\n\ndef greet_users(names):\n    for name in names:\n        msg = \"Hello, \" + name.title() + \"!\"\n        print(msg)\n\nusernames = ['hannah', 'ty', 'margot']\ngreet_users(usernames)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 14.4.1 禁止函数修改列表\n\ndef function(list_name):\n\nfunction(list1[:])\n\n\n1\n2\n3\n\n\n通过传递列表副本禁止函数修改列表\n\n\n# 14.4.2 传递任意数量的实参\n\ndef make_pizza(*toppings):\n    print(\"\\nMaking a pizza with the following toppings:\")\n    for topping in toppings:\n        print(\"- \" + topping)\n\nmake_pizza('mushrooms', 'green peppers', 'extra cheese')\n\n\n1\n2\n3\n4\n5\n6\n\n\n形参名*toppings中的星号让Python创建一个名为toppings的空元组，并将收到的所有值都封装到这个元组中\n\n# 14.4.3 位置实参和任意数量实参结合\n\n先匹配位置实参和关键字实参，剩余实参都收集到最后一个任意数量形参中去\n\n\n# 14.5 将函数存储在模块中\n\n模块是扩展名为.py的文件，包含要导入到程序中的代码\n\nimport pizza\nfrom module_name import function_0, function_1, function_2\nfrom pizza import make_pizza as mp\nimport pizza as p\nfrom pizza import * #导入模块中所有函数\n\n\n1\n2\n3\n4\n5\n\n\n\n# 15 类\n\n 1. 面向对象：编写表示现实世界中的事物和情景的类，基于这些类来创建对象\n 2. 实例化：根据类来创建对象\n\n\n# 15.1 创建和使用类\n\n# 15.1.1 创建类\n\nclass Dog():\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def sit(self):\n        print(self.name.title() + \" is now sitting.\")\n\n    def roll_over(self):\n        print(self.title() + \" rolled over!\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 1. 类中的函数称为方法，与函数的差别在于调用方法的方式。方法__init__()很特殊，根据Dog类创建新实例时，python都会自动运行它。\n 2. 对于方法__init__()，形参self必不可少且必须位于其他形参前面，是指向实例本身的引用，让实例能够访问类中的属性和方法\n 3. 属性：以self为前缀的变量，可供类中所有方法使用，可以通过类的任何实例来访问这些变量\n\n# 15.1.2 根据类创建实例\n\n# 访问属性\n\nclass Dog():\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def sit(self):\n        print(self.name.title() + \" is now sitting.\")\n\n    def roll_over(self):\n        print(self.title() + \" rolled over!\")\n\nmy_dog = Dog('willie', 6）\nprint(my_dog.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 调用方法\n\nclass Dog():\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def sit(self):\n        print(self.name.title() + \" is now sitting.\")\n\n    def roll_over(self):\n        print(self.title() + \" rolled over!\")\n\nmy_dog = Dog('willie', 6）\nmy_dog.sit()\nmy_dog.roll_over()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 15.2 使用类和实例\n\n# 15.2.1 给属性指定默认值\n\nclass Car():\n    def __int__(self , make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0 #对该属性设定初始值在方法__int__中就不需要该属性的形参\n    def get_descriptive_name(self):\n        long_name = str(self.year) + ' ' + self.make + ' ' + self.model\n        return long_name.title()\n    def read_odometer(self):\n        print(\"This car has\" + str(self.odometer_reading) + \"miles on it.\")\n\nmy_new_car = Car('audi' , 'a4' , 2016)\nmy_new_car.read_odometer()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 15.2.2 修改属性值\n\n# 直接修改属性值\n\nclass Car():\n    def __int__(self , make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0 \n    def get_descriptive_name(self):\n        long_name = str(self.year) + ' ' + self.make + ' ' + self.model\n        return long_name.title()\n    def read_odometer(self):\n        print(\"This car has\" + str(self.odometer_reading) + \"miles on it.\")\n\nmy_new_car = Car('audi' , 'a4' , 2016)\nmy_new_car.odometer_reading = 23 #直接在外部修改类内属性值\nmy_new_car.read_odometer()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 通过方法修改属性的值\n\nclass Car():\n    def __int__(self , make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0 \n    #设置一个def的方法\n    def update_odometer(self,mileage):\n        self.odometer_reading = mileage\n    def get_descriptive_name(self):\n        long_name = str(self.year) + ' ' + self.make + ' ' + self.model\n        return long_name.title()\n    def read_odometer(self):\n        print(\"This car has\" + str(self.odometer_reading) + \"miles on it.\")\n\nmy_new_car = Car('audi' , 'a4' , 2016)\nmy_new_car.update_odometer(23)\nmy_new_car.read_odometer()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 15.3 继承\n\n编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用继承继承。一个类继承继承另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为父类父类，而新类称为子类子类。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法\n\n# 15.3.1 子类的方法__int__()\n\n创建子类时，父类必须包含在当前文件中，且位于子类前面\n\nclass Car():\n    def __int__(self , make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0 \n    def update_odometer(self,mileage):\n        self.odometer_reading = mileage\n    def get_descriptive_name(self):\n        long_name = str(self.year) + ' ' + self.make + ' ' + self.model\n        return long_name.title()\n    def read_odometer(self):\n        print(\"This car has\" + str(self.odometer_reading) + \"miles on it.\")\n\nclass ElectricCar(Car):\n    def __int__(self, make, model, year):\n        super().__int__(make, model, year)#将父类和子类关联起来\n\nmy_tesla = ElectricCar('tesla', 'model s', 2016)\nprint(my_tesla,get_descriptive_name())\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 15.3.2 给子类定义属性和方法\n\nclass Car():\n    def __int__(self , make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0 \n    def update_odometer(self,mileage):\n        self.odometer_reading = mileage\n    def get_descriptive_name(self):\n        long_name = str(self.year) + ' ' + self.make + ' ' + self.model\n        return long_name.title()\n    def read_odometer(self):\n        print(\"This car has\" + str(self.odometer_reading) + \"miles on it.\")\n\nclass ElectricCar(Car):\n    def __int__(self, make, model, year):\n        super().__int__(make, model, year)\n        self.battery_size = 70 #子类设置新的属性\n    \n    def describe_battery(self):\n        print(\"This car has a\" + str(self.battery_size) + \"-kWh battery.\")\n\nmy_tesla = ElectricCar('tesla', 'model s', 2016)\nprint(my_tesla,get_descriptive_name())\nmy_tesla.describe_battery()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 15.3.3 重写父类的方法\n\n对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法\n\nclass Car():\n    def __int__(self , make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n        self.gas_tank = 0 \n    def fill_gas_tank(gas):\n        gas_tank += gas\n\nclass ElectricCar(Car):\n    def __int__(self, make, model, year):\n        super().__int__(make, model, year)\n    ## 添加一种父类里存在的方法改写父类\n    def fill_gas_tank():\n        print(\"This car doesn't need a gas tank!\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 15.3.4 将实例用作属性\n\nclass Car():\n    def __int__(self , make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n        self.gas_tank = 0 \n    def fill_gas_tank(gas):\n        gas_tank += gas\n\nclass Battery():\n    def __int__(self, battery_size = 70):\n        self.battery_size = battery_size\n    def describe_battery(self):\n        print(\"This car has a\" + str(self.battery_size) + \"-kWh battery.\")\n\nclass ElectricCar(Car):\n    def __int__(self, make, model, year):\n        super().__int__(make, model, year)\n        self.battery = Battery() #将属性连接上前面的实例\n\nmy_tesla = ElectricCar('tesla', 'model s', 2016)\nmy_tesla.battery.describe_battery()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 15.4 导入类\n\n# 15.4.1 导入单个类\n\nfrom car import Car\n\n\n1\n\n\n# 15.4.2 从一个模块中导入多个类\n\nfrom car import Car, ElectricCar\n\n\n1\n\n\n# 15.4.3 导入整个模块\n\nimport car\n\n\n1\n\n\n# 15.4.4 导入模块中的所有类\n\nfrom module_name import *\n\n\n1\n\n\n# 15.4.5 在一个模块中导入另一个模块\n\n\n# 16 文件和异常\n\n\n# 16.1 读取文件数据\n\n# 16.1.1 读取整个文件\n\nwith open('pi.txt') as file_object:\n    contents = file_object.read()\n    print(contents)\n\n\n1\n2\n3\n\n 1. open()函数：打开在当前文件同目录下的接收参数文件\n 2. with关键字：在不再需要访问文件后将文件关闭，就可以不用调用close()，减少出现bug的可能性，python会自动帮你关闭\n 3. .read()方法：读取文件的全部内容\n\n# 16.1.2 文件路径\n\n 1. 相对路径 with open('text_files/filename.txt') as file_object 在当前文件所处文件夹下的text_files内的filename.txt处\n 2. 绝对路径\n\nfile_path = 'C:\\\\Users\\\\ehmatthes\\\\other_files\\\\text_files\\\\filename.txt'\nwith open(file_path) as file_object\n\n\n1\n2\n\n\n# 16.1.3 逐行读取\n\nfilename = 'pi_digits.txt'\nwith open(filename) as file_object:\n        for line in file_object:      print(line.rstrip())\n\n\n1\n2\n3\n\n\n# 16.1.4 创建包含文件各行内容的列表\n\nfilename = 'pi_digits.txt'\nwith open(filename) as file_object:\n    lines = file_object.readlines()#从文件中读取每一行形成一个列表\n    for line in lines:\n        print(line.rstrip())\n\n\n1\n2\n3\n4\n5\n\n\n\n# 16.2 写入文件\n\n# 16.2.1 写入空文件\n\nfilename = 'programming.txt'\nwith open(filename, 'w') as file_object:\n    file_object.write(\"I love programming\n\n\n1\n2\n3\n\n 1. open()函数的两个常用实参：第一个为文件名称；第二个为文件打开方式，可指定为：\n    * 读取模式'r'\n    * 写入模式'w'\n    * 附加模式'a'\n    * 同时读取和写入'r+'\n 2. 如果写入的文件不存在函数open()会自动创建\n 3. 以写入打开，如果指定文件存在，python将在返回文件对象前清空该文件\n\n# 16.2.2 写入多行\n\n函数write()不会在你写入的文本末尾添加换行符\n\nfilename = 'programming.txt'\nwith open(filename, 'w') as file_object:  \n    file_object.write(\"I love programming.\\n\")\n    file_object.write(\"I love creating new games.\\n)\n\n\n1\n2\n3\n4\n\n\n# 16.2.3 附加到文件\n\n以附加模式打开文件，给文件添加内容但不覆盖原有内容；如果文件不存在自动创建一个空文件\n\nfilename = 'programming.txt'\nwith open(filename, 'a') as file_object:\n    file_object.write(\"I also love finding meaning in large datasets.\\n\")\n    file_object.write(\"I love creating apps that can run in a browser.\\n)\n\n\n1\n2\n3\n4\n\n\n\n# 16.3 异常\n\npython发生错误时会创建一个异常对象，如果编写了处理该异常的代码，程序将继续运行；若未对异常进行处理，程序将停止并显示一个traceback\n\n# 16.3.1 try-except代码块\n\ntry:\n    print(5/0)\nexcept ZeroDivisionError:\n    print(\"你不能拿0当除数！\")\n\n\n1\n2\n3\n4\n\n 1. try后面的代码没问题将跳过except代码块\n 2. try后面的代码有问题且报错与except后标注一致则运行except代码块\n\n# 16.3.2 使用异常避免崩溃\n\nprint(\"Give me two numbers, and I'll divide them.\")\nprint(\"Enter 'q' to quit.\")\nwhile True:\n    first_number = input(\"\\nFirst number: \")\n    if first_number == 'q':\n        break\n    second_number = input(\"Second number: \")\n    try:\n        answer = int(first_number) / int(second_number)\n    except ZeroDivisionError:\n        print(\"You can't divide by 0!\")\n    else:\n        print(answer)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 16.3.3 不报错\n\ntry:\n    print(5/0)\nexcept ZeroDivisionError:\n    pass\n\n\n1\n2\n3\n4\n\n\n\n# 16.4 存储数据\n\n# 16.4.1 json.dump()和json.load()\n\nimport json\nnumbers = [2, 3, 5, 7, 11, 13]\nfilename = 'numbers.json'\nwith open(filename, 'w') as f_obj:\n    json.dump(numbers, f_obj)#将numbers存储到f_obj文件中\n\n\n1\n2\n3\n4\n5\n\n\nimport json\nfilename = 'numbers.json'\nwith open(filename) as f_obj:\n    numbers = json.load(f_obj)#读取json文件\n    print(numbers)\n\n\n1\n2\n3\n4\n5\n\n\n# 16.4.2 保存和读取用户生成的数据\n\nimport json\n## 如果以前存储了用户名，就加载它\n#否则，就提示用户输入用户名并存储它\nfilename = 'username.json'\ntry:\n    with open(filename) as f_obj:\n        username = json.load(f_obj)\nexcept FileNotFoundError:\n    username = input(\"What is your name? \")\n    with open(filename, 'w') as f_obj:\n        json.dump(username, f_obj)\n        print(\"We'll remember you when you come back, \" + username + \"!\")\nelse:\n    print(\"Welcome back, \" + username + \"!\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 16.4.3 重构\n\nimport json\ndef get_stored_username():\n    \"\"\"如果存储了用户名，就获取它\"\"\"\n    filename = 'username.json'\n    try:\n        with open(filename) as f_obj:\n            username = json.load(f_obj)\n    except FileNotFoundError:\n        return None\n    else:\n        return username\ndef get_new_username():\n    \"\"\"提示用户输入用户名\"\"\"\n    username = input(\"What is your name? \")\n    filename = 'username.json'\n    with open(filename, 'w') as f_obj:\n        json.dump(username, f_obj)\n        return username\ndef greet_user():\n    \"\"\"问候用户，并指出其名字\"\"\"\n    username = get_stored_username()\n    if username:\n        print(\"Welcome back, \" + username + \"!\")\n    else:\n        username = get_new_username()\n        print(\"We'll remember you when you come back, \" + username + \"!\")\n\ngreet_user()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 17 测试代码\n\n\n# 17.1 测试函数\n\nimport unittest\nfrom name_function import get_formatted_name\nclass NamesTestCase(unittest.TestCase):\n    \"\"\"测试name_function.py\"\"\"\n    def test_first_last_name(self):\n        \"\"\"能够正确地处理像Janis Joplin这样的姓名吗？\"\"\"\n        formatted_name = get_formatted_name('janis', 'joplin')\n        self.assertEqual(formatted_name, 'Janis Joplin')\nunittest.main()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 1. 首先导入模块unittest和要测试的函数get_formatted_name\n 2. 创建一个类，用于包含一系列针对get_formatted_name()的单元测试，这个类必须继承unittest.TestCase类\n 3. assertEqual()断言方法：核实结果是否与期望的结果一致\n\n\n# 17.2 断言方法\n\n序号   断言方法                                   断言描述\n1    assertEqual(a, b, msg=None)            验证a = b\n2    assertNotEqual(a, b, msg=None)         验证a != b\n3    assertTrue(x, msg=None)                验证x是true\n4    assertFalse(x, msg=None)               验证x是false\n5    assertIsInstance(obj, cls, msg=None)   验证obj是cls的实例\n6    assertIn(arg1, arg2, msg=None)         验证arg1是arg2的子串\n\n\n# 17.3 测试类\n\nimport unittest\nfrom survey import AnonymousSurvey\nclass TestAnonmyousSurvey(unittest.TestCase):\n    \"\"\"针对AnonymousSurvey类的测试\"\"\"\n    def setUp(self):\n        \"\"\"创建一个调查对象和一组答案，供使用的测试方法使用\"\"\"\n        question = \"What language did you first learn to speak?\"\n        self.my_survey = AnonymousSurvey(question)\n        self.responses = ['English', 'Spanish', 'Mandarin']\n    \n    def test_store_single_response(self):\n         \"\"\"测试单个答案会被妥善地存储\"\"\"\n        question = \"What language did you first learn to speak?\"\n        self.my_survey.store_response(self.responses[0])\n        self.assertIn(self.responses[0], self.my_survey.responses)\n\n    def test_store_three_responses(self):\n        \"\"\"测试三个答案会被妥善地存储\"\"\"\n        for response in self.responses:\n            self.my_survey.store_response(response)\n        for response in self.responses:\n            self.assertIn(response, self.my_survey.responses)\n\nunittest.main()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n 1. 应用setUp()使测试中只用实例化一次类",normalizedContent:"# 1 变量\n\n 1. 变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头\n 2. 变量名不能包含空格，但可使用下划线来分隔其中的单词\n 3. python关键字和函数名不能用作变量名\n 4. python支持三元表达式\"yahoo!\" if 3 > 2 else 2\n\n\n# 2 运算符\n\n\n# 2.1 数字运算符\n\n 1. + - * /加减乘除,其中除法一定得到浮点数\n 2. // % **整除，取余，乘方\n\n\n# 2.2 逻辑运算法\n\n 1. and or not 与、或、非（优先级not>and>or）\n 2. == > < >= <= !=判断相等、大于、小于、大于等于、小于等于、不等于\n 3. is判断两个引用是否指向同一对象（判断地址）；==判断两个引用指向的具体内容是否相等（判断内容）\n 4. in判断元素是否存在列表、字典的键、元组、集合中 元素不在字典的键中会报错\n 5. bool()执行函数将0视为false，其他所有值视为true\n\n\n# 3 数字\n\n\n# 3.1 整数（int）\n\n\n# 3.2 浮点数（float）\n\n带小数点的数字\n\n\n# 3.3 str()\n\n将得字符串转换为字符串，这样才能print\n\n\n# 4 字符串\n\n\n# 4.1 拼接字符串\n\n 1. +字符串1+字符串2\n 2. 直接写在一起字符串1字符串2\n 3. 以指定字符连接序列元素形成新字符串连接用的字符.join(要被连接的序列)\n\n\n# 4.2 字符串索引\n\n 1. 获得索引对应值：字符串名[索引值]\n 2. 计算字符串长度：len(字符串名)\n 3. 获得值对应索引：\n    * 被检测字符串名.find(检测的字符串，开始检测索引，结束检测索引)默认从头检测到尾，返回最先检测到的值，检测不到返回-1\n    * 被检测字符串名.index(检测的字符串，开始检测索引，结束检测索引)默认从头检测到尾，返回最先检测到的值，检测不到报异常\n    * 被检测字符串名.rfind(检测的字符串，开始检测索引，结束检测索引)返回最后检测到的值\n\n\n# 4.3 常用函数\n\n 1. 每个单词首字母大写其余小写字符串名.title()\n 2. 使用制表符或换行符来添加空白 \\t:制表符，一个tab \\n:换行符，换行\n 3. 删除空白\n    * rstrip():暂时删除字符串末尾空白\n    * lstrip():暂时删除字符串开头空白\n    * strip():暂时删除字符串两端空白\n\n\n# 4.4 历遍字符串\n\nfor i , n in enumerate(s):\n\n\n1\n\n\n\n# 5 列表\n\n 1. 定义：由一系列按特定顺序排列的元素组成\n\n\n# 5.1 创建列表\n\n 1. 空列表列表名 = []\n 2. 赋值列表列表名 = [元素1 , 元素2]\n 3. 乘法赋值列表名 = [元素]*列表长度\n\n\n# 5.2 访问列表\n\n 1. 通过索引访问值列表名[索引值]\n 2. 索引从0开始,负数可以反向索引\n 3. 通过值访问索引\n\n\n# 5.3 修改元素\n\n 1. 直接赋值列表名[希望赋值的索引] = 赋予的值\n\n\n# 5.4 添加元素\n\n 1. 末尾添加元素列表名称.append(添加的元素)\n 2. 在列表中插入元素列表名称.insert(插入元素索引值，元素)\n 3. 在列表末尾添加多个元素被添加列表名称.extend(保存添加元素的列表)\n 4. 加法运算相当于extend列表1+列表2\n\n\n# 5.5 删除\n\n 1. del语句del 列表名[要删除元素的索引]\n 2. 出栈，可得到索引元素值出栈元素值 = 列表名.pop(索引) 不写索引默认为末尾元素\n 3. 根据值删除元素列表名.remove(要删除元素值)\n\n\n# 5.6 使用列表的一部分\n\n 1. 切片\n    * 列表名[切片开始:切片结束:切片步距]\n    * 切片左闭右开\n    * 可以另步距为-1实现倒叙\n 2. 复制\n    * 不能直接用==，这样复制地址内容没有备份\n    * 要用切片复制存储列表 = 被复制列表[:]\n    * 被复制列表.copy()\n\n\n# 5.7 组织列表\n\n 1. 永久性按照字母顺序排序\n    * 列表名.sort(key=none , reverse=false)\n    * key：用来进行比较的元素，默认第一个\n    * reverse默认为true，降序\n 2. 临时性按照字母顺序排序 列表名.sorted(key=none , reverse=false)\n 3. 永久性反转列表列表名.reverse()\n 4. 得到列表长度len(列表名)\n\n\n# 5.8 历遍列表\n\n 1. 历遍元素 for 后续代表元素名称 in 列表名:\n 2. 同时历遍索引和元素 for i, value in enumerate(列表名)\n\n\n# 6 元组\n\n不可变的列表\n\n\n# 6.1 创建元组\n\n 1. 空元组 元组名 = ()\n 2. 一个元素的元组 元组名 = (元素1,) 一个元素的元组必须加\",\"，因为小括号有优先级问题，否则会被认为是单个元素\n 3. 普通赋值元组 元组名 = (元素1,元素2)\n\n\n# 6.2 元组操作\n\n支持列表中绝大部分操作\n\n\n# 6.3 遍历元组\n\n和列表一样\n\n\n# 6.4 多个变量解压元组\n\na, *b , c = (1,2,3,4) 标星号表示b为一个list，其他变量一一对应后所剩的变量都是b的\n\n\n# 6.5 修改元组变量\n\n 1. 重新定义，不能单独修改一个值\n 2. 元组本身不能改变，但元组内可变元素（列表等）是可以改变的\n\n\n# 7 字典\n\n存储key和value的键值对。我们用{}表示一个dict，用:分隔key和value\n\n\n# 7.1 创建字典\n\n 1. 创建空字典 字典名 = {}\n 2. 赋值创建字典 字典名 = {键:值}\n 3. 键必须为不可变对象，list和dict都不可以作键\n\n\n# 7.2 访问字典\n\n 1. 检索方式，查找不到key会报错 值 = 字典名[查找的键]\n 2. get方式查找不到会返回none 值 = 字典名.get(查找的键)\n 3. 返回所有键 所有键的列表 = list(字典名.keys())\n 4. 返回所有值 所有键的列表 = list(字典名.values())\n\n\n# 7.3 插入新的字典对应\n\n 1. 为不存在的key插入value，存在不覆盖 字典名.setdefault(键,值)\n 2. 为不存在的key插入value，存在覆盖 字典名.update({键:值}) 字典名[键] = 值\n\n\n# 7.4 删除键——对值\n\ndel 字典名[键] 只能传入键\n\n\n# 7.5 历遍字典\n\n 1. 历遍所有键——值对 for key,value in 字典名.items():\n 2. 历遍字典中的所有键 for key in 字典名.keys():\n 3. 历遍字典中的所有值 for value in 字典名.values():\n\n\n# 7.6 嵌套\n\n 1. 字典列表\n\nalien_0 = {'color':'green' , 'points':5}\nalien_1 = {'color':'yellow' , 'points':10}\nalien_2 = {'color':'red' , 'points':15}\naliens = [alien_0 , alien_1 , alien_2]\nfor alien in aliens:\n    if alien['color'] == 'green':\n        print(alien['points'])\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 2. 字典中存储列表\n\nfavorite_languages = {'jen':['python' , 'ruby'] , 'sarah':['ruby' , 'go'] , 'edward':['c']}\nfor name,languages in favorite_languages.item():\n    for language in  languages:\n        print(language)\n\n\n1\n2\n3\n4\n\n 3. 字典中存储字典\n\nusers = {\n    'aeinstein': {'first': 'albert' , 'last': 'einstein' ,'location':'princeton'},\n    'mcurie': {'first': 'marie' , 'last': 'curie' , 'location': 'paris'}\n    }\nfor username,user_info in users.item():\n    print(\"\\nusername: \" + username)\n    for key,value in user_info:\n        print(key + value)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 8 集合\n\n用来存储不重复元素的容器，当中的元素都是不同的，相同的元素会被删除\n\n\n# 8.1 创建集合\n\n 1. 创建空集合 集合名 = set() 不能用{}创建空集合，会与字典冲突\n 2. 赋值创建集合 集合名 = set(元素) 集合名 = {元素}\n 3. set当中的元素也必须是不可变对象，因此list不能传入set\n\n\n# 8.2 插入元素\n\n 1. 添加单个元素，存在则不操作 集合名.add(元素)\n 2. 添加多个元素，保证集合内元素不重复 集合名.update(元素) 这里元素可以是列表，元组，字典等，会自动展开元素\n\n\n# 8.3 删除元素\n\n 1. 移除元素，不存在则报错 集合名.remove(要移除的元素)\n 2. 移除元素，不存在不会报错 集合名.discard(要移除的元素)\n 3. 随机删除一个元素 集合名.pop() pop过程中会对集合无序排列，删除左边第一个元素\n\n\n# 8.4 支持的集合操作\n\n 1. 交集 集合1 & 集合2\n 2. 并集 集合1 | 集合2\n 3. 差集 被求差集合 - 集合2\n 4. 对称集 对称保留集合 ^ 集合2 将前一个集合去掉两集合的交集\n 5. 超集、子集判断 集合1 >= 集合2判断1是否为2的超集 集合1 <= 集合2判断1是否为2的子集\n\n\n# 8.5 其他常用函数\n\n 1. 计算个数 len(集合名)\n 2. 清空集合 集合名.clear()\n\n\n# 9 输入输出\n\n\n# 9.1 输入\n\n 1. input(要输出的量)\n 2. 传入字符串\n\n\n# 9.2 输出\n\n 1. print(要输出的量)\n 2. 默认输出自动换行\n 3. print(要输出的量,end=' ')更换字符结尾替代换行\n\n\n# 10 if\n\n\n# 10.1 条件测试\n\n条件测试：值为true或flase的表达式\n\n# 10.1.1 检查是否相等\n\n 1. 使用==\n 2. 直接使用时考虑大小写\n 3. 加上.lower()时就可全部变为小写判断\n\n# 10.1.2 检查是否不相等\n\n使用!=\n\n# 10.1.3 比较数字\n\n可以包含等于、不等于、大于、小于等\n\n# 10.1.4 检查多个条件\n\n 1. and表示和\n 2. or表示或\n\n# 10.1.5 检查特定值是否在/不在\n\n 1. in表示在\n 2. not in表示不在\n\n# 10.1.6 布尔表达式\n\n\n# 10.2 语句结构\n\n# 10.2.1 if-else\n\n# 10.2.2 if-elif-else\n\n# 10.2.3 多个elif\n\n# 10.2.4 省略else\n\n\n# 11 while循环\n\n\n# 11.1 使用while循环\n\ncurrent_number = 1\nwhile current_number <= 5:\n    print(current_number)    current_number += 1\n\n\n1\n2\n3\n\n\n\n# 11.2 使用break退出循环\n\nprompt = \"\\nplease enter the name of a city you have visited:\"\nprompt += \"\\n(enter 'quit' when you are finished.) \"\nwhile true:\n    city = input(prompt)\n    if city == 'quit':\n        break\n    else:\n        print(\"i'd love to go to \" + city.title() + \"!\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 11.3 使用continue继续\n\ncurrent_number = 0\nwhile current_number < 10:\n    current_number += 1\n    if current_number % 2 == 0:\n        continue\n    print(current_number)\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 12 迭代器\n\niterator，永远指向当前的位置，永远知道下一个位置在哪里\n\n\n# 12.1 容器迭代器\n\n 1. 使用关键字获取迭代器 迭代器名 = iter(可迭代对象) 可迭代对象指list、tuple、dict类型\n 2. 调用迭代器\n    * 获取的元素 = next(迭代器名) 获得迭代器中下一个元素\n    * for 获取的元素 in 迭代器名\n 3. 调用迭代器超过元素个数会引发超界，python抛出stoplteration的error\n\n\n# 12.2 自定义迭代器\n\nclass powtwo:\n    生成2的幂的迭代器\n\n    def __init__(self, max = 0):\n        self.max = max\n\n    def __iter__(self):\n        self.n = 0\n        return self\n\n    def __next__(self):\n        if self.n <= self.max:\n            result = 2 ** self.n\n            self.n += 1\n            return result\n        else:\n            raise stopiteration\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 13 生成器\n\n生成器的概念和迭代器相辅相成，迭代器是生成一个遍历数据的迭代工具，而生成器则是数据生成工具\n\n\n# 13.1 括号创建法\n\n 1. 生成器名称 = (元素循环内操作 for i in range(元素个数))\n 2. 和用循环生成list几乎没什么差别，只是使用（）\n 3. 循环生成list的时候会运行整个循环，但创建生成器的时候只有每次调用的时候才会触发一次循环\n\n\n# 13.2 函数创建法\n\n 1. 看上起定义一个函数，但返回的不是一个值而是生成器\n\ndef 生成器名称(生成器生成个数):\n    for i in range(生成器生成个数):\n        yield f(i) #此处可以是关于i的任意函数\n\n\n1\n2\n3\n\n 2. 关键词yield\n    * 与return的相同点：会将之后的内容返回给调用方\n    * 不同点：当我们下一次再次执行的时候，会继续从上次yield处开始往下执行\n 3. 关键词yield from 返回一个迭代器或者是生成器执行next之后的结果\n\n\n# 14 函数\n\n\n# 14.1 定义函数\n\ndef greet_user(username):\n    print('hello' + username.title() + '!')\n\ngreet_user()\n\n\n1\n2\n3\n4\n\n\n输入的username是一个形参，如果直接输入信息则为实参\n\n\n# 14.2 传递实参\n\n# 14.2.1 位置实参\n\n一种函数调用中的实参与函数定义中的形参的关联方式，基于实参的顺序\n\ndef describe_pet(animal_type , pet_name):\n    print(\"\\ni have a\" + animal_type + ',')\n    print('my' + animal_type + \"'s name is\" + pet_name.title() + '.')\n\ndescribe_pet('hamster' , 'harry')\n\n\n1\n2\n3\n4\n5\n\n\n# 14.2.2 关键字实参\n\n传递给函数名称——值对\n\ndef describe_pet(animal_type , pet_name):\n    print(\"\\ni have a\" + animal_type + ',')\n    print('my' + animal_type + \"'s name is\" + pet_name.title() + '.')\n\ndescribe_pet(animal_type ='hamster' , pet_name = 'harry')\n\n\n1\n2\n3\n4\n5\n\n\n# 14.2.3 默认值\n\n定义函数时可以设置默认值\n\ndef describe_pet(animal_type , pet_name = 'harry'):\n    print(\"\\ni have a\" + animal_type + ',')\n    print('my' + animal_type + \"'s name is\" + pet_name.title() + '.')\n\ndescribe_pet('hamster')\n\n\n1\n2\n3\n4\n5\n\n\n\n# 14.3 返回值\n\n# 14.3.1 返回简单值\n\ndef get_formatted_name(first_name, last_name):\n    full_name = first_name + ' ' + last_name\n    return full_name.title()\n\nmusician = get_formatted_name('jimi', 'hendrix')\nprint(musician)\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 14.3.2 令实参变成可选的\n\ndef get_formatted_name(first_name, last_name , middle_name = ''):\n    full_name = first_name + ' ' + middle_name + ' ' + last_name\n    return full_name.title()\n\nmusician = get_formatted_name('jimi', 'hendrix')\nprint(musician)\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 14.3.3 返回字典\n\ndef build_person(first_name, last_name):\n    person = {'first': first_name, 'last': last_name}\n    return person\n\nmusician = get_formatted_name('jimi', 'hendrix')\nprint(musician)\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 14.3.4 结合使用函数和while\n\ndef get_formatted_name(first_name, last_name):\n    full_name = first_name + ' ' + last_name\n    return full_name.title()\nwhile true:\n    print(\"\\nplease tell me your name:\")\n    print(\"(enter 'q' at any time to quit)\")\n    f_name = input(\"first name: \")\n    if f_name == 'q':\n        break\n    l_name = input(\"last name: \"\n    if l_name == 'q':\n        break\n    formatted_name = get_formatted_name(f_name, l_name)\n    print(\"\\nhello, \" + formatted_name + \"!\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 14.4 传递列表\n\ndef greet_users(names):\n    for name in names:\n        msg = \"hello, \" + name.title() + \"!\"\n        print(msg)\n\nusernames = ['hannah', 'ty', 'margot']\ngreet_users(usernames)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 14.4.1 禁止函数修改列表\n\ndef function(list_name):\n\nfunction(list1[:])\n\n\n1\n2\n3\n\n\n通过传递列表副本禁止函数修改列表\n\n\n# 14.4.2 传递任意数量的实参\n\ndef make_pizza(*toppings):\n    print(\"\\nmaking a pizza with the following toppings:\")\n    for topping in toppings:\n        print(\"- \" + topping)\n\nmake_pizza('mushrooms', 'green peppers', 'extra cheese')\n\n\n1\n2\n3\n4\n5\n6\n\n\n形参名*toppings中的星号让python创建一个名为toppings的空元组，并将收到的所有值都封装到这个元组中\n\n# 14.4.3 位置实参和任意数量实参结合\n\n先匹配位置实参和关键字实参，剩余实参都收集到最后一个任意数量形参中去\n\n\n# 14.5 将函数存储在模块中\n\n模块是扩展名为.py的文件，包含要导入到程序中的代码\n\nimport pizza\nfrom module_name import function_0, function_1, function_2\nfrom pizza import make_pizza as mp\nimport pizza as p\nfrom pizza import * #导入模块中所有函数\n\n\n1\n2\n3\n4\n5\n\n\n\n# 15 类\n\n 1. 面向对象：编写表示现实世界中的事物和情景的类，基于这些类来创建对象\n 2. 实例化：根据类来创建对象\n\n\n# 15.1 创建和使用类\n\n# 15.1.1 创建类\n\nclass dog():\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def sit(self):\n        print(self.name.title() + \" is now sitting.\")\n\n    def roll_over(self):\n        print(self.title() + \" rolled over!\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 1. 类中的函数称为方法，与函数的差别在于调用方法的方式。方法__init__()很特殊，根据dog类创建新实例时，python都会自动运行它。\n 2. 对于方法__init__()，形参self必不可少且必须位于其他形参前面，是指向实例本身的引用，让实例能够访问类中的属性和方法\n 3. 属性：以self为前缀的变量，可供类中所有方法使用，可以通过类的任何实例来访问这些变量\n\n# 15.1.2 根据类创建实例\n\n# 访问属性\n\nclass dog():\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def sit(self):\n        print(self.name.title() + \" is now sitting.\")\n\n    def roll_over(self):\n        print(self.title() + \" rolled over!\")\n\nmy_dog = dog('willie', 6）\nprint(my_dog.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 调用方法\n\nclass dog():\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def sit(self):\n        print(self.name.title() + \" is now sitting.\")\n\n    def roll_over(self):\n        print(self.title() + \" rolled over!\")\n\nmy_dog = dog('willie', 6）\nmy_dog.sit()\nmy_dog.roll_over()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 15.2 使用类和实例\n\n# 15.2.1 给属性指定默认值\n\nclass car():\n    def __int__(self , make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0 #对该属性设定初始值在方法__int__中就不需要该属性的形参\n    def get_descriptive_name(self):\n        long_name = str(self.year) + ' ' + self.make + ' ' + self.model\n        return long_name.title()\n    def read_odometer(self):\n        print(\"this car has\" + str(self.odometer_reading) + \"miles on it.\")\n\nmy_new_car = car('audi' , 'a4' , 2016)\nmy_new_car.read_odometer()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 15.2.2 修改属性值\n\n# 直接修改属性值\n\nclass car():\n    def __int__(self , make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0 \n    def get_descriptive_name(self):\n        long_name = str(self.year) + ' ' + self.make + ' ' + self.model\n        return long_name.title()\n    def read_odometer(self):\n        print(\"this car has\" + str(self.odometer_reading) + \"miles on it.\")\n\nmy_new_car = car('audi' , 'a4' , 2016)\nmy_new_car.odometer_reading = 23 #直接在外部修改类内属性值\nmy_new_car.read_odometer()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 通过方法修改属性的值\n\nclass car():\n    def __int__(self , make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0 \n    #设置一个def的方法\n    def update_odometer(self,mileage):\n        self.odometer_reading = mileage\n    def get_descriptive_name(self):\n        long_name = str(self.year) + ' ' + self.make + ' ' + self.model\n        return long_name.title()\n    def read_odometer(self):\n        print(\"this car has\" + str(self.odometer_reading) + \"miles on it.\")\n\nmy_new_car = car('audi' , 'a4' , 2016)\nmy_new_car.update_odometer(23)\nmy_new_car.read_odometer()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 15.3 继承\n\n编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用继承继承。一个类继承继承另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为父类父类，而新类称为子类子类。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法\n\n# 15.3.1 子类的方法__int__()\n\n创建子类时，父类必须包含在当前文件中，且位于子类前面\n\nclass car():\n    def __int__(self , make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0 \n    def update_odometer(self,mileage):\n        self.odometer_reading = mileage\n    def get_descriptive_name(self):\n        long_name = str(self.year) + ' ' + self.make + ' ' + self.model\n        return long_name.title()\n    def read_odometer(self):\n        print(\"this car has\" + str(self.odometer_reading) + \"miles on it.\")\n\nclass electriccar(car):\n    def __int__(self, make, model, year):\n        super().__int__(make, model, year)#将父类和子类关联起来\n\nmy_tesla = electriccar('tesla', 'model s', 2016)\nprint(my_tesla,get_descriptive_name())\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 15.3.2 给子类定义属性和方法\n\nclass car():\n    def __int__(self , make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0 \n    def update_odometer(self,mileage):\n        self.odometer_reading = mileage\n    def get_descriptive_name(self):\n        long_name = str(self.year) + ' ' + self.make + ' ' + self.model\n        return long_name.title()\n    def read_odometer(self):\n        print(\"this car has\" + str(self.odometer_reading) + \"miles on it.\")\n\nclass electriccar(car):\n    def __int__(self, make, model, year):\n        super().__int__(make, model, year)\n        self.battery_size = 70 #子类设置新的属性\n    \n    def describe_battery(self):\n        print(\"this car has a\" + str(self.battery_size) + \"-kwh battery.\")\n\nmy_tesla = electriccar('tesla', 'model s', 2016)\nprint(my_tesla,get_descriptive_name())\nmy_tesla.describe_battery()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 15.3.3 重写父类的方法\n\n对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法\n\nclass car():\n    def __int__(self , make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n        self.gas_tank = 0 \n    def fill_gas_tank(gas):\n        gas_tank += gas\n\nclass electriccar(car):\n    def __int__(self, make, model, year):\n        super().__int__(make, model, year)\n    ## 添加一种父类里存在的方法改写父类\n    def fill_gas_tank():\n        print(\"this car doesn't need a gas tank!\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 15.3.4 将实例用作属性\n\nclass car():\n    def __int__(self , make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n        self.gas_tank = 0 \n    def fill_gas_tank(gas):\n        gas_tank += gas\n\nclass battery():\n    def __int__(self, battery_size = 70):\n        self.battery_size = battery_size\n    def describe_battery(self):\n        print(\"this car has a\" + str(self.battery_size) + \"-kwh battery.\")\n\nclass electriccar(car):\n    def __int__(self, make, model, year):\n        super().__int__(make, model, year)\n        self.battery = battery() #将属性连接上前面的实例\n\nmy_tesla = electriccar('tesla', 'model s', 2016)\nmy_tesla.battery.describe_battery()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 15.4 导入类\n\n# 15.4.1 导入单个类\n\nfrom car import car\n\n\n1\n\n\n# 15.4.2 从一个模块中导入多个类\n\nfrom car import car, electriccar\n\n\n1\n\n\n# 15.4.3 导入整个模块\n\nimport car\n\n\n1\n\n\n# 15.4.4 导入模块中的所有类\n\nfrom module_name import *\n\n\n1\n\n\n# 15.4.5 在一个模块中导入另一个模块\n\n\n# 16 文件和异常\n\n\n# 16.1 读取文件数据\n\n# 16.1.1 读取整个文件\n\nwith open('pi.txt') as file_object:\n    contents = file_object.read()\n    print(contents)\n\n\n1\n2\n3\n\n 1. open()函数：打开在当前文件同目录下的接收参数文件\n 2. with关键字：在不再需要访问文件后将文件关闭，就可以不用调用close()，减少出现bug的可能性，python会自动帮你关闭\n 3. .read()方法：读取文件的全部内容\n\n# 16.1.2 文件路径\n\n 1. 相对路径 with open('text_files/filename.txt') as file_object 在当前文件所处文件夹下的text_files内的filename.txt处\n 2. 绝对路径\n\nfile_path = 'c:\\\\users\\\\ehmatthes\\\\other_files\\\\text_files\\\\filename.txt'\nwith open(file_path) as file_object\n\n\n1\n2\n\n\n# 16.1.3 逐行读取\n\nfilename = 'pi_digits.txt'\nwith open(filename) as file_object:\n        for line in file_object:      print(line.rstrip())\n\n\n1\n2\n3\n\n\n# 16.1.4 创建包含文件各行内容的列表\n\nfilename = 'pi_digits.txt'\nwith open(filename) as file_object:\n    lines = file_object.readlines()#从文件中读取每一行形成一个列表\n    for line in lines:\n        print(line.rstrip())\n\n\n1\n2\n3\n4\n5\n\n\n\n# 16.2 写入文件\n\n# 16.2.1 写入空文件\n\nfilename = 'programming.txt'\nwith open(filename, 'w') as file_object:\n    file_object.write(\"i love programming\n\n\n1\n2\n3\n\n 1. open()函数的两个常用实参：第一个为文件名称；第二个为文件打开方式，可指定为：\n    * 读取模式'r'\n    * 写入模式'w'\n    * 附加模式'a'\n    * 同时读取和写入'r+'\n 2. 如果写入的文件不存在函数open()会自动创建\n 3. 以写入打开，如果指定文件存在，python将在返回文件对象前清空该文件\n\n# 16.2.2 写入多行\n\n函数write()不会在你写入的文本末尾添加换行符\n\nfilename = 'programming.txt'\nwith open(filename, 'w') as file_object:  \n    file_object.write(\"i love programming.\\n\")\n    file_object.write(\"i love creating new games.\\n)\n\n\n1\n2\n3\n4\n\n\n# 16.2.3 附加到文件\n\n以附加模式打开文件，给文件添加内容但不覆盖原有内容；如果文件不存在自动创建一个空文件\n\nfilename = 'programming.txt'\nwith open(filename, 'a') as file_object:\n    file_object.write(\"i also love finding meaning in large datasets.\\n\")\n    file_object.write(\"i love creating apps that can run in a browser.\\n)\n\n\n1\n2\n3\n4\n\n\n\n# 16.3 异常\n\npython发生错误时会创建一个异常对象，如果编写了处理该异常的代码，程序将继续运行；若未对异常进行处理，程序将停止并显示一个traceback\n\n# 16.3.1 try-except代码块\n\ntry:\n    print(5/0)\nexcept zerodivisionerror:\n    print(\"你不能拿0当除数！\")\n\n\n1\n2\n3\n4\n\n 1. try后面的代码没问题将跳过except代码块\n 2. try后面的代码有问题且报错与except后标注一致则运行except代码块\n\n# 16.3.2 使用异常避免崩溃\n\nprint(\"give me two numbers, and i'll divide them.\")\nprint(\"enter 'q' to quit.\")\nwhile true:\n    first_number = input(\"\\nfirst number: \")\n    if first_number == 'q':\n        break\n    second_number = input(\"second number: \")\n    try:\n        answer = int(first_number) / int(second_number)\n    except zerodivisionerror:\n        print(\"you can't divide by 0!\")\n    else:\n        print(answer)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 16.3.3 不报错\n\ntry:\n    print(5/0)\nexcept zerodivisionerror:\n    pass\n\n\n1\n2\n3\n4\n\n\n\n# 16.4 存储数据\n\n# 16.4.1 json.dump()和json.load()\n\nimport json\nnumbers = [2, 3, 5, 7, 11, 13]\nfilename = 'numbers.json'\nwith open(filename, 'w') as f_obj:\n    json.dump(numbers, f_obj)#将numbers存储到f_obj文件中\n\n\n1\n2\n3\n4\n5\n\n\nimport json\nfilename = 'numbers.json'\nwith open(filename) as f_obj:\n    numbers = json.load(f_obj)#读取json文件\n    print(numbers)\n\n\n1\n2\n3\n4\n5\n\n\n# 16.4.2 保存和读取用户生成的数据\n\nimport json\n## 如果以前存储了用户名，就加载它\n#否则，就提示用户输入用户名并存储它\nfilename = 'username.json'\ntry:\n    with open(filename) as f_obj:\n        username = json.load(f_obj)\nexcept filenotfounderror:\n    username = input(\"what is your name? \")\n    with open(filename, 'w') as f_obj:\n        json.dump(username, f_obj)\n        print(\"we'll remember you when you come back, \" + username + \"!\")\nelse:\n    print(\"welcome back, \" + username + \"!\")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 16.4.3 重构\n\nimport json\ndef get_stored_username():\n    \"\"\"如果存储了用户名，就获取它\"\"\"\n    filename = 'username.json'\n    try:\n        with open(filename) as f_obj:\n            username = json.load(f_obj)\n    except filenotfounderror:\n        return none\n    else:\n        return username\ndef get_new_username():\n    \"\"\"提示用户输入用户名\"\"\"\n    username = input(\"what is your name? \")\n    filename = 'username.json'\n    with open(filename, 'w') as f_obj:\n        json.dump(username, f_obj)\n        return username\ndef greet_user():\n    \"\"\"问候用户，并指出其名字\"\"\"\n    username = get_stored_username()\n    if username:\n        print(\"welcome back, \" + username + \"!\")\n    else:\n        username = get_new_username()\n        print(\"we'll remember you when you come back, \" + username + \"!\")\n\ngreet_user()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 17 测试代码\n\n\n# 17.1 测试函数\n\nimport unittest\nfrom name_function import get_formatted_name\nclass namestestcase(unittest.testcase):\n    \"\"\"测试name_function.py\"\"\"\n    def test_first_last_name(self):\n        \"\"\"能够正确地处理像janis joplin这样的姓名吗？\"\"\"\n        formatted_name = get_formatted_name('janis', 'joplin')\n        self.assertequal(formatted_name, 'janis joplin')\nunittest.main()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 1. 首先导入模块unittest和要测试的函数get_formatted_name\n 2. 创建一个类，用于包含一系列针对get_formatted_name()的单元测试，这个类必须继承unittest.testcase类\n 3. assertequal()断言方法：核实结果是否与期望的结果一致\n\n\n# 17.2 断言方法\n\n序号   断言方法                                   断言描述\n1    assertequal(a, b, msg=none)            验证a = b\n2    assertnotequal(a, b, msg=none)         验证a != b\n3    asserttrue(x, msg=none)                验证x是true\n4    assertfalse(x, msg=none)               验证x是false\n5    assertisinstance(obj, cls, msg=none)   验证obj是cls的实例\n6    assertin(arg1, arg2, msg=none)         验证arg1是arg2的子串\n\n\n# 17.3 测试类\n\nimport unittest\nfrom survey import anonymoussurvey\nclass testanonmyoussurvey(unittest.testcase):\n    \"\"\"针对anonymoussurvey类的测试\"\"\"\n    def setup(self):\n        \"\"\"创建一个调查对象和一组答案，供使用的测试方法使用\"\"\"\n        question = \"what language did you first learn to speak?\"\n        self.my_survey = anonymoussurvey(question)\n        self.responses = ['english', 'spanish', 'mandarin']\n    \n    def test_store_single_response(self):\n         \"\"\"测试单个答案会被妥善地存储\"\"\"\n        question = \"what language did you first learn to speak?\"\n        self.my_survey.store_response(self.responses[0])\n        self.assertin(self.responses[0], self.my_survey.responses)\n\n    def test_store_three_responses(self):\n        \"\"\"测试三个答案会被妥善地存储\"\"\"\n        for response in self.responses:\n            self.my_survey.store_response(response)\n        for response in self.responses:\n            self.assertin(response, self.my_survey.responses)\n\nunittest.main()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n 1. 应用setup()使测试中只用实例化一次类",charsets:{cjk:!0},lastUpdated:"2023/03/27, 17:41:36",lastUpdatedTimestamp:1679910096e3},{title:"计算机网络",frontmatter:{title:"计算机网络",date:"2022-04-11T16:34:43.000Z",permalink:"/pages/c317e3/",categories:["计算机基础","计算机网络"],tags:["计算机网络"],author:{name:"年华惊风雨",link:"https://github.com/wsy425"}},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/00.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/00.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html",relativePath:"02.计算机基础/00. 计算机网络/00. 计算机网络.md",key:"v-0f016060",path:"/pages/c317e3/",headers:[{level:2,title:"1 概述",slug:"_1-概述",normalizedTitle:"1 概述",charIndex:30},{level:3,title:"1.1 计算机网络概念",slug:"_1-1-计算机网络概念",normalizedTitle:"1.1 计算机网络概念",charIndex:41},{level:3,title:"1.2 计算机网络功能",slug:"_1-2-计算机网络功能",normalizedTitle:"1.2 计算机网络功能",charIndex:197},{level:3,title:"1.3 计算机网络的组成",slug:"_1-3-计算机网络的组成",normalizedTitle:"1.3 计算机网络的组成",charIndex:359},{level:4,title:"1.3.1 组成部分",slug:"_1-3-1-组成部分",normalizedTitle:"1.3.1 组成部分",charIndex:375},{level:4,title:"1.3.2 工作方式",slug:"_1-3-2-工作方式",normalizedTitle:"1.3.2 工作方式",charIndex:474},{level:4,title:"1.3.3 功能组成",slug:"_1-3-3-功能组成",normalizedTitle:"1.3.3 功能组成",charIndex:547},{level:3,title:"1.4 计算机网络的分类",slug:"_1-4-计算机网络的分类",normalizedTitle:"1.4 计算机网络的分类",charIndex:639},{level:4,title:"1.4.1 按分布范围",slug:"_1-4-1-按分布范围",normalizedTitle:"1.4.1 按分布范围",charIndex:655},{level:4,title:"1.4.2 按使用者",slug:"_1-4-2-按使用者",normalizedTitle:"1.4.2 按使用者",charIndex:715},{level:4,title:"1.4.3 按交换技术",slug:"_1-4-3-按交换技术",normalizedTitle:"1.4.3 按交换技术",charIndex:746},{level:4,title:"1.4.4 按拓扑结构",slug:"_1-4-4-按拓扑结构",normalizedTitle:"1.4.4 按拓扑结构",charIndex:789},{level:4,title:"1.4.5 按传输技术",slug:"_1-4-5-按传输技术",normalizedTitle:"1.4.5 按传输技术",charIndex:843},{level:3,title:"1.5 标准化工作",slug:"_1-5-标准化工作",normalizedTitle:"1.5 标准化工作",charIndex:905},{level:4,title:"1.5.1 标准分类",slug:"_1-5-1-标准分类",normalizedTitle:"1.5.1 标准分类",charIndex:918},{level:4,title:"1.5.2 RFC因特网标准形式",slug:"_1-5-2-rfc因特网标准形式",normalizedTitle:"1.5.2 rfc因特网标准形式",charIndex:1002},{level:4,title:"1.5.3 标准化相关组织",slug:"_1-5-3-标准化相关组织",normalizedTitle:"1.5.3 标准化相关组织",charIndex:1089},{level:3,title:"1.6 计算机网络性能",slug:"_1-6-计算机网络性能",normalizedTitle:"1.6 计算机网络性能",charIndex:1184},{level:4,title:"1.6.1 速率",slug:"_1-6-1-速率",normalizedTitle:"1.6.1 速率",charIndex:1199},{level:4,title:"1.6.2 带宽",slug:"_1-6-2-带宽",normalizedTitle:"1.6.2 带宽",charIndex:1323},{level:4,title:"1.6.3 吞吐量",slug:"_1-6-3-吞吐量",normalizedTitle:"1.6.3 吞吐量",charIndex:1461},{level:4,title:"1.6.4 时延",slug:"_1-6-4-时延",normalizedTitle:"1.6.4 时延",charIndex:1518},{level:4,title:"1.6.5 时延带宽积",slug:"_1-6-5-时延带宽积",normalizedTitle:"1.6.5 时延带宽积",charIndex:1764},{level:4,title:"1.6.6 往返时延RTT",slug:"_1-6-6-往返时延rtt",normalizedTitle:"1.6.6 往返时延rtt",charIndex:1845},{level:4,title:"1.6.7 利用率",slug:"_1-6-7-利用率",normalizedTitle:"1.6.7 利用率",charIndex:1973},{level:3,title:"1.7 分层结构",slug:"_1-7-分层结构",normalizedTitle:"1.7 分层结构",charIndex:2044},{level:4,title:"1.7.1 分层的基本原则",slug:"_1-7-1-分层的基本原则",normalizedTitle:"1.7.1 分层的基本原则",charIndex:2056},{level:4,title:"1.7.2 分层中的概念",slug:"_1-7-2-分层中的概念",normalizedTitle:"1.7.2 分层中的概念",charIndex:2252},{level:3,title:"1.8 计算机网络分层结构",slug:"_1-8-计算机网络分层结构",normalizedTitle:"1.8 计算机网络分层结构",charIndex:2574},{level:4,title:"1.8.1 OSI参考模型",slug:"_1-8-1-osi参考模型",normalizedTitle:"1.8.1 osi参考模型",charIndex:2591},{level:5,title:"应用层",slug:"应用层",normalizedTitle:"应用层",charIndex:2671},{level:5,title:"表示层",slug:"表示层",normalizedTitle:"表示层",charIndex:2667},{level:5,title:"会话层",slug:"会话层",normalizedTitle:"会话层",charIndex:2663},{level:5,title:"传输层",slug:"传输层",normalizedTitle:"传输层",charIndex:2659},{level:5,title:"网络层",slug:"网络层",normalizedTitle:"网络层",charIndex:2655},{level:5,title:"数据链路层",slug:"数据链路层",normalizedTitle:"数据链路层",charIndex:2649},{level:5,title:"物理层",slug:"物理层",normalizedTitle:"物理层",charIndex:2645},{level:4,title:"1.8.2 TCP/IP参考模型",slug:"_1-8-2-tcp-ip参考模型",normalizedTitle:"1.8.2 tcp/ip参考模型",charIndex:3490},{level:5,title:"网络接口层",slug:"网络接口层",normalizedTitle:"网络接口层",charIndex:3519},{level:5,title:"网际层",slug:"网际层",normalizedTitle:"网际层",charIndex:3542},{level:5,title:"传输层",slug:"传输层-2",normalizedTitle:"传输层",charIndex:2659},{level:5,title:"应用层",slug:"应用层-2",normalizedTitle:"应用层",charIndex:2671},{level:5,title:"与OSI的异同",slug:"与osi的异同",normalizedTitle:"与osi的异同",charIndex:3605},{level:4,title:"1.8.3 5层参考模型",slug:"_1-8-3-5层参考模型",normalizedTitle:"1.8.3 5层参考模型",charIndex:3827},{level:5,title:"应用层",slug:"应用层-3",normalizedTitle:"应用层",charIndex:2671},{level:5,title:"传输层",slug:"传输层-3",normalizedTitle:"传输层",charIndex:2659},{level:5,title:"网路层",slug:"网路层",normalizedTitle:"网路层",charIndex:2696},{level:5,title:"数据链路层",slug:"数据链路层-2",normalizedTitle:"数据链路层",charIndex:2649},{level:5,title:"物理层",slug:"物理层-2",normalizedTitle:"物理层",charIndex:2645},{level:2,title:"2 物理层",slug:"_2-物理层",normalizedTitle:"2 物理层",charIndex:3964},{level:3,title:"2.1 物理层基本概念",slug:"_2-1-物理层基本概念",normalizedTitle:"2.1 物理层基本概念",charIndex:4024},{level:3,title:"2.2 数据通信基础知识",slug:"_2-2-数据通信基础知识",normalizedTitle:"2.2 数据通信基础知识",charIndex:4249},{level:3,title:"2.3 码元",slug:"_2-3-码元",normalizedTitle:"2.3 码元",charIndex:4529},{level:3,title:"2.4 速率、波特、带宽",slug:"_2-4-速率、波特、带宽",normalizedTitle:"2.4 速率、波特、带宽",charIndex:4651},{level:3,title:"2.5 奈氏准则和香农定理",slug:"_2-5-奈氏准则和香农定理",normalizedTitle:"2.5 奈氏准则和香农定理",charIndex:4930},{level:3,title:"2.6 编码与调制",slug:"_2-6-编码与调制",normalizedTitle:"2.6 编码与调制",charIndex:5129},{level:4,title:"2.6.1 系带信号与宽带信号",slug:"_2-6-1-系带信号与宽带信号",normalizedTitle:"2.6.1 系带信号与宽带信号",charIndex:5142},{level:4,title:"2.6.2 编码",slug:"_2-6-2-编码",normalizedTitle:"2.6.2 编码",charIndex:5252},{level:5,title:"数字数据编码为数字信号",slug:"数字数据编码为数字信号",normalizedTitle:"数字数据编码为数字信号",charIndex:5274},{level:5,title:"模拟数据编码为数字信号",slug:"模拟数据编码为数字信号",normalizedTitle:"模拟数据编码为数字信号",charIndex:5329},{level:4,title:"2.6.3 调制",slug:"_2-6-3-调制",normalizedTitle:"2.6.3 调制",charIndex:5362},{level:5,title:"数字数据调制为模拟信号",slug:"数字数据调制为模拟信号",normalizedTitle:"数字数据调制为模拟信号",charIndex:5384},{level:5,title:"模拟数据调制为模拟信号",slug:"模拟数据调制为模拟信号",normalizedTitle:"模拟数据调制为模拟信号",charIndex:5451},{level:3,title:"2.7 物理层传输介质",slug:"_2-7-物理层传输介质",normalizedTitle:"2.7 物理层传输介质",charIndex:5467},{level:4,title:"2.7.1 导向性传输介质",slug:"_2-7-1-导向性传输介质",normalizedTitle:"2.7.1 导向性传输介质",charIndex:5525},{level:4,title:"2.7.2 非导向性传输介质",slug:"_2-7-2-非导向性传输介质",normalizedTitle:"2.7.2 非导向性传输介质",charIndex:5584},{level:3,title:"2.8 物理层设备",slug:"_2-8-物理层设备",normalizedTitle:"2.8 物理层设备",charIndex:5631},{level:4,title:"2.8.1 中继器",slug:"_2-8-1-中继器",normalizedTitle:"2.8.1 中继器",charIndex:5644},{level:4,title:"2.8.2 集线器（多口中继器）",slug:"_2-8-2-集线器-多口中继器",normalizedTitle:"2.8.2 集线器（多口中继器）",charIndex:5710},{level:2,title:"3 数据链路层",slug:"_3-数据链路层",normalizedTitle:"3 数据链路层",charIndex:5772},{level:3,title:"3.1 数据链路层概述",slug:"_3-1-数据链路层概述",normalizedTitle:"3.1 数据链路层概述",charIndex:5832},{level:4,title:"3.1.1 数据链路层基本概念",slug:"_3-1-1-数据链路层基本概念",normalizedTitle:"3.1.1 数据链路层基本概念",charIndex:5847},{level:4,title:"3.1.2 数据链路层功能概述",slug:"_3-1-2-数据链路层功能概述",normalizedTitle:"3.1.2 数据链路层功能概述",charIndex:6060},{level:3,title:"3.2 封装成帧",slug:"_3-2-封装成帧",normalizedTitle:"3.2 封装成帧",charIndex:6323},{level:4,title:"3.2.1 字符技术法",slug:"_3-2-1-字符技术法",normalizedTitle:"3.2.1 字符技术法",charIndex:6628},{level:4,title:"3.2.2 字符填充法",slug:"_3-2-2-字符填充法",normalizedTitle:"3.2.2 字符填充法",charIndex:6692},{level:4,title:"3.2.3 零比特填充法",slug:"_3-2-3-零比特填充法",normalizedTitle:"3.2.3 零比特填充法",charIndex:6738},{level:4,title:"3.2.4 违规编码法",slug:"_3-2-4-违规编码法",normalizedTitle:"3.2.4 违规编码法",charIndex:6856},{level:3,title:"3.3 差错控制",slug:"_3-3-差错控制",normalizedTitle:"3.3 差错控制",charIndex:6899},{level:4,title:"3.3.1 差错",slug:"_3-3-1-差错",normalizedTitle:"3.3.1 差错",charIndex:6911},{level:5,title:"差错的来源",slug:"差错的来源",normalizedTitle:"差错的来源",charIndex:6923},{level:5,title:"差错的分类",slug:"差错的分类",normalizedTitle:"差错的分类",charIndex:7079},{level:4,title:"3.3.2 检错编码",slug:"_3-3-2-检错编码",normalizedTitle:"3.3.2 检错编码",charIndex:7131},{level:5,title:"奇偶校验码",slug:"奇偶校验码",normalizedTitle:"奇偶校验码",charIndex:7145},{level:5,title:"CRC循环冗余码",slug:"crc循环冗余码",normalizedTitle:"crc循环冗余码",charIndex:7233},{level:4,title:"3.3.3 纠错编码",slug:"_3-3-3-纠错编码",normalizedTitle:"3.3.3 纠错编码",charIndex:7344},{level:5,title:"海明码工作流程",slug:"海明码工作流程",normalizedTitle:"海明码工作流程",charIndex:7403},{level:3,title:"3.4 流量控制与可靠传输",slug:"_3-4-流量控制与可靠传输",normalizedTitle:"3.4 流量控制与可靠传输",charIndex:7649},{level:4,title:"3.4.1 停止——等待协议",slug:"_3-4-1-停止-等待协议",normalizedTitle:"3.4.1 停止——等待协议",charIndex:7808},{level:5,title:"停止——等待协议关键点",slug:"停止-等待协议关键点",normalizedTitle:"停止——等待协议关键点",charIndex:7987},{level:5,title:"停止——等待协议性能",slug:"停止-等待协议性能",normalizedTitle:"停止——等待协议性能",charIndex:8149},{level:4,title:"3.4.2 滑动窗口协议",slug:"_3-4-2-滑动窗口协议",normalizedTitle:"3.4.2 滑动窗口协议",charIndex:8183},{level:5,title:"后退N帧协议（GBN）",slug:"后退n帧协议-gbn",normalizedTitle:"后退n帧协议（gbn）",charIndex:8257},{level:6,title:"GBN发送方响应",slug:"gbn发送方响应",normalizedTitle:"gbn发送方响应",charIndex:8368},{level:6,title:"GBN接收方响应",slug:"gbn接收方响应",normalizedTitle:"gbn接收方响应",charIndex:8483},{level:6,title:"GBN性能",slug:"gbn性能",normalizedTitle:"gbn性能",charIndex:8565},{level:5,title:"选择重传协议（SR）",slug:"选择重传协议-sr",normalizedTitle:"选择重传协议（sr）",charIndex:8628},{level:6,title:"SR发送方响应",slug:"sr发送方响应",normalizedTitle:"sr发送方响应",charIndex:8825},{level:6,title:"SR接收方响应",slug:"sr接收方响应",normalizedTitle:"sr接收方响应",charIndex:8957},{level:6,title:"SR重点",slug:"sr重点",normalizedTitle:"sr重点",charIndex:9104},{level:3,title:"3.5 可靠传输、滑动窗口、流量控制",slug:"_3-5-可靠传输、滑动窗口、流量控制",normalizedTitle:"3.5 可靠传输、滑动窗口、流量控制",charIndex:9158},{level:3,title:"3.6 介质访问控制（MAC协议）",slug:"_3-6-介质访问控制-mac协议",normalizedTitle:"3.6 介质访问控制（mac协议）",charIndex:9292},{level:4,title:"3.6.1 静态划分信道",slug:"_3-6-1-静态划分信道",normalizedTitle:"3.6.1 静态划分信道",charIndex:9445},{level:5,title:"频分多路复用FDM",slug:"频分多路复用fdm",normalizedTitle:"频分多路复用fdm",charIndex:9584},{level:5,title:"时分多路复用TDM",slug:"时分多路复用tdm",normalizedTitle:"时分多路复用tdm",charIndex:9718},{level:5,title:"波分多路复用WDM",slug:"波分多路复用wdm",normalizedTitle:"波分多路复用wdm",charIndex:9957},{level:5,title:"码分多路复用CDM",slug:"码分多路复用cdm",normalizedTitle:"码分多路复用cdm",charIndex:10058},{level:4,title:"3.6.2 动态分配信道",slug:"_3-6-2-动态分配信道",normalizedTitle:"3.6.2 动态分配信道",charIndex:10247},{level:5,title:"轮询访问介质访问控制",slug:"轮询访问介质访问控制",normalizedTitle:"轮询访问介质访问控制",charIndex:10289},{level:6,title:"轮询协议",slug:"轮询协议",normalizedTitle:"轮询协议",charIndex:10322},{level:6,title:"令牌传递协议",slug:"令牌传递协议",normalizedTitle:"令牌传递协议",charIndex:10394},{level:5,title:"随机访问介质访问控制",slug:"随机访问介质访问控制",normalizedTitle:"随机访问介质访问控制",charIndex:10565},{level:6,title:"ALOHA协议",slug:"aloha协议",normalizedTitle:"aloha协议",charIndex:10611},{level:6,title:"CSMA协议",slug:"csma协议",normalizedTitle:"csma协议",charIndex:10890},{level:6,title:"CSMA/CD协议",slug:"csma-cd协议",normalizedTitle:"csma/cd协议",charIndex:11667},{level:6,title:"CSMA/CA协议",slug:"csma-ca协议",normalizedTitle:"csma/ca协议",charIndex:12120},{level:3,title:"3.7 局域网",slug:"_3-7-局域网",normalizedTitle:"3.7 局域网",charIndex:12443},{level:4,title:"3.7.1 基本概念",slug:"_3-7-1-基本概念",normalizedTitle:"3.7.1 基本概念",charIndex:12454},{level:5,title:"局域网拓扑结构",slug:"局域网拓扑结构",normalizedTitle:"局域网拓扑结构",charIndex:12693},{level:5,title:"局域网传输介质",slug:"局域网传输介质",normalizedTitle:"局域网传输介质",charIndex:12873},{level:5,title:"介质访问控制方法",slug:"介质访问控制方法",normalizedTitle:"介质访问控制方法",charIndex:12681},{level:5,title:"局域网分类",slug:"局域网分类",normalizedTitle:"局域网分类",charIndex:13051},{level:5,title:"IEEE 802标准",slug:"ieee-802标准",normalizedTitle:"ieee 802标准",charIndex:13226},{level:5,title:"MAC子层和LLC子层",slug:"mac子层和llc子层",normalizedTitle:"mac子层和llc子层",charIndex:13322},{level:4,title:"3.7.2 以太网",slug:"_3-7-2-以太网",normalizedTitle:"3.7.2 以太网",charIndex:13548},{level:5,title:"以太网提供的服务",slug:"以太网提供的服务",normalizedTitle:"以太网提供的服务",charIndex:13730},{level:5,title:"传输介质与拓扑结构",slug:"传输介质与拓扑结构",normalizedTitle:"传输介质与拓扑结构",charIndex:13855},{level:5,title:"10BASE-T以太网",slug:"_10base-t以太网",normalizedTitle:"10base-t以太网",charIndex:13948},{level:5,title:"适配器与MAC地址",slug:"适配器与mac地址",normalizedTitle:"适配器与mac地址",charIndex:14091},{level:5,title:"以太网MAC帧",slug:"以太网mac帧",normalizedTitle:"以太网mac帧",charIndex:14156},{level:5,title:"高速以太网",slug:"高速以太网",normalizedTitle:"高速以太网",charIndex:14253},{level:4,title:"3.7.3 无限局域网",slug:"_3-7-3-无限局域网",normalizedTitle:"3.7.3 无限局域网",charIndex:14390},{level:5,title:"IEEE 802.11",slug:"ieee-802-11",normalizedTitle:"ieee 802.11",charIndex:13209},{level:5,title:"无线局网分类",slug:"无线局网分类",normalizedTitle:"无线局网分类",charIndex:14532},{level:3,title:"3.8 广域网协议",slug:"_3-8-广域网协议",normalizedTitle:"3.8 广域网协议",charIndex:14578},{level:4,title:"3.8.1 PPP协议",slug:"_3-8-1-ppp协议",normalizedTitle:"3.8.1 ppp协议",charIndex:14642},{level:5,title:"PPP协议要求",slug:"ppp协议要求",normalizedTitle:"ppp协议要求",charIndex:14718},{level:5,title:"PPP协议无需满足要求",slug:"ppp协议无需满足要求",normalizedTitle:"ppp协议无需满足要求",charIndex:14915},{level:5,title:"PPP协议功能",slug:"ppp协议功能",normalizedTitle:"ppp协议功能",charIndex:14966},{level:5,title:"PPP协议的状态图",slug:"ppp协议的状态图",normalizedTitle:"ppp协议的状态图",charIndex:15089},{level:5,title:"PPP协议的帧格式",slug:"ppp协议的帧格式",normalizedTitle:"ppp协议的帧格式",charIndex:15104},{level:4,title:"3.8.2 HDLC协议",slug:"_3-8-2-hdlc协议",normalizedTitle:"3.8.2 hdlc协议",charIndex:15156},{level:5,title:"HDLC站",slug:"hdlc站",normalizedTitle:"hdlc站",charIndex:15273},{level:5,title:"HDLC帧格式",slug:"hdlc帧格式",normalizedTitle:"hdlc帧格式",charIndex:15407},{level:4,title:"3.8.3 PPP与HDLC比较",slug:"_3-8-3-ppp与hdlc比较",normalizedTitle:"3.8.3 ppp与hdlc比较",charIndex:15449},{level:5,title:"相同点",slug:"相同点",normalizedTitle:"相同点",charIndex:3614},{level:5,title:"不同点",slug:"不同点",normalizedTitle:"不同点",charIndex:3659},{level:3,title:"3.9 链路层设备",slug:"_3-9-链路层设备",normalizedTitle:"3.9 链路层设备",charIndex:15642},{level:4,title:"3.9.1 物理层扩展以太网",slug:"_3-9-1-物理层扩展以太网",normalizedTitle:"3.9.1 物理层扩展以太网",charIndex:15655},{level:4,title:"3.9.2 链路层扩展以太网",slug:"_3-9-2-链路层扩展以太网",normalizedTitle:"3.9.2 链路层扩展以太网",charIndex:15705},{level:5,title:"网桥",slug:"网桥",normalizedTitle:"网桥",charIndex:15723},{level:5,title:"以太网交换机",slug:"以太网交换机",normalizedTitle:"以太网交换机",charIndex:15966},{level:2,title:"4 网络层",slug:"_4-网络层",normalizedTitle:"4 网络层",charIndex:16115},{level:3,title:"4.1 网络层概述",slug:"_4-1-网络层概述",normalizedTitle:"4.1 网络层概述",charIndex:16125},{level:4,title:"4.1.1 网络层功能",slug:"_4-1-1-网络层功能",normalizedTitle:"4.1.1 网络层功能",charIndex:16138},{level:4,title:"4.1.2 数据交换方式",slug:"_4-1-2-数据交换方式",normalizedTitle:"4.1.2 数据交换方式",charIndex:16312},{level:5,title:"电路交换",slug:"电路交换",normalizedTitle:"电路交换",charIndex:763},{level:5,title:"报文交换",slug:"报文交换",normalizedTitle:"报文交换",charIndex:772},{level:5,title:"分组交换",slug:"分组交换",normalizedTitle:"分组交换",charIndex:781},{level:6,title:"数据报方式",slug:"数据报方式",normalizedTitle:"数据报方式",charIndex:16833},{level:6,title:"虚电路方式",slug:"虚电路方式",normalizedTitle:"虚电路方式",charIndex:16988},{level:4,title:"4.1.3 传输单元名词",slug:"_4-1-3-传输单元名词",normalizedTitle:"4.1.3 传输单元名词",charIndex:17328},{level:3,title:"4.2 IP数据报",slug:"_4-2-ip数据报",normalizedTitle:"4.2 ip数据报",charIndex:17493},{level:4,title:"4.2.1 IP数据报格式",slug:"_4-2-1-ip数据报格式",normalizedTitle:"4.2.1 ip数据报格式",charIndex:17506},{level:4,title:"4.2.2 IP数据报分片",slug:"_4-2-2-ip数据报分片",normalizedTitle:"4.2.2 ip数据报分片",charIndex:18107},{level:3,title:"4.3 IP地址",slug:"_4-3-ip地址",normalizedTitle:"4.3 ip地址",charIndex:18208},{level:4,title:"4.3.1 分类的IP地址",slug:"_4-3-1-分类的ip地址",normalizedTitle:"4.3.1 分类的ip地址",charIndex:18302},{level:5,title:"特殊IP地址",slug:"特殊ip地址",normalizedTitle:"特殊ip地址",charIndex:18417},{level:5,title:"私有IP地址",slug:"私有ip地址",normalizedTitle:"私有ip地址",charIndex:18429},{level:5,title:"分来IP地址弱点",slug:"分来ip地址弱点",normalizedTitle:"分来ip地址弱点",charIndex:18567},{level:4,title:"4.3.2 NAT网络地址转换",slug:"_4-3-2-nat网络地址转换",normalizedTitle:"4.3.2 nat网络地址转换",charIndex:18612},{level:4,title:"4.3.3 子网划分",slug:"_4-3-3-子网划分",normalizedTitle:"4.3.3 子网划分",charIndex:18748},{level:4,title:"4.3.4 无分类编制CIDR",slug:"_4-3-4-无分类编制cidr",normalizedTitle:"4.3.4 无分类编制cidr",charIndex:19041},{level:5,title:"构成超网",slug:"构成超网",normalizedTitle:"构成超网",charIndex:19235},{level:3,title:"4.4 IP相关协议",slug:"_4-4-ip相关协议",normalizedTitle:"4.4 ip相关协议",charIndex:19328},{level:4,title:"4.4.1 ARP协议",slug:"_4-4-1-arp协议",normalizedTitle:"4.4.1 arp协议",charIndex:19342},{level:5,title:"ARP协议使用过程",slug:"arp协议使用过程",normalizedTitle:"arp协议使用过程",charIndex:19403},{level:5,title:"ARP协议特点",slug:"arp协议特点",normalizedTitle:"arp协议特点",charIndex:19593},{level:5,title:"ARP协议典型情况",slug:"arp协议典型情况",normalizedTitle:"arp协议典型情况",charIndex:19694},{level:4,title:"4.4.2 DHCP协议",slug:"_4-4-2-dhcp协议",normalizedTitle:"4.4.2 dhcp协议",charIndex:19861},{level:5,title:"DHCP工作流程",slug:"dhcp工作流程",normalizedTitle:"dhcp工作流程",charIndex:20016},{level:4,title:"4.4.3 ICMP协议",slug:"_4-4-3-icmp协议",normalizedTitle:"4.4.3 icmp协议",charIndex:20189},{level:5,title:"ICMP差错报告报文",slug:"icmp差错报告报文",normalizedTitle:"icmp差错报告报文",charIndex:20300},{level:6,title:"不发送情况",slug:"不发送情况",normalizedTitle:"不发送情况",charIndex:20405},{level:5,title:"ICMP询问报文",slug:"icmp询问报文",normalizedTitle:"icmp询问报文",charIndex:20484},{level:5,title:"ICMP应用",slug:"icmp应用",normalizedTitle:"icmp应用",charIndex:20575},{level:3,title:"4.5 IPv6",slug:"_4-5-ipv6",normalizedTitle:"4.5 ipv6",charIndex:20672},{level:4,title:"4.5.1 产生原因",slug:"_4-5-1-产生原因",normalizedTitle:"4.5.1 产生原因",charIndex:20684},{level:4,title:"4.5.2 IPv6数据报格式",slug:"_4-5-2-ipv6数据报格式",normalizedTitle:"4.5.2 ipv6数据报格式",charIndex:20787},{level:5,title:"基本首部",slug:"基本首部",normalizedTitle:"基本首部",charIndex:20806},{level:5,title:"有效载荷",slug:"有效载荷",normalizedTitle:"有效载荷",charIndex:20901},{level:4,title:"4.5.3 与IPv4的区别",slug:"_4-5-3-与ipv4的区别",normalizedTitle:"4.5.3 与ipv4的区别",charIndex:21060},{level:4,title:"4.5.4 IPv6地址表示形式",slug:"_4-5-4-ipv6地址表示形式",normalizedTitle:"4.5.4 ipv6地址表示形式",charIndex:21478},{level:4,title:"4.5.5 IPv6基本地址类型",slug:"_4-5-5-ipv6基本地址类型",normalizedTitle:"4.5.5 ipv6基本地址类型",charIndex:21582},{level:4,title:"4.5.6 IPv6项IPv4过渡策略",slug:"_4-5-6-ipv6项ipv4过渡策略",normalizedTitle:"4.5.6 ipv6项ipv4过渡策略",charIndex:21675},{level:5,title:"双栈协议",slug:"双栈协议",normalizedTitle:"双栈协议",charIndex:21698},{level:5,title:"隧道技术",slug:"隧道技术",normalizedTitle:"隧道技术",charIndex:21813},{level:3,title:"4.6 路由协议",slug:"_4-6-路由协议",normalizedTitle:"4.6 路由协议",charIndex:21851},{level:4,title:"4.6.1 路由算法与路由协议概述",slug:"_4-6-1-路由算法与路由协议概述",normalizedTitle:"4.6.1 路由算法与路由协议概述",charIndex:21863},{level:5,title:"路由算法",slug:"路由算法",normalizedTitle:"路由算法",charIndex:21869},{level:6,title:"路由算法分类",slug:"路由算法分类",normalizedTitle:"路由算法分类",charIndex:21933},{level:5,title:"路由协议",slug:"路由协议",normalizedTitle:"路由协议",charIndex:16957},{level:4,title:"4.6.2 RIP协议",slug:"_4-6-2-rip协议",normalizedTitle:"4.6.2 rip协议",charIndex:22451},{level:5,title:"距离向量算法",slug:"距离向量算法",normalizedTitle:"距离向量算法",charIndex:22797},{level:5,title:"RIP报文",slug:"rip报文",normalizedTitle:"rip报文",charIndex:22819},{level:5,title:"RIP协议特点",slug:"rip协议特点",normalizedTitle:"rip协议特点",charIndex:23075},{level:4,title:"4.6.3 OSPF协议",slug:"_4-6-3-ospf协议",normalizedTitle:"4.6.3 ospf协议",charIndex:23129},{level:5,title:"OSPF协议特点",slug:"ospf协议特点",normalizedTitle:"ospf协议特点",charIndex:23228},{level:5,title:"链路状态路由算法",slug:"链路状态路由算法",normalizedTitle:"链路状态路由算法",charIndex:22154},{level:5,title:"OSPF区域",slug:"ospf区域",normalizedTitle:"ospf区域",charIndex:23736},{level:5,title:"OSPF分组",slug:"ospf分组",normalizedTitle:"ospf分组",charIndex:23859},{level:4,title:"4.6.4 BGP协议",slug:"_4-6-4-bgp协议",normalizedTitle:"4.6.4 bgp协议",charIndex:23882},{level:5,title:"BGP协议特点",slug:"bgp协议特点",normalizedTitle:"bgp协议特点",charIndex:23920},{level:5,title:"BGP协议交换信息的过程",slug:"bgp协议交换信息的过程",normalizedTitle:"bgp协议交换信息的过程",charIndex:24065},{level:5,title:"BGP协议报文格式",slug:"bgp协议报文格式",normalizedTitle:"bgp协议报文格式",charIndex:24177},{level:5,title:"BGP-4报文",slug:"bgp-4报文",normalizedTitle:"bgp-4报文",charIndex:24264},{level:3,title:"4.7 IP组播（多播）",slug:"_4-7-ip组播-多播",normalizedTitle:"4.7 ip组播（多播）",charIndex:24435},{level:4,title:"4.7.1 IP数据报的三种传输方式",slug:"_4-7-1-ip数据报的三种传输方式",normalizedTitle:"4.7.1 ip数据报的三种传输方式",charIndex:24451},{level:4,title:"4.7.2 IP组播地址",slug:"_4-7-2-ip组播地址",normalizedTitle:"4.7.2 ip组播地址",charIndex:24690},{level:4,title:"4.7.3 硬件组播",slug:"_4-7-3-硬件组播",normalizedTitle:"4.7.3 硬件组播",charIndex:24917},{level:4,title:"4.7.4 IGMP协议",slug:"_4-7-4-igmp协议",normalizedTitle:"4.7.4 igmp协议",charIndex:24952},{level:5,title:"IGMP工作的两个阶段",slug:"igmp工作的两个阶段",normalizedTitle:"igmp工作的两个阶段",charIndex:25018},{level:4,title:"4.7.5 组播路由选择协议",slug:"_4-7-5-组播路由选择协议",normalizedTitle:"4.7.5 组播路由选择协议",charIndex:25284},{level:3,title:"4.8 移动IP",slug:"_4-8-移动ip",normalizedTitle:"4.8 移动ip",charIndex:25389},{level:4,title:"4.8.1 相关术语",slug:"_4-8-1-相关术语",normalizedTitle:"4.8.1 相关术语",charIndex:25401},{level:4,title:"4.8.2 通信过程",slug:"_4-8-2-通信过程",normalizedTitle:"4.8.2 通信过程",charIndex:25682},{level:5,title:"计算机A刚进入外部网络",slug:"计算机a刚进入外部网络",normalizedTitle:"计算机a刚进入外部网络",charIndex:25696},{level:5,title:"计算机B向A发送数据报",slug:"计算机b向a发送数据报",normalizedTitle:"计算机b向a发送数据报",charIndex:25758},{level:5,title:"计算机A向B发送数据报",slug:"计算机a向b发送数据报",normalizedTitle:"计算机a向b发送数据报",charIndex:25847},{level:5,title:"计算机A移动到下一个网络",slug:"计算机a移动到下一个网络",normalizedTitle:"计算机a移动到下一个网络",charIndex:25898},{level:5,title:"计算机A回到归属网络",slug:"计算机a回到归属网络",normalizedTitle:"计算机a回到归属网络",charIndex:25979},{level:3,title:"4.9 网络层设备",slug:"_4-9-网络层设备",normalizedTitle:"4.9 网络层设备",charIndex:26012},{level:4,title:"4.9.1 路由器",slug:"_4-9-1-路由器",normalizedTitle:"4.9.1 路由器",charIndex:26025},{level:5,title:"输入端口对线路上收到的分组的处理",slug:"输入端口对线路上收到的分组的处理",normalizedTitle:"输入端口对线路上收到的分组的处理",charIndex:26174},{level:5,title:"输出端口对线路上收到的分组的处理",slug:"输出端口对线路上收到的分组的处理",normalizedTitle:"输出端口对线路上收到的分组的处理",charIndex:26292},{level:4,title:"4.9.2 路由表与路由转发",slug:"_4-9-2-路由表与路由转发",normalizedTitle:"4.9.2 路由表与路由转发",charIndex:26427},{level:2,title:"5 传输层",slug:"_5-传输层",normalizedTitle:"5 传输层",charIndex:26517},{level:3,title:"5.1 功能",slug:"_5-1-功能",normalizedTitle:"5.1 功能",charIndex:26566},{level:3,title:"5.2 协议",slug:"_5-2-协议",normalizedTitle:"5.2 协议",charIndex:26635},{level:3,title:"5.3 寻址与端口",slug:"_5-3-寻址与端口",normalizedTitle:"5.3 寻址与端口",charIndex:26725},{level:4,title:"5.3.1 软件端口",slug:"_5-3-1-软件端口",normalizedTitle:"5.3.1 软件端口",charIndex:26801},{level:3,title:"5.4 UDP",slug:"_5-4-udp",normalizedTitle:"5.4 udp",charIndex:27085},{level:4,title:"5.4.1 特点",slug:"_5-4-1-特点",normalizedTitle:"5.4.1 特点",charIndex:27130},{level:4,title:"5.4.2 首部格式",slug:"_5-4-2-首部格式",normalizedTitle:"5.4.2 首部格式",charIndex:27268},{level:4,title:"5.4.3 UDP校验",slug:"_5-4-3-udp校验",normalizedTitle:"5.4.3 udp校验",charIndex:27319},{level:5,title:"发送端",slug:"发送端",normalizedTitle:"发送端",charIndex:6706},{level:4,title:"接收端",slug:"接收端",normalizedTitle:"接收端",charIndex:5021},{level:3,title:"5.5 TCP",slug:"_5-5-tcp",normalizedTitle:"5.5 tcp",charIndex:27525},{level:4,title:"5.5.1 特点",slug:"_5-5-1-特点",normalizedTitle:"5.5.1 特点",charIndex:27536},{level:4,title:"5.5.2 TCP报文段首部格式",slug:"_5-5-2-tcp报文段首部格式",normalizedTitle:"5.5.2 tcp报文段首部格式",charIndex:27817},{level:4,title:"5.5.3 TCP连接管理",slug:"_5-5-3-tcp连接管理",normalizedTitle:"5.5.3 tcp连接管理",charIndex:28570},{level:5,title:"TCP连接建立——三次握手",slug:"tcp连接建立-三次握手",normalizedTitle:"tcp连接建立——三次握手",charIndex:28672},{level:5,title:"TCP连接释放——四次握手",slug:"tcp连接释放-四次握手",normalizedTitle:"tcp连接释放——四次握手",charIndex:28958},{level:4,title:"5.5.4 TCP可靠传输",slug:"_5-5-4-tcp可靠传输",normalizedTitle:"5.5.4 tcp可靠传输",charIndex:29335},{level:5,title:"校验",slug:"校验",normalizedTitle:"校验",charIndex:2960},{level:5,title:"序号",slug:"序号",normalizedTitle:"序号",charIndex:8223},{level:5,title:"确认",slug:"确认",normalizedTitle:"确认",charIndex:1891},{level:5,title:"重传",slug:"重传",normalizedTitle:"重传",charIndex:8040},{level:4,title:"5.5.5 TCP流量控制",slug:"_5-5-5-tcp流量控制",normalizedTitle:"5.5.5 tcp流量控制",charIndex:29691},{level:4,title:"5.5.6 TCP拥塞控制",slug:"_5-5-6-tcp拥塞控制",normalizedTitle:"5.5.6 tcp拥塞控制",charIndex:29986},{level:5,title:"假定",slug:"假定",normalizedTitle:"假定",charIndex:30109},{level:5,title:"慢开始和拥塞避免算法",slug:"慢开始和拥塞避免算法",normalizedTitle:"慢开始和拥塞避免算法",charIndex:30176},{level:5,title:"快重传和快恢复",slug:"快重传和快恢复",normalizedTitle:"快重传和快恢复",charIndex:30286},{level:2,title:"6 应用层",slug:"_6-应用层",normalizedTitle:"6 应用层",charIndex:30300},{level:3,title:"6.1 概述",slug:"_6-1-概述",normalizedTitle:"6.1 概述",charIndex:30310},{level:3,title:"6.2 网络应用模型",slug:"_6-2-网络应用模型",normalizedTitle:"6.2 网络应用模型",charIndex:30560},{level:4,title:"6.2.1 客户/服务器模型",slug:"_6-2-1-客户-服务器模型",normalizedTitle:"6.2.1 客户/服务器模型",charIndex:30574},{level:4,title:"6.2.2 P2P模型",slug:"_6-2-2-p2p模型",normalizedTitle:"6.2.2 p2p模型",charIndex:30760},{level:3,title:"6.3 域名解析系统DNS",slug:"_6-3-域名解析系统dns",normalizedTitle:"6.3 域名解析系统dns",charIndex:30888},{level:4,title:"6.3.1 域名",slug:"_6-3-1-域名",normalizedTitle:"6.3.1 域名",charIndex:30905},{level:4,title:"6.3.2 域名服务器",slug:"_6-3-2-域名服务器",normalizedTitle:"6.3.2 域名服务器",charIndex:31154},{level:5,title:"根域名服务器",slug:"根域名服务器",normalizedTitle:"根域名服务器",charIndex:31169},{level:5,title:"顶级域名服务器",slug:"顶级域名服务器",normalizedTitle:"顶级域名服务器",charIndex:31207},{level:5,title:"权限域名服务器",slug:"权限域名服务器",normalizedTitle:"权限域名服务器",charIndex:31289},{level:5,title:"本地域名服务器",slug:"本地域名服务器",normalizedTitle:"本地域名服务器",charIndex:31324},{level:4,title:"6.3.3 域名解析过程",slug:"_6-3-3-域名解析过程",normalizedTitle:"6.3.3 域名解析过程",charIndex:31392},{level:5,title:"递归查询",slug:"递归查询",normalizedTitle:"递归查询",charIndex:31408},{level:5,title:"迭代查询",slug:"迭代查询",normalizedTitle:"迭代查询",charIndex:31416},{level:3,title:"6.4 文件传输协议FTP",slug:"_6-4-文件传输协议ftp",normalizedTitle:"6.4 文件传输协议ftp",charIndex:31425},{level:4,title:"6.4.1 FTP服务器和用户端",slug:"_6-4-1-ftp服务器和用户端",normalizedTitle:"6.4.1 ftp服务器和用户端",charIndex:31481},{level:4,title:"6.4.2 FTP工作原理",slug:"_6-4-2-ftp工作原理",normalizedTitle:"6.4.2 ftp工作原理",charIndex:31627},{level:5,title:"登录",slug:"登录",normalizedTitle:"登录",charIndex:30493},{level:5,title:"数据传输",slug:"数据传输",normalizedTitle:"数据传输",charIndex:1216},{level:5,title:"传输模式",slug:"传输模式",normalizedTitle:"传输模式",charIndex:3437},{level:3,title:"6.5 电子邮件",slug:"_6-5-电子邮件",normalizedTitle:"6.5 电子邮件",charIndex:31963},{level:4,title:"6.5.1 电子邮件系统概述",slug:"_6-5-1-电子邮件系统概述",normalizedTitle:"6.5.1 电子邮件系统概述",charIndex:31975},{level:5,title:"电子邮件信息格式",slug:"电子邮件信息格式",normalizedTitle:"电子邮件信息格式",charIndex:31993},{level:5,title:"电子邮件系统组成结构",slug:"电子邮件系统组成结构",normalizedTitle:"电子邮件系统组成结构",charIndex:32090},{level:3,title:"6.6 万维网",slug:"_6-6-万维网",normalizedTitle:"6.6 万维网",charIndex:32259},{level:3,title:"6.7 超文本传输协议HTTP",slug:"_6-7-超文本传输协议http",normalizedTitle:"6.7 超文本传输协议http",charIndex:32578},{level:4,title:"6.7.1 HTTP协议过程",slug:"_6-7-1-http协议过程",normalizedTitle:"6.7.1 http协议过程",charIndex:32657},{level:4,title:"6.7.2 HTTP协议特点",slug:"_6-7-2-http协议特点",normalizedTitle:"6.7.2 http协议特点",charIndex:32856},{level:4,title:"6.7.3 HTTP协议报文结构",slug:"_6-7-3-http协议报文结构",normalizedTitle:"6.7.3 http协议报文结构",charIndex:33089}],headersStr:"1 概述 1.1 计算机网络概念 1.2 计算机网络功能 1.3 计算机网络的组成 1.3.1 组成部分 1.3.2 工作方式 1.3.3 功能组成 1.4 计算机网络的分类 1.4.1 按分布范围 1.4.2 按使用者 1.4.3 按交换技术 1.4.4 按拓扑结构 1.4.5 按传输技术 1.5 标准化工作 1.5.1 标准分类 1.5.2 RFC因特网标准形式 1.5.3 标准化相关组织 1.6 计算机网络性能 1.6.1 速率 1.6.2 带宽 1.6.3 吞吐量 1.6.4 时延 1.6.5 时延带宽积 1.6.6 往返时延RTT 1.6.7 利用率 1.7 分层结构 1.7.1 分层的基本原则 1.7.2 分层中的概念 1.8 计算机网络分层结构 1.8.1 OSI参考模型 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 1.8.2 TCP/IP参考模型 网络接口层 网际层 传输层 应用层 与OSI的异同 1.8.3 5层参考模型 应用层 传输层 网路层 数据链路层 物理层 2 物理层 2.1 物理层基本概念 2.2 数据通信基础知识 2.3 码元 2.4 速率、波特、带宽 2.5 奈氏准则和香农定理 2.6 编码与调制 2.6.1 系带信号与宽带信号 2.6.2 编码 数字数据编码为数字信号 模拟数据编码为数字信号 2.6.3 调制 数字数据调制为模拟信号 模拟数据调制为模拟信号 2.7 物理层传输介质 2.7.1 导向性传输介质 2.7.2 非导向性传输介质 2.8 物理层设备 2.8.1 中继器 2.8.2 集线器（多口中继器） 3 数据链路层 3.1 数据链路层概述 3.1.1 数据链路层基本概念 3.1.2 数据链路层功能概述 3.2 封装成帧 3.2.1 字符技术法 3.2.2 字符填充法 3.2.3 零比特填充法 3.2.4 违规编码法 3.3 差错控制 3.3.1 差错 差错的来源 差错的分类 3.3.2 检错编码 奇偶校验码 CRC循环冗余码 3.3.3 纠错编码 海明码工作流程 3.4 流量控制与可靠传输 3.4.1 停止——等待协议 停止——等待协议关键点 停止——等待协议性能 3.4.2 滑动窗口协议 后退N帧协议（GBN） GBN发送方响应 GBN接收方响应 GBN性能 选择重传协议（SR） SR发送方响应 SR接收方响应 SR重点 3.5 可靠传输、滑动窗口、流量控制 3.6 介质访问控制（MAC协议） 3.6.1 静态划分信道 频分多路复用FDM 时分多路复用TDM 波分多路复用WDM 码分多路复用CDM 3.6.2 动态分配信道 轮询访问介质访问控制 轮询协议 令牌传递协议 随机访问介质访问控制 ALOHA协议 CSMA协议 CSMA/CD协议 CSMA/CA协议 3.7 局域网 3.7.1 基本概念 局域网拓扑结构 局域网传输介质 介质访问控制方法 局域网分类 IEEE 802标准 MAC子层和LLC子层 3.7.2 以太网 以太网提供的服务 传输介质与拓扑结构 10BASE-T以太网 适配器与MAC地址 以太网MAC帧 高速以太网 3.7.3 无限局域网 IEEE 802.11 无线局网分类 3.8 广域网协议 3.8.1 PPP协议 PPP协议要求 PPP协议无需满足要求 PPP协议功能 PPP协议的状态图 PPP协议的帧格式 3.8.2 HDLC协议 HDLC站 HDLC帧格式 3.8.3 PPP与HDLC比较 相同点 不同点 3.9 链路层设备 3.9.1 物理层扩展以太网 3.9.2 链路层扩展以太网 网桥 以太网交换机 4 网络层 4.1 网络层概述 4.1.1 网络层功能 4.1.2 数据交换方式 电路交换 报文交换 分组交换 数据报方式 虚电路方式 4.1.3 传输单元名词 4.2 IP数据报 4.2.1 IP数据报格式 4.2.2 IP数据报分片 4.3 IP地址 4.3.1 分类的IP地址 特殊IP地址 私有IP地址 分来IP地址弱点 4.3.2 NAT网络地址转换 4.3.3 子网划分 4.3.4 无分类编制CIDR 构成超网 4.4 IP相关协议 4.4.1 ARP协议 ARP协议使用过程 ARP协议特点 ARP协议典型情况 4.4.2 DHCP协议 DHCP工作流程 4.4.3 ICMP协议 ICMP差错报告报文 不发送情况 ICMP询问报文 ICMP应用 4.5 IPv6 4.5.1 产生原因 4.5.2 IPv6数据报格式 基本首部 有效载荷 4.5.3 与IPv4的区别 4.5.4 IPv6地址表示形式 4.5.5 IPv6基本地址类型 4.5.6 IPv6项IPv4过渡策略 双栈协议 隧道技术 4.6 路由协议 4.6.1 路由算法与路由协议概述 路由算法 路由算法分类 路由协议 4.6.2 RIP协议 距离向量算法 RIP报文 RIP协议特点 4.6.3 OSPF协议 OSPF协议特点 链路状态路由算法 OSPF区域 OSPF分组 4.6.4 BGP协议 BGP协议特点 BGP协议交换信息的过程 BGP协议报文格式 BGP-4报文 4.7 IP组播（多播） 4.7.1 IP数据报的三种传输方式 4.7.2 IP组播地址 4.7.3 硬件组播 4.7.4 IGMP协议 IGMP工作的两个阶段 4.7.5 组播路由选择协议 4.8 移动IP 4.8.1 相关术语 4.8.2 通信过程 计算机A刚进入外部网络 计算机B向A发送数据报 计算机A向B发送数据报 计算机A移动到下一个网络 计算机A回到归属网络 4.9 网络层设备 4.9.1 路由器 输入端口对线路上收到的分组的处理 输出端口对线路上收到的分组的处理 4.9.2 路由表与路由转发 5 传输层 5.1 功能 5.2 协议 5.3 寻址与端口 5.3.1 软件端口 5.4 UDP 5.4.1 特点 5.4.2 首部格式 5.4.3 UDP校验 发送端 接收端 5.5 TCP 5.5.1 特点 5.5.2 TCP报文段首部格式 5.5.3 TCP连接管理 TCP连接建立——三次握手 TCP连接释放——四次握手 5.5.4 TCP可靠传输 校验 序号 确认 重传 5.5.5 TCP流量控制 5.5.6 TCP拥塞控制 假定 慢开始和拥塞避免算法 快重传和快恢复 6 应用层 6.1 概述 6.2 网络应用模型 6.2.1 客户/服务器模型 6.2.2 P2P模型 6.3 域名解析系统DNS 6.3.1 域名 6.3.2 域名服务器 根域名服务器 顶级域名服务器 权限域名服务器 本地域名服务器 6.3.3 域名解析过程 递归查询 迭代查询 6.4 文件传输协议FTP 6.4.1 FTP服务器和用户端 6.4.2 FTP工作原理 登录 数据传输 传输模式 6.5 电子邮件 6.5.1 电子邮件系统概述 电子邮件信息格式 电子邮件系统组成结构 6.6 万维网 6.7 超文本传输协议HTTP 6.7.1 HTTP协议过程 6.7.2 HTTP协议特点 6.7.3 HTTP协议报文结构",content:"网络体系结构（5层）、各层协议、典型网络、网络设备\n\n\n# 1 概述\n\n\n\n\n# 1.1 计算机网络概念\n\n网络包含计算机网络 计算机网络：一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统 计算机网络是互连的、自治的计算机集合 互连：互联互通，计算机相互之间连通，能通信；自治：计算机之间不存在主从关系，不能彼此控制对方\n\n\n# 1.2 计算机网络功能\n\n 1. 数据通信（最重要） 保证连通性\n 2. 资源共享（主要） 三大类：硬件资源共享；软件资源共享；数据资源共享\n 3. 分布式处理 多台计算机各自承担同一工作任务的不同部分 常见平台：Hadoop（大数据常用）\n 4. 提高可靠性 存在替代机，\n 5. 负载均衡 分布式处理达到的效果\n\n\n# 1.3 计算机网络的组成\n\n# 1.3.1 组成部分\n\n 1. 硬件：主机（端系统）、链路（例如光纤）、通信设备（路由器等）\n 2. 软件：安装在端系统上的应用软件\n 3. 协议（计算机网络的协议）：一系列规则和约定的集合\n\n# 1.3.2 工作方式\n\n 1. 边缘部分：主机存在的部分、用户直接使用的；两种通信方式（C/S；P2P）\n 2. 核心部分：为边缘部分服务\n\n# 1.3.3 功能组成\n\n 1. 通信子网：实现数据通信；各种传输介质、通信设备、相应网络协议组成\n 2. 资源子网：实现资源共享、数据处理；实现资源共享功能的设备和软件的集合\n\n\n# 1.4 计算机网络的分类\n\n# 1.4.1 按分布范围\n\n 1. 广域网：交换技术\n 2. 城域网\n 3. 局域网：广播技术\n 4. 个人区域网\n\n# 1.4.2 按使用者\n\n 1. 公用网\n 2. 专用网\n\n# 1.4.3 按交换技术\n\n 1. 电路交换\n 2. 报文交换\n 3. 分组交换\n\n# 1.4.4 按拓扑结构\n\n 1. 总线型\n 2. 星型\n 3. 环型\n 4. 网状型（常用于广域网）\n\n# 1.4.5 按传输技术\n\n 1. 广播式网络：共享公共通信信道\n 2. 点对点网络：使用分组存储转发和路由选择机制\n\n\n# 1.5 标准化工作\n\n# 1.5.1 标准分类\n\n 1. 法定标准：由权威机构指定的正式的、合法的标准（OSI）\n 2. 事实标准：产品长期占据主流，产品中的协议进而技术（TCP/IP）\n\n# 1.5.2 RFC因特网标准形式\n\n上升成为因特网正式标准的四个阶段\n\n 1. 因特网草案\n 2. 建议标准：正式成为RFC文档\n 3. 草案标准\n 4. 因特网标准\n\n# 1.5.3 标准化相关组织\n\n 1. ISO ：国际化标准组织\n 2. ITU：国际电信联盟\n 3. IEEE：国际电气电子工程师协会\n 4. IETF：Internet工程任务组\n\n\n# 1.6 计算机网络性能\n\n# 1.6.1 速率\n\n速率即数据率或数据传输率或比特率 比特：数据量的单位 速率：连接在计算机网络的主机在数字信道上传送数据位数的速率 速率单位的换算是10^3，但存储容量是2^10=1024 存储容量中1Byte（字节）= 8bit（比特）\n\n# 1.6.2 带宽\n\n带宽原本指某个信号具有的频带宽度，即最高频率与最低频率只差，单位是赫兹 在计算机网络中，带宽用来表示网络的通信线路传送数据的能力 通常指单位时间内从网络中某一点到另一点所能通过的“最高数据率” 单位是比特每秒，b/s 带宽是网络设备所支持的最高速度\n\n# 1.6.3 吞吐量\n\n单位时间内通过某个网络的数据量，单位b/s 吞吐量手网络的带宽或网络的额定速率的限制\n\n# 1.6.4 时延\n\n指数据从网络的一端传送到另一端所需要的时间，也叫延迟或迟延。单位是s 时延分成4大类\n\n 1. 发送时延（传输时延）：发送分组的第一个比特算起，到改分组的最后一个比特发送完毕所需的时间 发送时延=数据长度/信道带宽（发送速率）\n 2. 传播时延：电磁波在信道中传播一定距离花费的时间 取决于电磁波传播速度和链路长度 传播时延=信道长度/电磁波在信道上的传播速率\n 3. 排队时延：等待输出、输入链路中花费的时间\n 4. 处理时延：主机或路由器在收到分组时花费的时间\n\n# 1.6.5 时延带宽积\n\n时延带宽积（bit） = 传播时延（s） * 带宽（b/s） 描述数据量、信息量的性能属性 以比特为单位的链路长度，链路数据容量\n\n# 1.6.6 往返时延RTT\n\n从发送方发送数据开始（第一个比特位发送），到发送发收到接收方的确认（第一个比特确认），急售房收到数据后立即发送确认，总工经历的时延 RTT越大，在收到确认之前，可以发送的数据越多 RTT = 2*传播时延+末端处理时间\n\n# 1.6.7 利用率\n\n 1. 信道利用率 = 有数据通过的时间/（有+无）数据通过时间\n 2. 网络利用率 = 信道利用率加权平均值\n\n\n# 1.7 分层结构\n\n# 1.7.1 分层的基本原则\n\n服务：每两层之间提供的东西，上层是使用下层服务，下层为上层服务 分层的基本原则：\n\n 1. 各层之间相互独立，每层只实现一种相对独立的功能\n 2. 每层之间的界限自然清晰，易于理解，相互交流尽可能少\n 3. 结构上可分割开。每层都采用最适合的技术来实现\n 4. 保持下层对上层的独立性，上层单向使用下层提供的服务\n 5. 整个分层结构应该能促进标准化工作\n\n# 1.7.2 分层中的概念\n\n 1. 实体：第n层中的活动元素称为n层实体\n 2. 对等实体：同一层的实体\n 3. 协议：对进行网络中的对等实体数据交换而建立的规则、标准或约定（水平的） 协议三要素：语法（传输数据的格式）；语义（规定所要完成的功能）；同步（规定各种操作顺序）\n 4. 接口（访问服务店SAP）：上层使用下层服务的入口\n 5. 服务：下层为响铃上层提供的功能调用（单向、垂直）\n 6. SDU（服务数据单元）：为完成用户所要求的的功能而应传送的数据\n 7. PCI（协议控制信息）：控制协议操作的信息\n 8. PDU（协议数据单元）：对等层次之间传送的数据单元\n 9. 计算机网络体系结构是计算机网络的各层及其协议的集合\n\n\n# 1.8 计算机网络分层结构\n\n# 1.8.1 OSI参考模型\n\n法定标准；7层（物联网淑惠试用） 目的：支持异构网络体系的互联互通 自下而上：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 通信子网（数据通信）：物理层、数据链路层、网路层 资源子网（数据处理）：应用层、表示层、会话层\n\n# 应用层\n\n用户与网络的界面，所有能和用户交互产生网络流量的程序 常见应用层服务：文件传输（FTP）、电子邮件（SMTP）、万维网（HTTP）\n\n# 表示层\n\n用于处理再两个通信系统中交换信息的表示方式（语法和语义） 功能：\n\n 1. 数据格式变换\n 2. 数据加密解密\n 3. 数据压缩和恢复\n\n# 会话层\n\n像表示层实体/用户进程提供简历连接并在连接上有序地传输数据，会话，也是建立同步 会话之间彼此独立互不影响 功能：\n\n 1. 建立、管理、终止会话\n 2. 使用校验点可使会话在通信失效时从校验点（同步点）继续恢复通信，实现数据同步 主要协议：ADSP、ASP\n\n# 传输层\n\n负责主机中两个进程的通信，即端到端的通信。传输单位是报文段或用户数据报 功能：\n\n 1. 可靠传输（有确认机制）、不可靠传输\n 2. 差错控制\n 3. 流量控制\n 4. 复用分用 主要协议：TCP、UDP\n\n# 网络层\n\n把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务 网络层的传输单位是数据报 功能：\n\n 1. 路由选择\n 2. 流量控制\n 3. 差错控制\n 4. 拥塞控制 主要协议：IP、IPX等\n\n# 数据链路层\n\n把网络层传下来的数据报组装成帧 传输单位：帧 功能：\n\n 1. 成帧（定义帧的开始和结束）\n 2. 差错控制（帧错、位错）\n 3. 流量控制\n 4. 访问（接入）控制，控制对信道的访问 主要协议：SDLC、HDLC、PPP、STP\n\n# 物理层\n\n物理媒体上实现比特流的透明传输 传输单位：比特 透明传输：不管所传数据是怎样的比特组合都应当能在链路上传送 功能：\n\n 1. 定义接口特性\n 2. 定义传输模式\n 3. 定义传输速率\n 4. 比特同步\n 5. 比特编码 主要协议：Rj45、802.3\n\n# 1.8.2 TCP/IP参考模型\n\n事实标准；4层\n\n# 网络接口层\n\nHTTP、FTP、DNS\n\n# 网际层\n\nTCP、UDP\n\n# 传输层\n\nIP、IP\n\n# 应用层\n\nEthernet、ATM、Frame Relay\n\n# 与OSI的异同\n\n相同点：\n\n 1. 都分层\n 2. 基于独立的协议栈的改线\n 3. 可以实现异构网络互联 不同点：\n 4. OSI定义三点：服务、协议、接口\n 5. OSI先出现，参考模型先于协议发明，不偏向特定协议\n 6. TCP/IP设计之初就考虑到异构网互联问题，将IP作为重要层次\n 7. 连接方式：TCP/IP特别看重异构网互联，所以网络层为无连接，而不是面向连接 PS：面向连接（有确认过程的信息传输），无连接（直接传输）\n\n# 1.8.3 5层参考模型\n\n综合了OSI和TCP/IP的有点\n\n# 应用层\n\n支持各种网络应用\n\n# 传输层\n\n进程-进程的数据传输\n\n# 网路层\n\n源主机到目的主机的数据分组路由与转发\n\n# 数据链路层\n\n把网络层传下来的数据报组装成帧\n\n# 物理层\n\n比特传输\n\n\n# 2 物理层\n\n 1. 通信基础\n 2. 两个公式lim\n 3. 看图说话\n 4. 传输介质\n 5. 物理层设备\n\n\n# 2.1 物理层基本概念\n\n 1. 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体\n 2. 物理层主要任务：确定与传输媒体接口有关的一些特性\n 3. 机械特性：定义物理接连的特性\n 4. 电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等\n 5. 功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途\n 6. 过程特性：定义各条物理线路的工作规程和时序关系\n\n\n# 2.2 数据通信基础知识\n\n 1. 通信目的：传送消息\n 2. 数据：传送信息的实体，通常是有意义的符号序列\n 3. 信号：数据的电器/电磁的表现，是数据在传输过程中的存在形式\n    * 数字信号：代表消息的参数取值是离散的\n    * 模拟信号：代表信息的参数取值是连续的\n 4. 信源：产生和发送数据的源头\n 5. 信宿：接受数据的终点\n 6. 信道：信号的传输媒介\n 7. 三种通信方式：单工通信、半双工通信（不能同时发收）、全双工通信\n 8. 两种数据传输方式：串行传输（速度慢、费用低、适合远距离）、并行传输（速度快、费用高、适合近距离）\n\n\n# 2.3 码元\n\n 1. 码元：一个固定时长的信号波形，代表不同离散数值的基本波形，是阿虎I通信中数字信号的计量单位\n 2. 码元宽度：码元的时长\n 3. 当码元的离散状态有M个时，称为M进制码元\n 4. 1码元可以携带多个比特的信息量\n\n\n# 2.4 速率、波特、带宽\n\n 1. 速率也叫数据率，指数据的传输速率，代表单位时间内容传输的数据量\n 2. 可以用码元传输速率和信息传输速率表示\n 3. 码元传输速率：1s传输多少码元，表示单位时间内数字通信系统所传输的码元个数（脉冲个数、信号变化次数）。又称码元速率、波形速率、调制速率、符号速率。单位波特（Baud）\n 4. 信息传输速率：1s传输多少比特，表示单位时间内容数字通信系统传输的二进制码元个数（比特数）。又称信息速率、比特率。单位是比特/秒（b/s）\n 5. 带宽：表示带单位时间内从网络中的某一点到另一点所能通过的“最高数据率”\n\n\n# 2.5 奈氏准则和香农定理\n\n 1. 影响失真程度的因素：码元传输速率；信号传输距离；噪声干扰；传输媒体质量\n 2. 信道带宽：信道能通过的最高频率和最低频率之差\n 3. 码间串扰：接收端收到的信号波形失去了码元之间清晰界限的现象\n 4. 奈氏准则给出了码元传输速率的限制，但没有对信息传输速率给出限制\n 5. 香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的传输速率有上限值\n\n\n# 2.6 编码与调制\n\n# 2.6.1 系带信号与宽带信号\n\n 1. 基带信号：将数字信号用两种不同的电压表示送到数字信道上传输（基带传输）\n 2. 宽带信号：将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信号上去传输（宽带传输）\n\n# 2.6.2 编码\n\n数据变为数字信号\n\n# 数字数据编码为数字信号\n\n 1. 非归零编码（NRZ）\n 2. 曼切斯特编码\n 3. 差分曼切斯特编码\n\n# 模拟数据编码为数字信号\n\n 1. PCM：抽样、量化、编码\n\n# 2.6.3 调制\n\n数据变为模拟信号\n\n# 数字数据调制为模拟信号\n\n 1. ASK(调幅)\n 2. FSK(调频)\n 3. PSK(调相)\n 4. QAM(调幅+调相)\n\n# 模拟数据调制为模拟信号\n\n\n# 2.7 物理层传输介质\n\n传输介质：数据传输系统中在发送设备和接受设备之间的物理通路，也称传输媒体/传输媒介\n\n# 2.7.1 导向性传输介质\n\n 1. 双绞线，绞合可以减少对相邻导线的电磁干扰\n 2. 同轴电缆\n 3. 光纤\n\n# 2.7.2 非导向性传输介质\n\n 1. 无线电波\n 2. 微波\n 3. 红外线、激光\n\n\n# 2.8 物理层设备\n\n# 2.8.1 中继器\n\n对信号进行再生和还原，再生数字信号 5-4-3规则：最多5个网段、最多4个物理层设备、最多挂3个计算机\n\n# 2.8.2 集线器（多口中继器）\n\n对信号进行放大转发，再生，放大信号 不具备信号的定向传送能力，是一个共享性设备\n\n\n# 3 数据链路层\n\n 1. 链路层的功能\n 2. 链路层的两种信道\n 3. 局域网、广域网\n 4. 链路层的设备\n\n\n# 3.1 数据链路层概述\n\n# 3.1.1 数据链路层基本概念\n\n 1. 结点：主机、路由器\n 2. 链路：网络中两个结点之间的物理通道，链路的传输介质主要是双绞线、光纤和微波。分为有限链路、无线链路\n 3. 数据链路：网络中两个结点之间的逻辑通道，把实际控制数据传输协议的硬件和软件加到链路上就构成数据链路\n 4. 帧：链路层的协议数据单元，封装网络层数据报\n 5. 数据链路层负责通过一条链路从一个结点向两一个物理链路直接连接的相邻结点传送数据报\n\n# 3.1.2 数据链路层功能概述\n\n数据链路层在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻结点的目标机网络层。其主要作用是加强物理层传输原式比特流的功能，将物理层提供的可以出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路\n\n 1. 为网络层提供服务：无确认无连接服务、有确认无连接服务、有确认面向服务（有连接一定有确认）\n 2. 链路管理，即连接的建立、维持、释放（用于面向连接的服务）\n 3. 组帧\n 4. 流量控制\n 5. 差错控制\n\n\n# 3.2 封装成帧\n\n 1. 封装成帧：在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束\n 2. 首部和尾部包含许多控制信息，他们的一个重要作用：帧定界（确定帧的界限）\n 3. 帧同步：接收方应该能从接收到的二进制比特流中区分出帧的起始和终止\n 4. 数据链路层的帧长：帧首部到帧尾部的距离\n 5. 最大传送单元（MTU）：帧的数据部分的最大长度\n 6. 组帧方法：①字符计数法；②字符（节）填充法；③零比特填充法；④违规编码法\n 7. 透明传输：不管所传数据是什么样的比特组合，都应当能够在链路上传送\n\n# 3.2.1 字符技术法\n\n帧首部使用一个计数字段（第一个字节，八位）来标明帧内字符数 首部一旦发生错误，后面全部无法识别\n\n# 3.2.2 字符填充法\n\n在发送端添加转义字符，在接收端把转义字符删掉，实现透明传输\n\n# 3.2.3 零比特填充法\n\n 1. 在发送端，扫描整个信息字段，只要连续5个1，就立即填入1个0\n 2. 在接收端收到一个帧时，先找到标志字段确定边界，再用硬件对比特流进行扫描。发现连续5个1时，就把后面的0删除 保证了透明传输\n\n# 3.2.4 违规编码法\n\n用两个编码中不会用到的电平方式来标志帧的起始和终止\n\n\n# 3.3 差错控制\n\n# 3.3.1 差错\n\n# 差错的来源\n\n传输中的差错都是由于噪声引起的\n\n 1. 全局性噪声：由于线路本身电气特性所产生的所及噪声（热噪声），是信道固有的，随机存在的 解决方法：提高信噪比来减少或避免干扰（调整传感器）\n 2. 局部性噪声：外界特定的断站原因所造成的冲击噪声，是产生差错的主要原因 解决办法：通常利用编码技术来解决\n\n# 差错的分类\n\n 1. 位错：比特位出错，1变成0、0变成1\n 2. 帧错：帧丢失；帧重复；帧失序\n\n# 3.3.2 检错编码\n\n# 奇偶校验码\n\n由n-1位信息元和1位校验元组成\n\n 1. 奇校验码：n个比特有奇数个1\n 2. 偶校验码：n个比特有偶数个1 只能检查出奇数个比特错误，检错能力为50%\n\n# CRC循环冗余码\n\n最终发送的数据：要发送的数据+帧检验序列FCS（冗余码） 计算冗余码： 1. 加0：加生成多项式阶个0 2. 模2除法：数据加0后处于多项式，余数为冗余码/FCS/CRC检验码的比特序列（异或）\n\n# 3.3.3 纠错编码\n\n 1. 海明码：可以发现双比特错，但只能纠正单比特错\n 2. 工作原理：动一发而牵全身\n\n# 海明码工作流程\n\n 1. 确定校验码位数r 海明不等式：2^r>=k+r+1(r:冗余信息位、k：信息位)\n 2. 确定校验码和数据的位置 校验码只能存在在2的几次方的位置，数据按照剩下的位置按序填写\n 3. 求校验码的值 把数据为变化成二进制位，二进制的位数由数据位最大的位数决定 校验码校验的位置是该校验码1位置一致的位 校验码的实际值与所有要校验位的实际值异或为0\n 4. 检错并纠错 求出每个校验码与所要校验位的异或 从最后校验码的异或网最前写，得出的二进制数就是出错的位置\n\n\n# 3.4 流量控制与可靠传输\n\n 1. 由于较高的发送速度和较低的接受能力的不匹配会造成传输出错，所以流量控制室数据链路层的重要工作\n 2. 数据链路层的流量控制是点对点；传输层的流量控制是端对端的\n 3. 数据链路层流量控制手段：接收方收不下就不回复确认\n 4. 传输层流量控制手段：接收端给发送端一个窗口公告\n\n# 3.4.1 停止——等待协议\n\n 1. 没发送完一个帧就停止发送，等待对方的确，在收到确认后再发送下一个帧\n 2. 发送窗口大小=1；接受窗口大小=1\n 3. 停止——等待协议目的：解决底层信道出现的丢包问题 丢包问题：物理线路故障、设备故障、病毒攻击、路由信息错误等原因，会导致数据报的丢失\n 4. 停止——等待协议应用情况：无差错情况；有差错情况\n\n# 停止——等待协议关键点\n\n 1. 超时计时器：每发送一个帧就启动一个计时器，计时器到时还未接收到ACK就会重传刚刚未收到确认的帧（自动重传）\n 2. 数据帧与确认帧必须编号\n 3. 接收方如果重复收到编号相同的帧，就丢弃重复帧并重传该帧的确认帧\n 4. 发送方如果重复收到编号相同的确认帧，就丢弃重复的确认帧不作处理\n\n# 停止——等待协议性能\n\n 1. 简单\n 2. 信道利用率太低\n\n# 3.4.2 滑动窗口协议\n\n 1. 发送窗口：发送方维持一组连续的允许发送的帧的序号\n 2. 接受窗口：接受方维持一组持续的允许接受帧的序号\n\n# 后退N帧协议（GBN）\n\n 1. 发送窗口大小>1；接受窗口大小=1\n 2. 发送方把数据分成：发完被确认的、已经发送等待确认的、还能发送的、还不能发送的\n 3. 滑动窗口长度小于2^n-1（n：帧编号的比特位数）\n\n# GBN发送方响应\n\n 1. 上层调用：检查发送窗口是否已满（实际上发送方可以缓存数据）\n 2. 收到ACK：累积确认，接受n号帧标明接收方收到n号帧及之前的全部帧\n 3. 超时事件：出现超时发送方重传所有已发送但未确认的帧\n\n# GBN接收方响应\n\n 1. 正确接收：为n号帧发送一个ACK，代表n号帧之前的所有帧都接受完毕\n 2. 其余情况：全部丢弃，为最近安序接收的帧重新发送ACK\n\n# GBN性能\n\n 1. 因连续发送数据帧而提高了信道利用率\n 2. 重传时必须把原来已经正确传送的数据帧重传，传送效率低\n\n# 选择重传协议（SR）\n\n 1. 发送窗口大小>1；接受窗口大小>1\n 2. 设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧\n 3. 发送方把数据分成：发完被确认的、已经发送等待确认的、还能发送的、还不能发送的\n 4. 接收方把数据分成：已经接受完并返回确认的、希望收到但没收到的、收到且确认的（缓存）、等待接受的、还无法接收的\n 5. 滑动窗口大小最大为2**（n-1）\n\n# SR发送方响应\n\n 1. 上层调用\n 2. 收到ACK\n    * 收到在帧序号窗口内的ACK，将帧标记为已接收\n    * 标记已接收的帧序号是窗口下界，则窗口向前移动到具有最小序号的未确认帧处\n 3. 超时事件：每个帧都有独立计时器，超时后只重传一个帧\n\n# SR接收方响应\n\n来者不拒（窗口的帧）\n\n 1. 正确接收：确认一个在窗口内的帧而不用管其是否按序，失序的帧将被缓存，并返回该帧的的确认帧，只表示该帧被接受\n 2. 窗口滑动：处于窗口下界的帧被接收时，向前滑动窗口至具有最小序号的未确认帧处\n 3. 其余情况：忽略该帧、返回该帧的ACK\n\n# SR重点\n\n 1. 对数据帧逐一确认，收到一个确认一个\n 2. 只重传错误帧\n 3. 接收方有缓存\n\n\n# 3.5 可靠传输、滑动窗口、流量控制\n\n 1. 可靠传输：发送端发啥，接收端收啥\n 2. 流量控制：控制发送速率，使接收方有足够的缓冲空间来接受每个帧\n 3. 滑动窗口：\n    * 流量控制：收不下就不给确认，控制发送\n    * 可靠传输：发送端自动重传\n\n\n# 3.6 介质访问控制（MAC协议）\n\n 1. 传输数据使用的两种链路\n    * 点对点链路：两个相邻节点通过一个链路相连，没有第三者。（PPP协议、广域网）\n    * 广播式链路：所有主机共享通信介质（局域网）\n 2. 介质访问控制：采取一定的措施，使得两对节点之间的通信不会发生互相干扰的情况\n\n# 3.6.1 静态划分信道\n\n 1. 信道划分介质访问控制：将受用介质的每个设备与来自同意信道上的其他设备的通信隔离开，把时域和频域合理地分配给网络上的设备\n 2. 多路复用技术：把多个型号组合在一条物理信道上进行传输，使得多个计算机或终端设备共享信道资源，提高信道利用率\n\n# 频分多路复用FDM\n\n 1. 用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带\n 2. 频分复用的所有用户在同样的时间占用不同的带宽（频率带宽）资源\n 3. 优点：\n    * 充分利用传输介质带宽，效率较高\n    * 技术比较成熟，实现比较容易\n\n# 时分多路复用TDM\n\n 1. 将时间划分成一段段登场的时分复用帧（TDM帧）\n 2. 每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，所有用户轮流占用信道\n 3. TDM帧是在物理层传送的比特流所划分的帧，标志一个周期\n 4. 统计时分复用STDM：\n    * 每个STDM帧时隙数小于连接在集中器上的用户数\n    * 各用户有了数据就随时发送集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存发出\n    * 不固定分配时隙，而是按需动态分配时隙\n\n# 波分多路复用WDM\n\n 1. 波分多路复用：本质就是光的频分多路复用，在一根光线中传输多种不同波长（频率）的光信号，由于波长不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来\n\n# 码分多路复用CDM\n\n 1. 码分多址（CDMA）是码分复用的一种方式\n 2. 将一个比特分为多个码片/芯片（chip），每个站点被指定一个唯一的m位的芯片序列\n 3. 发送1时发送芯片序列；发送0时发送芯片序列的反码\n 4. 不干扰：多个站点同时发送数据时，各个站点芯片序列相互正交\n 5. 合并：各路数据在信道中被线性相加\n 6. 分离：合并的数据和远战 规格化内积\n\n# 3.6.2 动态分配信道\n\n 1. 特点：信道并非在用户通信时固定分配给用户\n\n# 轮询访问介质访问控制\n\n既不产生冲突，又要发送时占全部带宽\n\n# 轮询协议\n\n 1. 主结点轮流“邀请”从属结点发送数据\n 2. 问题：\n    * 轮询开销\n    * 等待延迟\n    * 单点故障\n\n# 令牌传递协议\n\n 1. 令牌：\n    * 一个特殊格式的MAC控制帧，不包含任何信息。\n    * 可以控制信道的使用，确保同一时刻只有一个结点独占信道\n 2. 问题：\n    * 令牌开销\n    * 等待延迟\n    * 单点故障\n 3. 应用于令牌环网（物理星型拓扑，逻辑环形拓扑）\n 4. 常用于负载较重、通信量较大的网络中\n\n# 随机访问介质访问控制\n\n 1. 所有用户可随机发送信息\n 2. 发送信息时占全部带宽\n\n# ALOHA协议\n\n 1. 纯ALOHA协议比时隙ALOHA协议吞吐量低，效率更低\n 2. 纯ALOHA想法就发，时隙ALOHA协议只有在时间片段开始时才能发 ####### 纯ALOHA协议\n 3. 思想：想发就发，不监听信道，不按时间槽发送，随机重发\n 4. 冲突检测：接收方检测出差错不予确认，发送方在一定时间内收不到就判断发生冲突\n 5. 冲突解决：超时后等一随机时间重传 ####### 时隙ALOHA协议\n 6. 思想：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送\n\n# CSMA协议\n\n载波监听多路访问协议\n\n 1.  CS：载波监听，每个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据\n 2.  MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上\n 3.  协议思想：发送帧之前，监听信道\n 4.  监听结果\n     * 信道空闲：发送完整帧\n     * 信道忙：推迟发送 ####### 1-坚持CSMA\n 5.  坚持：对于监听信号忙后的坚持\n 6.  思想：\n     * 如果一个主机要发送消息，那么它先监听信道\n     * 空闲则直接传输，不必等待\n     * 忙则一直监听，指导空闲马上传输\n     * 如果冲突：等待一个随机场的时间再监听，重复上述过程\n 7.  优点：只要媒体空闲，站点就马上发送，媒体利用率高\n 8.  缺点：假如有两个或两个以上的站点有数据要发送，冲突不避免 ####### 非坚持CSMA\n 9.  非坚持：对于监听信道忙之后就不继续监听\n 10. 思想：\n     * 如果一个主机要发送消息，那么它先监听信道\n     * 空闲则直接传输，不必等待\n     * 忙则等待一个随机的时间之后再进行监听\n 11. 优点：采用随机的重发延迟时间可以减少冲突发生的可能性\n 12. 缺点：可能存在大家都在延迟等待过程中，媒体利用率低 ####### p-坚持CSMA\n 13. p-坚持：对监听信道空闲的处理\n 14. 思想：\n     * 如果一个主机要发送消息，那么它先监听信道\n     * 空闲则以p概率直接传输，不必等待；概率1-p等待到下一个时间槽再传输\n     * 忙则等待下一个时间槽再进行监听\n 15. 优点：既能像非坚持减少冲突，又能像1-坚持减少媒体空闲时间\n 16. 缺点：发生冲突后还是坚持把数据帧发送完，造成了浪费\n\n# CSMA/CD协议\n\n载波监听多点接入/碰撞检测协议\n\n 1. CS：载波监听，每个站在发送数据之前以及发送数据时要检测一下总线上是否有其他计算机在发送数据\n 2. MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上（应用于以太网）\n 3. CD：碰撞检测（冲突检测），“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化情况，以判断自己在发送数据时其他站是否也在发送数据（应用于半双工网络）\n 4. 只要经过2τ时间还没有检测到碰撞就能肯定这次发送不会发生碰撞\n 5. 截断二进制指数规避算法：\n    * 确定基本退避（推延）时间为征用期2τ\n    * 定义参数k，k=min(重传次数，10)\n    * 从离散的整数集合[ 0,1,2**k-1]中随机取出一个数r，重传所需退避时间为r被的基本退避时间\n    * 当重传达到16次仍不能成功，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告错误\n 6. 最小帧长=总线传播时延 * 数据传输速率 * 2\n\n# CSMA/CA协议\n\n载波监听多点接入/碰撞避免\n\n 1. 应用于无线局域网，CD无法全面检测碰撞\n 2. 工作原理：\n    * 发送数据前，先检测信道是否空闲\n    * 空闲则发出RTS；忙则等待\n    * 接收端收到RTS，将响应CTS\n    * 发送端收到CTS后，开始发送数据帧。同时预约信道（发送端告知其他站点自己要传多久数据）\n    * 接收端收到数据帧后，用CRC来检验数据是否正确，正确则响应ACK帧\n    * 发送方收到ACK就可以进行数据帧发送；若没有则一致重传到规定重发次数为止（截断二进制指数规避算法）\n 3. 重点：\n    * 预约信道\n    * ACK帧\n    * RTS/CTS帧（可选）\n\n\n# 3.7 局域网\n\n# 3.7.1 基本概念\n\n 1. 局域网：简称LAN，在某一区域内由多台计算机互联成的计算机组，使用广播信道\n 2. 局域网特点：\n    * 覆盖的地理范围小，只在一个相对独立的局部范围内互联\n    * 使用专门铺设的传输介质进行联网，数据传输速率高\n    * 通信延迟时间短，误码率低，可靠性较高\n    * 各站点为平等关系，共享传输信道\n    * 多采用分布式控制和广播式通信，能进行广播和组播\n 3. 局域网的主要要素：网络拓扑；传输介质；介质访问控制方法\n\n# 局域网拓扑结构\n\n 1. 星型拓扑：中间节点是控制中心，结构简单、建网容易；网络可靠性低、网络共享能力差，有单点故障问题\n 2. 总线型拓扑：网络可靠性高、节点响应速度快、成本低、无单点故障问题\n 3. 环形拓扑：通信设备和线路比价节省；有单点故障问题、不易扩充、系统响应延时长、信息传输效率低\n 4. 树型拓扑：易于扩展、易于隔离故障；有单点故障问题\n\n# 局域网传输介质\n\n 1. 有线局域网：双绞线、同轴电缆、光纤\n 2. 无线局域网：电磁波（空气）\n\n# 介质访问控制方法\n\n 1. CSMA/CD：常用于总线型局域网，也用于树型局域网\n 2. 令牌总线：常用于总线型局域网，也用于树型局域网。把网络中各个工作站按一定顺序排列形成一个逻辑换，只有持有令牌才能控制总线\n 3. 令牌环：常用于环形局域网\n\n# 局域网分类\n\n 1. 以太网：IEEE 802.3标准；逻辑拓扑总线型、物理拓扑是星型或扩展星型；CSMA/CD\n 2. 令牌环网:物理上星型拓扑，逻辑上环形拓扑\n 3. FDDI网：光纤，造价高；物理上双环拓扑、逻辑上环形拓扑\n 4. ATM网：较新型的单元交换技术，使用固定53字节单元交换\n 5. 无线局域网：IEEE 802.11标准\n\n# IEEE 802标准\n\n 1. IEEE 802.3:以太网\n 2. IEEE 802.5:令牌环网\n 3. IEEE 802.8：光纤技术\n 4. IEEE 802.11：无线局域网\n\n# MAC子层和LLC子层\n\n 1. IEEE 802标准描述的局域网参考模型只对应数据链路层和物理层\n 2. IEEE 802标准将数据链路层划分为：逻辑链路层LLC子层；介质访问控制MAC子层\n 3. LLC子层：负责识别网络层协议，然后进行封装。为网络层提供服务：无确认无连接、面向连接、带确认无连接、高速传送 4、 MAC子层：负责数据帧的封装/卸装，帧的寻址和识别，帧的接受与发送，链路的管理，帧的差错控制，屏蔽了不同物理链路种类的差异性\n\n# 3.7.2 以太网\n\n 1. 以太网（Ethernet）指几个公司联合开发的基带总线局域网规范\n 2. 以太网使用CSMA/CD技术\n 3. 以太网优点：\n    * 造价低廉\n    * 应用最广泛\n    * 偏移、简单\n    * 满足网络速率的要求\n 4. 以太网的两个标准：\n    * DIX Ethernet\n    * IEEE 802.3\n\n# 以太网提供的服务\n\n 1. 无连接：发送方和接收方之间无“握手过程”\n 2. 不可靠：\n    * 不对发送方的数据帧编号\n    * 接收方不向发送方进行确认，差错帧直接退旗，差错纠正由高层负责\n 3. 智能实现无差错的接受，不实现可靠传输\n\n# 传输介质与拓扑结构\n\n 1. 粗同轴电缆————细同轴电缆————双绞线+集线器\n 2. 总线型——————————————————————星型\n 3. 逻辑上总线型，物理上星型\n\n# 10BASE-T以太网\n\n 1. 10BASE-T是传输基带信号的双绞线以太网，采用的是无屏蔽双绞线，传输速率是10Mb/s，T表示采用双绞线\n 2. 物理上采用星型拓扑，逻辑上总线型\n 3. 每段双绞线最长100m\n 4. 采用曼切斯特编码\n 5. CSMA/CD介质访问控制\n\n# 适配器与MAC地址\n\n 1. 适配器：连接计算机与外界局域网的连接\n 2. MAC地址：局域网中硬件地址，48位二进制地址\n\n# 以太网MAC帧\n\n 1. 最常用的MAC帧是以太网V2的格式\n 2. MAC帧：目的地址（6字节）+源地址（6字节）+类型（2地址）+数据（46-1500）+FCS（纠错编码）（4字节）\n\n# 高速以太网\n\n 1. 100BASE-T以太网：双绞线上传送100Mb/s基带信号的星型拓扑以太网；支持全双工和半双工\n 2. 吉比特以太网：在光纤或双绞线上传送1Gb/s信号；支持全双工和半双工\n 3. 10吉比特以太网：在光纤上传送10Gb/s信号；只支持全双工\n\n# 3.7.3 无限局域网\n\n# IEEE 802.11\n\n 1. 无线局域网通用的标准\n 2. 802.11的MAC帧头格式：帧控制（2）+生存周期ID（2）+地址1（RA接收端，6）+地址2（TA发送方，6）+地址3（DA目的地，6）+序列控制（2）+地址4（SA源地址，6）\n\n# 无线局网分类\n\n 1. 有固定基础设施无线局域网\n 2. 无固定基础设施无限局域网\n\n\n# 3.8 广域网协议\n\n 1. 广域网：提供远距离通信，通信子网使用分组交换技术\n 2. 广域网可是实现远距离局域网的连接\n\n# 3.8.1 PPP协议\n\n 1. PPP协议：点对点协议，使用最广泛的数据链路层协议\n 2. PPP协议只支持全双工链路\n 3. 面向字节的协议\n\n# PPP协议要求\n\n 1.  简单：对于链路层的帧，无需纠错，无需序号，无需流量控制\n 2.  封装成帧：帧定界符\n 3.  透明传输：与帧定界符一样比特组合的处理：异步线路用字节填充；同步线路用比特填充\n 4.  满足多种网络层协议\n 5.  满足多种类型链路\n 6.  实现差错检测\n 7.  检测连接状态\n 8.  满足最大传送单元\n 9.  网络层地址协商\n 10. 数据压缩协商\n\n# PPP协议无需满足要求\n\n 1. 纠错\n 2. 流量控制\n 3. 序号\n 4. 不支持多点线路\n\n# PPP协议功能\n\n 1. 将IP数据报封装到串行链路（同步串行/异步串行）的方法\n 2. 链路控制协议LCP：建立并维护数据链路层连接\n 3. 网络控制协议NCP：不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接\n\n# PPP协议的状态图\n\n\n\n# PPP协议的帧格式\n\n帧定界符7E+地址字段FF+C03+协议+IP数据报+FCS+帧定界符7E\n\n# 3.8.2 HDLC协议\n\n 1. HDLC：高级数据链路控制协议\n 2. 面向比特的数据链路层协议\n 3. 可实现透明传输，使用“0比特插入法”\n 4. 采用全双工通信\n 5. CRC检验，对信息帧进行顺序编号，传输可靠性高\n\n# HDLC站\n\n 1. 主站：发送命令帧、接受响应帧\n 2. 从站：接受主站发送来的命令帧，向主站发送响应帧\n 3. 复合站：既能发送又能接受命令帧和响应帧\n 4. 三种数据操作方式：\n    * 正常响应方式\n    * 异步平衡方式\n    * 异步响应方式\n\n# HDLC帧格式\n\n标志字段+地址A+控制C+信息+帧检验序列FCS+标志字段\n\n# 3.8.3 PPP与HDLC比较\n\n# 相同点\n\n 1. 都只支持全双工链路\n 2. 都可实现透明传输\n 3. 都可实现差错检测，但不纠正\n\n# 不同点\n\n 1. 对于透明传输：PPP可以比特填充和字节填充；HDLC只能比特填充\n 2. PPP面向字节；HDLC面向比特\n 3. PPP有两个字节协议字段\n 4. PPP无序号无确认机制，不可靠；HDLC有编号和确认机制，可靠\n\n\n# 3.9 链路层设备\n\n# 3.9.1 物理层扩展以太网\n\n 1. 光纤调制器、光纤解调器\n 2. 主干集线器扩展冲突域\n\n# 3.9.2 链路层扩展以太网\n\n# 网桥\n\n 1. 网桥：根据MAC帧的目的地址对帧进行转发和过滤\n 2. 网段：一个计算机网络中使用同一物理层设备能够直接通讯的部分\n 3. 网桥优点：\n    * 过滤通信量。增大吞吐量\n    * 扩大了物理范围\n    * 提高可靠性\n    * 互联不同物理层、不同MAC子层和不同速率的以太网\n 4. 网桥分类：\n    * 透明网桥：即插即用，以太网的站点不知道帧将经过哪些网桥\n    * 源路由网桥：发送帧时，把详细的最佳路由信息（路由最少/时间最短）放在帧的首部\n\n# 以太网交换机\n\n 1. 以太网交换机可以独占传输媒体带宽\n 2. 直通式交换机：查完目的地址就立即转发；延迟小，可靠性低，无法支持具有不同速率的端口的交换\n 3. 存储转发式交换机：将帧放入高速缓存，并检查是否正确，正确就转发，错误则丢弃；延迟大，可靠性高，可以支持具有不同速率的端口交换\n\n\n# 4 网络层\n\n\n# 4.1 网络层概述\n\n# 4.1.1 网络层功能\n\n 1. 主要任务：把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务\n 2. 网络层传输单位：数据报\n 3. 功能一：路由选择与分组转发（选择最佳路径）\n 4. 功能二：异构网络互联\n 5. 功能三：拥塞控制 拥塞：所有结点都来不及接受分组，要丢弃大量分组 开环控制：静态控制方法 闭环控制：动态控制方法\n\n# 4.1.2 数据交换方式\n\n# 电路交换\n\n 1. 电路交换流程： 建立连接————通信————释放连接\n 2. 优点：\n    * 通信时延小\n    * 有序传输\n    * 没有冲突\n    * 实时性强\n 3. 缺点：\n    * 建立连接时间长\n    * 线路独占，使用效率低\n    * 灵活性差\n    * 无差错控制能力\n 4. 特点：独占资源\n\n# 报文交换\n\n 1. 报文：源应用发送的信息整体\n 2. 优点\n    * 无需建立连接\n    * 存储转发，动态分配线路\n    * 线路可靠性高\n    * 线路利用率较高\n    * 多目标服务\n 3. 缺点：\n    * 有存储转发时延\n    * 报文大小不定，需要网络节点有较大缓存空间\n\n# 分组交换\n\n 1. 分组：把大的数据块分割成小的数据块\n 2. 优点：\n    * 无需建立连接\n    * 存储转发，动态分配线路\n    * 线路可靠性较高\n    * 线路利用率较高\n    * 相对于报文交换，存储管理更容易\n 3. 缺点：\n    * 有存储转发时延\n    * 需要传输额外的信息量\n    * 乱序到目的主机时，要对分组排序重组\n\n# 数据报方式\n\n 1. 数据报方式：为网络层提供无连接服务\n 2. 无连接服务：不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同\n 3. 每个分组都携带源地址和目的地址\n 4. 路由器根据分组的目的地址转发分组：基于路由协议/算法构建转发表；检索转发表；每个分组独立选路\n\n# 虚电路方式\n\n 1. 虚电路方式：为网络层提供连接服务，将数据报方式和电路交换方式结合，发挥两者优点\n 2. 连接服务：首先为分组的传输确定传输路径（建立连接），然后沿该路径（连接）传输系列分组，系列分组传输路径相同，传输结束后拆除连接\n 3. 虚电路：一条源主机到目的主机类似于电路的路径（逻辑连接），路径上所有节点都要维持这条虚电路的建立。都维持一张虚电路表，每一项记录了一个打开的虚电路的信息\n 4. 通信过程：\n    * 建立连接（虚电路的建立）： 每个分组携带虚电路号，而非目的地址。 源主机发送“呼叫请求”分组，并收到“呼叫应答”分组后才算建立连接\n    * 数据传输：全双工通信\n    * 释放连接（虚电路释放）：源主机发送“释放请求”分组以拆除虚电路\n\n# 4.1.3 传输单元名词\n\n 1. 报文：应用层的传输单元\n 2. 报文段：传输层的传输单元，将报文分割而成\n 3. IP数据报：报文段到网络层封装上网络层地址（源地址、目的地址）\n 4. 分组：网络层的传输单元，将过长的数据报切割而成\n 5. 帧：数据链路层的传输单元，将分组加头加尾\n 6. 比特流：物理层的传输单元\n\n\n# 4.2 IP数据报\n\n# 4.2.1 IP数据报格式\n\n 1. 首部（固定部分+可变部分）+数据部分（TCP、UDP段）\n 2. 首部\n    * 固定部分：\n      * 版本：IP协议的版本（4bit）\n      * 首部长度：单位是4字节，最小是5（4bit）\n      * 区分服务：期望获得那种类型的服务（8bit）\n      * 总长度：整个IP数据报的长度，单位是1B（16bit）\n      * 标识：同一数据包的分片使用同一标识（16bit）\n      * 标志：只用后两位有用（3bit）\n        * 中间位DF 1：禁止分片 0：允许分片\n        * 最低位MF 1：后面还有分片 0：代表租后一篇/没分片\n      * 片偏移：某片在原分组中的相对位置，以8B为单位（13bit）\n      * 生存时间（TTL）：IP分组的保质期。每经过一个路由器生存时间-1，变成0则丢弃（8bit）\n      * 协议：数据部分使用的协议（TCP：6；UDP：17）（8bit）\n      * 首部检验和：只检验首部（16bit）\n      * 源地址（32bit）\n      * 目的地址（32bit）\n    * 可变部分：\n      * 可选字段（长度可变）：用来支持拍错、测量以及安全等措施（0~40B）\n      * 填充：全0，报首部不成4B的整数倍\n\n# 4.2.2 IP数据报分片\n\n 1. 最大传送单元MTU：链路层数据帧可封装数据的上限\n 2. 除了最后一个分片，每个分片长度一定是8B的整数倍\n 3. 片偏移量是从数据部分开始计算，不计首部\n\n\n# 4.3 IP地址\n\n 1. IP地址：全世界唯一的32位/4字节标识符，标识路由器主机的接口\n 2. :={<网络号>,<主机号>}\n 3. 采用点分十进制，例：223.1.1.1\n\n# 4.3.1 分类的IP地址\n\n 1. A类：0+7bit+主机号\n 2. B类：10+14bit+主机号\n 3. C类：110+21bit+主机号\n 4. D类：1110+多播地址\n 5. E类：1111（保留为今后使用）\n\n# 特殊IP地址\n\n\n\n# 私有IP地址\n\n路由器对目的地址是私有IP地址的数据报一律不进行转发\n\n 1. A类：10.0.0.0~10.255.255.255\n 2. B类：172.16.0.0~172.31.255.255\n 3. C类：192.168.0.0~191.168.255.255\n\n# 分来IP地址弱点\n\n 1. IP地址空间利用率很低\n 2. 两级的IP地址不够灵活\n\n# 4.3.2 NAT网络地址转换\n\n 1. 网络地址转换：在专用网连接到因特网的路由器上安装NAT软件\n 2. NAT路由器：安装了NAT软件的路由器，至少有一个有效的外部全球IP地址\n 3. NAT转换表 WAN端：IP地址——端口号 LAN端：IP地址——端口号\n\n# 4.3.3 子网划分\n\n 1. 采用三级IP地址：网络号+子网号+主机号（子网号从原来的主机号里的高位划出来）\n 2. 单位划分子网后，对外仍表现为一个网络\n 3. 子网掩码\n    * 二级IP地址：网络号全1，主机号全0\n    * 三级IP地址：网络号和子网号全1，主机号全0\n 4. 子网掩码与IP地址逐位与运算，得到子网网络地址\n 5. 使用子网时路由器转发分组算法\n    * 提取IP地址\n    * 判断是否直接交付\n    * 查看路由表中的特定主机路由\n    * 检测路由表中有无路径\n    * 默认路由0.0.0.0\n    * 丢弃，报告转发分组出错\n\n# 4.3.4 无分类编制CIDR\n\n 1. 消除传统A类、B类、C类地址以及划分子网的概念\n    * IP地址：网络前缀+主机号\n    * CIDR记法：在IP地址后加上/，然后写上网络前缀的位数\n 2. 融合子网地址与子网掩码，方便子网划分\n    * CIDR地址块：由网络前缀相同的连续IP地址组成，用最小地址/网络前缀位数\n    * 地址掩码：网络前缀全1，主机号全0\n\n# 构成超网\n\n 1. 构成超网（路由聚合）：将多个子网聚合成一个较大的子网\n 2. 方法：缩短网络前缀\n 3. 最长前缀匹配：使用CIDR时，查找路由表选择具有最长网络前缀的路由\n\n\n# 4.4 IP相关协议\n\n# 4.4.1 ARP协议\n\nARP高速缓存：IP地址与MAC地址的映射，用于网络层到数据链路层中增加MAC地址时使用\n\n# ARP协议使用过程\n\n 1. 检查ARP高速缓存，有对应表项则写入MAC帧\n 2. 没有则广播ARP分组请求 （自身IP地址+目的IP地址+自身物理MAC地址+全1广播目的MAC地址）\n 3. 单播放ARP响应分组 （目的IP地址+目的MAC地址），源主机收到后将此映射写入ARP缓存\n 4. PS：两个IP地址不在一个网段内，目的MAC地址是默认网关（路由器）MAC地址\n\n# ARP协议特点\n\n 1. ARP协议的产生原因：在实际网络的链路上传送数据帧时，最终必须使用MAC地址\n 2. ARP协议：完成主机或路由器IP地址到MAC地址的映射\n 3. ARP协议自动进行\n\n# ARP协议典型情况\n\n 1. 主机A发给本网络上的主机B：用ARP找到主机B的硬件地址\n 2. 主机A发给另一网络上的主机B：用ARP找到本网络上一个路由器（网关）的硬件地址\n 3. 路由器发给本网络的主机A：用ARP找到主机A的硬件地址\n 4. 路由器发给另一网络上的主机A：用ARP找到本网络上一个路由器（网关）的硬件地址\n\n# 4.4.2 DHCP协议\n\n 1. 动态主机配置协议DHCP是应用层协议，使用客户/服务器方式，客户端和服务端通过广播方式进行交互，基于UDP\n 2. DHCP用于分配IP地址，是一种动态分配主机IP地址的方法\n 3. DHCP提供即插即用联网机制，允许地址重用，支持移动用户加入网络，支持在用地址续租\n\n# DHCP工作流程\n\n 1. 主机广播DHCP发现报文主机寻找DHCP服务器，DHCP服务器选择IP地址\n 2. DHCP服务器广播DHCP提供报文拟分配主机IP地址及相关配置\n 3. 主机广播DHCP请求报文采用先到先得，广播使所有DHCP服务器都知道主机选用的IP地址\n 4. DHCP服务器广播DHCP确认报文正式将IP地址分配给主机\n\n# 4.4.3 ICMP协议\n\n 1. 网际控制报文协议ICMP：支持主机或路由器差错/异常报告或网络探询。（发送特定ICMP报文）\n 2. ICMP报文：类型+代码+检验和+ICMP数据部分（IP数据报首部+8字节）\n\n# ICMP差错报告报文\n\n 1. 终点不可达（无法交付）\n 2. 源点抑制（拥塞丢数据）\n 3. 时间超过（TTL=0）\n 4. 参数问题（首部字段有问题）\n 5. 改变路由/重定向（存在更好的路由路径）\n\n# 不发送情况\n\n 1. ICMP差错报告报文\n 2. 对第一个分片数据报片的所有后续数据报片\n 3. 具有组播地址的数据报\n 4. 具有特殊地质的数据报\n\n# ICMP询问报文\n\n 1. 回送请求和回答报文：测试目的站是否可达以及了解其相关状态\n 2. 时间戳请求和回答报文\n 3. 掩码地址请求和回答报文\n 4. 路由询问和通告报文\n\n# ICMP应用\n\n 1. PING：测试两个主机间的连通性，使用ICMP回送请求和回答报文\n 2. Traceroute：跟踪一个分组从源点到终点的路径，使用ICMP时间超过差错报告报文\n\n\n# 4.5 IPv6\n\n# 4.5.1 产生原因\n\n 1. 从根本上上解决地址耗尽问题\n 2. 改进首部格式，达成快速处理和转发数据报的功能\n 3. 支持QoS，指一个网络能够利用各种基础技术为指定的网络通信提供更好的服务能力\n\n# 4.5.2 IPv6数据报格式\n\n# 基本首部\n\n 1. 40字节\n 2. 版本：指明协议版本，4字节\n 3. 优先级：区分数据报的类别和优先级，8字节\n 4. 流标签：属于同一个流的数据报都具有同样的流标签，20字节\n 5. 有效载荷长度：有效载荷部分*（扩展首部+数据部分）的长度\n 6. 下一个首部：下一个扩展首部或上层协议首部，指向扩展首部1\n 7. 跳数限制：相当于TTL，生存时间\n 8. 源地址，128位\n 9. 目的地址，128位\n\n# 有效载荷\n\n 1. 扩展首部\n 2. 数据部分\n 3. 加起来不能超过65535字节\n\n# 4.5.3 与IPv4的区别\n\n 1.  IPv6将地址从32位（4B）扩展到了128位（16B），更大的地址空间\n 2.  IPv6将IPv4的校验和字段车底移除，减少每跳的处理时间\n 3.  IPv6将IPv4的可选字段移除首部，变成了扩展首部，成为灵活的首部格式，路由器通常不对扩展首部进行检查，大大提高了路由器的处理效率\n 4.  IPv6支持即插即用（自动配置），不需要DHCP协议\n 5.  IPv6首部长度必须是8B的整数倍；IPv4首部长度必须是4B的整数倍\n 6.  IPv6只能在主机处分片，IPv4可以在路由器和主机处分片\n 7.  ICMPv6：附加报文类型“分组过大”\n 8.  IPv6支持资源的预分配，支持实施视像等要求，保证一定的带宽和时延的应用\n 9.  IPv6取消了协议字段，改成下一个首部字段\n 10. IPv6取消了总长度字段，改用有效载荷长度字段\n 11. IPv6取消了服务类型字段\n\n# 4.5.4 IPv6地址表示形式\n\n 1. 一般形式：冒号十六进制记法\n 2. 压缩形式：前面有0的情况，删减0\n 3. 零压缩：一连串连续的0可以被一堆冒号取代，双冒号表示法在一个地址中仅可出现一次\n\n# 4.5.5 IPv6基本地址类型\n\n 1. 单播：一对一通信，可做源地址和目的地址\n 2. 多播：一对多通信，只能作为目的地址\n 3. 任播：一对多中的一个通信，只能作为目的地址\n\n# 4.5.6 IPv6项IPv4过渡策略\n\n# 双栈协议\n\n 1. 在一台设备上同时启用IPv4协议栈和IPv6协议栈\n 2. 路由器：不同接口上分别配置了IPv4地址和IPv6地址\n 3. 计算机：同时拥有IPv4地址和IPv6地址，并具备同时吃力这两个协议地址的功能\n\n# 隧道技术\n\n 1. 将其他协议的数据帧或包重新封装然后通过隧道发送\n\n\n# 4.6 路由协议\n\n# 4.6.1 路由算法与路由协议概述\n\n# 路由算法\n\n 1. 最佳路由：“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已\n\n# 路由算法分类\n\n 1. 静态路由算法（非自适应路由算法）：管理员手工配置路由信息\n    * 优点：简便、可靠，在负载稳定、拓扑变化不大的网络中运行效果好\n    * 缺点：路由更新慢。不适用大型网络\n 2. 动态路由算法（自适应路由算法）：路由器之间彼此家坡缓信息，按照路由算法优化出路由表项\n    * 优点：路由更新快，适用大型网络，及时响应链路费用或拓扑变化\n    * 缺点：算法复杂，增加网络负担\n    * 全局性动态路由算法：链路状态路由算法OSPF 所有路由器掌握完整的网络拓扑和链路费用信息\n    * 分散性动态路由算法：距离向量路由算法RIP 路由只掌握物理相连的邻居及链路费用\n\n# 路由协议\n\n 1. 自治系统AS：在单一的技术管理下的一组路由器。而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS之间的路由协议以确定在AS之间的路由 一个AS内的所有网络都数据一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通\n 2. 内部网关协议IGP，一个AS内使用的，如RIP、OSPF\n 3. 外部网关协议EGP，AS之间使用的，如BGP\n\n# 4.6.2 RIP协议\n\n 1. RIP是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大优点是简单\n 2. 要求网络中每一个路由器都维护从它自己到其他每一个目的网络的位移最佳距离记录（一组距离）\n 3. 距离：通常为跳数，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。\n    * 从一路由器到直接连接的网络距离为1\n    * RIP允许一条路由最多智能包含15个路由器（RIP只适用小的互联网）\n    * 距离16表示网络不可达\n 4. 仅和相邻路由器交换信息\n 5. 路由器交换的信息时自己的路由表\n 6. 每30秒交换一次路由信息，然后路由器根据信息系更新路由表\n 7. 若180s没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表\n\n# 距离向量算法\n\n 1. 修改相邻路由器发来的RIP报文中所有表项：距离+1，下一跳改为邻居\n 2. RIP报文填入路由表\n    * 路由器没有报文中的网络，直接填入\n    * 路由器中有报文中的网络\n      * 路由器中下一跳是邻居，直接更新（最新）\n      * 路由器中下一跳不是邻居，若路由表中距离更远则更新（最短）\n 3. 180s没收到相邻路由器的更新路由表，则把邻居距离设置为16\n\n# RIP报文\n\n\n\n 1. RIP是应用层协议，使用UDP传送数据\n 2. 一个RIP报文最多可以包括25个路由，若超过则发送几个RIP报文\n\n# RIP协议特点\n\n 1. 慢收敛：当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器\n\n# 4.6.3 OSPF协议\n\n 1. 开放最短路径优先OSPF协议，其中开放指不受某一家厂商控制，而是公开发表；使用了最短路径算法SPF\n 2. OSPF最主要的特征：使用分布式的链路状态协议\n\n# OSPF协议特点\n\n 1. 使用洪泛法向自治系统内所有路由器发送信息\n 2. 发送的信息位本路由器相邻的所有路由器的链路状态\n 3. 只有当链路状态发生变化时，路由器猜想所有路由器洪泛发送信息\n 4. 所有路由器建立一个链路状态数据库，即全网拓扑图\n 5. 每隔30min，要刷新一次数据库中的链路状态\n 6. 常用于互联网规模很大\n 7. OSPF不存在坏消息传得慢的问题，收敛速度很快\n\n# 链路状态路由算法\n\n 1. 每个路由器发现他的邻居结点hello问候分组，并两节邻居节点的网络地址\n 2. 设置到它的每个邻居的成本度量metric\n 3. 构造DD数据库描述分组，向邻站给出自己的链路状态数据库中的额所有链路状态项目的摘要信息\n 4. * 如果DD分组中的摘要都有，不作处理\n    * 如果存在没有或者更新的，则发送LSR链路状态请求分组，请求更新自己没有的和比自己更新的信息\n 5. 收到邻站的LSR分组后，发送LSU链路状态更新分组进行更新\n 6. 更新完毕后，邻站返回一个LSAck链路状态确认分组进行确认\n 7. 是有Dijkstra根据自己的链路状态数据库构造到其他结点间的最短路径\n\n# OSPF区域\n\n 1. 区域：为了使用与规模很大的网络，OSPF将一个自制系统再划分为若干个更小的范围\n 2. 每个范围有32位的区域标志符，一个区域不超过200个路由器\n 3. 主干区域0.0.0.0\n 4. 主干路由器、区域边界路由器\n\n# OSPF分组\n\n直接使用IP数据报传送\n\n# 4.6.4 BGP协议\n\n 1. BGP发言人一般是BGP边界路由器\n\n# BGP协议特点\n\n 1. 与其他AS邻站发言人交换信息\n 2. 交换网络可达性的信息：即要到达某个网络所要经过一系列AS\n 3. 发生变化时更新变化的部分\n 4. BGP支持CIDR，因此BGP的路由表应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列\n\n# BGP协议交换信息的过程\n\nBGP所交换的网络可达性的信息就是要达到某个网络所要经过的一系列AS。当BGP发言人互相贾环了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各AS的较好路由\n\n# BGP协议报文格式\n\n 1. BGP报文=BGP报文通用首部+BGP报文主体部分\n 2. IP首部+TCP首部+BGP报文\n 3. BGP是应用层协议，借助TCP传送\n\n# BGP-4报文\n\n 1. OPEN打开报文：用来与相邻的另一个BGP发言人建立关系，并认证发送方\n 2. UPDATE更新报文：通告新路径或撤销原路径\n 3. KEEPALIVE保活报文：在无UPDATE时，手气性证实邻站的连通性；也作为OPEN的确认\n 4. NOTIFICATION通知报文：报告先前报文的差错；也被用于关闭连接\n\n\n# 4.7 IP组播（多播）\n\n# 4.7.1 IP数据报的三种传输方式\n\n 1. 单播：用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播IP地址作为目的地址。是一种点对点传输方式\n 2. 广播：发送数据包到同一广播域或子网内的所有设备的一种数据传输方式。是一种点对多点传输方式\n 3. 组播（多播）：当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据报建立组播分发树，被传输的数据到达距离用户端尽可能近的结点后才开始复制和分发，是一种点对多点传输方式\n\n# 4.7.2 IP组播地址\n\n 1. IP组播地址：让源设备能够将分组发送给一组设备。属于同一多播组的设备奖杯分配一个组播组IP地址\n 2. 组播地址范围为224.0.0.0~239.255.255.255（D类地址），一个D类地址表示一个组播组。只能用作分组的目标地址。源地址总是单播地址\n 3. 组播数据报是“尽最大努力交付”，不提供可靠交付，应用于UDP\n 4. 对组播数据报不产生ICMP差错报文\n 5. 并非所有D类地址都可以作为组播地址\n\n# 4.7.3 硬件组播\n\n 1. IP地址与MAC地址有映射关系\n\n# 4.7.4 IGMP协议\n\n 1. IGMP网际组管理协议，让路由器指导本局域网上是否有主机（的进程）参加或推出了某个组播组\n\n# IGMP工作的两个阶段\n\n 1. 某主机要加入组播组时，该主机箱组播组的组播地址发送一个IGMP报文，声明自己要成为该组的成员\n 2. 本地组播路由器收到IGMP报文后，要利用组播路由选择协议报这组成员关系发给因特网上的其他组播路由器\n 3. 本地组播路由器周期性探寻本地局域网上的主机，以便指导这些主机是否还是组播组的成员\n 4. * 有一个主机对某个组响应，则组播路由器认为该组活跃\n    * 探询几次后没有响应，组播路由器不再将这组的成员关系发给其他的组播路由器\n    * 成员关系：所连接的局域网中有无组播组成员\n\n# 4.7.5 组播路由选择协议\n\n 1. 组播路由选择协议的目的是找出以源主机为根节点的组播转发树\n 2. 基于链路状态的路由选择\n 3. 基于距离-向量的路由选择\n 4. 协议无关的组播（稀疏/密集）\n\n\n# 4.8 移动IP\n\n# 4.8.1 相关术语\n\n 1. 移动IP技术：移动结点（计算机/服务器等）以固定的网络IP地址，实现跨越不同网段的漫游功能，保证基于网络IP的网络权限在漫游过程中不发生任何改变\n 2. 移动结点：具有永久IP地址的移动设备\n 3. 归属网络：一个移动结点拥有的旧居所\n 4. 归属代理（本地代理）：在归属网络中代表移动结点执行移动管理功能的实体\n 5. 外部代理（外地代理）：在外部网络中帮助移动结点完成移动管理功能的实体\n 6. 永久地址（归属地址/主地址）：移动站点在归属网络中的原始地址\n 7. 转交地址（辅地址）：移动站点在外部网络使用的临时地址\n\n# 4.8.2 通信过程\n\n# 计算机A刚进入外部网络\n\n 1. 在外部代理登记获得一个转交地址，离开时注销\n 2. 外地代理向本地代理登记转交地址\n\n# 计算机B向A发送数据报\n\n 1. 本地代理截获数据报\n 2. 本地代理再封装数据报，新数据宝目的地址是转交地址，发给外部代理（隧道）\n 3. 外部代理拆封数据报并发送给A\n\n# 计算机A向B发送数据报\n\nA用自己的主地址作为数据报源地址，用B的IP地址作为数据报的目的地址\n\n# 计算机A移动到下一个网络\n\n 1. 注销原有的转交地址\n 2. 在新外部代理登记注册一个转交地址\n 3. 新外部代理给本地代理发送新的转交地址（覆盖旧的）\n\n# 计算机A回到归属网络\n\n 1. A向本地代理注销转交地址\n\n\n# 4.9 网络层设备\n\n# 4.9.1 路由器\n\n 1. 路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组\n 2. 路由器选择处理机：根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表\n 3. 交换结构：根据转发表（路由表得来）对分组进行转发\n\n# 输入端口对线路上收到的分组的处理\n\n 1. 从线路接收分组\n 2. 物理层处理\n 3. 数据链路层处理\n 4. 网络层处理分组排队、查表和转发\n 5. 会产生时延\n 6. 输入端口中的查找和转发功能在路由器的交换功能中是最重要的\n\n# 输出端口对线路上收到的分组的处理\n\n 1. 网络层分组排队，缓存管理\n 2. 数据链路层处理\n 3. 物理层处理\n 4. 若路由器处理分组的速率赶不上分组进入队列的速率，则后面无法缓存的分组被丢弃\n 5. 路由器中的输入或输出队列产生移除是造成分组丢失的重要原因\n\n# 4.9.2 路由表与路由转发\n\n 1. 路由表根据路由选择算法得出，主要用途是路由选择，用软件来实现\n 2. 转发表是由路由表得来，可以用软件实现也可以用特殊的硬件来实现\n\n\n# 5 传输层\n\n 1. 只有主机才有的层次\n 2. 为应用层提供通信服务，使用网络层的服务\n\n\n# 5.1 功能\n\n 1. 提供进程和进程之间的逻辑通信（网络层是主机与主机）\n 2. 复用和分用\n 3. 对收到的报文进行差错检测\n\n\n# 5.2 协议\n\n 1. TCP：面向连接的传输控制协议；可靠，面向连接，时延大，适用于大文件\n 2. UDP：无连接的用户数据报协议；不可靠，无连接，时延小，适用于小文件\n\n\n# 5.3 寻址与端口\n\n 1. 复用：应用层所有的应用进程都可以通过传输层再传输到网络层\n 2. 分用：传输层从网络层收到数据后交付指明的应用进程\n\n# 5.3.1 软件端口\n\n 1. 软件端口是传输层的SAP，表示主机中的应用进程\n 2. 端口号只有本地意义，在因特网中不同计算机的相同端口号是没有联系的\n 3. 端口号长16bit，65536个\n 4. 端口号\n    * 服务端\n      * 熟知端口号（0~1023）：TCP/IP最重要的应用程序，所有用户都知道\n      * 登记端口号（1024~4951）：没有熟知端口号的应用程序使用\n    * 客户端（49152~65535）：尽在客户进程运行时才动态选择\n 5. 套接字：位移表示网络的一个主机和它上面的一个进程（主机IP地址+端口号）\n\n\n# 5.4 UDP\n\n 1. 只在IP数据报服务上增加很少功能：复用分用和差错检测功能\n\n# 5.4.1 特点\n\n 1. 无连接，减少开销和发送数据之前的时延\n 2. 使用最大努力交付，不保证可靠交付\n 3. 面向报文的，适合一次性传输少量数据的网络应用\n    * 面向报文：不会剪切和整合应用层报文\n 4. 无拥塞控制，适合实时应用\n 5. 首部开销少。8B\n\n# 5.4.2 首部格式\n\n16位源端口号+16位目的端口号+16位UDP长度+16位UDP检验和\n\n# 5.4.3 UDP校验\n\n# 发送端\n\n 1. 填上伪首部\n 2. 全0填充检验和字段\n 3. 全0填充数据部分（满足4B的整数倍）\n 4. 伪首部+首部+数据部分采用二进制反码求和\n 5. 把和求反码填入校验和字段\n 6. 去掉伪首部，发送\n\n# 接收端\n\n 1. 填上伪首部\n 2. 伪首部+首部+数据部分采用二进制反码求和\n 3. 结果全为1则无差错，否则丢弃数据报或者交给应用层附上出差错的警告\n\n\n# 5.5 TCP\n\n# 5.5.1 特点\n\n 1. 面向连接（虚连接）的传输层协议\n 2. 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的\n 3. TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达\n 4. TCP提供全双工通信（TCP协议两段都会有发送缓存和接受缓存）\n    * 发送缓存：准备发送的数据；已发送但尚未收到确认的数据\n    * 接收缓存：按序到达但尚未被接受应用程序读取的数据；不按序到达的数据\n 5. TCP面向字节流：TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流\n    * 流：流入到进程或从进程流出的字节序列\n\n# 5.5.2 TCP报文段首部格式\n\n 1.  TCP报文 = TCP首部+TCP数据部分\n 2.  TCP首部是4字节的整数倍\n 3.  源端口+目的端口+序号+确认号+数据偏移+保留+6个控制位+窗口+校验和+紧急指针+选项（长度可变）+填充\n 4.  序号：在一个TCP连接中传输的字节流中的每个字节都按顺序编号，本字段表示本报文段所发送的第一个字节的序号\n 5.  确认号：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N。则证明到序号N-1为止的所有数据都已正确收到\n 6.  数据偏移（首部长度）：TCP报文段的数据起始处距离TCP报文段的起始处有多远。以4B为单位，1个数值是4B\n 7.  控制位：\n     * 紧急位URG：为1时，表明次报文段中有紧急数据，是高优先级的数据，不用在缓存里排队，配合紧急指针字段使用\n     * 确认位ACK：为1时，确认号有效，在连接建立后所有传送的报文段都必须把ACK置1\n     * 推送位PSH：为1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付\n     * 复位RET： 为1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输连接；可以用来拒绝非法报文段或者打开链接\n     * 同步位SYN：为1时，表明这是一个连接请求/连接接受报文\n     * 终止位FIN：为1时，表明此报文段发送方数据已发完，要求释放连接\n 8.  窗口：发送本报文的一方的接收窗口，即现在允许对方发送的数据量\n 9.  检验和：检验首部+数据，检验时要加上12B伪首部\n 10. 紧急指针。在URG为1时才有意义，支出本报文段中紧急数据的字节数\n 11. 选项：最大报文段长度MSS、窗口扩大、时间戳、选择确认\n\n# 5.5.3 TCP连接管理\n\n 1. 三个阶段：连接建立+数据传输+连接释放\n 2. TCP连接的建立采用客户端服务器方式，主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器\n\n# TCP连接建立——三次握手\n\n 1. 客户端发送连接请求报文段，无应用层数据\n    * SYN=1，序号seq=x（随机）\n 2. 服务端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据\n    * SYN=1，ACK=1，序号seq=y（随机），确认号ack=x+1\n 3. 客户端为该TCP连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据\n    * SYN=1，ACK=1，序号seq=x+1，确认号ack=y+1\n 4. ps：SYN洪泛攻击：发送大量三次握手的第一次报文，且一直不确认，设置SYN cookie\n\n# TCP连接释放——四次握手\n\n 1. 参与一条TCP连接的两个进程中的任何一个都能终止该连接，连接结束后，主机中的“资源”（缓存和变量）将被释放\n 2. 客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接\n    * FIN=1，序号seq=u\n 3. 服务器端会送一个确认报文段，客户到服务器这个方向的连接就释放了（半关闭状态）\n    * ACK=1，序号seq=v，确认号ack=u+1\n 4. 此处服务器端还可以发送数据\n 5. 服务器端发完数据，就送连接释放报文段，主动关闭TCP连接\n    * FIN=1，ACK=1，序号seq=w，确认号ack=u+1\n 6. 客户端会送一个确认报文段，再等到时间等待计时器设置的2MSL（最长报文段寿命）后，连接彻底关闭\n    * ACK=1,序号seq=u+1，确认号ack=w+1\n\n# 5.5.4 TCP可靠传输\n\n 1. 可靠：保证接收方进程熊缓存区读出的字节流与发送方发出的字节流是完全一样的\n 2. TCP实现可靠传输的机制：校验、序号、确认、重传\n\n# 校验\n\n 1. 与UDP校验一样。增加伪首部\n\n# 序号\n\n 1. 一个字节占一个序号\n 2. 序号字段指的是一个报文段第一个字节的序号\n\n# 确认\n\n# 重传\n\n 1. 确认重传不分家。TCP的发送方在规定时间内没有收到确认就要重传已发送的报文段\n 2. TCP采用自适应算法，动态改变重传时间RTTs（加权平均往返时间）\n 3. 冗余ACK（冗余确认）：每当比希望序号的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节序号\n    * 发送方收到3个对于某个报文段的冗余ACK时，认为下一报文段丢失，重传（快速重传）\n\n# 5.5.5 TCP流量控制\n\n 1. TCP利用滑动窗口机制实现流量控制，发送窗口大小动态变化\n 2. 在通信过程中，接收方根据自己接受缓存的大小，动态地调整发送方的放松窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来讲rwnd通知给发送方），发送方的发送窗口取接受窗口rwnd和拥塞窗口cwnd的最小值\n 3. TCP为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器\n 4. 若持续计时器设置的时间到期，就发送一个零窗口探测报文段。接收方收到探测报文段时给出现在的窗口值\n 5. 若窗口仍是0，那么发送方就重新设置持续计时器\n\n# 5.5.6 TCP拥塞控制\n\n 1. 出现拥塞的条件：对资源需求的总和> 可用资源；网络中有许多资源同时呈现供应不足，导致网络性能变坏，导致网络吞吐量随输入负荷增大而下降\n 2. 拥塞控制的目的：防止过多的数据注入到网络中，是一个全局性的\n\n# 假定\n\n 1. 数据单方向传送，而另一个方向只传送确认\n 2. 接收方总是有足够大的缓存空间，因而发送窗口大小只取决于拥塞程度\n\n# 慢开始和拥塞避免算法\n\n 1. 一个传输轮次\n    * 发送了一批报文段并收到它们的确认的时间\n    * 一个往返时延RTT\n    * 开始发送一批拥塞窗口内的报文段到开始发送下一批拥塞窗口内的报文段的时间\n\n# 快重传和快恢复\n\n\n\n\n# 6 应用层\n\n\n# 6.1 概述\n\n 1. 应用层对应用程序的通信提供服务\n 2. 应用层协议内容：\n    * 应用进程交换的报文类型\n    * 各种报文类型的语法\n    * 字段的语义\n    * 进程何时、如何发送报文，以及对报文进行响应的规则\n 3. 应用层功能：\n    * 文件传输、访问和管理\n    * 电子邮件\n    * 虚拟终端\n    * 查询服务和远程作业登录\n 4. 应用层的重要协议\n    * FTP\n    * SMTP、POP3\n    * HTTP\n    * DNS\n\n\n# 6.2 网络应用模型\n\n# 6.2.1 客户/服务器模型\n\n 1. 服务器：提供计算服务的设备\n    * 永久提供服务\n    * 永久性访问地址/域名\n 2. 客户机： 请求服务的主机\n    * 与服务器通信，使用服务器提供的服务\n    * 间歇性接入网络\n    * 可能使用动态IP地址\n    * 不与其他客户机直接通信\n 3. 应用：Web，文件传输TFP，远程登录，电子邮件\n\n# 6.2.2 P2P模型\n\n 1. 不存在永远在线的服务器\n 2. 每个主机既可以提供服务，也可以请求服务\n 3. 任意端系统/节点之间可以直接通讯\n 4. 节点间歇性接入网络\n 5. 节点可能改变IP地址\n 6. 可扩展性好\n 7. 网络健壮性强\n\n\n# 6.3 域名解析系统DNS\n\n# 6.3.1 域名\n\n 1. 域名从前往后级别依次提高。最后一个.后的是顶级域名，往前是二级域名等等\n 2. 顶级域名：\n    * 国家顶级域名：cn、us、uk\n    * 通用顶级域名：com、net、org、gov、int、aero、museum、travel\n    * 基础结构域名/反向域名：arpa\n 3. 二级域名：\n    * 类别域名：ac、com、edu、gov、mil、org\n    * 行政区域名，用于我国各省、自治区、直辖市：bj、js\n    * 自己注册的\n\n# 6.3.2 域名服务器\n\n# 根域名服务器\n\n 1. 最高层次的域名服务器，也是最重要的\n 2. 知道所有顶级域名服务器的域名和IP地址\n 3. 一共有13个不同名字的根域名服务器\n\n# 顶级域名服务器\n\n 1. 管理该顶级域名服务器注册的所有二级域名和IP地址\n\n# 权限域名服务器\n\n 1. 负责一个区的域名服务器\n 2. 区：\n\n# 本地域名服务器\n\n 1. 不属于域名服务器层次结构\n 2. 当一个主机发出DNS查询请求时，这个查询请求报文就发给本地域名服务器\n\n# 6.3.3 域名解析过程\n\n# 递归查询\n\n# 迭代查询\n\n\n# 6.4 文件传输协议FTP\n\n 1. 提供不同种类主机系统（硬、软件体积等都可以不同）之间的文件传输能力\n\n# 6.4.1 FTP服务器和用户端\n\n 1. FTP是基于客户/服务器的协议：用户通过一个客户机程序连接至在远程计算机上运行的服务器程序\n 2. 依照FTP协议提供服务，进行文件传送的计算机就是FTP服务器\n 3. 连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是FTP客户端\n\n# 6.4.2 FTP工作原理\n\n# 登录\n\n 1. 输入ftp地址，用户名和密码\n 2. 可以采用匿名登录的方式\n\n# 数据传输\n\n 1. FTP使用TCP实现可靠传输\n 2. FTP服务器进程：\n    * 1个主进程\n    * n个从属进程\n 3. 控制进程和数据传送进程都属于从属进程\n 4. 控制连接始终保持，客户端和服务器端存在会话就保持\n 5. 数据连接保持一会儿\n 6. 是否使用TCP 20端口建立数据连接与传输模式有关\n 7. 主动方式使用TCP 20端口；被动方式有服务器和客户端自行协商决定（端口>1024）\n\n# 传输模式\n\n 1. 文本模式：ASCII模式，以文本序列传输数据\n 2. 二进制模式：Binary模式，以二进制序列传输数据\n\n\n# 6.5 电子邮件\n\n# 6.5.1 电子邮件系统概述\n\n# 电子邮件信息格式\n\n 1. 电子邮件包括信封和内容两个部分\n 2. 信封：信息主要包括收件人邮箱地址\n 3. 内容：\n    * 首部：To和Subject\n    * 主体：写信的内容\n\n# 电子邮件系统组成结构\n\n 1. 用户代理：电子邮件客户端软件\n 2. 用户代理功能\n    * 撰写\n    * 显示\n    * 处理\n    * 通信\n 3. 邮件服务器功能：\n    * 发送和接收邮件：\n    * 向发件人报告邮件传送结果\n 4. 协议\n    * SMTP：发送\n    * POP3、IMAP：接收\n\n\n# 6.6 万维网\n\n 1. 万维网www是一个大规模的、联机式的信息储藏所/资料空间，是无数个网络站点和网页的集合\n 2. 统一资源定位符URL唯一识别资源\n 3. URL一般形式：<协议>://<主机>:<端口>/<路径>\n    * 协议：http、ftp\n    * 主机：域名、IP地址\n 4. 用户通过点击超链接获取资源，这些资源通过超文本传输协议（HTTP）传送给使用者\n 5. 万维网以客户/服务器方式工作，用户使用的留恋其就是万维网客户程序，万维网文档所驻留的主机运行服务器程序\n 6. 万维网使用超文本标记语言HTML，使得万维网月面设计者可以很方便地从一个界面的连接转到另一个界面，并能够在自己的屏幕上显示出来\n\n\n# 6.7 超文本传输协议HTTP\n\n 1. HTTP协议定义了浏览器（万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器\n\n# 6.7.1 HTTP协议过程\n\n 1. 用户浏览页面方法：\n    * 输入URL\n    * 点击超链接\n 2. HTTP过程：\n    * 浏览器分析URL\n    * 丽蓝旗向DNS请求解析IP地址\n    * DNS解析出IP地址\n    * 浏览器与服务器建立TCP连接\n    * 浏览器发出取文件命令\n    * 服务器响应\n    * 释放TCP连接\n    * 浏览器显示\n\n# 6.7.2 HTTP协议特点\n\n 1. HTTP协议是无状态的，无记忆的\n    * 这样诞生了存储用户主机中的文本文件Cookie，记录一段时间内用户的访问记录\n 2. HTTP采用TCP作为运输层协议，但HTTP协议本身是无连接的（通信双方在交换HTTP报文之前不需要先建立HTTP连接）\n 3. HTTP连接方式\n    * 持久连接Keep-alive\n      * 非流水线\n      * 流水线\n    * 非持戒连接Close\n    * \n\n# 6.7.3 HTTP协议报文结构\n\n 1. HTTP报文是面向文本的，因此在报文中的每一个字段都是一些ASCII码串\n 2. HTTP报文分成请求报文和响应报文\n 3. \n 4. 状态码\n    * 1xx：表示通知信息的，如请求收到了或正在处理\n    * 2xx：表示成功，如接受或知道了\n    * 3xx：表示重定向，如要完成请求还必须采取进一步的行动\n    * 4xx：表示客户的差错，如请求中有错误的语法或不能完成\n    * 5xx：表示服务器的差错，如服务器失效无法完成请求",normalizedContent:"网络体系结构（5层）、各层协议、典型网络、网络设备\n\n\n# 1 概述\n\n\n\n\n# 1.1 计算机网络概念\n\n网络包含计算机网络 计算机网络：一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统 计算机网络是互连的、自治的计算机集合 互连：互联互通，计算机相互之间连通，能通信；自治：计算机之间不存在主从关系，不能彼此控制对方\n\n\n# 1.2 计算机网络功能\n\n 1. 数据通信（最重要） 保证连通性\n 2. 资源共享（主要） 三大类：硬件资源共享；软件资源共享；数据资源共享\n 3. 分布式处理 多台计算机各自承担同一工作任务的不同部分 常见平台：hadoop（大数据常用）\n 4. 提高可靠性 存在替代机，\n 5. 负载均衡 分布式处理达到的效果\n\n\n# 1.3 计算机网络的组成\n\n# 1.3.1 组成部分\n\n 1. 硬件：主机（端系统）、链路（例如光纤）、通信设备（路由器等）\n 2. 软件：安装在端系统上的应用软件\n 3. 协议（计算机网络的协议）：一系列规则和约定的集合\n\n# 1.3.2 工作方式\n\n 1. 边缘部分：主机存在的部分、用户直接使用的；两种通信方式（c/s；p2p）\n 2. 核心部分：为边缘部分服务\n\n# 1.3.3 功能组成\n\n 1. 通信子网：实现数据通信；各种传输介质、通信设备、相应网络协议组成\n 2. 资源子网：实现资源共享、数据处理；实现资源共享功能的设备和软件的集合\n\n\n# 1.4 计算机网络的分类\n\n# 1.4.1 按分布范围\n\n 1. 广域网：交换技术\n 2. 城域网\n 3. 局域网：广播技术\n 4. 个人区域网\n\n# 1.4.2 按使用者\n\n 1. 公用网\n 2. 专用网\n\n# 1.4.3 按交换技术\n\n 1. 电路交换\n 2. 报文交换\n 3. 分组交换\n\n# 1.4.4 按拓扑结构\n\n 1. 总线型\n 2. 星型\n 3. 环型\n 4. 网状型（常用于广域网）\n\n# 1.4.5 按传输技术\n\n 1. 广播式网络：共享公共通信信道\n 2. 点对点网络：使用分组存储转发和路由选择机制\n\n\n# 1.5 标准化工作\n\n# 1.5.1 标准分类\n\n 1. 法定标准：由权威机构指定的正式的、合法的标准（osi）\n 2. 事实标准：产品长期占据主流，产品中的协议进而技术（tcp/ip）\n\n# 1.5.2 rfc因特网标准形式\n\n上升成为因特网正式标准的四个阶段\n\n 1. 因特网草案\n 2. 建议标准：正式成为rfc文档\n 3. 草案标准\n 4. 因特网标准\n\n# 1.5.3 标准化相关组织\n\n 1. iso ：国际化标准组织\n 2. itu：国际电信联盟\n 3. ieee：国际电气电子工程师协会\n 4. ietf：internet工程任务组\n\n\n# 1.6 计算机网络性能\n\n# 1.6.1 速率\n\n速率即数据率或数据传输率或比特率 比特：数据量的单位 速率：连接在计算机网络的主机在数字信道上传送数据位数的速率 速率单位的换算是10^3，但存储容量是2^10=1024 存储容量中1byte（字节）= 8bit（比特）\n\n# 1.6.2 带宽\n\n带宽原本指某个信号具有的频带宽度，即最高频率与最低频率只差，单位是赫兹 在计算机网络中，带宽用来表示网络的通信线路传送数据的能力 通常指单位时间内从网络中某一点到另一点所能通过的“最高数据率” 单位是比特每秒，b/s 带宽是网络设备所支持的最高速度\n\n# 1.6.3 吞吐量\n\n单位时间内通过某个网络的数据量，单位b/s 吞吐量手网络的带宽或网络的额定速率的限制\n\n# 1.6.4 时延\n\n指数据从网络的一端传送到另一端所需要的时间，也叫延迟或迟延。单位是s 时延分成4大类\n\n 1. 发送时延（传输时延）：发送分组的第一个比特算起，到改分组的最后一个比特发送完毕所需的时间 发送时延=数据长度/信道带宽（发送速率）\n 2. 传播时延：电磁波在信道中传播一定距离花费的时间 取决于电磁波传播速度和链路长度 传播时延=信道长度/电磁波在信道上的传播速率\n 3. 排队时延：等待输出、输入链路中花费的时间\n 4. 处理时延：主机或路由器在收到分组时花费的时间\n\n# 1.6.5 时延带宽积\n\n时延带宽积（bit） = 传播时延（s） * 带宽（b/s） 描述数据量、信息量的性能属性 以比特为单位的链路长度，链路数据容量\n\n# 1.6.6 往返时延rtt\n\n从发送方发送数据开始（第一个比特位发送），到发送发收到接收方的确认（第一个比特确认），急售房收到数据后立即发送确认，总工经历的时延 rtt越大，在收到确认之前，可以发送的数据越多 rtt = 2*传播时延+末端处理时间\n\n# 1.6.7 利用率\n\n 1. 信道利用率 = 有数据通过的时间/（有+无）数据通过时间\n 2. 网络利用率 = 信道利用率加权平均值\n\n\n# 1.7 分层结构\n\n# 1.7.1 分层的基本原则\n\n服务：每两层之间提供的东西，上层是使用下层服务，下层为上层服务 分层的基本原则：\n\n 1. 各层之间相互独立，每层只实现一种相对独立的功能\n 2. 每层之间的界限自然清晰，易于理解，相互交流尽可能少\n 3. 结构上可分割开。每层都采用最适合的技术来实现\n 4. 保持下层对上层的独立性，上层单向使用下层提供的服务\n 5. 整个分层结构应该能促进标准化工作\n\n# 1.7.2 分层中的概念\n\n 1. 实体：第n层中的活动元素称为n层实体\n 2. 对等实体：同一层的实体\n 3. 协议：对进行网络中的对等实体数据交换而建立的规则、标准或约定（水平的） 协议三要素：语法（传输数据的格式）；语义（规定所要完成的功能）；同步（规定各种操作顺序）\n 4. 接口（访问服务店sap）：上层使用下层服务的入口\n 5. 服务：下层为响铃上层提供的功能调用（单向、垂直）\n 6. sdu（服务数据单元）：为完成用户所要求的的功能而应传送的数据\n 7. pci（协议控制信息）：控制协议操作的信息\n 8. pdu（协议数据单元）：对等层次之间传送的数据单元\n 9. 计算机网络体系结构是计算机网络的各层及其协议的集合\n\n\n# 1.8 计算机网络分层结构\n\n# 1.8.1 osi参考模型\n\n法定标准；7层（物联网淑惠试用） 目的：支持异构网络体系的互联互通 自下而上：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 通信子网（数据通信）：物理层、数据链路层、网路层 资源子网（数据处理）：应用层、表示层、会话层\n\n# 应用层\n\n用户与网络的界面，所有能和用户交互产生网络流量的程序 常见应用层服务：文件传输（ftp）、电子邮件（smtp）、万维网（http）\n\n# 表示层\n\n用于处理再两个通信系统中交换信息的表示方式（语法和语义） 功能：\n\n 1. 数据格式变换\n 2. 数据加密解密\n 3. 数据压缩和恢复\n\n# 会话层\n\n像表示层实体/用户进程提供简历连接并在连接上有序地传输数据，会话，也是建立同步 会话之间彼此独立互不影响 功能：\n\n 1. 建立、管理、终止会话\n 2. 使用校验点可使会话在通信失效时从校验点（同步点）继续恢复通信，实现数据同步 主要协议：adsp、asp\n\n# 传输层\n\n负责主机中两个进程的通信，即端到端的通信。传输单位是报文段或用户数据报 功能：\n\n 1. 可靠传输（有确认机制）、不可靠传输\n 2. 差错控制\n 3. 流量控制\n 4. 复用分用 主要协议：tcp、udp\n\n# 网络层\n\n把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务 网络层的传输单位是数据报 功能：\n\n 1. 路由选择\n 2. 流量控制\n 3. 差错控制\n 4. 拥塞控制 主要协议：ip、ipx等\n\n# 数据链路层\n\n把网络层传下来的数据报组装成帧 传输单位：帧 功能：\n\n 1. 成帧（定义帧的开始和结束）\n 2. 差错控制（帧错、位错）\n 3. 流量控制\n 4. 访问（接入）控制，控制对信道的访问 主要协议：sdlc、hdlc、ppp、stp\n\n# 物理层\n\n物理媒体上实现比特流的透明传输 传输单位：比特 透明传输：不管所传数据是怎样的比特组合都应当能在链路上传送 功能：\n\n 1. 定义接口特性\n 2. 定义传输模式\n 3. 定义传输速率\n 4. 比特同步\n 5. 比特编码 主要协议：rj45、802.3\n\n# 1.8.2 tcp/ip参考模型\n\n事实标准；4层\n\n# 网络接口层\n\nhttp、ftp、dns\n\n# 网际层\n\ntcp、udp\n\n# 传输层\n\nip、ip\n\n# 应用层\n\nethernet、atm、frame relay\n\n# 与osi的异同\n\n相同点：\n\n 1. 都分层\n 2. 基于独立的协议栈的改线\n 3. 可以实现异构网络互联 不同点：\n 4. osi定义三点：服务、协议、接口\n 5. osi先出现，参考模型先于协议发明，不偏向特定协议\n 6. tcp/ip设计之初就考虑到异构网互联问题，将ip作为重要层次\n 7. 连接方式：tcp/ip特别看重异构网互联，所以网络层为无连接，而不是面向连接 ps：面向连接（有确认过程的信息传输），无连接（直接传输）\n\n# 1.8.3 5层参考模型\n\n综合了osi和tcp/ip的有点\n\n# 应用层\n\n支持各种网络应用\n\n# 传输层\n\n进程-进程的数据传输\n\n# 网路层\n\n源主机到目的主机的数据分组路由与转发\n\n# 数据链路层\n\n把网络层传下来的数据报组装成帧\n\n# 物理层\n\n比特传输\n\n\n# 2 物理层\n\n 1. 通信基础\n 2. 两个公式lim\n 3. 看图说话\n 4. 传输介质\n 5. 物理层设备\n\n\n# 2.1 物理层基本概念\n\n 1. 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体\n 2. 物理层主要任务：确定与传输媒体接口有关的一些特性\n 3. 机械特性：定义物理接连的特性\n 4. 电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等\n 5. 功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途\n 6. 过程特性：定义各条物理线路的工作规程和时序关系\n\n\n# 2.2 数据通信基础知识\n\n 1. 通信目的：传送消息\n 2. 数据：传送信息的实体，通常是有意义的符号序列\n 3. 信号：数据的电器/电磁的表现，是数据在传输过程中的存在形式\n    * 数字信号：代表消息的参数取值是离散的\n    * 模拟信号：代表信息的参数取值是连续的\n 4. 信源：产生和发送数据的源头\n 5. 信宿：接受数据的终点\n 6. 信道：信号的传输媒介\n 7. 三种通信方式：单工通信、半双工通信（不能同时发收）、全双工通信\n 8. 两种数据传输方式：串行传输（速度慢、费用低、适合远距离）、并行传输（速度快、费用高、适合近距离）\n\n\n# 2.3 码元\n\n 1. 码元：一个固定时长的信号波形，代表不同离散数值的基本波形，是阿虎i通信中数字信号的计量单位\n 2. 码元宽度：码元的时长\n 3. 当码元的离散状态有m个时，称为m进制码元\n 4. 1码元可以携带多个比特的信息量\n\n\n# 2.4 速率、波特、带宽\n\n 1. 速率也叫数据率，指数据的传输速率，代表单位时间内容传输的数据量\n 2. 可以用码元传输速率和信息传输速率表示\n 3. 码元传输速率：1s传输多少码元，表示单位时间内数字通信系统所传输的码元个数（脉冲个数、信号变化次数）。又称码元速率、波形速率、调制速率、符号速率。单位波特（baud）\n 4. 信息传输速率：1s传输多少比特，表示单位时间内容数字通信系统传输的二进制码元个数（比特数）。又称信息速率、比特率。单位是比特/秒（b/s）\n 5. 带宽：表示带单位时间内从网络中的某一点到另一点所能通过的“最高数据率”\n\n\n# 2.5 奈氏准则和香农定理\n\n 1. 影响失真程度的因素：码元传输速率；信号传输距离；噪声干扰；传输媒体质量\n 2. 信道带宽：信道能通过的最高频率和最低频率之差\n 3. 码间串扰：接收端收到的信号波形失去了码元之间清晰界限的现象\n 4. 奈氏准则给出了码元传输速率的限制，但没有对信息传输速率给出限制\n 5. 香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的传输速率有上限值\n\n\n# 2.6 编码与调制\n\n# 2.6.1 系带信号与宽带信号\n\n 1. 基带信号：将数字信号用两种不同的电压表示送到数字信道上传输（基带传输）\n 2. 宽带信号：将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信号上去传输（宽带传输）\n\n# 2.6.2 编码\n\n数据变为数字信号\n\n# 数字数据编码为数字信号\n\n 1. 非归零编码（nrz）\n 2. 曼切斯特编码\n 3. 差分曼切斯特编码\n\n# 模拟数据编码为数字信号\n\n 1. pcm：抽样、量化、编码\n\n# 2.6.3 调制\n\n数据变为模拟信号\n\n# 数字数据调制为模拟信号\n\n 1. ask(调幅)\n 2. fsk(调频)\n 3. psk(调相)\n 4. qam(调幅+调相)\n\n# 模拟数据调制为模拟信号\n\n\n# 2.7 物理层传输介质\n\n传输介质：数据传输系统中在发送设备和接受设备之间的物理通路，也称传输媒体/传输媒介\n\n# 2.7.1 导向性传输介质\n\n 1. 双绞线，绞合可以减少对相邻导线的电磁干扰\n 2. 同轴电缆\n 3. 光纤\n\n# 2.7.2 非导向性传输介质\n\n 1. 无线电波\n 2. 微波\n 3. 红外线、激光\n\n\n# 2.8 物理层设备\n\n# 2.8.1 中继器\n\n对信号进行再生和还原，再生数字信号 5-4-3规则：最多5个网段、最多4个物理层设备、最多挂3个计算机\n\n# 2.8.2 集线器（多口中继器）\n\n对信号进行放大转发，再生，放大信号 不具备信号的定向传送能力，是一个共享性设备\n\n\n# 3 数据链路层\n\n 1. 链路层的功能\n 2. 链路层的两种信道\n 3. 局域网、广域网\n 4. 链路层的设备\n\n\n# 3.1 数据链路层概述\n\n# 3.1.1 数据链路层基本概念\n\n 1. 结点：主机、路由器\n 2. 链路：网络中两个结点之间的物理通道，链路的传输介质主要是双绞线、光纤和微波。分为有限链路、无线链路\n 3. 数据链路：网络中两个结点之间的逻辑通道，把实际控制数据传输协议的硬件和软件加到链路上就构成数据链路\n 4. 帧：链路层的协议数据单元，封装网络层数据报\n 5. 数据链路层负责通过一条链路从一个结点向两一个物理链路直接连接的相邻结点传送数据报\n\n# 3.1.2 数据链路层功能概述\n\n数据链路层在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻结点的目标机网络层。其主要作用是加强物理层传输原式比特流的功能，将物理层提供的可以出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路\n\n 1. 为网络层提供服务：无确认无连接服务、有确认无连接服务、有确认面向服务（有连接一定有确认）\n 2. 链路管理，即连接的建立、维持、释放（用于面向连接的服务）\n 3. 组帧\n 4. 流量控制\n 5. 差错控制\n\n\n# 3.2 封装成帧\n\n 1. 封装成帧：在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束\n 2. 首部和尾部包含许多控制信息，他们的一个重要作用：帧定界（确定帧的界限）\n 3. 帧同步：接收方应该能从接收到的二进制比特流中区分出帧的起始和终止\n 4. 数据链路层的帧长：帧首部到帧尾部的距离\n 5. 最大传送单元（mtu）：帧的数据部分的最大长度\n 6. 组帧方法：①字符计数法；②字符（节）填充法；③零比特填充法；④违规编码法\n 7. 透明传输：不管所传数据是什么样的比特组合，都应当能够在链路上传送\n\n# 3.2.1 字符技术法\n\n帧首部使用一个计数字段（第一个字节，八位）来标明帧内字符数 首部一旦发生错误，后面全部无法识别\n\n# 3.2.2 字符填充法\n\n在发送端添加转义字符，在接收端把转义字符删掉，实现透明传输\n\n# 3.2.3 零比特填充法\n\n 1. 在发送端，扫描整个信息字段，只要连续5个1，就立即填入1个0\n 2. 在接收端收到一个帧时，先找到标志字段确定边界，再用硬件对比特流进行扫描。发现连续5个1时，就把后面的0删除 保证了透明传输\n\n# 3.2.4 违规编码法\n\n用两个编码中不会用到的电平方式来标志帧的起始和终止\n\n\n# 3.3 差错控制\n\n# 3.3.1 差错\n\n# 差错的来源\n\n传输中的差错都是由于噪声引起的\n\n 1. 全局性噪声：由于线路本身电气特性所产生的所及噪声（热噪声），是信道固有的，随机存在的 解决方法：提高信噪比来减少或避免干扰（调整传感器）\n 2. 局部性噪声：外界特定的断站原因所造成的冲击噪声，是产生差错的主要原因 解决办法：通常利用编码技术来解决\n\n# 差错的分类\n\n 1. 位错：比特位出错，1变成0、0变成1\n 2. 帧错：帧丢失；帧重复；帧失序\n\n# 3.3.2 检错编码\n\n# 奇偶校验码\n\n由n-1位信息元和1位校验元组成\n\n 1. 奇校验码：n个比特有奇数个1\n 2. 偶校验码：n个比特有偶数个1 只能检查出奇数个比特错误，检错能力为50%\n\n# crc循环冗余码\n\n最终发送的数据：要发送的数据+帧检验序列fcs（冗余码） 计算冗余码： 1. 加0：加生成多项式阶个0 2. 模2除法：数据加0后处于多项式，余数为冗余码/fcs/crc检验码的比特序列（异或）\n\n# 3.3.3 纠错编码\n\n 1. 海明码：可以发现双比特错，但只能纠正单比特错\n 2. 工作原理：动一发而牵全身\n\n# 海明码工作流程\n\n 1. 确定校验码位数r 海明不等式：2^r>=k+r+1(r:冗余信息位、k：信息位)\n 2. 确定校验码和数据的位置 校验码只能存在在2的几次方的位置，数据按照剩下的位置按序填写\n 3. 求校验码的值 把数据为变化成二进制位，二进制的位数由数据位最大的位数决定 校验码校验的位置是该校验码1位置一致的位 校验码的实际值与所有要校验位的实际值异或为0\n 4. 检错并纠错 求出每个校验码与所要校验位的异或 从最后校验码的异或网最前写，得出的二进制数就是出错的位置\n\n\n# 3.4 流量控制与可靠传输\n\n 1. 由于较高的发送速度和较低的接受能力的不匹配会造成传输出错，所以流量控制室数据链路层的重要工作\n 2. 数据链路层的流量控制是点对点；传输层的流量控制是端对端的\n 3. 数据链路层流量控制手段：接收方收不下就不回复确认\n 4. 传输层流量控制手段：接收端给发送端一个窗口公告\n\n# 3.4.1 停止——等待协议\n\n 1. 没发送完一个帧就停止发送，等待对方的确，在收到确认后再发送下一个帧\n 2. 发送窗口大小=1；接受窗口大小=1\n 3. 停止——等待协议目的：解决底层信道出现的丢包问题 丢包问题：物理线路故障、设备故障、病毒攻击、路由信息错误等原因，会导致数据报的丢失\n 4. 停止——等待协议应用情况：无差错情况；有差错情况\n\n# 停止——等待协议关键点\n\n 1. 超时计时器：每发送一个帧就启动一个计时器，计时器到时还未接收到ack就会重传刚刚未收到确认的帧（自动重传）\n 2. 数据帧与确认帧必须编号\n 3. 接收方如果重复收到编号相同的帧，就丢弃重复帧并重传该帧的确认帧\n 4. 发送方如果重复收到编号相同的确认帧，就丢弃重复的确认帧不作处理\n\n# 停止——等待协议性能\n\n 1. 简单\n 2. 信道利用率太低\n\n# 3.4.2 滑动窗口协议\n\n 1. 发送窗口：发送方维持一组连续的允许发送的帧的序号\n 2. 接受窗口：接受方维持一组持续的允许接受帧的序号\n\n# 后退n帧协议（gbn）\n\n 1. 发送窗口大小>1；接受窗口大小=1\n 2. 发送方把数据分成：发完被确认的、已经发送等待确认的、还能发送的、还不能发送的\n 3. 滑动窗口长度小于2^n-1（n：帧编号的比特位数）\n\n# gbn发送方响应\n\n 1. 上层调用：检查发送窗口是否已满（实际上发送方可以缓存数据）\n 2. 收到ack：累积确认，接受n号帧标明接收方收到n号帧及之前的全部帧\n 3. 超时事件：出现超时发送方重传所有已发送但未确认的帧\n\n# gbn接收方响应\n\n 1. 正确接收：为n号帧发送一个ack，代表n号帧之前的所有帧都接受完毕\n 2. 其余情况：全部丢弃，为最近安序接收的帧重新发送ack\n\n# gbn性能\n\n 1. 因连续发送数据帧而提高了信道利用率\n 2. 重传时必须把原来已经正确传送的数据帧重传，传送效率低\n\n# 选择重传协议（sr）\n\n 1. 发送窗口大小>1；接受窗口大小>1\n 2. 设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧\n 3. 发送方把数据分成：发完被确认的、已经发送等待确认的、还能发送的、还不能发送的\n 4. 接收方把数据分成：已经接受完并返回确认的、希望收到但没收到的、收到且确认的（缓存）、等待接受的、还无法接收的\n 5. 滑动窗口大小最大为2**（n-1）\n\n# sr发送方响应\n\n 1. 上层调用\n 2. 收到ack\n    * 收到在帧序号窗口内的ack，将帧标记为已接收\n    * 标记已接收的帧序号是窗口下界，则窗口向前移动到具有最小序号的未确认帧处\n 3. 超时事件：每个帧都有独立计时器，超时后只重传一个帧\n\n# sr接收方响应\n\n来者不拒（窗口的帧）\n\n 1. 正确接收：确认一个在窗口内的帧而不用管其是否按序，失序的帧将被缓存，并返回该帧的的确认帧，只表示该帧被接受\n 2. 窗口滑动：处于窗口下界的帧被接收时，向前滑动窗口至具有最小序号的未确认帧处\n 3. 其余情况：忽略该帧、返回该帧的ack\n\n# sr重点\n\n 1. 对数据帧逐一确认，收到一个确认一个\n 2. 只重传错误帧\n 3. 接收方有缓存\n\n\n# 3.5 可靠传输、滑动窗口、流量控制\n\n 1. 可靠传输：发送端发啥，接收端收啥\n 2. 流量控制：控制发送速率，使接收方有足够的缓冲空间来接受每个帧\n 3. 滑动窗口：\n    * 流量控制：收不下就不给确认，控制发送\n    * 可靠传输：发送端自动重传\n\n\n# 3.6 介质访问控制（mac协议）\n\n 1. 传输数据使用的两种链路\n    * 点对点链路：两个相邻节点通过一个链路相连，没有第三者。（ppp协议、广域网）\n    * 广播式链路：所有主机共享通信介质（局域网）\n 2. 介质访问控制：采取一定的措施，使得两对节点之间的通信不会发生互相干扰的情况\n\n# 3.6.1 静态划分信道\n\n 1. 信道划分介质访问控制：将受用介质的每个设备与来自同意信道上的其他设备的通信隔离开，把时域和频域合理地分配给网络上的设备\n 2. 多路复用技术：把多个型号组合在一条物理信道上进行传输，使得多个计算机或终端设备共享信道资源，提高信道利用率\n\n# 频分多路复用fdm\n\n 1. 用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带\n 2. 频分复用的所有用户在同样的时间占用不同的带宽（频率带宽）资源\n 3. 优点：\n    * 充分利用传输介质带宽，效率较高\n    * 技术比较成熟，实现比较容易\n\n# 时分多路复用tdm\n\n 1. 将时间划分成一段段登场的时分复用帧（tdm帧）\n 2. 每一个时分复用的用户在每一个tdm帧中占用固定序号的时隙，所有用户轮流占用信道\n 3. tdm帧是在物理层传送的比特流所划分的帧，标志一个周期\n 4. 统计时分复用stdm：\n    * 每个stdm帧时隙数小于连接在集中器上的用户数\n    * 各用户有了数据就随时发送集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存发出\n    * 不固定分配时隙，而是按需动态分配时隙\n\n# 波分多路复用wdm\n\n 1. 波分多路复用：本质就是光的频分多路复用，在一根光线中传输多种不同波长（频率）的光信号，由于波长不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来\n\n# 码分多路复用cdm\n\n 1. 码分多址（cdma）是码分复用的一种方式\n 2. 将一个比特分为多个码片/芯片（chip），每个站点被指定一个唯一的m位的芯片序列\n 3. 发送1时发送芯片序列；发送0时发送芯片序列的反码\n 4. 不干扰：多个站点同时发送数据时，各个站点芯片序列相互正交\n 5. 合并：各路数据在信道中被线性相加\n 6. 分离：合并的数据和远战 规格化内积\n\n# 3.6.2 动态分配信道\n\n 1. 特点：信道并非在用户通信时固定分配给用户\n\n# 轮询访问介质访问控制\n\n既不产生冲突，又要发送时占全部带宽\n\n# 轮询协议\n\n 1. 主结点轮流“邀请”从属结点发送数据\n 2. 问题：\n    * 轮询开销\n    * 等待延迟\n    * 单点故障\n\n# 令牌传递协议\n\n 1. 令牌：\n    * 一个特殊格式的mac控制帧，不包含任何信息。\n    * 可以控制信道的使用，确保同一时刻只有一个结点独占信道\n 2. 问题：\n    * 令牌开销\n    * 等待延迟\n    * 单点故障\n 3. 应用于令牌环网（物理星型拓扑，逻辑环形拓扑）\n 4. 常用于负载较重、通信量较大的网络中\n\n# 随机访问介质访问控制\n\n 1. 所有用户可随机发送信息\n 2. 发送信息时占全部带宽\n\n# aloha协议\n\n 1. 纯aloha协议比时隙aloha协议吞吐量低，效率更低\n 2. 纯aloha想法就发，时隙aloha协议只有在时间片段开始时才能发 ####### 纯aloha协议\n 3. 思想：想发就发，不监听信道，不按时间槽发送，随机重发\n 4. 冲突检测：接收方检测出差错不予确认，发送方在一定时间内收不到就判断发生冲突\n 5. 冲突解决：超时后等一随机时间重传 ####### 时隙aloha协议\n 6. 思想：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送\n\n# csma协议\n\n载波监听多路访问协议\n\n 1.  cs：载波监听，每个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据\n 2.  ma：多点接入，表示许多计算机以多点接入的方式连接在一根总线上\n 3.  协议思想：发送帧之前，监听信道\n 4.  监听结果\n     * 信道空闲：发送完整帧\n     * 信道忙：推迟发送 ####### 1-坚持csma\n 5.  坚持：对于监听信号忙后的坚持\n 6.  思想：\n     * 如果一个主机要发送消息，那么它先监听信道\n     * 空闲则直接传输，不必等待\n     * 忙则一直监听，指导空闲马上传输\n     * 如果冲突：等待一个随机场的时间再监听，重复上述过程\n 7.  优点：只要媒体空闲，站点就马上发送，媒体利用率高\n 8.  缺点：假如有两个或两个以上的站点有数据要发送，冲突不避免 ####### 非坚持csma\n 9.  非坚持：对于监听信道忙之后就不继续监听\n 10. 思想：\n     * 如果一个主机要发送消息，那么它先监听信道\n     * 空闲则直接传输，不必等待\n     * 忙则等待一个随机的时间之后再进行监听\n 11. 优点：采用随机的重发延迟时间可以减少冲突发生的可能性\n 12. 缺点：可能存在大家都在延迟等待过程中，媒体利用率低 ####### p-坚持csma\n 13. p-坚持：对监听信道空闲的处理\n 14. 思想：\n     * 如果一个主机要发送消息，那么它先监听信道\n     * 空闲则以p概率直接传输，不必等待；概率1-p等待到下一个时间槽再传输\n     * 忙则等待下一个时间槽再进行监听\n 15. 优点：既能像非坚持减少冲突，又能像1-坚持减少媒体空闲时间\n 16. 缺点：发生冲突后还是坚持把数据帧发送完，造成了浪费\n\n# csma/cd协议\n\n载波监听多点接入/碰撞检测协议\n\n 1. cs：载波监听，每个站在发送数据之前以及发送数据时要检测一下总线上是否有其他计算机在发送数据\n 2. ma：多点接入，表示许多计算机以多点接入的方式连接在一根总线上（应用于以太网）\n 3. cd：碰撞检测（冲突检测），“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化情况，以判断自己在发送数据时其他站是否也在发送数据（应用于半双工网络）\n 4. 只要经过2τ时间还没有检测到碰撞就能肯定这次发送不会发生碰撞\n 5. 截断二进制指数规避算法：\n    * 确定基本退避（推延）时间为征用期2τ\n    * 定义参数k，k=min(重传次数，10)\n    * 从离散的整数集合[ 0,1,2**k-1]中随机取出一个数r，重传所需退避时间为r被的基本退避时间\n    * 当重传达到16次仍不能成功，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告错误\n 6. 最小帧长=总线传播时延 * 数据传输速率 * 2\n\n# csma/ca协议\n\n载波监听多点接入/碰撞避免\n\n 1. 应用于无线局域网，cd无法全面检测碰撞\n 2. 工作原理：\n    * 发送数据前，先检测信道是否空闲\n    * 空闲则发出rts；忙则等待\n    * 接收端收到rts，将响应cts\n    * 发送端收到cts后，开始发送数据帧。同时预约信道（发送端告知其他站点自己要传多久数据）\n    * 接收端收到数据帧后，用crc来检验数据是否正确，正确则响应ack帧\n    * 发送方收到ack就可以进行数据帧发送；若没有则一致重传到规定重发次数为止（截断二进制指数规避算法）\n 3. 重点：\n    * 预约信道\n    * ack帧\n    * rts/cts帧（可选）\n\n\n# 3.7 局域网\n\n# 3.7.1 基本概念\n\n 1. 局域网：简称lan，在某一区域内由多台计算机互联成的计算机组，使用广播信道\n 2. 局域网特点：\n    * 覆盖的地理范围小，只在一个相对独立的局部范围内互联\n    * 使用专门铺设的传输介质进行联网，数据传输速率高\n    * 通信延迟时间短，误码率低，可靠性较高\n    * 各站点为平等关系，共享传输信道\n    * 多采用分布式控制和广播式通信，能进行广播和组播\n 3. 局域网的主要要素：网络拓扑；传输介质；介质访问控制方法\n\n# 局域网拓扑结构\n\n 1. 星型拓扑：中间节点是控制中心，结构简单、建网容易；网络可靠性低、网络共享能力差，有单点故障问题\n 2. 总线型拓扑：网络可靠性高、节点响应速度快、成本低、无单点故障问题\n 3. 环形拓扑：通信设备和线路比价节省；有单点故障问题、不易扩充、系统响应延时长、信息传输效率低\n 4. 树型拓扑：易于扩展、易于隔离故障；有单点故障问题\n\n# 局域网传输介质\n\n 1. 有线局域网：双绞线、同轴电缆、光纤\n 2. 无线局域网：电磁波（空气）\n\n# 介质访问控制方法\n\n 1. csma/cd：常用于总线型局域网，也用于树型局域网\n 2. 令牌总线：常用于总线型局域网，也用于树型局域网。把网络中各个工作站按一定顺序排列形成一个逻辑换，只有持有令牌才能控制总线\n 3. 令牌环：常用于环形局域网\n\n# 局域网分类\n\n 1. 以太网：ieee 802.3标准；逻辑拓扑总线型、物理拓扑是星型或扩展星型；csma/cd\n 2. 令牌环网:物理上星型拓扑，逻辑上环形拓扑\n 3. fddi网：光纤，造价高；物理上双环拓扑、逻辑上环形拓扑\n 4. atm网：较新型的单元交换技术，使用固定53字节单元交换\n 5. 无线局域网：ieee 802.11标准\n\n# ieee 802标准\n\n 1. ieee 802.3:以太网\n 2. ieee 802.5:令牌环网\n 3. ieee 802.8：光纤技术\n 4. ieee 802.11：无线局域网\n\n# mac子层和llc子层\n\n 1. ieee 802标准描述的局域网参考模型只对应数据链路层和物理层\n 2. ieee 802标准将数据链路层划分为：逻辑链路层llc子层；介质访问控制mac子层\n 3. llc子层：负责识别网络层协议，然后进行封装。为网络层提供服务：无确认无连接、面向连接、带确认无连接、高速传送 4、 mac子层：负责数据帧的封装/卸装，帧的寻址和识别，帧的接受与发送，链路的管理，帧的差错控制，屏蔽了不同物理链路种类的差异性\n\n# 3.7.2 以太网\n\n 1. 以太网（ethernet）指几个公司联合开发的基带总线局域网规范\n 2. 以太网使用csma/cd技术\n 3. 以太网优点：\n    * 造价低廉\n    * 应用最广泛\n    * 偏移、简单\n    * 满足网络速率的要求\n 4. 以太网的两个标准：\n    * dix ethernet\n    * ieee 802.3\n\n# 以太网提供的服务\n\n 1. 无连接：发送方和接收方之间无“握手过程”\n 2. 不可靠：\n    * 不对发送方的数据帧编号\n    * 接收方不向发送方进行确认，差错帧直接退旗，差错纠正由高层负责\n 3. 智能实现无差错的接受，不实现可靠传输\n\n# 传输介质与拓扑结构\n\n 1. 粗同轴电缆————细同轴电缆————双绞线+集线器\n 2. 总线型——————————————————————星型\n 3. 逻辑上总线型，物理上星型\n\n# 10base-t以太网\n\n 1. 10base-t是传输基带信号的双绞线以太网，采用的是无屏蔽双绞线，传输速率是10mb/s，t表示采用双绞线\n 2. 物理上采用星型拓扑，逻辑上总线型\n 3. 每段双绞线最长100m\n 4. 采用曼切斯特编码\n 5. csma/cd介质访问控制\n\n# 适配器与mac地址\n\n 1. 适配器：连接计算机与外界局域网的连接\n 2. mac地址：局域网中硬件地址，48位二进制地址\n\n# 以太网mac帧\n\n 1. 最常用的mac帧是以太网v2的格式\n 2. mac帧：目的地址（6字节）+源地址（6字节）+类型（2地址）+数据（46-1500）+fcs（纠错编码）（4字节）\n\n# 高速以太网\n\n 1. 100base-t以太网：双绞线上传送100mb/s基带信号的星型拓扑以太网；支持全双工和半双工\n 2. 吉比特以太网：在光纤或双绞线上传送1gb/s信号；支持全双工和半双工\n 3. 10吉比特以太网：在光纤上传送10gb/s信号；只支持全双工\n\n# 3.7.3 无限局域网\n\n# ieee 802.11\n\n 1. 无线局域网通用的标准\n 2. 802.11的mac帧头格式：帧控制（2）+生存周期id（2）+地址1（ra接收端，6）+地址2（ta发送方，6）+地址3（da目的地，6）+序列控制（2）+地址4（sa源地址，6）\n\n# 无线局网分类\n\n 1. 有固定基础设施无线局域网\n 2. 无固定基础设施无限局域网\n\n\n# 3.8 广域网协议\n\n 1. 广域网：提供远距离通信，通信子网使用分组交换技术\n 2. 广域网可是实现远距离局域网的连接\n\n# 3.8.1 ppp协议\n\n 1. ppp协议：点对点协议，使用最广泛的数据链路层协议\n 2. ppp协议只支持全双工链路\n 3. 面向字节的协议\n\n# ppp协议要求\n\n 1.  简单：对于链路层的帧，无需纠错，无需序号，无需流量控制\n 2.  封装成帧：帧定界符\n 3.  透明传输：与帧定界符一样比特组合的处理：异步线路用字节填充；同步线路用比特填充\n 4.  满足多种网络层协议\n 5.  满足多种类型链路\n 6.  实现差错检测\n 7.  检测连接状态\n 8.  满足最大传送单元\n 9.  网络层地址协商\n 10. 数据压缩协商\n\n# ppp协议无需满足要求\n\n 1. 纠错\n 2. 流量控制\n 3. 序号\n 4. 不支持多点线路\n\n# ppp协议功能\n\n 1. 将ip数据报封装到串行链路（同步串行/异步串行）的方法\n 2. 链路控制协议lcp：建立并维护数据链路层连接\n 3. 网络控制协议ncp：不同的网络层协议都要一个相应的ncp来配置，为网络层协议建立和配置逻辑连接\n\n# ppp协议的状态图\n\n\n\n# ppp协议的帧格式\n\n帧定界符7e+地址字段ff+c03+协议+ip数据报+fcs+帧定界符7e\n\n# 3.8.2 hdlc协议\n\n 1. hdlc：高级数据链路控制协议\n 2. 面向比特的数据链路层协议\n 3. 可实现透明传输，使用“0比特插入法”\n 4. 采用全双工通信\n 5. crc检验，对信息帧进行顺序编号，传输可靠性高\n\n# hdlc站\n\n 1. 主站：发送命令帧、接受响应帧\n 2. 从站：接受主站发送来的命令帧，向主站发送响应帧\n 3. 复合站：既能发送又能接受命令帧和响应帧\n 4. 三种数据操作方式：\n    * 正常响应方式\n    * 异步平衡方式\n    * 异步响应方式\n\n# hdlc帧格式\n\n标志字段+地址a+控制c+信息+帧检验序列fcs+标志字段\n\n# 3.8.3 ppp与hdlc比较\n\n# 相同点\n\n 1. 都只支持全双工链路\n 2. 都可实现透明传输\n 3. 都可实现差错检测，但不纠正\n\n# 不同点\n\n 1. 对于透明传输：ppp可以比特填充和字节填充；hdlc只能比特填充\n 2. ppp面向字节；hdlc面向比特\n 3. ppp有两个字节协议字段\n 4. ppp无序号无确认机制，不可靠；hdlc有编号和确认机制，可靠\n\n\n# 3.9 链路层设备\n\n# 3.9.1 物理层扩展以太网\n\n 1. 光纤调制器、光纤解调器\n 2. 主干集线器扩展冲突域\n\n# 3.9.2 链路层扩展以太网\n\n# 网桥\n\n 1. 网桥：根据mac帧的目的地址对帧进行转发和过滤\n 2. 网段：一个计算机网络中使用同一物理层设备能够直接通讯的部分\n 3. 网桥优点：\n    * 过滤通信量。增大吞吐量\n    * 扩大了物理范围\n    * 提高可靠性\n    * 互联不同物理层、不同mac子层和不同速率的以太网\n 4. 网桥分类：\n    * 透明网桥：即插即用，以太网的站点不知道帧将经过哪些网桥\n    * 源路由网桥：发送帧时，把详细的最佳路由信息（路由最少/时间最短）放在帧的首部\n\n# 以太网交换机\n\n 1. 以太网交换机可以独占传输媒体带宽\n 2. 直通式交换机：查完目的地址就立即转发；延迟小，可靠性低，无法支持具有不同速率的端口的交换\n 3. 存储转发式交换机：将帧放入高速缓存，并检查是否正确，正确就转发，错误则丢弃；延迟大，可靠性高，可以支持具有不同速率的端口交换\n\n\n# 4 网络层\n\n\n# 4.1 网络层概述\n\n# 4.1.1 网络层功能\n\n 1. 主要任务：把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务\n 2. 网络层传输单位：数据报\n 3. 功能一：路由选择与分组转发（选择最佳路径）\n 4. 功能二：异构网络互联\n 5. 功能三：拥塞控制 拥塞：所有结点都来不及接受分组，要丢弃大量分组 开环控制：静态控制方法 闭环控制：动态控制方法\n\n# 4.1.2 数据交换方式\n\n# 电路交换\n\n 1. 电路交换流程： 建立连接————通信————释放连接\n 2. 优点：\n    * 通信时延小\n    * 有序传输\n    * 没有冲突\n    * 实时性强\n 3. 缺点：\n    * 建立连接时间长\n    * 线路独占，使用效率低\n    * 灵活性差\n    * 无差错控制能力\n 4. 特点：独占资源\n\n# 报文交换\n\n 1. 报文：源应用发送的信息整体\n 2. 优点\n    * 无需建立连接\n    * 存储转发，动态分配线路\n    * 线路可靠性高\n    * 线路利用率较高\n    * 多目标服务\n 3. 缺点：\n    * 有存储转发时延\n    * 报文大小不定，需要网络节点有较大缓存空间\n\n# 分组交换\n\n 1. 分组：把大的数据块分割成小的数据块\n 2. 优点：\n    * 无需建立连接\n    * 存储转发，动态分配线路\n    * 线路可靠性较高\n    * 线路利用率较高\n    * 相对于报文交换，存储管理更容易\n 3. 缺点：\n    * 有存储转发时延\n    * 需要传输额外的信息量\n    * 乱序到目的主机时，要对分组排序重组\n\n# 数据报方式\n\n 1. 数据报方式：为网络层提供无连接服务\n 2. 无连接服务：不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同\n 3. 每个分组都携带源地址和目的地址\n 4. 路由器根据分组的目的地址转发分组：基于路由协议/算法构建转发表；检索转发表；每个分组独立选路\n\n# 虚电路方式\n\n 1. 虚电路方式：为网络层提供连接服务，将数据报方式和电路交换方式结合，发挥两者优点\n 2. 连接服务：首先为分组的传输确定传输路径（建立连接），然后沿该路径（连接）传输系列分组，系列分组传输路径相同，传输结束后拆除连接\n 3. 虚电路：一条源主机到目的主机类似于电路的路径（逻辑连接），路径上所有节点都要维持这条虚电路的建立。都维持一张虚电路表，每一项记录了一个打开的虚电路的信息\n 4. 通信过程：\n    * 建立连接（虚电路的建立）： 每个分组携带虚电路号，而非目的地址。 源主机发送“呼叫请求”分组，并收到“呼叫应答”分组后才算建立连接\n    * 数据传输：全双工通信\n    * 释放连接（虚电路释放）：源主机发送“释放请求”分组以拆除虚电路\n\n# 4.1.3 传输单元名词\n\n 1. 报文：应用层的传输单元\n 2. 报文段：传输层的传输单元，将报文分割而成\n 3. ip数据报：报文段到网络层封装上网络层地址（源地址、目的地址）\n 4. 分组：网络层的传输单元，将过长的数据报切割而成\n 5. 帧：数据链路层的传输单元，将分组加头加尾\n 6. 比特流：物理层的传输单元\n\n\n# 4.2 ip数据报\n\n# 4.2.1 ip数据报格式\n\n 1. 首部（固定部分+可变部分）+数据部分（tcp、udp段）\n 2. 首部\n    * 固定部分：\n      * 版本：ip协议的版本（4bit）\n      * 首部长度：单位是4字节，最小是5（4bit）\n      * 区分服务：期望获得那种类型的服务（8bit）\n      * 总长度：整个ip数据报的长度，单位是1b（16bit）\n      * 标识：同一数据包的分片使用同一标识（16bit）\n      * 标志：只用后两位有用（3bit）\n        * 中间位df 1：禁止分片 0：允许分片\n        * 最低位mf 1：后面还有分片 0：代表租后一篇/没分片\n      * 片偏移：某片在原分组中的相对位置，以8b为单位（13bit）\n      * 生存时间（ttl）：ip分组的保质期。每经过一个路由器生存时间-1，变成0则丢弃（8bit）\n      * 协议：数据部分使用的协议（tcp：6；udp：17）（8bit）\n      * 首部检验和：只检验首部（16bit）\n      * 源地址（32bit）\n      * 目的地址（32bit）\n    * 可变部分：\n      * 可选字段（长度可变）：用来支持拍错、测量以及安全等措施（0~40b）\n      * 填充：全0，报首部不成4b的整数倍\n\n# 4.2.2 ip数据报分片\n\n 1. 最大传送单元mtu：链路层数据帧可封装数据的上限\n 2. 除了最后一个分片，每个分片长度一定是8b的整数倍\n 3. 片偏移量是从数据部分开始计算，不计首部\n\n\n# 4.3 ip地址\n\n 1. ip地址：全世界唯一的32位/4字节标识符，标识路由器主机的接口\n 2. :={<网络号>,<主机号>}\n 3. 采用点分十进制，例：223.1.1.1\n\n# 4.3.1 分类的ip地址\n\n 1. a类：0+7bit+主机号\n 2. b类：10+14bit+主机号\n 3. c类：110+21bit+主机号\n 4. d类：1110+多播地址\n 5. e类：1111（保留为今后使用）\n\n# 特殊ip地址\n\n\n\n# 私有ip地址\n\n路由器对目的地址是私有ip地址的数据报一律不进行转发\n\n 1. a类：10.0.0.0~10.255.255.255\n 2. b类：172.16.0.0~172.31.255.255\n 3. c类：192.168.0.0~191.168.255.255\n\n# 分来ip地址弱点\n\n 1. ip地址空间利用率很低\n 2. 两级的ip地址不够灵活\n\n# 4.3.2 nat网络地址转换\n\n 1. 网络地址转换：在专用网连接到因特网的路由器上安装nat软件\n 2. nat路由器：安装了nat软件的路由器，至少有一个有效的外部全球ip地址\n 3. nat转换表 wan端：ip地址——端口号 lan端：ip地址——端口号\n\n# 4.3.3 子网划分\n\n 1. 采用三级ip地址：网络号+子网号+主机号（子网号从原来的主机号里的高位划出来）\n 2. 单位划分子网后，对外仍表现为一个网络\n 3. 子网掩码\n    * 二级ip地址：网络号全1，主机号全0\n    * 三级ip地址：网络号和子网号全1，主机号全0\n 4. 子网掩码与ip地址逐位与运算，得到子网网络地址\n 5. 使用子网时路由器转发分组算法\n    * 提取ip地址\n    * 判断是否直接交付\n    * 查看路由表中的特定主机路由\n    * 检测路由表中有无路径\n    * 默认路由0.0.0.0\n    * 丢弃，报告转发分组出错\n\n# 4.3.4 无分类编制cidr\n\n 1. 消除传统a类、b类、c类地址以及划分子网的概念\n    * ip地址：网络前缀+主机号\n    * cidr记法：在ip地址后加上/，然后写上网络前缀的位数\n 2. 融合子网地址与子网掩码，方便子网划分\n    * cidr地址块：由网络前缀相同的连续ip地址组成，用最小地址/网络前缀位数\n    * 地址掩码：网络前缀全1，主机号全0\n\n# 构成超网\n\n 1. 构成超网（路由聚合）：将多个子网聚合成一个较大的子网\n 2. 方法：缩短网络前缀\n 3. 最长前缀匹配：使用cidr时，查找路由表选择具有最长网络前缀的路由\n\n\n# 4.4 ip相关协议\n\n# 4.4.1 arp协议\n\narp高速缓存：ip地址与mac地址的映射，用于网络层到数据链路层中增加mac地址时使用\n\n# arp协议使用过程\n\n 1. 检查arp高速缓存，有对应表项则写入mac帧\n 2. 没有则广播arp分组请求 （自身ip地址+目的ip地址+自身物理mac地址+全1广播目的mac地址）\n 3. 单播放arp响应分组 （目的ip地址+目的mac地址），源主机收到后将此映射写入arp缓存\n 4. ps：两个ip地址不在一个网段内，目的mac地址是默认网关（路由器）mac地址\n\n# arp协议特点\n\n 1. arp协议的产生原因：在实际网络的链路上传送数据帧时，最终必须使用mac地址\n 2. arp协议：完成主机或路由器ip地址到mac地址的映射\n 3. arp协议自动进行\n\n# arp协议典型情况\n\n 1. 主机a发给本网络上的主机b：用arp找到主机b的硬件地址\n 2. 主机a发给另一网络上的主机b：用arp找到本网络上一个路由器（网关）的硬件地址\n 3. 路由器发给本网络的主机a：用arp找到主机a的硬件地址\n 4. 路由器发给另一网络上的主机a：用arp找到本网络上一个路由器（网关）的硬件地址\n\n# 4.4.2 dhcp协议\n\n 1. 动态主机配置协议dhcp是应用层协议，使用客户/服务器方式，客户端和服务端通过广播方式进行交互，基于udp\n 2. dhcp用于分配ip地址，是一种动态分配主机ip地址的方法\n 3. dhcp提供即插即用联网机制，允许地址重用，支持移动用户加入网络，支持在用地址续租\n\n# dhcp工作流程\n\n 1. 主机广播dhcp发现报文主机寻找dhcp服务器，dhcp服务器选择ip地址\n 2. dhcp服务器广播dhcp提供报文拟分配主机ip地址及相关配置\n 3. 主机广播dhcp请求报文采用先到先得，广播使所有dhcp服务器都知道主机选用的ip地址\n 4. dhcp服务器广播dhcp确认报文正式将ip地址分配给主机\n\n# 4.4.3 icmp协议\n\n 1. 网际控制报文协议icmp：支持主机或路由器差错/异常报告或网络探询。（发送特定icmp报文）\n 2. icmp报文：类型+代码+检验和+icmp数据部分（ip数据报首部+8字节）\n\n# icmp差错报告报文\n\n 1. 终点不可达（无法交付）\n 2. 源点抑制（拥塞丢数据）\n 3. 时间超过（ttl=0）\n 4. 参数问题（首部字段有问题）\n 5. 改变路由/重定向（存在更好的路由路径）\n\n# 不发送情况\n\n 1. icmp差错报告报文\n 2. 对第一个分片数据报片的所有后续数据报片\n 3. 具有组播地址的数据报\n 4. 具有特殊地质的数据报\n\n# icmp询问报文\n\n 1. 回送请求和回答报文：测试目的站是否可达以及了解其相关状态\n 2. 时间戳请求和回答报文\n 3. 掩码地址请求和回答报文\n 4. 路由询问和通告报文\n\n# icmp应用\n\n 1. ping：测试两个主机间的连通性，使用icmp回送请求和回答报文\n 2. traceroute：跟踪一个分组从源点到终点的路径，使用icmp时间超过差错报告报文\n\n\n# 4.5 ipv6\n\n# 4.5.1 产生原因\n\n 1. 从根本上上解决地址耗尽问题\n 2. 改进首部格式，达成快速处理和转发数据报的功能\n 3. 支持qos，指一个网络能够利用各种基础技术为指定的网络通信提供更好的服务能力\n\n# 4.5.2 ipv6数据报格式\n\n# 基本首部\n\n 1. 40字节\n 2. 版本：指明协议版本，4字节\n 3. 优先级：区分数据报的类别和优先级，8字节\n 4. 流标签：属于同一个流的数据报都具有同样的流标签，20字节\n 5. 有效载荷长度：有效载荷部分*（扩展首部+数据部分）的长度\n 6. 下一个首部：下一个扩展首部或上层协议首部，指向扩展首部1\n 7. 跳数限制：相当于ttl，生存时间\n 8. 源地址，128位\n 9. 目的地址，128位\n\n# 有效载荷\n\n 1. 扩展首部\n 2. 数据部分\n 3. 加起来不能超过65535字节\n\n# 4.5.3 与ipv4的区别\n\n 1.  ipv6将地址从32位（4b）扩展到了128位（16b），更大的地址空间\n 2.  ipv6将ipv4的校验和字段车底移除，减少每跳的处理时间\n 3.  ipv6将ipv4的可选字段移除首部，变成了扩展首部，成为灵活的首部格式，路由器通常不对扩展首部进行检查，大大提高了路由器的处理效率\n 4.  ipv6支持即插即用（自动配置），不需要dhcp协议\n 5.  ipv6首部长度必须是8b的整数倍；ipv4首部长度必须是4b的整数倍\n 6.  ipv6只能在主机处分片，ipv4可以在路由器和主机处分片\n 7.  icmpv6：附加报文类型“分组过大”\n 8.  ipv6支持资源的预分配，支持实施视像等要求，保证一定的带宽和时延的应用\n 9.  ipv6取消了协议字段，改成下一个首部字段\n 10. ipv6取消了总长度字段，改用有效载荷长度字段\n 11. ipv6取消了服务类型字段\n\n# 4.5.4 ipv6地址表示形式\n\n 1. 一般形式：冒号十六进制记法\n 2. 压缩形式：前面有0的情况，删减0\n 3. 零压缩：一连串连续的0可以被一堆冒号取代，双冒号表示法在一个地址中仅可出现一次\n\n# 4.5.5 ipv6基本地址类型\n\n 1. 单播：一对一通信，可做源地址和目的地址\n 2. 多播：一对多通信，只能作为目的地址\n 3. 任播：一对多中的一个通信，只能作为目的地址\n\n# 4.5.6 ipv6项ipv4过渡策略\n\n# 双栈协议\n\n 1. 在一台设备上同时启用ipv4协议栈和ipv6协议栈\n 2. 路由器：不同接口上分别配置了ipv4地址和ipv6地址\n 3. 计算机：同时拥有ipv4地址和ipv6地址，并具备同时吃力这两个协议地址的功能\n\n# 隧道技术\n\n 1. 将其他协议的数据帧或包重新封装然后通过隧道发送\n\n\n# 4.6 路由协议\n\n# 4.6.1 路由算法与路由协议概述\n\n# 路由算法\n\n 1. 最佳路由：“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已\n\n# 路由算法分类\n\n 1. 静态路由算法（非自适应路由算法）：管理员手工配置路由信息\n    * 优点：简便、可靠，在负载稳定、拓扑变化不大的网络中运行效果好\n    * 缺点：路由更新慢。不适用大型网络\n 2. 动态路由算法（自适应路由算法）：路由器之间彼此家坡缓信息，按照路由算法优化出路由表项\n    * 优点：路由更新快，适用大型网络，及时响应链路费用或拓扑变化\n    * 缺点：算法复杂，增加网络负担\n    * 全局性动态路由算法：链路状态路由算法ospf 所有路由器掌握完整的网络拓扑和链路费用信息\n    * 分散性动态路由算法：距离向量路由算法rip 路由只掌握物理相连的邻居及链路费用\n\n# 路由协议\n\n 1. 自治系统as：在单一的技术管理下的一组路由器。而这些路由器使用一种as内部的路由选择协议和共同的度量以确定分组在该as内的路由，同时还使用一种as之间的路由协议以确定在as之间的路由 一个as内的所有网络都数据一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通\n 2. 内部网关协议igp，一个as内使用的，如rip、ospf\n 3. 外部网关协议egp，as之间使用的，如bgp\n\n# 4.6.2 rip协议\n\n 1. rip是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大优点是简单\n 2. 要求网络中每一个路由器都维护从它自己到其他每一个目的网络的位移最佳距离记录（一组距离）\n 3. 距离：通常为跳数，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。\n    * 从一路由器到直接连接的网络距离为1\n    * rip允许一条路由最多智能包含15个路由器（rip只适用小的互联网）\n    * 距离16表示网络不可达\n 4. 仅和相邻路由器交换信息\n 5. 路由器交换的信息时自己的路由表\n 6. 每30秒交换一次路由信息，然后路由器根据信息系更新路由表\n 7. 若180s没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表\n\n# 距离向量算法\n\n 1. 修改相邻路由器发来的rip报文中所有表项：距离+1，下一跳改为邻居\n 2. rip报文填入路由表\n    * 路由器没有报文中的网络，直接填入\n    * 路由器中有报文中的网络\n      * 路由器中下一跳是邻居，直接更新（最新）\n      * 路由器中下一跳不是邻居，若路由表中距离更远则更新（最短）\n 3. 180s没收到相邻路由器的更新路由表，则把邻居距离设置为16\n\n# rip报文\n\n\n\n 1. rip是应用层协议，使用udp传送数据\n 2. 一个rip报文最多可以包括25个路由，若超过则发送几个rip报文\n\n# rip协议特点\n\n 1. 慢收敛：当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器\n\n# 4.6.3 ospf协议\n\n 1. 开放最短路径优先ospf协议，其中开放指不受某一家厂商控制，而是公开发表；使用了最短路径算法spf\n 2. ospf最主要的特征：使用分布式的链路状态协议\n\n# ospf协议特点\n\n 1. 使用洪泛法向自治系统内所有路由器发送信息\n 2. 发送的信息位本路由器相邻的所有路由器的链路状态\n 3. 只有当链路状态发生变化时，路由器猜想所有路由器洪泛发送信息\n 4. 所有路由器建立一个链路状态数据库，即全网拓扑图\n 5. 每隔30min，要刷新一次数据库中的链路状态\n 6. 常用于互联网规模很大\n 7. ospf不存在坏消息传得慢的问题，收敛速度很快\n\n# 链路状态路由算法\n\n 1. 每个路由器发现他的邻居结点hello问候分组，并两节邻居节点的网络地址\n 2. 设置到它的每个邻居的成本度量metric\n 3. 构造dd数据库描述分组，向邻站给出自己的链路状态数据库中的额所有链路状态项目的摘要信息\n 4. * 如果dd分组中的摘要都有，不作处理\n    * 如果存在没有或者更新的，则发送lsr链路状态请求分组，请求更新自己没有的和比自己更新的信息\n 5. 收到邻站的lsr分组后，发送lsu链路状态更新分组进行更新\n 6. 更新完毕后，邻站返回一个lsack链路状态确认分组进行确认\n 7. 是有dijkstra根据自己的链路状态数据库构造到其他结点间的最短路径\n\n# ospf区域\n\n 1. 区域：为了使用与规模很大的网络，ospf将一个自制系统再划分为若干个更小的范围\n 2. 每个范围有32位的区域标志符，一个区域不超过200个路由器\n 3. 主干区域0.0.0.0\n 4. 主干路由器、区域边界路由器\n\n# ospf分组\n\n直接使用ip数据报传送\n\n# 4.6.4 bgp协议\n\n 1. bgp发言人一般是bgp边界路由器\n\n# bgp协议特点\n\n 1. 与其他as邻站发言人交换信息\n 2. 交换网络可达性的信息：即要到达某个网络所要经过一系列as\n 3. 发生变化时更新变化的部分\n 4. bgp支持cidr，因此bgp的路由表应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列\n\n# bgp协议交换信息的过程\n\nbgp所交换的网络可达性的信息就是要达到某个网络所要经过的一系列as。当bgp发言人互相贾环了网络可达性的信息后，各bgp发言人就根据所采用的策略从收到的路由信息中找出到达各as的较好路由\n\n# bgp协议报文格式\n\n 1. bgp报文=bgp报文通用首部+bgp报文主体部分\n 2. ip首部+tcp首部+bgp报文\n 3. bgp是应用层协议，借助tcp传送\n\n# bgp-4报文\n\n 1. open打开报文：用来与相邻的另一个bgp发言人建立关系，并认证发送方\n 2. update更新报文：通告新路径或撤销原路径\n 3. keepalive保活报文：在无update时，手气性证实邻站的连通性；也作为open的确认\n 4. notification通知报文：报告先前报文的差错；也被用于关闭连接\n\n\n# 4.7 ip组播（多播）\n\n# 4.7.1 ip数据报的三种传输方式\n\n 1. 单播：用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播ip地址作为目的地址。是一种点对点传输方式\n 2. 广播：发送数据包到同一广播域或子网内的所有设备的一种数据传输方式。是一种点对多点传输方式\n 3. 组播（多播）：当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据报建立组播分发树，被传输的数据到达距离用户端尽可能近的结点后才开始复制和分发，是一种点对多点传输方式\n\n# 4.7.2 ip组播地址\n\n 1. ip组播地址：让源设备能够将分组发送给一组设备。属于同一多播组的设备奖杯分配一个组播组ip地址\n 2. 组播地址范围为224.0.0.0~239.255.255.255（d类地址），一个d类地址表示一个组播组。只能用作分组的目标地址。源地址总是单播地址\n 3. 组播数据报是“尽最大努力交付”，不提供可靠交付，应用于udp\n 4. 对组播数据报不产生icmp差错报文\n 5. 并非所有d类地址都可以作为组播地址\n\n# 4.7.3 硬件组播\n\n 1. ip地址与mac地址有映射关系\n\n# 4.7.4 igmp协议\n\n 1. igmp网际组管理协议，让路由器指导本局域网上是否有主机（的进程）参加或推出了某个组播组\n\n# igmp工作的两个阶段\n\n 1. 某主机要加入组播组时，该主机箱组播组的组播地址发送一个igmp报文，声明自己要成为该组的成员\n 2. 本地组播路由器收到igmp报文后，要利用组播路由选择协议报这组成员关系发给因特网上的其他组播路由器\n 3. 本地组播路由器周期性探寻本地局域网上的主机，以便指导这些主机是否还是组播组的成员\n 4. * 有一个主机对某个组响应，则组播路由器认为该组活跃\n    * 探询几次后没有响应，组播路由器不再将这组的成员关系发给其他的组播路由器\n    * 成员关系：所连接的局域网中有无组播组成员\n\n# 4.7.5 组播路由选择协议\n\n 1. 组播路由选择协议的目的是找出以源主机为根节点的组播转发树\n 2. 基于链路状态的路由选择\n 3. 基于距离-向量的路由选择\n 4. 协议无关的组播（稀疏/密集）\n\n\n# 4.8 移动ip\n\n# 4.8.1 相关术语\n\n 1. 移动ip技术：移动结点（计算机/服务器等）以固定的网络ip地址，实现跨越不同网段的漫游功能，保证基于网络ip的网络权限在漫游过程中不发生任何改变\n 2. 移动结点：具有永久ip地址的移动设备\n 3. 归属网络：一个移动结点拥有的旧居所\n 4. 归属代理（本地代理）：在归属网络中代表移动结点执行移动管理功能的实体\n 5. 外部代理（外地代理）：在外部网络中帮助移动结点完成移动管理功能的实体\n 6. 永久地址（归属地址/主地址）：移动站点在归属网络中的原始地址\n 7. 转交地址（辅地址）：移动站点在外部网络使用的临时地址\n\n# 4.8.2 通信过程\n\n# 计算机a刚进入外部网络\n\n 1. 在外部代理登记获得一个转交地址，离开时注销\n 2. 外地代理向本地代理登记转交地址\n\n# 计算机b向a发送数据报\n\n 1. 本地代理截获数据报\n 2. 本地代理再封装数据报，新数据宝目的地址是转交地址，发给外部代理（隧道）\n 3. 外部代理拆封数据报并发送给a\n\n# 计算机a向b发送数据报\n\na用自己的主地址作为数据报源地址，用b的ip地址作为数据报的目的地址\n\n# 计算机a移动到下一个网络\n\n 1. 注销原有的转交地址\n 2. 在新外部代理登记注册一个转交地址\n 3. 新外部代理给本地代理发送新的转交地址（覆盖旧的）\n\n# 计算机a回到归属网络\n\n 1. a向本地代理注销转交地址\n\n\n# 4.9 网络层设备\n\n# 4.9.1 路由器\n\n 1. 路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组\n 2. 路由器选择处理机：根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表\n 3. 交换结构：根据转发表（路由表得来）对分组进行转发\n\n# 输入端口对线路上收到的分组的处理\n\n 1. 从线路接收分组\n 2. 物理层处理\n 3. 数据链路层处理\n 4. 网络层处理分组排队、查表和转发\n 5. 会产生时延\n 6. 输入端口中的查找和转发功能在路由器的交换功能中是最重要的\n\n# 输出端口对线路上收到的分组的处理\n\n 1. 网络层分组排队，缓存管理\n 2. 数据链路层处理\n 3. 物理层处理\n 4. 若路由器处理分组的速率赶不上分组进入队列的速率，则后面无法缓存的分组被丢弃\n 5. 路由器中的输入或输出队列产生移除是造成分组丢失的重要原因\n\n# 4.9.2 路由表与路由转发\n\n 1. 路由表根据路由选择算法得出，主要用途是路由选择，用软件来实现\n 2. 转发表是由路由表得来，可以用软件实现也可以用特殊的硬件来实现\n\n\n# 5 传输层\n\n 1. 只有主机才有的层次\n 2. 为应用层提供通信服务，使用网络层的服务\n\n\n# 5.1 功能\n\n 1. 提供进程和进程之间的逻辑通信（网络层是主机与主机）\n 2. 复用和分用\n 3. 对收到的报文进行差错检测\n\n\n# 5.2 协议\n\n 1. tcp：面向连接的传输控制协议；可靠，面向连接，时延大，适用于大文件\n 2. udp：无连接的用户数据报协议；不可靠，无连接，时延小，适用于小文件\n\n\n# 5.3 寻址与端口\n\n 1. 复用：应用层所有的应用进程都可以通过传输层再传输到网络层\n 2. 分用：传输层从网络层收到数据后交付指明的应用进程\n\n# 5.3.1 软件端口\n\n 1. 软件端口是传输层的sap，表示主机中的应用进程\n 2. 端口号只有本地意义，在因特网中不同计算机的相同端口号是没有联系的\n 3. 端口号长16bit，65536个\n 4. 端口号\n    * 服务端\n      * 熟知端口号（0~1023）：tcp/ip最重要的应用程序，所有用户都知道\n      * 登记端口号（1024~4951）：没有熟知端口号的应用程序使用\n    * 客户端（49152~65535）：尽在客户进程运行时才动态选择\n 5. 套接字：位移表示网络的一个主机和它上面的一个进程（主机ip地址+端口号）\n\n\n# 5.4 udp\n\n 1. 只在ip数据报服务上增加很少功能：复用分用和差错检测功能\n\n# 5.4.1 特点\n\n 1. 无连接，减少开销和发送数据之前的时延\n 2. 使用最大努力交付，不保证可靠交付\n 3. 面向报文的，适合一次性传输少量数据的网络应用\n    * 面向报文：不会剪切和整合应用层报文\n 4. 无拥塞控制，适合实时应用\n 5. 首部开销少。8b\n\n# 5.4.2 首部格式\n\n16位源端口号+16位目的端口号+16位udp长度+16位udp检验和\n\n# 5.4.3 udp校验\n\n# 发送端\n\n 1. 填上伪首部\n 2. 全0填充检验和字段\n 3. 全0填充数据部分（满足4b的整数倍）\n 4. 伪首部+首部+数据部分采用二进制反码求和\n 5. 把和求反码填入校验和字段\n 6. 去掉伪首部，发送\n\n# 接收端\n\n 1. 填上伪首部\n 2. 伪首部+首部+数据部分采用二进制反码求和\n 3. 结果全为1则无差错，否则丢弃数据报或者交给应用层附上出差错的警告\n\n\n# 5.5 tcp\n\n# 5.5.1 特点\n\n 1. 面向连接（虚连接）的传输层协议\n 2. 每一条tcp连接只能有两个端点，每一条tcp连接只能是点对点的\n 3. tcp提供可靠交付的服务，无差错、不丢失、不重复、按序到达\n 4. tcp提供全双工通信（tcp协议两段都会有发送缓存和接受缓存）\n    * 发送缓存：准备发送的数据；已发送但尚未收到确认的数据\n    * 接收缓存：按序到达但尚未被接受应用程序读取的数据；不按序到达的数据\n 5. tcp面向字节流：tcp把应用程序交下来的数据看成仅仅是一连串的无结构的字节流\n    * 流：流入到进程或从进程流出的字节序列\n\n# 5.5.2 tcp报文段首部格式\n\n 1.  tcp报文 = tcp首部+tcp数据部分\n 2.  tcp首部是4字节的整数倍\n 3.  源端口+目的端口+序号+确认号+数据偏移+保留+6个控制位+窗口+校验和+紧急指针+选项（长度可变）+填充\n 4.  序号：在一个tcp连接中传输的字节流中的每个字节都按顺序编号，本字段表示本报文段所发送的第一个字节的序号\n 5.  确认号：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为n。则证明到序号n-1为止的所有数据都已正确收到\n 6.  数据偏移（首部长度）：tcp报文段的数据起始处距离tcp报文段的起始处有多远。以4b为单位，1个数值是4b\n 7.  控制位：\n     * 紧急位urg：为1时，表明次报文段中有紧急数据，是高优先级的数据，不用在缓存里排队，配合紧急指针字段使用\n     * 确认位ack：为1时，确认号有效，在连接建立后所有传送的报文段都必须把ack置1\n     * 推送位psh：为1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付\n     * 复位ret： 为1时，表明tcp连接中出现严重差错，必须释放连接，然后再重新建立传输连接；可以用来拒绝非法报文段或者打开链接\n     * 同步位syn：为1时，表明这是一个连接请求/连接接受报文\n     * 终止位fin：为1时，表明此报文段发送方数据已发完，要求释放连接\n 8.  窗口：发送本报文的一方的接收窗口，即现在允许对方发送的数据量\n 9.  检验和：检验首部+数据，检验时要加上12b伪首部\n 10. 紧急指针。在urg为1时才有意义，支出本报文段中紧急数据的字节数\n 11. 选项：最大报文段长度mss、窗口扩大、时间戳、选择确认\n\n# 5.5.3 tcp连接管理\n\n 1. 三个阶段：连接建立+数据传输+连接释放\n 2. tcp连接的建立采用客户端服务器方式，主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器\n\n# tcp连接建立——三次握手\n\n 1. 客户端发送连接请求报文段，无应用层数据\n    * syn=1，序号seq=x（随机）\n 2. 服务端为该tcp连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据\n    * syn=1，ack=1，序号seq=y（随机），确认号ack=x+1\n 3. 客户端为该tcp连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据\n    * syn=1，ack=1，序号seq=x+1，确认号ack=y+1\n 4. ps：syn洪泛攻击：发送大量三次握手的第一次报文，且一直不确认，设置syn cookie\n\n# tcp连接释放——四次握手\n\n 1. 参与一条tcp连接的两个进程中的任何一个都能终止该连接，连接结束后，主机中的“资源”（缓存和变量）将被释放\n 2. 客户端发送连接释放报文段，停止发送数据，主动关闭tcp连接\n    * fin=1，序号seq=u\n 3. 服务器端会送一个确认报文段，客户到服务器这个方向的连接就释放了（半关闭状态）\n    * ack=1，序号seq=v，确认号ack=u+1\n 4. 此处服务器端还可以发送数据\n 5. 服务器端发完数据，就送连接释放报文段，主动关闭tcp连接\n    * fin=1，ack=1，序号seq=w，确认号ack=u+1\n 6. 客户端会送一个确认报文段，再等到时间等待计时器设置的2msl（最长报文段寿命）后，连接彻底关闭\n    * ack=1,序号seq=u+1，确认号ack=w+1\n\n# 5.5.4 tcp可靠传输\n\n 1. 可靠：保证接收方进程熊缓存区读出的字节流与发送方发出的字节流是完全一样的\n 2. tcp实现可靠传输的机制：校验、序号、确认、重传\n\n# 校验\n\n 1. 与udp校验一样。增加伪首部\n\n# 序号\n\n 1. 一个字节占一个序号\n 2. 序号字段指的是一个报文段第一个字节的序号\n\n# 确认\n\n# 重传\n\n 1. 确认重传不分家。tcp的发送方在规定时间内没有收到确认就要重传已发送的报文段\n 2. tcp采用自适应算法，动态改变重传时间rtts（加权平均往返时间）\n 3. 冗余ack（冗余确认）：每当比希望序号的失序报文段到达时，发送一个冗余ack，指明下一个期待字节序号\n    * 发送方收到3个对于某个报文段的冗余ack时，认为下一报文段丢失，重传（快速重传）\n\n# 5.5.5 tcp流量控制\n\n 1. tcp利用滑动窗口机制实现流量控制，发送窗口大小动态变化\n 2. 在通信过程中，接收方根据自己接受缓存的大小，动态地调整发送方的放松窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来讲rwnd通知给发送方），发送方的发送窗口取接受窗口rwnd和拥塞窗口cwnd的最小值\n 3. tcp为每一个连接设有一个持续计时器，只要tcp连接的一方收到对方的零窗口通知，就启动持续计时器\n 4. 若持续计时器设置的时间到期，就发送一个零窗口探测报文段。接收方收到探测报文段时给出现在的窗口值\n 5. 若窗口仍是0，那么发送方就重新设置持续计时器\n\n# 5.5.6 tcp拥塞控制\n\n 1. 出现拥塞的条件：对资源需求的总和> 可用资源；网络中有许多资源同时呈现供应不足，导致网络性能变坏，导致网络吞吐量随输入负荷增大而下降\n 2. 拥塞控制的目的：防止过多的数据注入到网络中，是一个全局性的\n\n# 假定\n\n 1. 数据单方向传送，而另一个方向只传送确认\n 2. 接收方总是有足够大的缓存空间，因而发送窗口大小只取决于拥塞程度\n\n# 慢开始和拥塞避免算法\n\n 1. 一个传输轮次\n    * 发送了一批报文段并收到它们的确认的时间\n    * 一个往返时延rtt\n    * 开始发送一批拥塞窗口内的报文段到开始发送下一批拥塞窗口内的报文段的时间\n\n# 快重传和快恢复\n\n\n\n\n# 6 应用层\n\n\n# 6.1 概述\n\n 1. 应用层对应用程序的通信提供服务\n 2. 应用层协议内容：\n    * 应用进程交换的报文类型\n    * 各种报文类型的语法\n    * 字段的语义\n    * 进程何时、如何发送报文，以及对报文进行响应的规则\n 3. 应用层功能：\n    * 文件传输、访问和管理\n    * 电子邮件\n    * 虚拟终端\n    * 查询服务和远程作业登录\n 4. 应用层的重要协议\n    * ftp\n    * smtp、pop3\n    * http\n    * dns\n\n\n# 6.2 网络应用模型\n\n# 6.2.1 客户/服务器模型\n\n 1. 服务器：提供计算服务的设备\n    * 永久提供服务\n    * 永久性访问地址/域名\n 2. 客户机： 请求服务的主机\n    * 与服务器通信，使用服务器提供的服务\n    * 间歇性接入网络\n    * 可能使用动态ip地址\n    * 不与其他客户机直接通信\n 3. 应用：web，文件传输tfp，远程登录，电子邮件\n\n# 6.2.2 p2p模型\n\n 1. 不存在永远在线的服务器\n 2. 每个主机既可以提供服务，也可以请求服务\n 3. 任意端系统/节点之间可以直接通讯\n 4. 节点间歇性接入网络\n 5. 节点可能改变ip地址\n 6. 可扩展性好\n 7. 网络健壮性强\n\n\n# 6.3 域名解析系统dns\n\n# 6.3.1 域名\n\n 1. 域名从前往后级别依次提高。最后一个.后的是顶级域名，往前是二级域名等等\n 2. 顶级域名：\n    * 国家顶级域名：cn、us、uk\n    * 通用顶级域名：com、net、org、gov、int、aero、museum、travel\n    * 基础结构域名/反向域名：arpa\n 3. 二级域名：\n    * 类别域名：ac、com、edu、gov、mil、org\n    * 行政区域名，用于我国各省、自治区、直辖市：bj、js\n    * 自己注册的\n\n# 6.3.2 域名服务器\n\n# 根域名服务器\n\n 1. 最高层次的域名服务器，也是最重要的\n 2. 知道所有顶级域名服务器的域名和ip地址\n 3. 一共有13个不同名字的根域名服务器\n\n# 顶级域名服务器\n\n 1. 管理该顶级域名服务器注册的所有二级域名和ip地址\n\n# 权限域名服务器\n\n 1. 负责一个区的域名服务器\n 2. 区：\n\n# 本地域名服务器\n\n 1. 不属于域名服务器层次结构\n 2. 当一个主机发出dns查询请求时，这个查询请求报文就发给本地域名服务器\n\n# 6.3.3 域名解析过程\n\n# 递归查询\n\n# 迭代查询\n\n\n# 6.4 文件传输协议ftp\n\n 1. 提供不同种类主机系统（硬、软件体积等都可以不同）之间的文件传输能力\n\n# 6.4.1 ftp服务器和用户端\n\n 1. ftp是基于客户/服务器的协议：用户通过一个客户机程序连接至在远程计算机上运行的服务器程序\n 2. 依照ftp协议提供服务，进行文件传送的计算机就是ftp服务器\n 3. 连接ftp服务器，遵循ftp协议与服务器传送文件的电脑就是ftp客户端\n\n# 6.4.2 ftp工作原理\n\n# 登录\n\n 1. 输入ftp地址，用户名和密码\n 2. 可以采用匿名登录的方式\n\n# 数据传输\n\n 1. ftp使用tcp实现可靠传输\n 2. ftp服务器进程：\n    * 1个主进程\n    * n个从属进程\n 3. 控制进程和数据传送进程都属于从属进程\n 4. 控制连接始终保持，客户端和服务器端存在会话就保持\n 5. 数据连接保持一会儿\n 6. 是否使用tcp 20端口建立数据连接与传输模式有关\n 7. 主动方式使用tcp 20端口；被动方式有服务器和客户端自行协商决定（端口>1024）\n\n# 传输模式\n\n 1. 文本模式：ascii模式，以文本序列传输数据\n 2. 二进制模式：binary模式，以二进制序列传输数据\n\n\n# 6.5 电子邮件\n\n# 6.5.1 电子邮件系统概述\n\n# 电子邮件信息格式\n\n 1. 电子邮件包括信封和内容两个部分\n 2. 信封：信息主要包括收件人邮箱地址\n 3. 内容：\n    * 首部：to和subject\n    * 主体：写信的内容\n\n# 电子邮件系统组成结构\n\n 1. 用户代理：电子邮件客户端软件\n 2. 用户代理功能\n    * 撰写\n    * 显示\n    * 处理\n    * 通信\n 3. 邮件服务器功能：\n    * 发送和接收邮件：\n    * 向发件人报告邮件传送结果\n 4. 协议\n    * smtp：发送\n    * pop3、imap：接收\n\n\n# 6.6 万维网\n\n 1. 万维网www是一个大规模的、联机式的信息储藏所/资料空间，是无数个网络站点和网页的集合\n 2. 统一资源定位符url唯一识别资源\n 3. url一般形式：<协议>://<主机>:<端口>/<路径>\n    * 协议：http、ftp\n    * 主机：域名、ip地址\n 4. 用户通过点击超链接获取资源，这些资源通过超文本传输协议（http）传送给使用者\n 5. 万维网以客户/服务器方式工作，用户使用的留恋其就是万维网客户程序，万维网文档所驻留的主机运行服务器程序\n 6. 万维网使用超文本标记语言html，使得万维网月面设计者可以很方便地从一个界面的连接转到另一个界面，并能够在自己的屏幕上显示出来\n\n\n# 6.7 超文本传输协议http\n\n 1. http协议定义了浏览器（万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器\n\n# 6.7.1 http协议过程\n\n 1. 用户浏览页面方法：\n    * 输入url\n    * 点击超链接\n 2. http过程：\n    * 浏览器分析url\n    * 丽蓝旗向dns请求解析ip地址\n    * dns解析出ip地址\n    * 浏览器与服务器建立tcp连接\n    * 浏览器发出取文件命令\n    * 服务器响应\n    * 释放tcp连接\n    * 浏览器显示\n\n# 6.7.2 http协议特点\n\n 1. http协议是无状态的，无记忆的\n    * 这样诞生了存储用户主机中的文本文件cookie，记录一段时间内用户的访问记录\n 2. http采用tcp作为运输层协议，但http协议本身是无连接的（通信双方在交换http报文之前不需要先建立http连接）\n 3. http连接方式\n    * 持久连接keep-alive\n      * 非流水线\n      * 流水线\n    * 非持戒连接close\n    * \n\n# 6.7.3 http协议报文结构\n\n 1. http报文是面向文本的，因此在报文中的每一个字段都是一些ascii码串\n 2. http报文分成请求报文和响应报文\n 3. \n 4. 状态码\n    * 1xx：表示通知信息的，如请求收到了或正在处理\n    * 2xx：表示成功，如接受或知道了\n    * 3xx：表示重定向，如要完成请求还必须采取进一步的行动\n    * 4xx：表示客户的差错，如请求中有错误的语法或不能完成\n    * 5xx：表示服务器的差错，如服务器失效无法完成请求",charsets:{cjk:!0},lastUpdated:"2023/03/27, 17:41:36",lastUpdatedTimestamp:1679910096e3},{title:"Web3D",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"《Web3D理论基础》",imgUrl:"https://games-cn.org/wp-content/uploads/2020/02/231580721935_.pic_hd-232x300.jpg",description:"Web3D基础理论"}},title:"Web3D",permalink:"/note/Web3D",article:!1,comment:!1,editLink:!1,author:{name:"年华惊风雨",link:"https://github.com/wsy425"},date:"2023-08-08T09:04:03.000Z"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/25.%20Web3D/Web3D.html",relativePath:"02.计算机基础/25. Web3D/Web3D.md",key:"v-0bedbba6",path:"/note/Web3D/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"Numpy",frontmatter:{title:"Numpy",date:"2022-04-11T16:50:51.000Z",permalink:"/pages/726723/",categories:["其他技术","Python"],tags:["Numpy","Python"],author:{name:"年华惊风雨",link:"https://github.com/wsy425"}},regularPath:"/03.%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/00.%20Python/05.%20Numpy.html",relativePath:"03.其他技术/00. Python/05. Numpy.md",key:"v-4b231790",path:"/pages/726723/",headers:[{level:2,title:"1 基础操作",slug:"_1-基础操作",normalizedTitle:"1 基础操作",charIndex:2},{level:3,title:"1.1 创建数组",slug:"_1-1-创建数组",normalizedTitle:"1.1 创建数组",charIndex:32},{level:3,title:"1.2 读取维度",slug:"_1-2-读取维度",normalizedTitle:"1.2 读取维度",charIndex:226},{level:3,title:"1.3 读取各维度大小",slug:"_1-3-读取各维度大小",normalizedTitle:"1.3 读取各维度大小",charIndex:251},{level:3,title:"1.4 读取元素类型",slug:"_1-4-读取元素类型",normalizedTitle:"1.4 读取元素类型",charIndex:278},{level:3,title:"1.5 与list的互相转换",slug:"_1-5-与list的互相转换",normalizedTitle:"1.5 与list的互相转换",charIndex:304},{level:3,title:"1.6 改变数据类型",slug:"_1-6-改变数据类型",normalizedTitle:"1.6 改变数据类型",charIndex:400},{level:2,title:"2 计算",slug:"_2-计算",normalizedTitle:"2 计算",charIndex:661},{level:3,title:"2.1 一般计算",slug:"_2-1-一般计算",normalizedTitle:"2.1 一般计算",charIndex:670},{level:3,title:"2.2 广播计算",slug:"_2-2-广播计算",normalizedTitle:"2.2 广播计算",charIndex:827},{level:4,title:"2.2.1 单数字广播",slug:"_2-2-1-单数字广播",normalizedTitle:"2.2.1 单数字广播",charIndex:839},{level:4,title:"2.2.2 行向量或列向量广播",slug:"_2-2-2-行向量或列向量广播",normalizedTitle:"2.2.2 行向量或列向量广播",charIndex:898},{level:2,title:"3 切片",slug:"_3-切片",normalizedTitle:"3 切片",charIndex:941},{level:3,title:"3.1 切片操作",slug:"_3-1-切片操作",normalizedTitle:"3.1 切片操作",charIndex:950},{level:3,title:"3.2 拷贝操作",slug:"_3-2-拷贝操作",normalizedTitle:"3.2 拷贝操作",charIndex:1053},{level:2,title:"4 索引",slug:"_4-索引",normalizedTitle:"4 索引",charIndex:1171},{level:3,title:"4.1 普通索引",slug:"_4-1-普通索引",normalizedTitle:"4.1 普通索引",charIndex:1180},{level:3,title:"4.2 切片索引",slug:"_4-2-切片索引",normalizedTitle:"4.2 切片索引",charIndex:1370},{level:3,title:"bool索引",slug:"bool索引",normalizedTitle:"bool索引",charIndex:1385},{level:3,title:"花式索引",slug:"花式索引",normalizedTitle:"花式索引",charIndex:1398}],headersStr:"1 基础操作 1.1 创建数组 1.2 读取维度 1.3 读取各维度大小 1.4 读取元素类型 1.5 与list的互相转换 1.6 改变数据类型 2 计算 2.1 一般计算 2.2 广播计算 2.2.1 单数字广播 2.2.2 行向量或列向量广播 3 切片 3.1 切片操作 3.2 拷贝操作 4 索引 4.1 普通索引 4.2 切片索引 bool索引 花式索引",content:"# 1 基础操作\n\nndarray：存储高维数组的对象\n\n\n# 1.1 创建数组\n\nimport numpy as np\narr = np.zeros((10, 10)) #创建数组，10*10全是0的数组\nnp.arange(10) #从0开始的10个自然数\nnp.arange(1, 5, 0.5) #生成等差数列,1到5间隔0.5的等差数列\nnp.ones #生成全是1的数组\nnp.eye #生成单位矩阵\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 1.2 读取维度\n\narr.ndim #\n\n\n# 1.3 读取各维度大小\n\narr.shape\n\n\n# 1.4 读取元素类型\n\narr.dtype\n\n\n# 1.5 与list的互相转换\n\narr.tolist() #变换成python原生list\narr=np.array() #python原生list变换成ndarray\n\n\n1\n2\n\n\n\n# 1.6 改变数据类型\n\nex1 = np.arange(10)\nex1.astype(np.float64) #调用astype方法更改ndarray中所有变量的类型\nex1 = np.arange(10, dtype=np.float32) #创建时通过dtype参数来设置数据类型\n\n\n1\n2\n3\n\n\nnumpy 支持的数据类型：int（带符号和不带符号的8、32、64、128）、float（16、32、64、128）、complex（64、128、256）、string_、object、unicode_\n\n\n# 2 计算\n\n\n# 2.1 一般计算\n\n基本的四则运算和逻辑运算都可以实现 Numpy中四则运算符直接映射到对应的元素中 逻辑运算返回False、True 可以通过np的api进行常见数学计算公式：log、exp、pow等，与math中一致\n\narr = np.array([[1,2,3],[2,2,3]])\n\n\n1\n\n\n\n\n\n# 2.2 广播计算\n\n# 2.2.1 单数字广播\n\narr + 3 #数组中所有数字全加3\narr ** 2 #数字全平方\n\n\n1\n2\n\n\n# 2.2.2 行向量或列向量广播\n\n将行向量或列向量与原数组的各行或各列作运算\n\n\n# 3 切片\n\n\n# 3.1 切片操作\n\n我们用上下标加上冒号来表示我们想要切片的范围， 和Python一样，这是一个左闭右开的区间。\n\narr[4:10] #取4到10位\narr[::-1] #反向切片\n\n\n1\n2\n\n\n\n# 3.2 拷贝操作\n\nNumpy中的切片代表原数组一段区间的引用，而不是拷贝。也就是说我们修改切片中的内容是会影响原数组的 为了不影响原数组需要拷贝是需要调用copy方法\n\narr[3:10].copy() #复制数组\n\n\n1\n\n\n\n# 4 索引\n\n\n# 4.1 普通索引\n\n支持和python一样的多个方括号锁定元素位置；也支持python原生数组不支持的逗号分隔查询\n\narr[2][3] #python原生支持\narr[0,1,1] #python原生不支持\n\n\n1\n2\n\n\n拿3维数组举例，如果我们访问的时候只用一个下标，那么我们获得的是一个二维数组。如果使用两个下标，则获得的是一个一维数组。对于更高的维度也是同样。\n\n\n# 4.2 切片索引\n\n\n\n\n# bool索引\n\n\n\n\n# 花式索引\n\n以次去3、2、1、1、3行的arr组成新的数组",normalizedContent:"# 1 基础操作\n\nndarray：存储高维数组的对象\n\n\n# 1.1 创建数组\n\nimport numpy as np\narr = np.zeros((10, 10)) #创建数组，10*10全是0的数组\nnp.arange(10) #从0开始的10个自然数\nnp.arange(1, 5, 0.5) #生成等差数列,1到5间隔0.5的等差数列\nnp.ones #生成全是1的数组\nnp.eye #生成单位矩阵\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 1.2 读取维度\n\narr.ndim #\n\n\n# 1.3 读取各维度大小\n\narr.shape\n\n\n# 1.4 读取元素类型\n\narr.dtype\n\n\n# 1.5 与list的互相转换\n\narr.tolist() #变换成python原生list\narr=np.array() #python原生list变换成ndarray\n\n\n1\n2\n\n\n\n# 1.6 改变数据类型\n\nex1 = np.arange(10)\nex1.astype(np.float64) #调用astype方法更改ndarray中所有变量的类型\nex1 = np.arange(10, dtype=np.float32) #创建时通过dtype参数来设置数据类型\n\n\n1\n2\n3\n\n\nnumpy 支持的数据类型：int（带符号和不带符号的8、32、64、128）、float（16、32、64、128）、complex（64、128、256）、string_、object、unicode_\n\n\n# 2 计算\n\n\n# 2.1 一般计算\n\n基本的四则运算和逻辑运算都可以实现 numpy中四则运算符直接映射到对应的元素中 逻辑运算返回false、true 可以通过np的api进行常见数学计算公式：log、exp、pow等，与math中一致\n\narr = np.array([[1,2,3],[2,2,3]])\n\n\n1\n\n\n\n\n\n# 2.2 广播计算\n\n# 2.2.1 单数字广播\n\narr + 3 #数组中所有数字全加3\narr ** 2 #数字全平方\n\n\n1\n2\n\n\n# 2.2.2 行向量或列向量广播\n\n将行向量或列向量与原数组的各行或各列作运算\n\n\n# 3 切片\n\n\n# 3.1 切片操作\n\n我们用上下标加上冒号来表示我们想要切片的范围， 和python一样，这是一个左闭右开的区间。\n\narr[4:10] #取4到10位\narr[::-1] #反向切片\n\n\n1\n2\n\n\n\n# 3.2 拷贝操作\n\nnumpy中的切片代表原数组一段区间的引用，而不是拷贝。也就是说我们修改切片中的内容是会影响原数组的 为了不影响原数组需要拷贝是需要调用copy方法\n\narr[3:10].copy() #复制数组\n\n\n1\n\n\n\n# 4 索引\n\n\n# 4.1 普通索引\n\n支持和python一样的多个方括号锁定元素位置；也支持python原生数组不支持的逗号分隔查询\n\narr[2][3] #python原生支持\narr[0,1,1] #python原生不支持\n\n\n1\n2\n\n\n拿3维数组举例，如果我们访问的时候只用一个下标，那么我们获得的是一个二维数组。如果使用两个下标，则获得的是一个一维数组。对于更高的维度也是同样。\n\n\n# 4.2 切片索引\n\n\n\n\n# bool索引\n\n\n\n\n# 花式索引\n\n以次去3、2、1、1、3行的arr组成新的数组",charsets:{cjk:!0},lastUpdated:"2023/03/27, 17:41:36",lastUpdatedTimestamp:1679910096e3},{title:"Matplotlib",frontmatter:{title:"Matplotlib",date:"2022-04-11T16:51:14.000Z",permalink:"/pages/18746f/",categories:["其他技术","Python"],tags:["Matplotlib","Python"],author:{name:"年华惊风雨",link:"https://github.com/wsy425"}},regularPath:"/03.%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/00.%20Python/10.%20Matplotlib.html",relativePath:"03.其他技术/00. Python/10. Matplotlib.md",key:"v-49874ed0",path:"/pages/18746f/",headers:[{level:2,title:"1 基础绘图",slug:"_1-基础绘图",normalizedTitle:"1 基础绘图",charIndex:2},{level:3,title:"1.1 曲线图",slug:"_1-1-曲线图",normalizedTitle:"1.1 曲线图",charIndex:13},{level:3,title:"1.2 直方图",slug:"_1-2-直方图",normalizedTitle:"1.2 直方图",charIndex:76},{level:3,title:"1.3 散点图",slug:"_1-3-散点图",normalizedTitle:"1.3 散点图",charIndex:153},{level:3,title:"1.4 饼状图",slug:"_1-4-饼状图",normalizedTitle:"1.4 饼状图",charIndex:201},{level:2,title:"2 绘图标注",slug:"_2-绘图标注",normalizedTitle:"2 绘图标注",charIndex:273},{level:3,title:"2.1 颜色",slug:"_2-1-颜色",normalizedTitle:"2.1 颜色",charIndex:284},{level:3,title:"2.2 标记",slug:"_2-2-标记",normalizedTitle:"2.2 标记",charIndex:418},{level:3,title:"2.3 线条",slug:"_2-3-线条",normalizedTitle:"2.3 线条",charIndex:475},{level:3,title:"2.4 上述三种合一",slug:"_2-4-上述三种合一",normalizedTitle:"2.4 上述三种合一",charIndex:518},{level:3,title:"2.5 标题",slug:"_2-5-标题",normalizedTitle:"2.5 标题",charIndex:565},{level:4,title:"2.5.1 基础设置：plt.title('标题')",slug:"_2-5-1-基础设置-plt-title-标题",normalizedTitle:"2.5.1 基础设置：plt.title('标题')",charIndex:575},{level:4,title:"2.5.2 子图设置标题",slug:"_2-5-2-子图设置标题",normalizedTitle:"2.5.2 子图设置标题",charIndex:605},{level:4,title:"2.5.3 标题参数",slug:"_2-5-3-标题参数",normalizedTitle:"2.5.3 标题参数",charIndex:859},{level:3,title:"2.6 轴名称",slug:"_2-6-轴名称",normalizedTitle:"2.6 轴名称",charIndex:1398},{level:3,title:"2.7 标签",slug:"_2-7-标签",normalizedTitle:"2.7 标签",charIndex:1441},{level:2,title:"3 图表设置",slug:"_3-图表设置",normalizedTitle:"3 图表设置",charIndex:1683},{level:3,title:"3.1 xlim、ylim",slug:"_3-1-xlim、ylim",normalizedTitle:"3.1 xlim、ylim",charIndex:1694},{level:3,title:"3.2 xticks、ytixks",slug:"_3-2-xticks、ytixks",normalizedTitle:"3.2 xticks、ytixks",charIndex:1739}],headersStr:"1 基础绘图 1.1 曲线图 1.2 直方图 1.3 散点图 1.4 饼状图 2 绘图标注 2.1 颜色 2.2 标记 2.3 线条 2.4 上述三种合一 2.5 标题 2.5.1 基础设置：plt.title('标题') 2.5.2 子图设置标题 2.5.3 标题参数 2.6 轴名称 2.7 标签 3 图表设置 3.1 xlim、ylim 3.2 xticks、ytixks",content:"# 1 基础绘图\n\n\n# 1.1 曲线图\n\n原理：描点呈现，只要输入x、y的两个list就可以了\n\nplt.plot(x,y)呈现x、y的映射\n\n\n# 1.2 直方图\n\n用hist绘制直方图，需要串入一个数组和分类数量参数bins\n\nplt.hist(x,bins= 30) #将x数据分成30组\n\n\n# 1.3 散点图\n\nscatter函数传入x、y数组\n\nplt.scatter(x,y)\n\n\n# 1.4 饼状图\n\n将一个list传入pie函数，plot会根据list中各数字占list数据和的比例绘制饼状图\n\nplt.pie(a)\n\n\n# 2 绘图标注\n\n\n# 2.1 颜色\n\nplt.plot(x,y,color = 'green')加入color参数即可设定绘图颜色\n\n颜色的表示有以下几种\n\n 1. 常见颜色缩写：绿色（g）、红色（r）、蓝色（b）、黄色（y）\n 2. 查阅相关文档\n 3. 16进制RGB表示颜色\n\n\n# 2.2 标记\n\n给数据位置特定图形\n\nplt.plot(x,y,marker='o')\n\n具体标记符号见\n\n\n# 2.3 线条\n\nplt.plot(x,y,linestyle='--')虚线\n\n\n# 2.4 上述三种合一\n\nplt.plot(x,y,'og--')o型标记、绿色、虚线\n\n\n# 2.5 标题\n\n# 2.5.1 基础设置：plt.title('标题')\n\n# 2.5.2 子图设置标题\n\nfig = plt.figure()\nax1 = fig.add_subplot(2,1,1)\nax2 = fig.add_subplot(2,1,2)\n\nax1.set_title('line')\nax2.set_title('logistic')\nplt.subplots_adjust(hspace=0.5) #调节子图之间的间隙\nax1.plot(rang(10))\nax2.plot(x,y)\nplt.show()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 2.5.3 标题参数\n\n 1. fontsize字体大小\n    * 数字代表字体大小，默认为12\n    * 字符串确定字体大小：'xx-small', 'x-small', 'small', 'medium', 'large','x-large', 'xx-large'\n 2. fontweight字体粗细：常用的选项有：['light', 'normal', 'medium', 'semibold', 'bold', 'heavy', 'black'] 。bold就是加粗，semibold是半加粗，heavy是重加粗，black就是全黑了\n 3. verticalalignment竖直对齐方式：'center' , 'top' , 'bottom' ,'baseline'\n 4. horizontalalignment水平对齐方式：[left,right,center]\n 5. rotation旋转角度：输入数字代表旋转角度\n 6. alpha透明度，参数在0到1之间\n 7. backgroundcolor背景颜色\n 8. bbox背景框：facecolor背景颜色，edgecolor线条颜色，boxstyle方框外形，edgewidth线条粗细\n\n\n# 2.6 轴名称\n\nplt.xlabel('x轴名称')\n\n多个子图与标题一样\n\n\n# 2.7 标签\n\n调用legend方法，在绘图后加上laber参数\n\nplt.plot(x,x,laber = 'linear')\nplt.plot(x,x**2,laber = 'quadratic')\nplt.legend()\nplt.show()\n\n\n1\n2\n3\n4\n\n\nlegend参数：常用的是loc，标签位置。\n\n上中下为upper、center、lower；左中右为left、center、right，两两组合得到9中方位，再还有一种best，自适配最佳放置位置\n\n\n# 3 图表设置\n\n\n# 3.1 xlim、ylim\n\n设置坐标轴范围plt.xlim(-5,5)，不常用\n\n\n# 3.2 xticks、ytixks\n\n既可以设置范围也可以设置每个刻度之间的间距，还可以设置坐标轴刻度及旋转角度\n\n#x从-10到10每隔5画一个点，标签为labers且旋转30°\nplt.plot(x,x**2,label='quadratic')\nplt.xlaber('x laber')\nplt.ylaber('y laber')\nlabers = ['10 , 5 , 0 , 5 , 10']\nplt.xicks(range(-10,15,5),laber=labers,rotation=30) #range前闭后开\n\n\n1\n2\n3\n4\n5\n6\n\n\n在月报表等刻度为汉字的时候很有用",normalizedContent:"# 1 基础绘图\n\n\n# 1.1 曲线图\n\n原理：描点呈现，只要输入x、y的两个list就可以了\n\nplt.plot(x,y)呈现x、y的映射\n\n\n# 1.2 直方图\n\n用hist绘制直方图，需要串入一个数组和分类数量参数bins\n\nplt.hist(x,bins= 30) #将x数据分成30组\n\n\n# 1.3 散点图\n\nscatter函数传入x、y数组\n\nplt.scatter(x,y)\n\n\n# 1.4 饼状图\n\n将一个list传入pie函数，plot会根据list中各数字占list数据和的比例绘制饼状图\n\nplt.pie(a)\n\n\n# 2 绘图标注\n\n\n# 2.1 颜色\n\nplt.plot(x,y,color = 'green')加入color参数即可设定绘图颜色\n\n颜色的表示有以下几种\n\n 1. 常见颜色缩写：绿色（g）、红色（r）、蓝色（b）、黄色（y）\n 2. 查阅相关文档\n 3. 16进制rgb表示颜色\n\n\n# 2.2 标记\n\n给数据位置特定图形\n\nplt.plot(x,y,marker='o')\n\n具体标记符号见\n\n\n# 2.3 线条\n\nplt.plot(x,y,linestyle='--')虚线\n\n\n# 2.4 上述三种合一\n\nplt.plot(x,y,'og--')o型标记、绿色、虚线\n\n\n# 2.5 标题\n\n# 2.5.1 基础设置：plt.title('标题')\n\n# 2.5.2 子图设置标题\n\nfig = plt.figure()\nax1 = fig.add_subplot(2,1,1)\nax2 = fig.add_subplot(2,1,2)\n\nax1.set_title('line')\nax2.set_title('logistic')\nplt.subplots_adjust(hspace=0.5) #调节子图之间的间隙\nax1.plot(rang(10))\nax2.plot(x,y)\nplt.show()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 2.5.3 标题参数\n\n 1. fontsize字体大小\n    * 数字代表字体大小，默认为12\n    * 字符串确定字体大小：'xx-small', 'x-small', 'small', 'medium', 'large','x-large', 'xx-large'\n 2. fontweight字体粗细：常用的选项有：['light', 'normal', 'medium', 'semibold', 'bold', 'heavy', 'black'] 。bold就是加粗，semibold是半加粗，heavy是重加粗，black就是全黑了\n 3. verticalalignment竖直对齐方式：'center' , 'top' , 'bottom' ,'baseline'\n 4. horizontalalignment水平对齐方式：[left,right,center]\n 5. rotation旋转角度：输入数字代表旋转角度\n 6. alpha透明度，参数在0到1之间\n 7. backgroundcolor背景颜色\n 8. bbox背景框：facecolor背景颜色，edgecolor线条颜色，boxstyle方框外形，edgewidth线条粗细\n\n\n# 2.6 轴名称\n\nplt.xlabel('x轴名称')\n\n多个子图与标题一样\n\n\n# 2.7 标签\n\n调用legend方法，在绘图后加上laber参数\n\nplt.plot(x,x,laber = 'linear')\nplt.plot(x,x**2,laber = 'quadratic')\nplt.legend()\nplt.show()\n\n\n1\n2\n3\n4\n\n\nlegend参数：常用的是loc，标签位置。\n\n上中下为upper、center、lower；左中右为left、center、right，两两组合得到9中方位，再还有一种best，自适配最佳放置位置\n\n\n# 3 图表设置\n\n\n# 3.1 xlim、ylim\n\n设置坐标轴范围plt.xlim(-5,5)，不常用\n\n\n# 3.2 xticks、ytixks\n\n既可以设置范围也可以设置每个刻度之间的间距，还可以设置坐标轴刻度及旋转角度\n\n#x从-10到10每隔5画一个点，标签为labers且旋转30°\nplt.plot(x,x**2,label='quadratic')\nplt.xlaber('x laber')\nplt.ylaber('y laber')\nlabers = ['10 , 5 , 0 , 5 , 10']\nplt.xicks(range(-10,15,5),laber=labers,rotation=30) #range前闭后开\n\n\n1\n2\n3\n4\n5\n6\n\n\n在月报表等刻度为汉字的时候很有用",charsets:{cjk:!0},lastUpdated:"2023/03/27, 17:41:36",lastUpdatedTimestamp:1679910096e3},{title:"前端面试八股文",frontmatter:{title:"前端面试八股文",date:"2022-04-11T16:56:26.000Z",permalink:"/pages/cd11f8/",categories:["更多","面试"],tags:["面试"],author:{name:"年华惊风雨",link:"https://github.com/wsy425"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/00.%20%E9%9D%A2%E8%AF%95/00.%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87.html",relativePath:"04.更多/00. 面试/00. 前端面试八股文.md",key:"v-8040b698",path:"/pages/cd11f8/",headers:[{level:2,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2},{level:3,title:"var let const1",slug:"var-let-const1",normalizedTitle:"var let const1",charIndex:17},{level:4,title:"var、let、const异同",slug:"var、let、const异同",normalizedTitle:"var、let、const异同",charIndex:35},{level:4,title:"var 1",slug:"var-1",normalizedTitle:"var 1",charIndex:137},{level:4,title:"let 1",slug:"let-1",normalizedTitle:"let 1",charIndex:207},{level:4,title:"const 1",slug:"const-1",normalizedTitle:"const 1",charIndex:397},{level:4,title:"变量提升的理解 1",slug:"变量提升的理解-1",normalizedTitle:"变量提升的理解 1",charIndex:517},{level:3,title:"箭头函数1",slug:"箭头函数1",normalizedTitle:"箭头函数1",charIndex:560},{level:4,title:"箭头函数与普通函数的区别 1",slug:"箭头函数与普通函数的区别-1",normalizedTitle:"箭头函数与普通函数的区别 1",charIndex:569},{level:3,title:"事件代理1",slug:"事件代理1",normalizedTitle:"事件代理1",charIndex:1024},{level:3,title:"cookie sessionStorage localStorage 1",slug:"cookie-sessionstorage-localstorage-1",normalizedTitle:"cookie sessionstorage localstorage 1",charIndex:1909},{level:4,title:"cookie",slug:"cookie",normalizedTitle:"cookie",charIndex:1909},{level:4,title:"localStorage 1",slug:"localstorage-1",normalizedTitle:"localstorage 1",charIndex:1931},{level:4,title:"sessionStorage 1",slug:"sessionstorage-1",normalizedTitle:"sessionstorage 1",charIndex:2214},{level:3,title:"js数据类型1",slug:"js数据类型1",normalizedTitle:"js数据类型1",charIndex:2377},{level:4,title:"js数据类型判断1",slug:"js数据类型判断1",normalizedTitle:"js数据类型判断1",charIndex:2492},{level:4,title:"instanceof的实现",slug:"instanceof的实现",normalizedTitle:"instanceof的实现",charIndex:2918},{level:3,title:"Promise",slug:"promise",normalizedTitle:"promise",charIndex:3224},{level:4,title:"Promise是什么?",slug:"promise是什么",normalizedTitle:"promise是什么?",charIndex:3452},{level:4,title:"Promise是为解决什么问题而产生的?",slug:"promise是为解决什么问题而产生的",normalizedTitle:"promise是为解决什么问题而产生的?",charIndex:3613},{level:4,title:"Promise的两个特点",slug:"promise的两个特点",normalizedTitle:"promise的两个特点",charIndex:3664},{level:4,title:"Promise的三个缺点",slug:"promise的三个缺点",normalizedTitle:"promise的三个缺点",charIndex:3856},{level:4,title:"Promise在哪存放成功回调序列和失败回调序列",slug:"promise在哪存放成功回调序列和失败回调序列",normalizedTitle:"promise在哪存放成功回调序列和失败回调序列",charIndex:3990},{level:3,title:"ES6新特性",slug:"es6新特性",normalizedTitle:"es6新特性",charIndex:4379},{level:3,title:"原型链",slug:"原型链",normalizedTitle:"原型链",charIndex:4846},{level:4,title:"什么是原型链",slug:"什么是原型链",normalizedTitle:"什么是原型链",charIndex:4906},{level:4,title:"原型对象和实例之间有什么作用",slug:"原型对象和实例之间有什么作用",normalizedTitle:"原型对象和实例之间有什么作用",charIndex:5052},{level:4,title:"prototype原型对象",slug:"prototype原型对象",normalizedTitle:"prototype原型对象",charIndex:5161},{level:4,title:"_proto_对象原型",slug:"proto-对象原型",normalizedTitle:"_proto_对象原型",charIndex:null},{level:4,title:"constructor构造函数",slug:"constructor构造函数",normalizedTitle:"constructor构造函数",charIndex:5559},{level:3,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:778},{level:4,title:"原型链继承",slug:"原型链继承",normalizedTitle:"原型链继承",charIndex:5772},{level:4,title:"借用构造函数继承（伪造对象、经典继承）",slug:"借用构造函数继承-伪造对象、经典继承",normalizedTitle:"借用构造函数继承（伪造对象、经典继承）",charIndex:6167},{level:4,title:"组合继承",slug:"组合继承",normalizedTitle:"组合继承",charIndex:6559},{level:4,title:"ES6class继承",slug:"es6class继承",normalizedTitle:"es6class继承",charIndex:7084},{level:3,title:"Null undefined",slug:"null-undefined",normalizedTitle:"null undefined",charIndex:7633},{level:4,title:"Null",slug:"null",normalizedTitle:"null",charIndex:7633},{level:4,title:"undefined",slug:"undefined",normalizedTitle:"undefined",charIndex:2424},{level:3,title:"call bind apply",slug:"call-bind-apply",normalizedTitle:"call bind apply",charIndex:7818},{level:4,title:"apply方法",slug:"apply方法",normalizedTitle:"apply方法",charIndex:7837},{level:4,title:"call方法",slug:"call方法",normalizedTitle:"call方法",charIndex:8010},{level:4,title:"bind方法",slug:"bind方法",normalizedTitle:"bind方法",charIndex:8205},{level:3,title:"闭包",slug:"闭包",normalizedTitle:"闭包",charIndex:8386},{level:4,title:"变量作用域",slug:"变量作用域",normalizedTitle:"变量作用域",charIndex:8392},{level:4,title:"从外部读取函数内部的局部变量",slug:"从外部读取函数内部的局部变量",normalizedTitle:"从外部读取函数内部的局部变量",charIndex:8444},{level:4,title:"闭包的概念",slug:"闭包的概念",normalizedTitle:"闭包的概念",charIndex:8760},{level:4,title:"闭包的用途",slug:"闭包的用途",normalizedTitle:"闭包的用途",charIndex:8836},{level:4,title:"使用闭包的注意点",slug:"使用闭包的注意点",normalizedTitle:"使用闭包的注意点",charIndex:8896},{level:3,title:"数组去重",slug:"数组去重",normalizedTitle:"数组去重",charIndex:9137},{level:4,title:"利用ES6 Set去重（ES6中最常用）",slug:"利用es6-set去重-es6中最常用",normalizedTitle:"利用es6 set去重（es6中最常用）",charIndex:9145},{level:4,title:"利用for嵌套for，然后splice去重（ES5中最常用）",slug:"利用for嵌套for-然后splice去重-es5中最常用",normalizedTitle:"利用for嵌套for，然后splice去重（es5中最常用）",charIndex:9265},{level:4,title:"利用indexOf去重",slug:"利用indexof去重",normalizedTitle:"利用indexof去重",charIndex:9637},{level:4,title:"利用sort()",slug:"利用sort",normalizedTitle:"利用sort()",charIndex:9873},{level:4,title:"利用includes",slug:"利用includes",normalizedTitle:"利用includes",charIndex:10226},{level:4,title:"利用filter",slug:"利用filter",normalizedTitle:"利用filter",charIndex:10493},{level:4,title:"利用Map数据结构去重",slug:"利用map数据结构去重",normalizedTitle:"利用map数据结构去重",charIndex:10684},{level:3,title:"深浅拷贝",slug:"深浅拷贝",normalizedTitle:"深浅拷贝",charIndex:11059},{level:3,title:"require import",slug:"require-import",normalizedTitle:"require import",charIndex:11198},{level:2,title:"浏览器原理",slug:"浏览器原理",normalizedTitle:"浏览器原理",charIndex:11683},{level:3,title:"跨域1",slug:"跨域1",normalizedTitle:"跨域1",charIndex:11693},{level:4,title:"同源策略",slug:"同源策略",normalizedTitle:"同源策略",charIndex:11777},{level:5,title:"同源的定义",slug:"同源的定义",normalizedTitle:"同源的定义",charIndex:11785},{level:5,title:"同源策略的作用",slug:"同源策略的作用",normalizedTitle:"同源策略的作用",charIndex:11902},{level:4,title:"跨域请求发送出去了吗",slug:"跨域请求发送出去了吗",normalizedTitle:"跨域请求发送出去了吗",charIndex:12082},{level:4,title:"跨域请求的解决方案 1",slug:"跨域请求的解决方案-1",normalizedTitle:"跨域请求的解决方案 1",charIndex:12166},{level:4,title:"cors 方案中预检过程 1",slug:"cors-方案中预检过程-1",normalizedTitle:"cors 方案中预检过程 1",charIndex:12443},{level:4,title:"jsonp 方案的大致流程 1",slug:"jsonp-方案的大致流程-1",normalizedTitle:"jsonp 方案的大致流程 1",charIndex:12861},{level:4,title:"nginx 和 webpack 代理方式的区别",slug:"nginx-和-webpack-代理方式的区别",normalizedTitle:"nginx 和 webpack 代理方式的区别",charIndex:13060},{level:3,title:"HTTP请求",slug:"http请求",normalizedTitle:"http请求",charIndex:12558},{level:4,title:"GET方法",slug:"get方法",normalizedTitle:"get方法",charIndex:13223},{level:4,title:"POST方法",slug:"post方法",normalizedTitle:"post方法",charIndex:13440},{level:4,title:"GET和POST的区别",slug:"get和post的区别",normalizedTitle:"get和post的区别",charIndex:13574},{level:4,title:"HEAD方法",slug:"head方法",normalizedTitle:"head方法",charIndex:13866},{level:4,title:"PUT方法",slug:"put方法",normalizedTitle:"put方法",charIndex:13945},{level:4,title:"DELETE方法",slug:"delete方法",normalizedTitle:"delete方法",charIndex:14081},{level:4,title:"CONNECT方法",slug:"connect方法",normalizedTitle:"connect方法",charIndex:14138},{level:4,title:"OPTIONS方法",slug:"options方法",normalizedTitle:"options方法",charIndex:14241},{level:4,title:"TRACE方法",slug:"trace方法",normalizedTitle:"trace方法",charIndex:14305},{level:3,title:"URL输出到页面的全过程",slug:"url输出到页面的全过程",normalizedTitle:"url输出到页面的全过程",charIndex:14388},{level:4,title:"浏览器构建HTTP Request请求",slug:"浏览器构建http-request请求",normalizedTitle:"浏览器构建http request请求",charIndex:14406},{level:4,title:"网络传输",slug:"网络传输",normalizedTitle:"网络传输",charIndex:15867},{level:4,title:"服务器处理及反向传输",slug:"服务器处理及反向传输",normalizedTitle:"服务器处理及反向传输",charIndex:15875},{level:4,title:"浏览器渲染",slug:"浏览器渲染",normalizedTitle:"浏览器渲染",charIndex:16187},{level:3,title:"事件循环",slug:"事件循环",normalizedTitle:"事件循环",charIndex:17451},{level:2,title:"VUE",slug:"vue",normalizedTitle:"vue",charIndex:17467},{level:3,title:"组件间传递数据1",slug:"组件间传递数据1",normalizedTitle:"组件间传递数据1",charIndex:17475},{level:3,title:"VUE2和VUE3的区别1",slug:"vue2和vue3的区别1",normalizedTitle:"vue2和vue3的区别1",charIndex:17916},{level:3,title:"响应式1",slug:"响应式1",normalizedTitle:"响应式1",charIndex:18250},{level:4,title:"MVC模式",slug:"mvc模式",normalizedTitle:"mvc模式",charIndex:18258},{level:4,title:"MVVM模式",slug:"mvvm模式",normalizedTitle:"mvvm模式",charIndex:18332},{level:4,title:"双向绑定原理 1",slug:"双向绑定原理-1",normalizedTitle:"双向绑定原理 1",charIndex:18547},{level:4,title:"VUE2.x怎么实现复杂数据结构的数据监听 1",slug:"vue2-x怎么实现复杂数据结构的数据监听-1",normalizedTitle:"vue2.x怎么实现复杂数据结构的数据监听 1",charIndex:18914},{level:3,title:"状态管理1",slug:"状态管理1",normalizedTitle:"状态管理1",charIndex:18983},{level:4,title:"vuex",slug:"vuex",normalizedTitle:"vuex",charIndex:18992},{level:4,title:"pinia 1",slug:"pinia-1",normalizedTitle:"pinia 1",charIndex:19e3},{level:3,title:"生命周期函数",slug:"生命周期函数",normalizedTitle:"生命周期函数",charIndex:19012},{level:4,title:"VUE2生命周期",slug:"vue2生命周期",normalizedTitle:"vue2生命周期",charIndex:19156},{level:4,title:"VUE3生命周期",slug:"vue3生命周期",normalizedTitle:"vue3生命周期",charIndex:19552},{level:2,title:"CSS",slug:"css",normalizedTitle:"css",charIndex:16448},{level:3,title:"选择器 1",slug:"选择器-1",normalizedTitle:"选择器 1",charIndex:20019},{level:4,title:"标签选择器",slug:"标签选择器",normalizedTitle:"标签选择器",charIndex:20030},{level:4,title:"类选择器",slug:"类选择器",normalizedTitle:"类选择器",charIndex:20065},{level:4,title:"ID选择器",slug:"id选择器",normalizedTitle:"id选择器",charIndex:20129},{level:4,title:"通配符选择器",slug:"通配符选择器",normalizedTitle:"通配符选择器",charIndex:20186},{level:4,title:"后代选择器",slug:"后代选择器",normalizedTitle:"后代选择器",charIndex:20223},{level:4,title:"子代选择器",slug:"子代选择器",normalizedTitle:"子代选择器",charIndex:20283},{level:4,title:"并集选择器",slug:"并集选择器",normalizedTitle:"并集选择器",charIndex:20320},{level:4,title:"链接伪类选择器",slug:"链接伪类选择器",normalizedTitle:"链接伪类选择器",charIndex:20371},{level:4,title:"：focus伪类选择",slug:"focus伪类选择",normalizedTitle:"：focus伪类选择",charIndex:20540},{level:3,title:"水平垂直居中 1",slug:"水平垂直居中-1",normalizedTitle:"水平垂直居中 1",charIndex:20598},{level:4,title:"flex布局",slug:"flex布局",normalizedTitle:"flex布局",charIndex:20610},{level:4,title:"margin:auto",slug:"margin-auto",normalizedTitle:"margin:auto",charIndex:20684},{level:4,title:"利用相对定位和绝对定位，再加上外边距和平移的配合",slug:"利用相对定位和绝对定位-再加上外边距和平移的配合",normalizedTitle:"利用相对定位和绝对定位，再加上外边距和平移的配合",charIndex:20744},{level:4,title:"利用textAlign和verticalAlign",slug:"利用textalign和verticalalign",normalizedTitle:"利用textalign和verticalalign",charIndex:20831},{level:3,title:"盒子模型 1",slug:"盒子模型-1",normalizedTitle:"盒子模型 1",charIndex:20961},{level:3,title:"块级元素 行内元素 行内块元素",slug:"块级元素-行内元素-行内块元素",normalizedTitle:"块级元素 行内元素 行内块元素",charIndex:21126},{level:4,title:"块级元素",slug:"块级元素",normalizedTitle:"块级元素",charIndex:21126},{level:4,title:"行内元素",slug:"行内元素",normalizedTitle:"行内元素",charIndex:20882},{level:4,title:"行内块元素",slug:"行内块元素",normalizedTitle:"行内块元素",charIndex:21136},{level:2,title:"HTML",slug:"html",normalizedTitle:"html",charIndex:16177},{level:3,title:"HTML5新特性",slug:"html5新特性",normalizedTitle:"html5新特性",charIndex:21420},{level:4,title:"语义标签",slug:"语义标签",normalizedTitle:"语义标签",charIndex:21432},{level:4,title:"增强表单",slug:"增强表单",normalizedTitle:"增强表单",charIndex:21520},{level:4,title:"视频和音频",slug:"视频和音频",normalizedTitle:"视频和音频",charIndex:21639},{level:4,title:"Canvas绘图",slug:"canvas绘图",normalizedTitle:"canvas绘图",charIndex:21675},{level:4,title:"SVG绘图",slug:"svg绘图",normalizedTitle:"svg绘图",charIndex:21687},{level:4,title:"地理定位",slug:"地理定位",normalizedTitle:"地理定位",charIndex:21696},{level:4,title:"拖放API",slug:"拖放api",normalizedTitle:"拖放api",charIndex:21704},{level:4,title:"WebWorker",slug:"webworker",normalizedTitle:"webworker",charIndex:21713},{level:4,title:"WebStorage",slug:"webstorage",normalizedTitle:"webstorage",charIndex:21758},{level:4,title:"WebSocket",slug:"websocket",normalizedTitle:"websocket",charIndex:21806},{level:2,title:"系统部署",slug:"系统部署",normalizedTitle:"系统部署",charIndex:21835},{level:3,title:"webpack 1",slug:"webpack-1",normalizedTitle:"webpack 1",charIndex:21844},{level:4,title:"webpack打包流程 1",slug:"webpack打包流程-1",normalizedTitle:"webpack打包流程 1",charIndex:21857},{level:4,title:"webpack怎么实现ES6到ES5 1",slug:"webpack怎么实现es6到es5-1",normalizedTitle:"webpack怎么实现es6到es5 1",charIndex:21874},{level:4,title:"webpack配置参数 1",slug:"webpack配置参数-1",normalizedTitle:"webpack配置参数 1",charIndex:21898}],headersStr:"JavaScript var let const1 var、let、const异同 var 1 let 1 const 1 变量提升的理解 1 箭头函数1 箭头函数与普通函数的区别 1 事件代理1 cookie sessionStorage localStorage 1 cookie localStorage 1 sessionStorage 1 js数据类型1 js数据类型判断1 instanceof的实现 Promise Promise是什么? Promise是为解决什么问题而产生的? Promise的两个特点 Promise的三个缺点 Promise在哪存放成功回调序列和失败回调序列 ES6新特性 原型链 什么是原型链 原型对象和实例之间有什么作用 prototype原型对象 _proto_对象原型 constructor构造函数 继承 原型链继承 借用构造函数继承（伪造对象、经典继承） 组合继承 ES6class继承 Null undefined Null undefined call bind apply apply方法 call方法 bind方法 闭包 变量作用域 从外部读取函数内部的局部变量 闭包的概念 闭包的用途 使用闭包的注意点 数组去重 利用ES6 Set去重（ES6中最常用） 利用for嵌套for，然后splice去重（ES5中最常用） 利用indexOf去重 利用sort() 利用includes 利用filter 利用Map数据结构去重 深浅拷贝 require import 浏览器原理 跨域1 同源策略 同源的定义 同源策略的作用 跨域请求发送出去了吗 跨域请求的解决方案 1 cors 方案中预检过程 1 jsonp 方案的大致流程 1 nginx 和 webpack 代理方式的区别 HTTP请求 GET方法 POST方法 GET和POST的区别 HEAD方法 PUT方法 DELETE方法 CONNECT方法 OPTIONS方法 TRACE方法 URL输出到页面的全过程 浏览器构建HTTP Request请求 网络传输 服务器处理及反向传输 浏览器渲染 事件循环 VUE 组件间传递数据1 VUE2和VUE3的区别1 响应式1 MVC模式 MVVM模式 双向绑定原理 1 VUE2.x怎么实现复杂数据结构的数据监听 1 状态管理1 vuex pinia 1 生命周期函数 VUE2生命周期 VUE3生命周期 CSS 选择器 1 标签选择器 类选择器 ID选择器 通配符选择器 后代选择器 子代选择器 并集选择器 链接伪类选择器 ：focus伪类选择 水平垂直居中 1 flex布局 margin:auto 利用相对定位和绝对定位，再加上外边距和平移的配合 利用textAlign和verticalAlign 盒子模型 1 块级元素 行内元素 行内块元素 块级元素 行内元素 行内块元素 HTML HTML5新特性 语义标签 增强表单 视频和音频 Canvas绘图 SVG绘图 地理定位 拖放API WebWorker WebStorage WebSocket 系统部署 webpack 1 webpack打包流程 1 webpack怎么实现ES6到ES5 1 webpack配置参数 1",content:'# JavaScript\n\n\n# var let const1\n\n# var、let、const异同\n\n 1. 共同点：都能声明变量\n 2. 不同点：var 在ECMAScript 的所有版本中都可以使用，而const和let只能在ECMAScript6及更晚中使用\n\n# var 1\n\n 1. var存在变量提升\n 2. 函数作用域\n 3. 可以重复声明\n 4. 全局声明时会变成windows对象的属性\n\n# let 1\n\n 1. 块级作用域\n 2. 全局声明时不会变成windows对象的属性\n 3. 不能进行条件式声明（判断是否声明然后再确定是否声明），因为会声明在条件符合的块级作用域里\n 4. let没有变量提升\n 5. 不允许重复声明\n 6. 暂时性死区：js引擎会注意到后面的let声明，但并没有变量提升，会抛出ReferenceError，而不是not defined\n\n# const 1\n\n 1. 块级作用域\n 2. 全局声明时不会变成windows对象的属性\n 3. 没有变量提升\n 4. 不允许重复声明\n 5. 声明变量时必须赋值\n 6. 变量不能修改，但仅限于变量引用的对象，对内部属性的修改不报错\n\n# 变量提升的理解 1\n\nvar变量的时候会把所有变量声明都拉到函数作用域的顶部\n\n\n# 箭头函数1\n\n# 箭头函数与普通函数的区别 1\n\n 1.  箭头函数没有this，所以需要通过查找作用域链来确定this的值，这就意味着如果箭头函数被非箭头函数包含，this绑定的就是最近一层非箭头函数的this\n 2.  箭头函数没有自己的arguments对象，但是可以访问外围函数的arguments对象\n 3.  不能通过new关键字调用，同样也没有new.target值和原型\n 4.  语法更加简洁、清晰\n 5.  箭头函数继承而来的this指向永远不变\n 6.  .call()/.apply()/.bind()无法改变箭头函数中this的指向\n 7.  箭头函数不能作为构造函数使用\n 8.  箭头函数没有自己的arguments，可以在箭头函数中使用rest参数代替arguments对象，来访问箭头函数的参数列表\n 9.  箭头函数没有原型prototype\n 10. 箭头函数不能用作Generator函数，不能使用yeild关键字\n 11. 箭头函数不具有super，不具有new.target\n\n\n# 事件代理1\n\n 1. 事件代理（Event Delegation），又称之为事件委托。是JavaScript中常用绑定事件的常用技巧\n 2. 事件传播\n    1. 捕获阶段：从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase），捕获阶段不会响应任何事件\n    2. 目标阶段：在目标节点上触发，称为“目标阶段”\n    3. 冒泡阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层\n 3. 事件代理优点\n    1. 可以大量节省内存占用，减少事件注册，比如在ul上代理所有li的click事件就非常棒\n    2. 可以实现当新增子对象时无需再次对其绑定（动态绑定事件）\n 4. 事件代理的实现\n\nvar item1 = document.getElementById("goSomewhere");\nvar item2 = document.getElementById("doSomething");\nvar item3 = document.getElementById("sayHi");\n\ndocument.addEventListener("click", function (event) {\n  var target = event.target;\n  switch (target.id) {\n    case "doSomething":\n      document.title = "事件委托";\n      break;\n    case "goSomewhere":\n      location.href = "http://www.baidu.com";\n      break;\n    case "sayHi": alert("hi");\n      break;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# cookie sessionStorage localStorage 1\n\n\n\n# cookie\n\n 1. 存储的数据量小，每个不超过4096字节\n 2. 每个域有cookie个数限值，具体个数与浏览器相关\n 3. 可以通过HTTP-only限值浏览器通过js访问\n 4. 通过设置 domain、path 等参数可以随着请求发送到服务器端\n 5. 可以通过 expires 设置有效期\n\n# localStorage 1\n\n 1. 永久存储机制：将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，\n 2. 浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用\n\n# sessionStorage 1\n\n 1. 跨会话存储机制：将数据保存在session对象中。\n 2. session是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间\n 3. 存储的数据不受页面刷新的影响，但只能在最初存储数据的页面使用，在多页应用程序中的用处有限\n\n\n# js数据类型1\n\n 1. 简单数据类型：String、Number、boolean、null、undefined、bigInt、symbol\n 2. 引用数据类型：object里面包括function、Array、Date\n\n# js数据类型判断1\n\n 1. typeof，只能判断简单数据类型，不能具体区分object\n    1. 对于基本类型，除 null 以外，均可以返回正确的结果。\n    2. 对于引用类型，除 function 以外，一律返回 object 类型。\n    3. 对于 null ，返回 object 类型。\n    4. 对于 function 返回 function 类型\n 2. instanceof:instanceof 检测的是原型\n 3. constructor：当一个函数F被创建时，JS引擎会为其添加prototype原型，然后在原型上添加一个constructor属性，并让其指向F的引用。也就是说F.prototype.constructor === F // ---\x3e true\n 4. toString() ：toString 方法默认返回其调用者的具体类型，更严格的讲是toString运行时，this指向的对象类型\n\n# instanceof的实现\n\nfunction instanceof(obj, classType) {\n  let classProto = classType.prototype;\n  obj = obj.__proto__;\n  while (true) {\n    if (obj === null) {\n      return false;\n    }\n    if (obj === classProto) {\n      return true;\n    }\n    obj = obj.__proto__;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Promise\n\n 1. Promise 是一种为了避免回调地狱的异步解决方案\n 2. Promise 是一种状态机： pending（进行中）、fulfilled（已成功）和rejected（已失败） 只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。\n 3. 回调地狱:回调函数中嵌套回调函数的情况就叫做回调地狱\n 4. 回调地狱就是为是实现代码顺序执行而出现的一种操作，它会造成我们的代码可读性非常差，后期不好维护\n\n# Promise是什么?\n\n 1. Promise是最早由社区提出和实现的一种解决异步编程的方案，比其他传统的解决方案（回调函数和事件）更合理和更强大\n 2. ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。\n 3. ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。\n\n# Promise是为解决什么问题而产生的?\n\npromise是为解决异步处理回调地狱问题而产生的\n\n# Promise的两个特点\n\n 1. Promise对象的状态不受外界影响\n    1. pending 初始状态\n    2. fulfilled 成功状态\n    3. rejected 失败状态\n 2. Promise的状态一旦改变，就不会再变，任何时候都可以得到这个结果，状态不可以逆，只能由 pending变成fulfilled或者由pending变成rejected\n\n# Promise的三个缺点\n\n 1. 无法取消Promise,一旦新建它就会立即执行，无法中途取消\n 2. 如果不设置回调函数，Promise内部抛出的错误，不会反映到外部\n 3. 当处于pending状态时，无法得知目前进展到哪一个阶段，是刚刚开始还是即将完成\n\n# Promise在哪存放成功回调序列和失败回调序列\n\n 1. onResolvedCallbacks 成功后要执行的回调序列 是一个数组\n 2. onRejectedCallbacks 失败后要执行的回调序列 是一个数组\n 3. 以上两个数组存放在Promise 创建实例时给Promise这个类传的函数中，默认都是空数组。\n 4. 每次实例then的时候 传入 onFulfilled 成功回调 onRejected 失败回调，如果此时的状态是pending 则将onFulfilled和onRejected push到对应的成功回调序列数组和失败回调序列数组中，如果此时的状态是fulfilled 则onFulfilled立即执行，如果此时的状态是rejected则onRejected立即执行\n 5. 上述序列中的回调函数执行的时候 是有顺序的，即按照顺序依次执行\n\n\n# ES6新特性\n\n 1. let与const\n    1. let 允许创建块级作用域（最靠近的一个花括号内有效），不具备变量提升，不允许重复声明 2.const 允许创建块级作用域（最靠近的一个花括号内有效）、变量声明不提升、const 在声明时必须被赋值、声明时大写变量（默认规则）、block作用域\n 2. 箭头函数：ES6 中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =>，紧接着是函数体：\n 3. 函数默认参数值：ES6 中允许你对函数参数设置默认值\n 4. 对象超类：ES6 允许在对象中使用 super 方法来调用父类的构造函数\n 5. Map VS WeakMap\n    1. ES6 中两种新的数据结构集：Map 和 WeakMap。事实上每个对象都可以看作是一个 Map\n    2. 一个对象由多个 key-val 对构成，在 Map 中，任何类型都可以作为对象的 key\n 6. 类\n    1. ES6 中有 class 语法。值得注意是，这里的 class 不是新的对象继承模型，它只是原型链的语法糖表现形式\n    2. 函数中使用 static 关键词定义构造函数的的方法和属性\n\n\n# 原型链\n\n# 什么是原型链\n\n简单理解就是原型组成的链，对象的__proto__它的是原型，而原型也是一个对象，也有__proto__属性，原型的__proto__又是原型的原型，就这样可以一直通过__proto__想上找，这就是原型链，当向上找找到Object的原型的时候，这条原型链就算到头了。\n\n# 原型对象和实例之间有什么作用\n\n通过一个构造函数创建出来的多个实例，如果都要添加一个方法，给每个实例去添加并不是一个明智的选择。这时就该用上原型了。\n实例的原型上添加一个方法，这个原型的所有实例便都有了这个方法\n\n# prototype原型对象\n\n 1. prototype属性，它是函数所独有的，它是从一个函数指向一个对象。\n 2. 每一个构造函数都一个prototype属性，指向另一个对象。这个对象的所有属性和方法都会被构造函数所拥有\n 3. 构造函数通过原型分配的函数是所有对象所共享的\n\n# __proto__对象原型\n\n 1. 对象都会有一个属性__proto__指向构造函数的prototype原型对象，这让对象可以使用构造函数原型对象的属性和方法\n 2. 对象都会有一个属性__proto__指向构造函数的prototype原型对象，这让对象可以使用构造函数原型对象的属性和方法\n 3. __proto__是一个非标准属性，不能对其赋值\n 4. 对象方法查找规则\n    1. 先查找对象是否存在该方法，有就执行对象上的方法\n    2. 通过__proto__去构造函数原型对象里查找执行\n\n# constructor构造函数\n\n 1. 对象原型__proto__和构造函数prototype原型对象里面都有一个属性constructor，被称为构造函数，因为它指回构造函数本身\n 2. constructor用于记录该对象引用哪个构造函数，它可以让原型对象重新指向原来的构造函数\n 3. 如果修改了原来的原型对象，给原型对象幅值的是一个对象，则必须手动地使用constructor指回原来的构造函数\n\n\n# 继承\n\n# 原型链继承\n\n 1. 父类的实例作为子类的原型\n\nfunction Father() {\n}\nFather.prototype.money = function(){\n    console.log(100000)\n}\nSon.prototype = new Father();\n//如果利用对象的形式修改了原型对象，要用constructor指回原来的构造函数\nSon.prototype.constructor = Son;\nfunction Son() {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 2. 优点：简单易于实现，父类的新增的实例与属性子类都能访问\n 3. 缺点：\n    1. 可以在子类中增加实例属性，如果要新增加原型属性和方法需要在new 父类构造函数的后面\n    2. 无法实现多继承\n    3. 创建子类实例时，不能向父类构造函数中传参数\n\n# 借用构造函数继承（伪造对象、经典继承）\n\n 1. 复制父类的实例属性给子类\n\nfunction Father(uname, age) {\n    //此处的this指向父构造函数的对象实例\n    this.uname = uname;\n    this.age = age;\n}\nfunction Son(uname, age) {\n    //将父构造函数的this改成子构造函数的this\n    Father.call(this, uname, age);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 2. 优点\n    1. 解决了子类构造函数向父类构造函数中传递参数\n    2. 可以实现多继承（call或者apply多个父类）\n 3. 缺点\n    1. 方法都在构造函数中定义，无法复用\n    2. 不能继承原型属性/方法，只能继承父类的实例属性和方法\n\n# 组合继承\n\n 1. 这种方式关键在于:通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。\n\nfunction Father (name, age) {\n    this.name = name,\n    this.age = age,\n    this.setAge = function () { }\n}\nfunction Son (name, age, price) {\n    Father.call(this, name, age)  \n    this.price = price  \n    this.setScore = function () { }\n}\nSon.prototype = new Father()\nSon.prototype.constructor = Son      \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n 2. 优点\n    1. 可以继承实例属性/方法，也可以继承原型属性/方法\n    2. 不存在引用属性共享问题\n    3. 可传参\n    4. 函数可复用\n 3. 缺点\n    1. 调用了两次父类构造函数，生成了两份实例\n\n# ES6class继承\n\nclass Father {\n    constructor(name, age) {\n        this.name = name\n        this.age = age\n    }\n    howName () {\n        console.log("调用父类的方法")\n        console.log(this.name, this.age);\n    }\n})\nSon extends Father {\n    constructor(name, age, salary) {\n        super(name, age)\n        this.salary = salary\n    }\n    showName () {\n        console.log("调用子类的方法")\n        console.log(this.name, this.age, this.salary);\n    }\n}    \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n 2. 优点：语法简单易懂,操作更方便\n 3. 缺点：并不是所有的浏览器都支持class关键字\n\n\n# Null undefined\n\n# Null\n\n 1. 空指针对象\n 2. typeof一个null会返回object\n 3. 使用==判断null与undefined始终返回true\n\n# undefined\n\n 1. 表示一个变量声明了但没有赋值\n 2. onsole.log(未声明的变量)会报错，但typeof(未声明的变量)则会返回undefined\n\n\n# call bind apply\n\n# apply方法\n\n 1. 可以调用函数，也可以改变this指向\n 2. 语法函数名.apply(this指向,[实参])\n 3. 实参的传递必须使用数组的方式\n 4. 当第一个参数为null、undefined的时候，默认指向window\n 5. 使用apply方法改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次\n\n# call方法\n\n 1. 可以调用函数和改变this指向\n 2. 语法函数名.call(this指向,实参)\n 3. 实参是一个参数列表\n 4. 主要作用是实现继承。在子构造函数里用call调用父构造函数父构造函数名.call(this,参数)\n 5. 当第一个参数为null、undefined的时候，默认指向window\n 6. call也只是临时改变一次this指向，并立即执行\n\n# bind方法\n\n 1. 不会调用函数，但能改变函数内部this指向\n 2. 语法函数名.bind(this指向,实参)\n 3. 实参是一个参数列表，但是这个参数列表可以分多次传入，call则必须一次性传入所有参数\n 4. 返回由指定的this值和初始化参数改造的原函数拷贝\n 5. 改变this指向后不会立即执行，而是返回一个永久改变this指向的函数\n\n\n# 闭包\n\n# 变量作用域\n\n 1. js函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量\n\n# 从外部读取函数内部的局部变量\n\nfunction f1(){\n    var n =999\n    function f2(){\n        console.log(n)\n    }\n    return f2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 1. 函数 f2 就被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来就不行，f2 内部的局部变量，对 f1 就是不可见的。\n 2. "链式作用域"结构：子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立\n 3. 把 f2 作为返回值，我们就可以在 f1 外部读取它的内部变量了\n\n# 闭包的概念\n\n 1. 闭包就是能够读取其他函数内部变量的函数\n 2. 在本质上，闭包是将函数内部和函数外部连接起来的桥梁\n 3. 就是上面的f2\n\n# 闭包的用途\n\n 1. 读取函数内部的变量\n 2. 让这些变量的值始终保持在内存中，不会在 f1 调用后被自动清除\n\n# 使用闭包的注意点\n\n 1. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除\n 2. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值\n\n\n# 数组去重\n\n# 利用ES6 Set去重（ES6中最常用）\n\nfunction unique (arr) {\n  return Array.from(new Set(arr))\n}\n\n\n1\n2\n3\n\n 1. 不考虑兼容性\n 2. 法去掉“{}”空对象\n\n# 利用for嵌套for，然后splice去重（ES5中最常用）\n\nfunction unique(arr){            \n        for(var i=0; i<arr.length; i++){\n            for(var j=i+1; j<arr.length; j++){\n                if(arr[i]==arr[j]){         //第一个等同于第二个，splice方法删除第二个\n                    arr.splice(j,1);\n                    j--;\n                }\n            }\n        }\nreturn arr;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 利用indexOf去重\n\nfunction unique(arr) {\n    var array = [];\n    for (var i = 0; i < arr.length; i++) {\n        if (array .indexOf(arr[i]) === -1) {\n            array .push(arr[i])\n        }\n    }\n    return array;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 利用sort()\n\nfunction unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log(\'type error!\')\n        return;\n    }\n    arr = arr.sort()\n    var array= [arr[0]];\n    for (var i = 1; i < arr.length; i++) {\n        if (arr[i] !== arr[i-1]) {\n            arrry.push(arr[i]);\n        }\n    }\n    return arrray;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 利用includes\n\nfunction unique(arr) {\n    var array =[];\n    for(var i = 0; i < arr.length; i++) {\n            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值\n                    array.push(arr[i]);\n              }\n    }\n    return array\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 利用filter\n\nfunction unique(arr) {\n  return arr.filter(function(item, index, arr) {\n    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素\n    return arr.indexOf(item, 0) === index;\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 利用Map数据结构去重\n\nfunction arrayNonRepeatfy(arr) {\n  let map = new Map();\n  let array = new Array();  // 数组用于返回结果\n  for (let i = 0; i < arr.length; i++) {\n    if(map .has(arr[i])) {  // 如果有该key值\n      map .set(arr[i], true); \n    } else { \n      map .set(arr[i], false);   // 如果没有该key值\n      array .push(arr[i]);\n    }\n  } \n  return array ;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 深浅拷贝\n\n 1. 深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的\n 2. 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存\n 3. 深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象\n\n\n# require import\n\n 1. import在代码编译时被加载，所以必须放在文件开头，require在代码运行时被加载，所以require理论上可以运用在代码的任何地方，所以import性能更好\n 2. import引入的对象被修改时，源对象也会被修改，相当于浅拷贝，require引入的对象被修改时，源对象不会被修改，官网称值拷贝，我们可以理解为深拷贝\n 3. import有利于tree-shaking（移除JavaScript上下文中未引用的代码），require对tree-shaking不友好\n 4. import会触发代码分割（把代码分离到不同的bundle中，然后可以按需加载或者并行加载这些文件），require不会触发\n 5. import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法，require 是 AMD规范引入方式\n 6. 目前所有的引擎都还没有实现import，import最终都会被转码为require，在webpack打包中，import和require都会变为_webpack_require_\n\n\n# 浏览器原理\n\n\n# 跨域1\n\n浏览器限制了脚本发起的资源请求 （一般是 XHR 或 Fetch API） 只能发生在同源网址之间，如果本网页想要访问非同源网址的资源就会产生跨域请求\n\n# 同源策略\n\n# 同源的定义\n\n 1. 同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支持JavaScript 的浏览器都会使用这个策略来对脚本和请求进行校验，若不同源，则禁止使用\n 2. 域名，协议，端口三个都相同才算同源\n\n# 同源策略的作用\n\n 1. 无法用js读取非同源的Cookie、LocalStorage 和 IndexDB，防止恶意网站通过js获取用户其他网站的cookie等用户信息\n 2. 无法用js获取非同源的DOM，防止恶意网站通过iframe获取页面dom，从而窃取页面的信息\n 3. 无法用js发送非同源的AJAX请求，防止恶意的请求攻击服务器窃取数据信息\n\n# 跨域请求发送出去了吗\n\n 1. 对于简单请求，跨域请求发送出去了，只是结果被浏览器拦截了\n 2. 对于非简单请求，由于预检过程的存在，真正的跨域请求没有发送出去\n\n# 跨域请求的解决方案 1\n\n 1. 目前最常用的 CORS：服务器端可以在 HTTP 响应头上通过 Access-Control-Allow-(Origin/Headers/Methods/Credentials/) 等响应头字段设置允许访问该资源的请求源，请求头，请求方法，是否允许携带 cookies 等\n 2. webpack 提供的 proxy：仅适用于开发阶段\n 3. Nginx 添加请求头：允许的源很难动态更改\n 4. JSONP\n    1. 只允许 GET 请求，因此 URL 长度受限，不安全\n    2. 需要服务器端进行配合\n\n# cors 方案中预检过程 1\n\n 1. 提到简单请求和非简单请求，只有非简单请求才会触发预检过程\n    1. 简单请求必须同时满足下面三个条件\n       1. 请求方式只能是：GET、POST、HEAD\n       2. HTTP请求头限制这几种字段：Accept、Accept-Language、Content-Language、Content-Type、Last-Event-ID\n       3. Content-type只能取：application/x-www-form-urlencoded、multipart/form-data、text/plain\n 2. 浏览器首先发出一个 OPTIONS 请求，包含非简单请求中存在的请求信息，如请求方法，请求头，源等等\n 3. 服务器端返回它所允许的上述内容，并且如果预检请求能够通过就返回 200 响应\n 4. 浏览器接收到响应后，再判断是否真正发出非简单请求\n\n# jsonp 方案的大致流程 1\n\n 1. 浏览器端声明需要执行的 callback 函数，比如叫 run\n 2. 浏览器端动态生成 script 标签，将 src 属性指向目标 url 同时携带上参数 callback=run\n 3. 服务器端接收到请求后将结果包装成 json 格式，同时返回字符串 run(json 格式的结果)\n 4. 浏览器端接收到数据后就会执行相应的 run 函数\n\n# nginx 和 webpack 代理方式的区别\n\n 1. nginx 是通过为每一个 HTTP 响应添加上满足 CORS 要求的请求头实现的跨域，本质上请求还是通过浏览器发出的\n 2. webpack 是通过内部发送请求的方式绕过浏览器获取到结果之后再返回给浏览器，本质上请求不是通过浏览器发出的\n\n\n# HTTP请求\n\n# GET方法\n\n 1. GET方法用于使用给定的URI从给定服务器中检索信息，即从指定资源中请求数据\n 2. /test/demo_form.php?name1=value1&name2=value2\n 3. GET请求是可以缓存的，我们可以从浏览器历史记录中查找到GET请求，还可以把它收藏到书签中\n 4. GET请求有长度限制，仅用于请求数据（不修改）\n 5. 由于参数显示再地址栏所以不安全，一般需要保密的请求不使用GET\n\n# POST方法\n\n 1. POST方法用于将数据发送到服务器以创建或更新资源，它要求服务器确认请求中包含的内容作为由URI区分的Web资源的另一个下属\n 2. POST请求永远不会被缓存，且对数据长度没有限制\n 3. 我们无法从浏览器历史记录中查找到POST请求\n\n# GET和POST的区别\n\n 1. GET提交的数据放在URL中，POST则不会。这是最显而易见的差别。这点意味着GET更不安全（POST也不安全，因为HTTP是明文传输抓包就能获取数据内容，要想安全还得加密）\n 2. GET回退浏览器无害，POST会再次提交请求（GET方法回退后浏览器再缓存中拿结果，POST每次都会创建新资源）\n 3. GET提交的数据大小有限制（是因为浏览器对URL的长度有限制，GET本身没有限制），POST没有\n 4. GET可以被保存为书签，POST不可以\n 5. GET能被缓存，POST不能\n 6. GET只允许ASCII字符，POST没有限制\n\n# HEAD方法\n\n 1. HEAD方法与GET方法相同，但没有响应体，仅传输状态行和标题部分。这对于恢复相应头部编写的元数据非常有用，而无需传输整个内容\n\n# PUT方法\n\n 1. PUT方法用于将数据发送到服务器以创建或更新资源，它可以用上传的内容替换目标资源中的所有当前内容\n 2. 它会将包含的元素放在所提供的URI下，如果URI指示的是当前资源，则会被改变。如果URI未指示当前资源，则服务器可以使用该URI创建资源\n\n# DELETE方法\n\n 1. DELETE方法用来删除指定的资源，它会删除URI给出的目标资源的所有当前内容\n\n# CONNECT方法\n\n 1. CONNECT方法用来建立到给定URI标识的服务器的隧道；它通过简单的TCP / IP隧道更改请求连接，通常实使用解码的HTTP代理来进行SSL编码的通信（HTTPS）\n\n# OPTIONS方法\n\n 1. OPTIONS方法用来描述了目标资源的通信选项，会返回服务器支持预定义URL的HTTP策略\n\n# TRACE方法\n\n 1. TRACE方法用于沿着目标资源的路径执行消息环回测试；它回应收到的请求，以便客户可以看到中间服务器进行了哪些（假设任何）进度或增量\n\n\n# URL输出到页面的全过程\n\n\n\n# 浏览器构建HTTP Request请求\n\n 1. 应用层进行DNS解析\n    通过DNS将域名解析成IP地址。在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、ISP(运营商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到IP地址\n 2. 应用层生成HTTP请求报文\n    * 应用层生成针对目标WEB服务器的HTTP请求报文，HTTP请求报文包括起始行、首部和主体部分\n    * 首部包括域名host、keep-alive、User-Agent、Accept-Encoding、Accept-Language、Cookie等信息\n 3. 传输层建立TCP连接\n    * 由于HTTP协议使用的是TCP协议，为了方便通信，将HTTP请求报文按序号分为多个报文段(segment)，并对每个报文段进行封装。\n    * 使用本地一个大于1024以上的随机TCP源端口(这里假设是1030)建立到目的服务器TCP80号端口(HTTPS协议对应的端口号是443)的连接\n    * TCP源端口和目的端口被加入到报文段中，学名叫协议数据单元(Protocol Data Unit, PDU)\n    * 因TCP是一个可靠的传输控制协议，传输层还会加入序列号、确认号、窗口大小、校验和等参数，共添加20字节的头部信息\n    * TCP协议是面向连接的，所以它在开始传输数据之前需要先建立连接。要建立或初始化一个连接，两端主机必须同步双方的初始序号。同步是通过交换连接建立数据分段和初始序号来完成的，在连接建立数据分段中包含一个SYN(同步)的控制位。同步需要双方都发送自己的初始序号，并且发送确认的ACK。此过程就是三次握手\n      1. 第一次握手：主机A发往主机B，主机A的初始序号是X，设置SYN位，未设置ACK位\n      2. 第二次握手：主机B发往主机A，主机B的初始序号是Y，确认号(ACK)是X+1，X+1确认号暗示己经收到主机A发往主机B的同步序号。设置SYN位和ACK位\n      3. 第三次握手：主机A发往主机B，主机A的序号是X+1，确认号是Y+1，Y+1确认号暗示已经收到主机B发往主机A的同步序号。设置ACK位，未设置SYN位\n 4. 网络层使用IP协议来选择路线\n    * 处理来自传输层的数据段segment，将数据段segment装入数据包packet，填充包头，主要就是添加源和目的IP地址，然后发送数据\n    * 在数据传输的过程中，IP协议负责选择传送的路线，称为路由功能\n 5. 数据链路层实现网络相邻结点间可靠的数据通信\n    * 为了保证数据的可靠传输，把数据包packet封装成帧(Frame)，并按顺序传送各帧。由于物理线路的不可靠，发出的数据帧有可能在线路上出错或丢失，于是为每个数据分块计算出CRC(循环冗余检验)，并把CRC添加到帧中，这样接收方就可以通过重新计算CRC来判断数据接收的正确性。一旦出错就重传\n    * 将数据包packet封装成帧(Frame)，包括帧头和帧尾。帧尾是添加被称做CRC的循环冗余校验部分。帧头主要是添加数据链路层的地址，即数据链路层的源地址和目的地址，即网络相邻结点间的源MAC地址和目的MAC地址\n 6. 物理层传输数据\n    * 数据链路层的帧(Frame)转换成二进制形式的比特(Bit)流，从网卡发送出去，再把比特转换成电子、光学或微波信号在网络中传输\n\n# 网络传输\n\n# 服务器处理及反向传输\n\n 1. 服务器接收到这个比特流，把比特流转换成帧格式，上传到数据链路层，服务器发现数据帧中的目的MAC地址与本网卡的MAC地址相同，服务器拆除数据链路层的封装后，把数据包上传到网络层。服务器的网络层比较数据包中的目的IP地址，发现与本机的IP地址相同，服务器拆除网络层的封装后，把数据分段上传到传输层。传输层对数据分段进行确认、排序、重组，确保数据传输的可靠性。数据最后被传到服务器的应用层\n 2. HTTP服务器，如nginx通过反向代理，将其定位到服务器实际的端口位置，如8080。比如，8080端口对应的是一个NodeJS服务，生成响应报文，报文主体内容是google首页的HTML页面\n\n# 浏览器渲染\n\n\n\n 1. 网络线程安全校验\n    1. 谷歌浏览器通过SafeBrowsing检查站点是否是恶意站点，如果是会跳转警告页面阻止你的访问\n 2. UI线程创建渲染器进程（Renderer Thread）渲染页面\n    1. 浏览器进程通过IPC管道将数据（HTML）传送给渲染器进程\n    2. 渲染器进程主线程解析HTML，构建DOM数据结构\n       1. tokeniser标记化，将输入的html内容解析成多个标记\n       2. 根据识别后的标记进行DOM树构造\n       3. CSS、image等不会阻塞html解析，不会影响DOM的生成\n       4. 遇到script标签会停止html解析过程，转而去加载解析并且执行js\n    3. 主线程解析CSS样式\n       1. 如果没有CSS就查找浏览器自带的CSS样式\n    4. 主线程layout布局\n       1. 主线程通过遍历DOM和计算好的样式来生成layout tree\n       2. layout tree上的每个节点都记录了x y坐标和边框尺寸\n       3. DOM tree和layout tree不是一一对应的\n          1. 设置了display:none的节点不会出现在layout tree上\n          2. 伪类元素的content里的内容会出现在layout tree上\n    5. 主线程绘制\n       1. 遍历layout tree创建一个绘制记录表（Paint Record）\n       2. 该表记录绘制的顺序\n    6. 遍历layout tree生成layer tree\n    7. 主线程将layer tree和绘制记录表传递给合成器线程\n    8. 合成器线程将图层栅格化\n       1. 合成器线程将图层切分成图块\n       2. 合成器线程将图块发送给栅格线程（Raster Thread）\n       3. 栅格线程栅格化每个图块，并存储到GPU内存中\n       4. 合成器线程收集draw quads的图块信息，并生成合成器帧\n    9. 将合成器帧通过IPC传送给浏览器进程\n 3. 浏览器进程将合成器帧传到GPU进行渲染\n 4. 重排：改变元素尺寸位置属性时，会重新进行样式计算，并生成layout tree后面的所有流程\n 5. 重绘：改变元素的颜色属性时，不会重新触发布局，但会触发样式计算和绘制\n 6. js也运行在主线程上\n 7. 优化\n    1. requestAnimationFrame()\n       1. 可以将js运行任务分成更小的任务块分到每一帧\n       2. 在每一帧时间用万千暂停js执行归还主线程\n    2. CSS的transform属性\n       1. 通过该属性实现的动画不会经过布局和绘制，而是直接运行在合成器线程和栅格线程\n\n\n# 事件循环\n\nTODO:\n\n\n# VUE\n\n\n# 组件间传递数据1\n\n 1. 父子组件通信\n    1. 父组件向子组件传递数据，使用props属性\n    2. 子组件向父组件中传递数据，在子组件中使用$emit派发事件，父组件中使用v-on监听事件\n    3. 缺点：组件嵌套层次多的话，传递数据比较麻烦\n 2. 祖孙组件通信\n    1. 通过依赖注入(inject / provide)的方式，向其所有子孙后代传递数据\n    2. 缺点：无法监听数据修改的来源，不支持响应式\n 3. 通过属性$root / $parent / $children /ref，访问根组件、父级组件、子组件中的数据；缺点：要求组件之间要有传递性\n 4. 事件总线(event bus)\n    1. 可以实现任意两个组件间进行数据传递\n    2. 缺点：不支持响应式，这个概念是vue1.0版本中的，现在已经废弃\n 5. 状态管理模式 Vue\n    1. 实现多个组件进行数据共享，推荐使用这种方式进行项目中各组件间的数据传递\n\n\n# VUE2和VUE3的区别1\n\n 1. 响应式原理的重写\n    1. vue2 响应式是基于Object.defineProperty实现的，存在较大的问题\n       1. 对数组等集合类型的支持不佳\n       2. 对嵌套属性的深层响应支持不佳\n       3. 对新增属性的支持不佳）\n    2. vue3 响应式是基于新的 APIproxy实现的，功能更加强大\n 2. 组合式 API 的引入，使 vue 可以写出更加解耦的代码\n 3. vue3 各模块之间更加解耦，响应式相关封装成了 reactivity 包，组合式 API 相关封装成了composition-api包，因此可以按需引入了\n 4. 对 typescript 的支持更好\n\n\n# 响应式1\n\n# MVC模式\n\n以往的MVC模式是单向绑定，即Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新\n\n# MVVM模式\n\nMVVM模式就是Model–View–ViewModel模式。它实现了View的变动，自动反映在 ViewModel，反之亦然。对于双向绑定的理解，就是用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定。再说细点，就是在单向绑定的基础上给可输入元素input、textare等添加了change(input)事件,(change事件触发，View的状态就被更新了)来动态修改model\n\n# 双向绑定原理 1\n\n 1. vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的\n 2. 我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。\n 3. 因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的\n 4. 我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令（如v-model，v-on）对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图\n\n# VUE2.x怎么实现复杂数据结构的数据监听 1\n\n虽然 Vue 中确实能检测到数组数据的变化，但是其实是使用了 hack 的办法\n\n\n# 状态管理1\n\n# vuex\n\n# pinia 1\n\n\n# 生命周期函数\n\n 1. 又名生命周期回调函数、生命周期函数、生命周期钩子\n 2. 生命周期函数是Vue在关键时刻帮我们调用的一些特殊名称的函数\n 3. 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的\n 4. 生命周期函数中的 this 指向是vm或组件实例对象\n\n# VUE2生命周期\n\n\n\nbeforeCreate() {console.log(\'初始化但没有数据代理\')},\ncreated() {console.log(\'初始化且完成数据监测和数据代理\')},\nbeforeMount() {console.log(\'虚拟DOM已经生成，但还没有转换为真实DOM\')},\nmounted() {console.log(\'VUE解析并把真实DOM挂载到页面上\')},\nbeforeUpdate() {console.log(\'数据已经更新，但页面还未更新\')},\nupdated() {console.log(\'页面和数据都更新完毕\')},\nbeforeDestroy() {console.log(\'马上要销毁VUE实例\')},\ndestroyed() {console.log(\'destroyed\')},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# VUE3生命周期\n\n\n\n 1. Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名\n    1. beforeDestroy改名为 beforeUnmount\n    2. destroyed改名为 unmounted\n 2. Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下\n    1. beforeCreate===>setup()\n    2. created=======>setup()\n    3. beforeMount ===>onBeforeMount\n    4. mounted=======>onMounted\n    5. beforeUpdate===>onBeforeUpdate\n    6. updated =======>onUpdated\n    7. beforeUnmount ==>onBeforeUnmount\n    8. unmounted =====>onUnmounted\n\n\n# CSS\n\n\n# 选择器 1\n\n\n\n# 标签选择器\n\n 1. HTML标签名作为选择器\n 2. 权重1\n\n# 类选择器\n\n 1. 用class属性进行选择\n 2. 一个标签可以使用多个类名，多个类名之间用空格隔开\n 3. 权重10\n\n# ID选择器\n\n 1. 通过#定义id，以id属性选择\n 2. 只能调用一次，具有唯一性\n 3. 权重100\n\n# 通配符选择器\n\n 1. 用*，表示选取页面所有标签\n 2. 权重0\n\n# 后代选择器\n\n 1. 后代可以是子类也可以是子类的子类\n 2. 两个都可以是任意的基础选择器\n 3. 符号是空格\n\n# 子代选择器\n\n 1. 只能选择某元素最近一级子代\n 2. 符号是>\n\n# 并集选择器\n\n 1. 选择多组标签，同时定义相同的样式，用于集体声明\n 2. 语法：用逗号分隔\n\n# 链接伪类选择器\n\n 1. a:link 选择所有未访问的连接\n 2. a:visited 选择所有已访问的连接\n 3. a:hover 选择鼠标指针位于其上的连接\n 4. a:active 选择活动连接（鼠标按下未弹起的连接）\n 5. 为了确保能够生效，必须使用LVHA的顺序写\n 6. 浏览器中a有固定样式，要改变必须用a来设定\n\n# ：focus伪类选择\n\n 1. 用于获取光标所在的表单元素\n 2. 语法input:focus{样式说明}\n\n\n# 水平垂直居中 1\n\n# flex布局\n\n 1. 利用flex的alignItems:center垂直居中\n 2. justifycontent:center水平居中\n\n# margin:auto\n\n相对定位下，使用绝对定位将上下左右都设置为0，再设置margin:auto即可实现居中\n\n# 利用相对定位和绝对定位，再加上外边距和平移的配合\n\n相对定位下，使用绝对定位，利用margin偏移外容器的50%，再利用translate平移回补自身宽高的50%即可\n\n# 利用textAlign和verticalAlign\n\n 1. 利用textAlign:center实现行内元素的水平居中\n 2. 再利用verticalAlign:middle实现行内元素的垂直居中\n 3. 前提是要先加上伪元素并给设置高度为100%\n\n\n# 盒子模型 1\n\n 1. 盒模型包括margin、border、padding、content四个部分，主要的设置属性是margin、border、padding\n 2. 正常设置盒子模型的width时不包括padding和margin，当box-sizing设置为border-box时则包括padding和border\n\n\n# 块级元素 行内元素 行内块元素\n\n# 块级元素\n\n 1. 霸占一行，不能与其他任何元素并列\n 2. 能接受宽高，如果不设置宽度，那么宽度将默认变为父级的100%\n 3. 常见块级元素：div、ul、li、form、tale、h系列、hr、p、dl、dt、dd\n\n# 行内元素\n\n 1. 与其他行内元素并排\n 2. 不能设置宽高，默认的宽度就是文字的宽度\n 3. 常见行内元素：a、span\n\n# 行内块元素\n\n 1. 与其他行内元素并排\n 2. 默认宽度是本身内容的宽度\n 3. 宽度、高度、内外边距都可以控制\n 4. 常见行内块元素：img、input、td\n\n\n# HTML\n\n\n# HTML5新特性\n\n# 语义标签\n\nheader、footer、nav、section、article、details、summary、dialog、figure、main、mark、time\n\n# 增强表单\n\n 1. input属性修改：color、date、datetime、datetime-local、month、week、time、email、number、url、tel、search、range\n 2. 新增表单元素\n\n# 视频和音频\n\n支持直接播放视频和音频，并提供了相应的控制 api\n\n# Canvas绘图\n\n# SVG绘图\n\n# 地理定位\n\n# 拖放API\n\n# WebWorker\n\n让 Web 应用程序具备后台处理能力，对多线程的支持性非常好\n\n# WebStorage\n\n增加了 localstorage， sessionstorage\n\n# WebSocket\n\n基于 tcp 的全双工通讯\n\n\n# 系统部署\n\n\n# webpack 1\n\n# webpack打包流程 1\n\n# webpack怎么实现ES6到ES5 1\n\n# webpack配置参数 1',normalizedContent:'# javascript\n\n\n# var let const1\n\n# var、let、const异同\n\n 1. 共同点：都能声明变量\n 2. 不同点：var 在ecmascript 的所有版本中都可以使用，而const和let只能在ecmascript6及更晚中使用\n\n# var 1\n\n 1. var存在变量提升\n 2. 函数作用域\n 3. 可以重复声明\n 4. 全局声明时会变成windows对象的属性\n\n# let 1\n\n 1. 块级作用域\n 2. 全局声明时不会变成windows对象的属性\n 3. 不能进行条件式声明（判断是否声明然后再确定是否声明），因为会声明在条件符合的块级作用域里\n 4. let没有变量提升\n 5. 不允许重复声明\n 6. 暂时性死区：js引擎会注意到后面的let声明，但并没有变量提升，会抛出referenceerror，而不是not defined\n\n# const 1\n\n 1. 块级作用域\n 2. 全局声明时不会变成windows对象的属性\n 3. 没有变量提升\n 4. 不允许重复声明\n 5. 声明变量时必须赋值\n 6. 变量不能修改，但仅限于变量引用的对象，对内部属性的修改不报错\n\n# 变量提升的理解 1\n\nvar变量的时候会把所有变量声明都拉到函数作用域的顶部\n\n\n# 箭头函数1\n\n# 箭头函数与普通函数的区别 1\n\n 1.  箭头函数没有this，所以需要通过查找作用域链来确定this的值，这就意味着如果箭头函数被非箭头函数包含，this绑定的就是最近一层非箭头函数的this\n 2.  箭头函数没有自己的arguments对象，但是可以访问外围函数的arguments对象\n 3.  不能通过new关键字调用，同样也没有new.target值和原型\n 4.  语法更加简洁、清晰\n 5.  箭头函数继承而来的this指向永远不变\n 6.  .call()/.apply()/.bind()无法改变箭头函数中this的指向\n 7.  箭头函数不能作为构造函数使用\n 8.  箭头函数没有自己的arguments，可以在箭头函数中使用rest参数代替arguments对象，来访问箭头函数的参数列表\n 9.  箭头函数没有原型prototype\n 10. 箭头函数不能用作generator函数，不能使用yeild关键字\n 11. 箭头函数不具有super，不具有new.target\n\n\n# 事件代理1\n\n 1. 事件代理（event delegation），又称之为事件委托。是javascript中常用绑定事件的常用技巧\n 2. 事件传播\n    1. 捕获阶段：从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase），捕获阶段不会响应任何事件\n    2. 目标阶段：在目标节点上触发，称为“目标阶段”\n    3. 冒泡阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层\n 3. 事件代理优点\n    1. 可以大量节省内存占用，减少事件注册，比如在ul上代理所有li的click事件就非常棒\n    2. 可以实现当新增子对象时无需再次对其绑定（动态绑定事件）\n 4. 事件代理的实现\n\nvar item1 = document.getelementbyid("gosomewhere");\nvar item2 = document.getelementbyid("dosomething");\nvar item3 = document.getelementbyid("sayhi");\n\ndocument.addeventlistener("click", function (event) {\n  var target = event.target;\n  switch (target.id) {\n    case "dosomething":\n      document.title = "事件委托";\n      break;\n    case "gosomewhere":\n      location.href = "http://www.baidu.com";\n      break;\n    case "sayhi": alert("hi");\n      break;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# cookie sessionstorage localstorage 1\n\n\n\n# cookie\n\n 1. 存储的数据量小，每个不超过4096字节\n 2. 每个域有cookie个数限值，具体个数与浏览器相关\n 3. 可以通过http-only限值浏览器通过js访问\n 4. 通过设置 domain、path 等参数可以随着请求发送到服务器端\n 5. 可以通过 expires 设置有效期\n\n# localstorage 1\n\n 1. 永久存储机制：将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，\n 2. 浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用\n\n# sessionstorage 1\n\n 1. 跨会话存储机制：将数据保存在session对象中。\n 2. session是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间\n 3. 存储的数据不受页面刷新的影响，但只能在最初存储数据的页面使用，在多页应用程序中的用处有限\n\n\n# js数据类型1\n\n 1. 简单数据类型：string、number、boolean、null、undefined、bigint、symbol\n 2. 引用数据类型：object里面包括function、array、date\n\n# js数据类型判断1\n\n 1. typeof，只能判断简单数据类型，不能具体区分object\n    1. 对于基本类型，除 null 以外，均可以返回正确的结果。\n    2. 对于引用类型，除 function 以外，一律返回 object 类型。\n    3. 对于 null ，返回 object 类型。\n    4. 对于 function 返回 function 类型\n 2. instanceof:instanceof 检测的是原型\n 3. constructor：当一个函数f被创建时，js引擎会为其添加prototype原型，然后在原型上添加一个constructor属性，并让其指向f的引用。也就是说f.prototype.constructor === f // ---\x3e true\n 4. tostring() ：tostring 方法默认返回其调用者的具体类型，更严格的讲是tostring运行时，this指向的对象类型\n\n# instanceof的实现\n\nfunction instanceof(obj, classtype) {\n  let classproto = classtype.prototype;\n  obj = obj.__proto__;\n  while (true) {\n    if (obj === null) {\n      return false;\n    }\n    if (obj === classproto) {\n      return true;\n    }\n    obj = obj.__proto__;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# promise\n\n 1. promise 是一种为了避免回调地狱的异步解决方案\n 2. promise 是一种状态机： pending（进行中）、fulfilled（已成功）和rejected（已失败） 只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。\n 3. 回调地狱:回调函数中嵌套回调函数的情况就叫做回调地狱\n 4. 回调地狱就是为是实现代码顺序执行而出现的一种操作，它会造成我们的代码可读性非常差，后期不好维护\n\n# promise是什么?\n\n 1. promise是最早由社区提出和实现的一种解决异步编程的方案，比其他传统的解决方案（回调函数和事件）更合理和更强大\n 2. es6 将其写进了语言标准，统一了用法，原生提供了promise对象。\n 3. es6 规定，promise对象是一个构造函数，用来生成promise实例。\n\n# promise是为解决什么问题而产生的?\n\npromise是为解决异步处理回调地狱问题而产生的\n\n# promise的两个特点\n\n 1. promise对象的状态不受外界影响\n    1. pending 初始状态\n    2. fulfilled 成功状态\n    3. rejected 失败状态\n 2. promise的状态一旦改变，就不会再变，任何时候都可以得到这个结果，状态不可以逆，只能由 pending变成fulfilled或者由pending变成rejected\n\n# promise的三个缺点\n\n 1. 无法取消promise,一旦新建它就会立即执行，无法中途取消\n 2. 如果不设置回调函数，promise内部抛出的错误，不会反映到外部\n 3. 当处于pending状态时，无法得知目前进展到哪一个阶段，是刚刚开始还是即将完成\n\n# promise在哪存放成功回调序列和失败回调序列\n\n 1. onresolvedcallbacks 成功后要执行的回调序列 是一个数组\n 2. onrejectedcallbacks 失败后要执行的回调序列 是一个数组\n 3. 以上两个数组存放在promise 创建实例时给promise这个类传的函数中，默认都是空数组。\n 4. 每次实例then的时候 传入 onfulfilled 成功回调 onrejected 失败回调，如果此时的状态是pending 则将onfulfilled和onrejected push到对应的成功回调序列数组和失败回调序列数组中，如果此时的状态是fulfilled 则onfulfilled立即执行，如果此时的状态是rejected则onrejected立即执行\n 5. 上述序列中的回调函数执行的时候 是有顺序的，即按照顺序依次执行\n\n\n# es6新特性\n\n 1. let与const\n    1. let 允许创建块级作用域（最靠近的一个花括号内有效），不具备变量提升，不允许重复声明 2.const 允许创建块级作用域（最靠近的一个花括号内有效）、变量声明不提升、const 在声明时必须被赋值、声明时大写变量（默认规则）、block作用域\n 2. 箭头函数：es6 中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =>，紧接着是函数体：\n 3. 函数默认参数值：es6 中允许你对函数参数设置默认值\n 4. 对象超类：es6 允许在对象中使用 super 方法来调用父类的构造函数\n 5. map vs weakmap\n    1. es6 中两种新的数据结构集：map 和 weakmap。事实上每个对象都可以看作是一个 map\n    2. 一个对象由多个 key-val 对构成，在 map 中，任何类型都可以作为对象的 key\n 6. 类\n    1. es6 中有 class 语法。值得注意是，这里的 class 不是新的对象继承模型，它只是原型链的语法糖表现形式\n    2. 函数中使用 static 关键词定义构造函数的的方法和属性\n\n\n# 原型链\n\n# 什么是原型链\n\n简单理解就是原型组成的链，对象的__proto__它的是原型，而原型也是一个对象，也有__proto__属性，原型的__proto__又是原型的原型，就这样可以一直通过__proto__想上找，这就是原型链，当向上找找到object的原型的时候，这条原型链就算到头了。\n\n# 原型对象和实例之间有什么作用\n\n通过一个构造函数创建出来的多个实例，如果都要添加一个方法，给每个实例去添加并不是一个明智的选择。这时就该用上原型了。\n实例的原型上添加一个方法，这个原型的所有实例便都有了这个方法\n\n# prototype原型对象\n\n 1. prototype属性，它是函数所独有的，它是从一个函数指向一个对象。\n 2. 每一个构造函数都一个prototype属性，指向另一个对象。这个对象的所有属性和方法都会被构造函数所拥有\n 3. 构造函数通过原型分配的函数是所有对象所共享的\n\n# __proto__对象原型\n\n 1. 对象都会有一个属性__proto__指向构造函数的prototype原型对象，这让对象可以使用构造函数原型对象的属性和方法\n 2. 对象都会有一个属性__proto__指向构造函数的prototype原型对象，这让对象可以使用构造函数原型对象的属性和方法\n 3. __proto__是一个非标准属性，不能对其赋值\n 4. 对象方法查找规则\n    1. 先查找对象是否存在该方法，有就执行对象上的方法\n    2. 通过__proto__去构造函数原型对象里查找执行\n\n# constructor构造函数\n\n 1. 对象原型__proto__和构造函数prototype原型对象里面都有一个属性constructor，被称为构造函数，因为它指回构造函数本身\n 2. constructor用于记录该对象引用哪个构造函数，它可以让原型对象重新指向原来的构造函数\n 3. 如果修改了原来的原型对象，给原型对象幅值的是一个对象，则必须手动地使用constructor指回原来的构造函数\n\n\n# 继承\n\n# 原型链继承\n\n 1. 父类的实例作为子类的原型\n\nfunction father() {\n}\nfather.prototype.money = function(){\n    console.log(100000)\n}\nson.prototype = new father();\n//如果利用对象的形式修改了原型对象，要用constructor指回原来的构造函数\nson.prototype.constructor = son;\nfunction son() {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 2. 优点：简单易于实现，父类的新增的实例与属性子类都能访问\n 3. 缺点：\n    1. 可以在子类中增加实例属性，如果要新增加原型属性和方法需要在new 父类构造函数的后面\n    2. 无法实现多继承\n    3. 创建子类实例时，不能向父类构造函数中传参数\n\n# 借用构造函数继承（伪造对象、经典继承）\n\n 1. 复制父类的实例属性给子类\n\nfunction father(uname, age) {\n    //此处的this指向父构造函数的对象实例\n    this.uname = uname;\n    this.age = age;\n}\nfunction son(uname, age) {\n    //将父构造函数的this改成子构造函数的this\n    father.call(this, uname, age);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 2. 优点\n    1. 解决了子类构造函数向父类构造函数中传递参数\n    2. 可以实现多继承（call或者apply多个父类）\n 3. 缺点\n    1. 方法都在构造函数中定义，无法复用\n    2. 不能继承原型属性/方法，只能继承父类的实例属性和方法\n\n# 组合继承\n\n 1. 这种方式关键在于:通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。\n\nfunction father (name, age) {\n    this.name = name,\n    this.age = age,\n    this.setage = function () { }\n}\nfunction son (name, age, price) {\n    father.call(this, name, age)  \n    this.price = price  \n    this.setscore = function () { }\n}\nson.prototype = new father()\nson.prototype.constructor = son      \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n 2. 优点\n    1. 可以继承实例属性/方法，也可以继承原型属性/方法\n    2. 不存在引用属性共享问题\n    3. 可传参\n    4. 函数可复用\n 3. 缺点\n    1. 调用了两次父类构造函数，生成了两份实例\n\n# es6class继承\n\nclass father {\n    constructor(name, age) {\n        this.name = name\n        this.age = age\n    }\n    howname () {\n        console.log("调用父类的方法")\n        console.log(this.name, this.age);\n    }\n})\nson extends father {\n    constructor(name, age, salary) {\n        super(name, age)\n        this.salary = salary\n    }\n    showname () {\n        console.log("调用子类的方法")\n        console.log(this.name, this.age, this.salary);\n    }\n}    \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n 2. 优点：语法简单易懂,操作更方便\n 3. 缺点：并不是所有的浏览器都支持class关键字\n\n\n# null undefined\n\n# null\n\n 1. 空指针对象\n 2. typeof一个null会返回object\n 3. 使用==判断null与undefined始终返回true\n\n# undefined\n\n 1. 表示一个变量声明了但没有赋值\n 2. onsole.log(未声明的变量)会报错，但typeof(未声明的变量)则会返回undefined\n\n\n# call bind apply\n\n# apply方法\n\n 1. 可以调用函数，也可以改变this指向\n 2. 语法函数名.apply(this指向,[实参])\n 3. 实参的传递必须使用数组的方式\n 4. 当第一个参数为null、undefined的时候，默认指向window\n 5. 使用apply方法改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次\n\n# call方法\n\n 1. 可以调用函数和改变this指向\n 2. 语法函数名.call(this指向,实参)\n 3. 实参是一个参数列表\n 4. 主要作用是实现继承。在子构造函数里用call调用父构造函数父构造函数名.call(this,参数)\n 5. 当第一个参数为null、undefined的时候，默认指向window\n 6. call也只是临时改变一次this指向，并立即执行\n\n# bind方法\n\n 1. 不会调用函数，但能改变函数内部this指向\n 2. 语法函数名.bind(this指向,实参)\n 3. 实参是一个参数列表，但是这个参数列表可以分多次传入，call则必须一次性传入所有参数\n 4. 返回由指定的this值和初始化参数改造的原函数拷贝\n 5. 改变this指向后不会立即执行，而是返回一个永久改变this指向的函数\n\n\n# 闭包\n\n# 变量作用域\n\n 1. js函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量\n\n# 从外部读取函数内部的局部变量\n\nfunction f1(){\n    var n =999\n    function f2(){\n        console.log(n)\n    }\n    return f2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 1. 函数 f2 就被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来就不行，f2 内部的局部变量，对 f1 就是不可见的。\n 2. "链式作用域"结构：子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立\n 3. 把 f2 作为返回值，我们就可以在 f1 外部读取它的内部变量了\n\n# 闭包的概念\n\n 1. 闭包就是能够读取其他函数内部变量的函数\n 2. 在本质上，闭包是将函数内部和函数外部连接起来的桥梁\n 3. 就是上面的f2\n\n# 闭包的用途\n\n 1. 读取函数内部的变量\n 2. 让这些变量的值始终保持在内存中，不会在 f1 调用后被自动清除\n\n# 使用闭包的注意点\n\n 1. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在ie中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除\n 2. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（public method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值\n\n\n# 数组去重\n\n# 利用es6 set去重（es6中最常用）\n\nfunction unique (arr) {\n  return array.from(new set(arr))\n}\n\n\n1\n2\n3\n\n 1. 不考虑兼容性\n 2. 法去掉“{}”空对象\n\n# 利用for嵌套for，然后splice去重（es5中最常用）\n\nfunction unique(arr){            \n        for(var i=0; i<arr.length; i++){\n            for(var j=i+1; j<arr.length; j++){\n                if(arr[i]==arr[j]){         //第一个等同于第二个，splice方法删除第二个\n                    arr.splice(j,1);\n                    j--;\n                }\n            }\n        }\nreturn arr;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 利用indexof去重\n\nfunction unique(arr) {\n    var array = [];\n    for (var i = 0; i < arr.length; i++) {\n        if (array .indexof(arr[i]) === -1) {\n            array .push(arr[i])\n        }\n    }\n    return array;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 利用sort()\n\nfunction unique(arr) {\n    if (!array.isarray(arr)) {\n        console.log(\'type error!\')\n        return;\n    }\n    arr = arr.sort()\n    var array= [arr[0]];\n    for (var i = 1; i < arr.length; i++) {\n        if (arr[i] !== arr[i-1]) {\n            arrry.push(arr[i]);\n        }\n    }\n    return arrray;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 利用includes\n\nfunction unique(arr) {\n    var array =[];\n    for(var i = 0; i < arr.length; i++) {\n            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值\n                    array.push(arr[i]);\n              }\n    }\n    return array\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 利用filter\n\nfunction unique(arr) {\n  return arr.filter(function(item, index, arr) {\n    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素\n    return arr.indexof(item, 0) === index;\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 利用map数据结构去重\n\nfunction arraynonrepeatfy(arr) {\n  let map = new map();\n  let array = new array();  // 数组用于返回结果\n  for (let i = 0; i < arr.length; i++) {\n    if(map .has(arr[i])) {  // 如果有该key值\n      map .set(arr[i], true); \n    } else { \n      map .set(arr[i], false);   // 如果没有该key值\n      array .push(arr[i]);\n    }\n  } \n  return array ;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 深浅拷贝\n\n 1. 深拷贝和浅拷贝是只针对object和array这样的引用数据类型的\n 2. 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存\n 3. 深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象\n\n\n# require import\n\n 1. import在代码编译时被加载，所以必须放在文件开头，require在代码运行时被加载，所以require理论上可以运用在代码的任何地方，所以import性能更好\n 2. import引入的对象被修改时，源对象也会被修改，相当于浅拷贝，require引入的对象被修改时，源对象不会被修改，官网称值拷贝，我们可以理解为深拷贝\n 3. import有利于tree-shaking（移除javascript上下文中未引用的代码），require对tree-shaking不友好\n 4. import会触发代码分割（把代码分离到不同的bundle中，然后可以按需加载或者并行加载这些文件），require不会触发\n 5. import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法，require 是 amd规范引入方式\n 6. 目前所有的引擎都还没有实现import，import最终都会被转码为require，在webpack打包中，import和require都会变为_webpack_require_\n\n\n# 浏览器原理\n\n\n# 跨域1\n\n浏览器限制了脚本发起的资源请求 （一般是 xhr 或 fetch api） 只能发生在同源网址之间，如果本网页想要访问非同源网址的资源就会产生跨域请求\n\n# 同源策略\n\n# 同源的定义\n\n 1. 同源策略，它是由netscape提出的一个著名的安全策略。现在所有支持javascript 的浏览器都会使用这个策略来对脚本和请求进行校验，若不同源，则禁止使用\n 2. 域名，协议，端口三个都相同才算同源\n\n# 同源策略的作用\n\n 1. 无法用js读取非同源的cookie、localstorage 和 indexdb，防止恶意网站通过js获取用户其他网站的cookie等用户信息\n 2. 无法用js获取非同源的dom，防止恶意网站通过iframe获取页面dom，从而窃取页面的信息\n 3. 无法用js发送非同源的ajax请求，防止恶意的请求攻击服务器窃取数据信息\n\n# 跨域请求发送出去了吗\n\n 1. 对于简单请求，跨域请求发送出去了，只是结果被浏览器拦截了\n 2. 对于非简单请求，由于预检过程的存在，真正的跨域请求没有发送出去\n\n# 跨域请求的解决方案 1\n\n 1. 目前最常用的 cors：服务器端可以在 http 响应头上通过 access-control-allow-(origin/headers/methods/credentials/) 等响应头字段设置允许访问该资源的请求源，请求头，请求方法，是否允许携带 cookies 等\n 2. webpack 提供的 proxy：仅适用于开发阶段\n 3. nginx 添加请求头：允许的源很难动态更改\n 4. jsonp\n    1. 只允许 get 请求，因此 url 长度受限，不安全\n    2. 需要服务器端进行配合\n\n# cors 方案中预检过程 1\n\n 1. 提到简单请求和非简单请求，只有非简单请求才会触发预检过程\n    1. 简单请求必须同时满足下面三个条件\n       1. 请求方式只能是：get、post、head\n       2. http请求头限制这几种字段：accept、accept-language、content-language、content-type、last-event-id\n       3. content-type只能取：application/x-www-form-urlencoded、multipart/form-data、text/plain\n 2. 浏览器首先发出一个 options 请求，包含非简单请求中存在的请求信息，如请求方法，请求头，源等等\n 3. 服务器端返回它所允许的上述内容，并且如果预检请求能够通过就返回 200 响应\n 4. 浏览器接收到响应后，再判断是否真正发出非简单请求\n\n# jsonp 方案的大致流程 1\n\n 1. 浏览器端声明需要执行的 callback 函数，比如叫 run\n 2. 浏览器端动态生成 script 标签，将 src 属性指向目标 url 同时携带上参数 callback=run\n 3. 服务器端接收到请求后将结果包装成 json 格式，同时返回字符串 run(json 格式的结果)\n 4. 浏览器端接收到数据后就会执行相应的 run 函数\n\n# nginx 和 webpack 代理方式的区别\n\n 1. nginx 是通过为每一个 http 响应添加上满足 cors 要求的请求头实现的跨域，本质上请求还是通过浏览器发出的\n 2. webpack 是通过内部发送请求的方式绕过浏览器获取到结果之后再返回给浏览器，本质上请求不是通过浏览器发出的\n\n\n# http请求\n\n# get方法\n\n 1. get方法用于使用给定的uri从给定服务器中检索信息，即从指定资源中请求数据\n 2. /test/demo_form.php?name1=value1&name2=value2\n 3. get请求是可以缓存的，我们可以从浏览器历史记录中查找到get请求，还可以把它收藏到书签中\n 4. get请求有长度限制，仅用于请求数据（不修改）\n 5. 由于参数显示再地址栏所以不安全，一般需要保密的请求不使用get\n\n# post方法\n\n 1. post方法用于将数据发送到服务器以创建或更新资源，它要求服务器确认请求中包含的内容作为由uri区分的web资源的另一个下属\n 2. post请求永远不会被缓存，且对数据长度没有限制\n 3. 我们无法从浏览器历史记录中查找到post请求\n\n# get和post的区别\n\n 1. get提交的数据放在url中，post则不会。这是最显而易见的差别。这点意味着get更不安全（post也不安全，因为http是明文传输抓包就能获取数据内容，要想安全还得加密）\n 2. get回退浏览器无害，post会再次提交请求（get方法回退后浏览器再缓存中拿结果，post每次都会创建新资源）\n 3. get提交的数据大小有限制（是因为浏览器对url的长度有限制，get本身没有限制），post没有\n 4. get可以被保存为书签，post不可以\n 5. get能被缓存，post不能\n 6. get只允许ascii字符，post没有限制\n\n# head方法\n\n 1. head方法与get方法相同，但没有响应体，仅传输状态行和标题部分。这对于恢复相应头部编写的元数据非常有用，而无需传输整个内容\n\n# put方法\n\n 1. put方法用于将数据发送到服务器以创建或更新资源，它可以用上传的内容替换目标资源中的所有当前内容\n 2. 它会将包含的元素放在所提供的uri下，如果uri指示的是当前资源，则会被改变。如果uri未指示当前资源，则服务器可以使用该uri创建资源\n\n# delete方法\n\n 1. delete方法用来删除指定的资源，它会删除uri给出的目标资源的所有当前内容\n\n# connect方法\n\n 1. connect方法用来建立到给定uri标识的服务器的隧道；它通过简单的tcp / ip隧道更改请求连接，通常实使用解码的http代理来进行ssl编码的通信（https）\n\n# options方法\n\n 1. options方法用来描述了目标资源的通信选项，会返回服务器支持预定义url的http策略\n\n# trace方法\n\n 1. trace方法用于沿着目标资源的路径执行消息环回测试；它回应收到的请求，以便客户可以看到中间服务器进行了哪些（假设任何）进度或增量\n\n\n# url输出到页面的全过程\n\n\n\n# 浏览器构建http request请求\n\n 1. 应用层进行dns解析\n    通过dns将域名解析成ip地址。在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、isp(运营商)dns缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到ip地址\n 2. 应用层生成http请求报文\n    * 应用层生成针对目标web服务器的http请求报文，http请求报文包括起始行、首部和主体部分\n    * 首部包括域名host、keep-alive、user-agent、accept-encoding、accept-language、cookie等信息\n 3. 传输层建立tcp连接\n    * 由于http协议使用的是tcp协议，为了方便通信，将http请求报文按序号分为多个报文段(segment)，并对每个报文段进行封装。\n    * 使用本地一个大于1024以上的随机tcp源端口(这里假设是1030)建立到目的服务器tcp80号端口(https协议对应的端口号是443)的连接\n    * tcp源端口和目的端口被加入到报文段中，学名叫协议数据单元(protocol data unit, pdu)\n    * 因tcp是一个可靠的传输控制协议，传输层还会加入序列号、确认号、窗口大小、校验和等参数，共添加20字节的头部信息\n    * tcp协议是面向连接的，所以它在开始传输数据之前需要先建立连接。要建立或初始化一个连接，两端主机必须同步双方的初始序号。同步是通过交换连接建立数据分段和初始序号来完成的，在连接建立数据分段中包含一个syn(同步)的控制位。同步需要双方都发送自己的初始序号，并且发送确认的ack。此过程就是三次握手\n      1. 第一次握手：主机a发往主机b，主机a的初始序号是x，设置syn位，未设置ack位\n      2. 第二次握手：主机b发往主机a，主机b的初始序号是y，确认号(ack)是x+1，x+1确认号暗示己经收到主机a发往主机b的同步序号。设置syn位和ack位\n      3. 第三次握手：主机a发往主机b，主机a的序号是x+1，确认号是y+1，y+1确认号暗示已经收到主机b发往主机a的同步序号。设置ack位，未设置syn位\n 4. 网络层使用ip协议来选择路线\n    * 处理来自传输层的数据段segment，将数据段segment装入数据包packet，填充包头，主要就是添加源和目的ip地址，然后发送数据\n    * 在数据传输的过程中，ip协议负责选择传送的路线，称为路由功能\n 5. 数据链路层实现网络相邻结点间可靠的数据通信\n    * 为了保证数据的可靠传输，把数据包packet封装成帧(frame)，并按顺序传送各帧。由于物理线路的不可靠，发出的数据帧有可能在线路上出错或丢失，于是为每个数据分块计算出crc(循环冗余检验)，并把crc添加到帧中，这样接收方就可以通过重新计算crc来判断数据接收的正确性。一旦出错就重传\n    * 将数据包packet封装成帧(frame)，包括帧头和帧尾。帧尾是添加被称做crc的循环冗余校验部分。帧头主要是添加数据链路层的地址，即数据链路层的源地址和目的地址，即网络相邻结点间的源mac地址和目的mac地址\n 6. 物理层传输数据\n    * 数据链路层的帧(frame)转换成二进制形式的比特(bit)流，从网卡发送出去，再把比特转换成电子、光学或微波信号在网络中传输\n\n# 网络传输\n\n# 服务器处理及反向传输\n\n 1. 服务器接收到这个比特流，把比特流转换成帧格式，上传到数据链路层，服务器发现数据帧中的目的mac地址与本网卡的mac地址相同，服务器拆除数据链路层的封装后，把数据包上传到网络层。服务器的网络层比较数据包中的目的ip地址，发现与本机的ip地址相同，服务器拆除网络层的封装后，把数据分段上传到传输层。传输层对数据分段进行确认、排序、重组，确保数据传输的可靠性。数据最后被传到服务器的应用层\n 2. http服务器，如nginx通过反向代理，将其定位到服务器实际的端口位置，如8080。比如，8080端口对应的是一个nodejs服务，生成响应报文，报文主体内容是google首页的html页面\n\n# 浏览器渲染\n\n\n\n 1. 网络线程安全校验\n    1. 谷歌浏览器通过safebrowsing检查站点是否是恶意站点，如果是会跳转警告页面阻止你的访问\n 2. ui线程创建渲染器进程（renderer thread）渲染页面\n    1. 浏览器进程通过ipc管道将数据（html）传送给渲染器进程\n    2. 渲染器进程主线程解析html，构建dom数据结构\n       1. tokeniser标记化，将输入的html内容解析成多个标记\n       2. 根据识别后的标记进行dom树构造\n       3. css、image等不会阻塞html解析，不会影响dom的生成\n       4. 遇到script标签会停止html解析过程，转而去加载解析并且执行js\n    3. 主线程解析css样式\n       1. 如果没有css就查找浏览器自带的css样式\n    4. 主线程layout布局\n       1. 主线程通过遍历dom和计算好的样式来生成layout tree\n       2. layout tree上的每个节点都记录了x y坐标和边框尺寸\n       3. dom tree和layout tree不是一一对应的\n          1. 设置了display:none的节点不会出现在layout tree上\n          2. 伪类元素的content里的内容会出现在layout tree上\n    5. 主线程绘制\n       1. 遍历layout tree创建一个绘制记录表（paint record）\n       2. 该表记录绘制的顺序\n    6. 遍历layout tree生成layer tree\n    7. 主线程将layer tree和绘制记录表传递给合成器线程\n    8. 合成器线程将图层栅格化\n       1. 合成器线程将图层切分成图块\n       2. 合成器线程将图块发送给栅格线程（raster thread）\n       3. 栅格线程栅格化每个图块，并存储到gpu内存中\n       4. 合成器线程收集draw quads的图块信息，并生成合成器帧\n    9. 将合成器帧通过ipc传送给浏览器进程\n 3. 浏览器进程将合成器帧传到gpu进行渲染\n 4. 重排：改变元素尺寸位置属性时，会重新进行样式计算，并生成layout tree后面的所有流程\n 5. 重绘：改变元素的颜色属性时，不会重新触发布局，但会触发样式计算和绘制\n 6. js也运行在主线程上\n 7. 优化\n    1. requestanimationframe()\n       1. 可以将js运行任务分成更小的任务块分到每一帧\n       2. 在每一帧时间用万千暂停js执行归还主线程\n    2. css的transform属性\n       1. 通过该属性实现的动画不会经过布局和绘制，而是直接运行在合成器线程和栅格线程\n\n\n# 事件循环\n\ntodo:\n\n\n# vue\n\n\n# 组件间传递数据1\n\n 1. 父子组件通信\n    1. 父组件向子组件传递数据，使用props属性\n    2. 子组件向父组件中传递数据，在子组件中使用$emit派发事件，父组件中使用v-on监听事件\n    3. 缺点：组件嵌套层次多的话，传递数据比较麻烦\n 2. 祖孙组件通信\n    1. 通过依赖注入(inject / provide)的方式，向其所有子孙后代传递数据\n    2. 缺点：无法监听数据修改的来源，不支持响应式\n 3. 通过属性$root / $parent / $children /ref，访问根组件、父级组件、子组件中的数据；缺点：要求组件之间要有传递性\n 4. 事件总线(event bus)\n    1. 可以实现任意两个组件间进行数据传递\n    2. 缺点：不支持响应式，这个概念是vue1.0版本中的，现在已经废弃\n 5. 状态管理模式 vue\n    1. 实现多个组件进行数据共享，推荐使用这种方式进行项目中各组件间的数据传递\n\n\n# vue2和vue3的区别1\n\n 1. 响应式原理的重写\n    1. vue2 响应式是基于object.defineproperty实现的，存在较大的问题\n       1. 对数组等集合类型的支持不佳\n       2. 对嵌套属性的深层响应支持不佳\n       3. 对新增属性的支持不佳）\n    2. vue3 响应式是基于新的 apiproxy实现的，功能更加强大\n 2. 组合式 api 的引入，使 vue 可以写出更加解耦的代码\n 3. vue3 各模块之间更加解耦，响应式相关封装成了 reactivity 包，组合式 api 相关封装成了composition-api包，因此可以按需引入了\n 4. 对 typescript 的支持更好\n\n\n# 响应式1\n\n# mvc模式\n\n以往的mvc模式是单向绑定，即model绑定到view，当我们用javascript代码更新model时，view就会自动更新\n\n# mvvm模式\n\nmvvm模式就是model–view–viewmodel模式。它实现了view的变动，自动反映在 viewmodel，反之亦然。对于双向绑定的理解，就是用户更新了view，model的数据也自动被更新了，这种情况就是双向绑定。再说细点，就是在单向绑定的基础上给可输入元素input、textare等添加了change(input)事件,(change事件触发，view的状态就被更新了)来动态修改model\n\n# 双向绑定原理 1\n\n 1. vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的\n 2. 我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者watcher看是否需要更新。\n 3. 因为订阅者是有很多个，所以我们需要有一个消息订阅器dep来专门收集这些订阅者，然后在监听器observer和订阅者watcher之间进行统一管理的\n 4. 我们还需要有一个指令解析器compile，对每个节点元素进行扫描和解析，将相关指令（如v-model，v-on）对应初始化成一个订阅者watcher，并替换模板数据或者绑定相应的函数，此时当订阅者watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图\n\n# vue2.x怎么实现复杂数据结构的数据监听 1\n\n虽然 vue 中确实能检测到数组数据的变化，但是其实是使用了 hack 的办法\n\n\n# 状态管理1\n\n# vuex\n\n# pinia 1\n\n\n# 生命周期函数\n\n 1. 又名生命周期回调函数、生命周期函数、生命周期钩子\n 2. 生命周期函数是vue在关键时刻帮我们调用的一些特殊名称的函数\n 3. 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的\n 4. 生命周期函数中的 this 指向是vm或组件实例对象\n\n# vue2生命周期\n\n\n\nbeforecreate() {console.log(\'初始化但没有数据代理\')},\ncreated() {console.log(\'初始化且完成数据监测和数据代理\')},\nbeforemount() {console.log(\'虚拟dom已经生成，但还没有转换为真实dom\')},\nmounted() {console.log(\'vue解析并把真实dom挂载到页面上\')},\nbeforeupdate() {console.log(\'数据已经更新，但页面还未更新\')},\nupdated() {console.log(\'页面和数据都更新完毕\')},\nbeforedestroy() {console.log(\'马上要销毁vue实例\')},\ndestroyed() {console.log(\'destroyed\')},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# vue3生命周期\n\n\n\n 1. vue3.0中可以继续使用vue2.x中的生命周期钩子，但有有两个被更名\n    1. beforedestroy改名为 beforeunmount\n    2. destroyed改名为 unmounted\n 2. vue3.0也提供了 composition api 形式的生命周期钩子，与vue2.x中钩子对应关系如下\n    1. beforecreate===>setup()\n    2. created=======>setup()\n    3. beforemount ===>onbeforemount\n    4. mounted=======>onmounted\n    5. beforeupdate===>onbeforeupdate\n    6. updated =======>onupdated\n    7. beforeunmount ==>onbeforeunmount\n    8. unmounted =====>onunmounted\n\n\n# css\n\n\n# 选择器 1\n\n\n\n# 标签选择器\n\n 1. html标签名作为选择器\n 2. 权重1\n\n# 类选择器\n\n 1. 用class属性进行选择\n 2. 一个标签可以使用多个类名，多个类名之间用空格隔开\n 3. 权重10\n\n# id选择器\n\n 1. 通过#定义id，以id属性选择\n 2. 只能调用一次，具有唯一性\n 3. 权重100\n\n# 通配符选择器\n\n 1. 用*，表示选取页面所有标签\n 2. 权重0\n\n# 后代选择器\n\n 1. 后代可以是子类也可以是子类的子类\n 2. 两个都可以是任意的基础选择器\n 3. 符号是空格\n\n# 子代选择器\n\n 1. 只能选择某元素最近一级子代\n 2. 符号是>\n\n# 并集选择器\n\n 1. 选择多组标签，同时定义相同的样式，用于集体声明\n 2. 语法：用逗号分隔\n\n# 链接伪类选择器\n\n 1. a:link 选择所有未访问的连接\n 2. a:visited 选择所有已访问的连接\n 3. a:hover 选择鼠标指针位于其上的连接\n 4. a:active 选择活动连接（鼠标按下未弹起的连接）\n 5. 为了确保能够生效，必须使用lvha的顺序写\n 6. 浏览器中a有固定样式，要改变必须用a来设定\n\n# ：focus伪类选择\n\n 1. 用于获取光标所在的表单元素\n 2. 语法input:focus{样式说明}\n\n\n# 水平垂直居中 1\n\n# flex布局\n\n 1. 利用flex的alignitems:center垂直居中\n 2. justifycontent:center水平居中\n\n# margin:auto\n\n相对定位下，使用绝对定位将上下左右都设置为0，再设置margin:auto即可实现居中\n\n# 利用相对定位和绝对定位，再加上外边距和平移的配合\n\n相对定位下，使用绝对定位，利用margin偏移外容器的50%，再利用translate平移回补自身宽高的50%即可\n\n# 利用textalign和verticalalign\n\n 1. 利用textalign:center实现行内元素的水平居中\n 2. 再利用verticalalign:middle实现行内元素的垂直居中\n 3. 前提是要先加上伪元素并给设置高度为100%\n\n\n# 盒子模型 1\n\n 1. 盒模型包括margin、border、padding、content四个部分，主要的设置属性是margin、border、padding\n 2. 正常设置盒子模型的width时不包括padding和margin，当box-sizing设置为border-box时则包括padding和border\n\n\n# 块级元素 行内元素 行内块元素\n\n# 块级元素\n\n 1. 霸占一行，不能与其他任何元素并列\n 2. 能接受宽高，如果不设置宽度，那么宽度将默认变为父级的100%\n 3. 常见块级元素：div、ul、li、form、tale、h系列、hr、p、dl、dt、dd\n\n# 行内元素\n\n 1. 与其他行内元素并排\n 2. 不能设置宽高，默认的宽度就是文字的宽度\n 3. 常见行内元素：a、span\n\n# 行内块元素\n\n 1. 与其他行内元素并排\n 2. 默认宽度是本身内容的宽度\n 3. 宽度、高度、内外边距都可以控制\n 4. 常见行内块元素：img、input、td\n\n\n# html\n\n\n# html5新特性\n\n# 语义标签\n\nheader、footer、nav、section、article、details、summary、dialog、figure、main、mark、time\n\n# 增强表单\n\n 1. input属性修改：color、date、datetime、datetime-local、month、week、time、email、number、url、tel、search、range\n 2. 新增表单元素\n\n# 视频和音频\n\n支持直接播放视频和音频，并提供了相应的控制 api\n\n# canvas绘图\n\n# svg绘图\n\n# 地理定位\n\n# 拖放api\n\n# webworker\n\n让 web 应用程序具备后台处理能力，对多线程的支持性非常好\n\n# webstorage\n\n增加了 localstorage， sessionstorage\n\n# websocket\n\n基于 tcp 的全双工通讯\n\n\n# 系统部署\n\n\n# webpack 1\n\n# webpack打包流程 1\n\n# webpack怎么实现es6到es5 1\n\n# webpack配置参数 1',charsets:{cjk:!0},lastUpdated:"2023/03/27, 17:41:36",lastUpdatedTimestamp:1679910096e3},{title:"美团前端实习一面",frontmatter:{title:"美团前端实习一面",date:"2022-04-11T16:56:57.000Z",permalink:"/pages/8e13ff/",categories:["更多","面试"],tags:[null]},regularPath:"/04.%E6%9B%B4%E5%A4%9A/00.%20%E9%9D%A2%E8%AF%95/05.%20%E7%BE%8E%E5%9B%A2%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2.html",relativePath:"04.更多/00. 面试/05. 美团前端实习一面.md",key:"v-1343a71d",path:"/pages/8e13ff/",headers:[{level:2,title:"简历相关",slug:"简历相关",normalizedTitle:"简历相关",charIndex:23},{level:3,title:"自我介绍",slug:"自我介绍",normalizedTitle:"自我介绍",charIndex:32},{level:3,title:"介绍项目",slug:"介绍项目",normalizedTitle:"介绍项目",charIndex:41},{level:2,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:89},{level:4,title:"localStorage",slug:"localstorage",normalizedTitle:"localstorage",charIndex:103},{level:4,title:"sessionStorage",slug:"sessionstorage",normalizedTitle:"sessionstorage",charIndex:116},{level:4,title:"var",slug:"var",normalizedTitle:"var",charIndex:1487},{level:4,title:"let",slug:"let",normalizedTitle:"let",charIndex:1491},{level:4,title:"const",slug:"const",normalizedTitle:"const",charIndex:911},{level:4,title:"变量提升的理解",slug:"变量提升的理解",normalizedTitle:"变量提升的理解",charIndex:1501},{level:2,title:"浏览器",slug:"浏览器",normalizedTitle:"浏览器",charIndex:203},{level:2,title:"HTML/CSS",slug:"html-css",normalizedTitle:"html/css",charIndex:2813},{level:4,title:"flex布局",slug:"flex布局",normalizedTitle:"flex布局",charIndex:3017},{level:4,title:"margin:auto",slug:"margin-auto",normalizedTitle:"margin:auto",charIndex:3091},{level:4,title:"利用相对定位和绝对定位，再加上外边距和平移的配合",slug:"利用相对定位和绝对定位-再加上外边距和平移的配合",normalizedTitle:"利用相对定位和绝对定位，再加上外边距和平移的配合",charIndex:3151},{level:4,title:"利用textAlign和verticalAlign",slug:"利用textalign和verticalalign",normalizedTitle:"利用textalign和verticalalign",charIndex:3238},{level:2,title:"webpack",slug:"webpack",normalizedTitle:"webpack",charIndex:2087},{level:2,title:"VUE",slug:"vue",normalizedTitle:"vue",charIndex:3446}],headersStr:"简历相关 自我介绍 介绍项目 JavaScript localStorage sessionStorage var let const 变量提升的理解 浏览器 HTML/CSS flex布局 margin:auto 利用相对定位和绝对定位，再加上外边距和平移的配合 利用textAlign和verticalAlign webpack VUE",content:"美团前端实习一面，面试时长约38分钟\n\n\n# 简历相关\n\n\n# 自我介绍\n\n\n# 介绍项目\n\n 1. 项目中遇到的问题，怎么解决的\n 2. 怎么和后端进行持续的数据交互\n\n\n# JavaScript\n\n> localStorage和sessionStorage的区别\n\n# localStorage\n\n 1. 永久存储机制：将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，\n 2. 浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用\n\n# sessionStorage\n\n 1. 跨会话存储机制：将数据保存在session对象中。\n 2. session是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间\n 3. 存储的数据不受页面刷新的影响，但只能在最初存储数据的页面使用，在多页应用程序中的用处有限\n\n> 捕获和冒泡与事件代理\n\n 1. 事件代理（Event Delegation），又称之为事件委托。是JavaScript中常用绑定事件的常用技巧\n 2. 事件传播\n    1. 捕获阶段：从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase），捕获阶段不会响应任何事件\n    2. 目标阶段：在目标节点上触发，称为“目标阶段”\n    3. 冒泡阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层\n\n> js判断数据类型\n\n 1. typeof，只能判断简单数据类型，不能具体区分object\n    1. 对于基本类型，除 null 以外，均可以返回正确的结果。\n    2. 对于引用类型，除 function 以外，一律返回 object 类型。\n    3. 对于 null ，返回 object 类型。\n    4. 对于 function 返回 function 类型\n 2. instanceof:instanceof 检测的是原型\n 3. constructor：当一个函数F被创建时，JS引擎会为其添加prototype原型，然后在原型上添加一个constructor属性，并让其指向F的引用。也就是说F.prototype.constructor === F // ---\x3e true\n 4. toString() ：toString 方法默认返回其调用者的具体类型，更严格的讲是toString运行时，this指向的对象类型\n\n> 箭头函数和普通函数的区别\n\n 1. 箭头函数没有this，所以需要通过查找作用域链来确定this的值，这就意味着如果箭头函数被非箭头函数包含，this绑定的就是最近一层非箭头函数的this\n 2. 箭头函数没有自己的arguments对象，可以在箭头函数中使用rest参数代替arguments对象，来访问箭头函数的参数列表\n 3. 不能通过new关键字调用，同样也没有new.target值和原型\n 4. 箭头函数继承而来的this指向永远不变,.call()/.apply()/.bind()无法改变箭头函数中this的指向\n 5. 箭头函数不能作为构造函数使用\n 6. 箭头函数没有原型prototype\n 7. 箭头函数不能用作Generator函数，不能使用yeild关键字\n 8. 箭头函数不具有super，不具有new.target\n\n> var let const 变量提升的理解\n\n# var\n\n 1. var存在变量提升\n 2. 函数作用域\n 3. 可以重复声明\n 4. 全局声明时会变成windows对象的属性\n\n# let\n\n 1. 块级作用域\n 2. 全局声明时不会变成windows对象的属性\n 3. 不能进行条件式声明（判断是否声明然后再确定是否声明），因为会声明在条件符合的块级作用域里\n 4. let没有变量提升\n 5. 不允许重复声明\n 6. 暂时性死区：js引擎会注意到后面的let声明，但并没有变量提升，会抛出ReferenceError，而不是not defined\n\n# const\n\n 1. 块级作用域\n 2. 全局声明时不会变成windows对象的属性\n 3. 没有变量提升\n 4. 不允许重复声明\n 5. 声明变量时必须赋值\n 6. 变量不能修改，但仅限于变量引用的对象，对内部属性的修改不报错\n\n# 变量提升的理解\n\nvar变量的时候会把所有变量声明都拉到函数作用域的顶部\n\n\n# 浏览器\n\n> 如何解决跨域\n\n 1. 目前最常用的 CORS：服务器端可以在 HTTP 响应头上通过 Access-Control-Allow-(Origin/Headers/Methods/Credentials/) 等响应头字段设置允许访问该资源的请求源，请求头，请求方法，是否允许携带 cookies 等\n 2. webpack 提供的 proxy：仅适用于开发阶段\n 3. Nginx 添加请求头：允许的源很难动态更改\n 4. JSONP\n    1. 只允许 GET 请求，因此 URL 长度受限，不安全\n    2. 需要服务器端进行配合\n\n> JSONP的处理流程\n\n 1. 浏览器端声明需要执行的 callback 函数，比如叫 run\n 2. 浏览器端动态生成 script 标签，将 src 属性指向目标 url 同时携带上参数 callback=run\n 3. 服务器端接收到请求后将结果包装成 json 格式，同时返回字符串 run(json 格式的结果)\n 4. 浏览器端接收到数据后就会执行相应的 run 函数\n\n> cors的处理流程\n\n 1. 提到简单请求和非简单请求，只有非简单请求才会触发预过程\n    1. 简单请求必须同时满足下面三个条件\n       1. 请求方式只能是：GET、POST、HEAD\n       2. HTTP请求头限制这几种字段：Accept、Accept-Language、Content-Language、Content-Type、Last-Event-ID\n       3. Content-type只能取：application/x-www-form-urlencoded、multipart/form-data、text/plain\n 2. 浏览器首先发出一个 OPTIONS 请求，包含非简单请求中存在的请求信息，如请求方法，请求头，源等等\n 3. 服务器端返回它所允许的上述内容，并且如果预检请求能够通过就返回 200 响应\n 4. 浏览器接收到响应后，再判断是否真正发出非简单请求\n\n\n# HTML/CSS\n\n> 盒子模型\n\n 1. 盒模型包括margin、border、padding、content四个部分，主要的设置属性是margin、border、padding\n 2. 正常设置盒子模型的width时不包括padding和margin，当box-sizing设置为border-box时则包括padding和border\n\n> CSS选择符，权重 div中的img如何上下左右居中\n\n# flex布局\n\n 1. 利用flex的alignItems:center垂直居中\n 2. justifycontent:center水平居中\n\n# margin:auto\n\n相对定位下，使用绝对定位将上下左右都设置为0，再设置margin:auto即可实现居中\n\n# 利用相对定位和绝对定位，再加上外边距和平移的配合\n\n相对定位下，使用绝对定位，利用margin偏移外容器的50%，再利用translate平移回补自身宽高的50%即可\n\n# 利用textAlign和verticalAlign\n\n 1. 利用textAlign:center实现行内元素的水平居中\n 2. 再利用verticalAlign:middle实现行内元素的垂直居中\n 3. 前提是要先加上伪元素并给设置高度为100%\n\n\n# webpack\n\n 12. webpack的理解，如何打包的\n 13. webpack怎么实现ES6到ES5\n 14. webpack怎么配置参数\n\n\n# VUE\n\n> VUE2.x和VUE3的区别 VUE2.X和VUE3的数据响应式原理区别\n\n 1. 响应式原理的重写\n    1. vue2 响应式是基于Object.defineProperty实现的，存在较大的问题\n       1. 对数组等集合类型的支持不佳\n       2. 对嵌套属性的深层响应支持不佳\n       3. 对新增属性的支持不佳）\n    2. vue3 响应式是基于新的 APIproxy实现的，功能更加强大\n 2. 组合式 API 的引入，使 vue 可以写出更加解耦的代码\n 3. vue3 各模块之间更加解耦，响应式相关封装成了 reactivity 包，组合式 API 相关封装成了composition-api包，因此可以按需引入了\n 4. 对 typescript 的支持更好\n\n> VUE2.x怎么实现复杂数据结构的数据监听 VUE开发组件方面 Angular和VUE的区别，使用起来的 谈谈pinia",normalizedContent:"美团前端实习一面，面试时长约38分钟\n\n\n# 简历相关\n\n\n# 自我介绍\n\n\n# 介绍项目\n\n 1. 项目中遇到的问题，怎么解决的\n 2. 怎么和后端进行持续的数据交互\n\n\n# javascript\n\n> localstorage和sessionstorage的区别\n\n# localstorage\n\n 1. 永久存储机制：将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，\n 2. 浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用\n\n# sessionstorage\n\n 1. 跨会话存储机制：将数据保存在session对象中。\n 2. session是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间\n 3. 存储的数据不受页面刷新的影响，但只能在最初存储数据的页面使用，在多页应用程序中的用处有限\n\n> 捕获和冒泡与事件代理\n\n 1. 事件代理（event delegation），又称之为事件委托。是javascript中常用绑定事件的常用技巧\n 2. 事件传播\n    1. 捕获阶段：从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase），捕获阶段不会响应任何事件\n    2. 目标阶段：在目标节点上触发，称为“目标阶段”\n    3. 冒泡阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层\n\n> js判断数据类型\n\n 1. typeof，只能判断简单数据类型，不能具体区分object\n    1. 对于基本类型，除 null 以外，均可以返回正确的结果。\n    2. 对于引用类型，除 function 以外，一律返回 object 类型。\n    3. 对于 null ，返回 object 类型。\n    4. 对于 function 返回 function 类型\n 2. instanceof:instanceof 检测的是原型\n 3. constructor：当一个函数f被创建时，js引擎会为其添加prototype原型，然后在原型上添加一个constructor属性，并让其指向f的引用。也就是说f.prototype.constructor === f // ---\x3e true\n 4. tostring() ：tostring 方法默认返回其调用者的具体类型，更严格的讲是tostring运行时，this指向的对象类型\n\n> 箭头函数和普通函数的区别\n\n 1. 箭头函数没有this，所以需要通过查找作用域链来确定this的值，这就意味着如果箭头函数被非箭头函数包含，this绑定的就是最近一层非箭头函数的this\n 2. 箭头函数没有自己的arguments对象，可以在箭头函数中使用rest参数代替arguments对象，来访问箭头函数的参数列表\n 3. 不能通过new关键字调用，同样也没有new.target值和原型\n 4. 箭头函数继承而来的this指向永远不变,.call()/.apply()/.bind()无法改变箭头函数中this的指向\n 5. 箭头函数不能作为构造函数使用\n 6. 箭头函数没有原型prototype\n 7. 箭头函数不能用作generator函数，不能使用yeild关键字\n 8. 箭头函数不具有super，不具有new.target\n\n> var let const 变量提升的理解\n\n# var\n\n 1. var存在变量提升\n 2. 函数作用域\n 3. 可以重复声明\n 4. 全局声明时会变成windows对象的属性\n\n# let\n\n 1. 块级作用域\n 2. 全局声明时不会变成windows对象的属性\n 3. 不能进行条件式声明（判断是否声明然后再确定是否声明），因为会声明在条件符合的块级作用域里\n 4. let没有变量提升\n 5. 不允许重复声明\n 6. 暂时性死区：js引擎会注意到后面的let声明，但并没有变量提升，会抛出referenceerror，而不是not defined\n\n# const\n\n 1. 块级作用域\n 2. 全局声明时不会变成windows对象的属性\n 3. 没有变量提升\n 4. 不允许重复声明\n 5. 声明变量时必须赋值\n 6. 变量不能修改，但仅限于变量引用的对象，对内部属性的修改不报错\n\n# 变量提升的理解\n\nvar变量的时候会把所有变量声明都拉到函数作用域的顶部\n\n\n# 浏览器\n\n> 如何解决跨域\n\n 1. 目前最常用的 cors：服务器端可以在 http 响应头上通过 access-control-allow-(origin/headers/methods/credentials/) 等响应头字段设置允许访问该资源的请求源，请求头，请求方法，是否允许携带 cookies 等\n 2. webpack 提供的 proxy：仅适用于开发阶段\n 3. nginx 添加请求头：允许的源很难动态更改\n 4. jsonp\n    1. 只允许 get 请求，因此 url 长度受限，不安全\n    2. 需要服务器端进行配合\n\n> jsonp的处理流程\n\n 1. 浏览器端声明需要执行的 callback 函数，比如叫 run\n 2. 浏览器端动态生成 script 标签，将 src 属性指向目标 url 同时携带上参数 callback=run\n 3. 服务器端接收到请求后将结果包装成 json 格式，同时返回字符串 run(json 格式的结果)\n 4. 浏览器端接收到数据后就会执行相应的 run 函数\n\n> cors的处理流程\n\n 1. 提到简单请求和非简单请求，只有非简单请求才会触发预过程\n    1. 简单请求必须同时满足下面三个条件\n       1. 请求方式只能是：get、post、head\n       2. http请求头限制这几种字段：accept、accept-language、content-language、content-type、last-event-id\n       3. content-type只能取：application/x-www-form-urlencoded、multipart/form-data、text/plain\n 2. 浏览器首先发出一个 options 请求，包含非简单请求中存在的请求信息，如请求方法，请求头，源等等\n 3. 服务器端返回它所允许的上述内容，并且如果预检请求能够通过就返回 200 响应\n 4. 浏览器接收到响应后，再判断是否真正发出非简单请求\n\n\n# html/css\n\n> 盒子模型\n\n 1. 盒模型包括margin、border、padding、content四个部分，主要的设置属性是margin、border、padding\n 2. 正常设置盒子模型的width时不包括padding和margin，当box-sizing设置为border-box时则包括padding和border\n\n> css选择符，权重 div中的img如何上下左右居中\n\n# flex布局\n\n 1. 利用flex的alignitems:center垂直居中\n 2. justifycontent:center水平居中\n\n# margin:auto\n\n相对定位下，使用绝对定位将上下左右都设置为0，再设置margin:auto即可实现居中\n\n# 利用相对定位和绝对定位，再加上外边距和平移的配合\n\n相对定位下，使用绝对定位，利用margin偏移外容器的50%，再利用translate平移回补自身宽高的50%即可\n\n# 利用textalign和verticalalign\n\n 1. 利用textalign:center实现行内元素的水平居中\n 2. 再利用verticalalign:middle实现行内元素的垂直居中\n 3. 前提是要先加上伪元素并给设置高度为100%\n\n\n# webpack\n\n 12. webpack的理解，如何打包的\n 13. webpack怎么实现es6到es5\n 14. webpack怎么配置参数\n\n\n# vue\n\n> vue2.x和vue3的区别 vue2.x和vue3的数据响应式原理区别\n\n 1. 响应式原理的重写\n    1. vue2 响应式是基于object.defineproperty实现的，存在较大的问题\n       1. 对数组等集合类型的支持不佳\n       2. 对嵌套属性的深层响应支持不佳\n       3. 对新增属性的支持不佳）\n    2. vue3 响应式是基于新的 apiproxy实现的，功能更加强大\n 2. 组合式 api 的引入，使 vue 可以写出更加解耦的代码\n 3. vue3 各模块之间更加解耦，响应式相关封装成了 reactivity 包，组合式 api 相关封装成了composition-api包，因此可以按需引入了\n 4. 对 typescript 的支持更好\n\n> vue2.x怎么实现复杂数据结构的数据监听 vue开发组件方面 angular和vue的区别，使用起来的 谈谈pinia",charsets:{cjk:!0},lastUpdated:"2023/03/27, 17:41:36",lastUpdatedTimestamp:1679910096e3},{title:"关于",frontmatter:{title:"关于",date:"2019-12-25T14:27:01.000Z",permalink:"/about",sidebar:!1,article:!1},regularPath:"/05.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E.html",relativePath:"05.关于/01.关于.md",key:"v-7df42191",path:"/about/",headers:[{level:2,title:"📚Blog",slug:"📚blog",normalizedTitle:"📚blog",charIndex:2},{level:2,title:"🎨Theme",slug:"🎨theme",normalizedTitle:"🎨theme",charIndex:140},{level:2,title:"🐼Me",slug:"🐼me",normalizedTitle:"🐼me",charIndex:292},{level:3,title:"技能",slug:"技能",normalizedTitle:"技能",charIndex:311},{level:2,title:"前端学习",slug:"前端学习",normalizedTitle:"前端学习",charIndex:440},{level:2,title:"✉️ 联系",slug:"联系",normalizedTitle:"✉️ 联系",charIndex:479}],headersStr:"📚Blog 🎨Theme 🐼Me 技能 前端学习 ✉️ 联系",content:"# 📚Blog\n\n这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是Web前端技术。如果你喜欢这个博客&主题欢迎到GitHub点个Star，或者交换友链 ( •̀ ω •́ )✧\n\n提示\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。\n\n更新日志\n\n\n# 🎨Theme\n\n\n\n本站主题是 Vdoing，这是一款简洁高效的VuePress 知识管理&博客 主题。旨在轻松打造一个结构化与碎片化并存的个人在线知识库&博客，让你的知识海洋像一本本书一样清晰易读。配合多维索引，让每一个知识点都可以快速定位！ Github地址 | 在线vscode预览源码\n\n\n# 🐼Me\n\nweb前端小学生\n\n\n# 技能\n\n * 熟悉 JavaScript、HTML、CSS、Vue、React 的拼写\n * 了解 Linux、windows、macOS 的开关机方式\n * 精通 Git 的 pull 和 push，并注册了 GitHub 帐号刷了一些 star\n\n\n# 前端学习\n\n\n关注公众号，回复前端资源，即可获取这些 前端学习资源。\n\n\n# ✉️ 联系\n\n * WeChat or QQ: {{ QQ }}\n * Email: 894072666@qq.com\n * GitHub: https://github.com/xugaoyi\n * Vdoing主题文档：https://doc.xugaoyi.com\n * Vdoing交流QQ群：694387113",normalizedContent:"# 📚blog\n\n这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是web前端技术。如果你喜欢这个博客&主题欢迎到github点个star，或者交换友链 ( • ω • )✧\n\n提示\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。\n\n更新日志\n\n\n# 🎨theme\n\n\n\n本站主题是 vdoing，这是一款简洁高效的vuepress 知识管理&博客 主题。旨在轻松打造一个结构化与碎片化并存的个人在线知识库&博客，让你的知识海洋像一本本书一样清晰易读。配合多维索引，让每一个知识点都可以快速定位！ github地址 | 在线vscode预览源码\n\n\n# 🐼me\n\nweb前端小学生\n\n\n# 技能\n\n * 熟悉 javascript、html、css、vue、react 的拼写\n * 了解 linux、windows、macos 的开关机方式\n * 精通 git 的 pull 和 push，并注册了 github 帐号刷了一些 star\n\n\n# 前端学习\n\n\n关注公众号，回复前端资源，即可获取这些 前端学习资源。\n\n\n# ✉️ 联系\n\n * wechat or qq: {{ qq }}\n * email: 894072666@qq.com\n * github: https://github.com/xugaoyi\n * vdoing主题文档：https://doc.xugaoyi.com\n * vdoing交流qq群：694387113",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"收藏",frontmatter:{title:"收藏",date:"2022-04-11T16:55:16.000Z",permalink:"/pages/8384dd/",categories:["更多"],tags:[null]},regularPath:"/04.%E6%9B%B4%E5%A4%9A/05.%20%E6%94%B6%E8%97%8F.html",relativePath:"04.更多/05. 收藏.md",key:"v-77b5865d",path:"/pages/8384dd/",headers:[{level:2,title:"推荐",slug:"推荐",normalizedTitle:"推荐",charIndex:12},{level:2,title:"文档",slug:"文档",normalizedTitle:"文档",charIndex:167},{level:2,title:"社区",slug:"社区",normalizedTitle:"社区",charIndex:375},{level:3,title:"社区互动",slug:"社区互动",normalizedTitle:"社区互动",charIndex:596},{level:2,title:"技巧",slug:"技巧",normalizedTitle:"技巧",charIndex:623},{level:2,title:"博客",slug:"博客",normalizedTitle:"博客",charIndex:711},{level:2,title:"电子书",slug:"电子书",normalizedTitle:"电子书",charIndex:775},{level:2,title:"优秀文章",slug:"优秀文章",normalizedTitle:"优秀文章",charIndex:833},{level:2,title:"视频",slug:"视频",normalizedTitle:"视频",charIndex:897},{level:2,title:"Github",slug:"github",normalizedTitle:"github",charIndex:382},{level:2,title:"评论系统",slug:"评论系统",normalizedTitle:"评论系统",charIndex:1148},{level:2,title:"前端小工具",slug:"前端小工具",normalizedTitle:"前端小工具",charIndex:1197},{level:2,title:"代码编辑",slug:"代码编辑",normalizedTitle:"代码编辑",charIndex:1269},{level:2,title:"Emoji表情",slug:"emoji表情",normalizedTitle:"emoji表情",charIndex:1330},{level:2,title:"图片工具",slug:"图片工具",normalizedTitle:"图片工具",charIndex:1493},{level:2,title:"思维导图",slug:"思维导图",normalizedTitle:"思维导图",charIndex:1753},{level:2,title:"CSS",slug:"css",normalizedTitle:"css",charIndex:875},{level:2,title:"CDN加速",slug:"cdn加速",normalizedTitle:"cdn加速",charIndex:2090},{level:2,title:"网站托管",slug:"网站托管",normalizedTitle:"网站托管",charIndex:2150},{level:2,title:"正则",slug:"正则",normalizedTitle:"正则",charIndex:2180},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:2241},{level:2,title:"设计",slug:"设计",normalizedTitle:"设计",charIndex:574},{level:2,title:"图库",slug:"图库",normalizedTitle:"图库",charIndex:3342},{level:2,title:"3D",slug:"_3d",normalizedTitle:"3d",charIndex:1967},{level:2,title:"交互",slug:"交互",normalizedTitle:"交互",charIndex:2420},{level:2,title:"有趣",slug:"有趣",normalizedTitle:"有趣",charIndex:139},{level:2,title:"生成器",slug:"生成器",normalizedTitle:"生成器",charIndex:1839},{level:2,title:"元宇宙",slug:"元宇宙",normalizedTitle:"元宇宙",charIndex:4444},{level:2,title:"教程",slug:"教程",normalizedTitle:"教程",charIndex:251},{level:2,title:"产品",slug:"产品",normalizedTitle:"产品",charIndex:3329},{level:2,title:"实用",slug:"实用",normalizedTitle:"实用",charIndex:4688},{level:2,title:"Talk",slug:"talk",normalizedTitle:"talk",charIndex:5061},{level:2,title:"算法",slug:"算法",normalizedTitle:"算法",charIndex:2330},{level:2,title:"nginx",slug:"nginx",normalizedTitle:"nginx",charIndex:5141},{level:2,title:"生活",slug:"生活",normalizedTitle:"生活",charIndex:5169}],excerpt:'<h1 id="个人收藏夹"><a class="header-anchor" href="#个人收藏夹">#</a> 个人收藏夹</h1>\n<h2 id="推荐"><a class="header-anchor" href="#推荐">#</a> 推荐</h2>\n<ul>\n<li><a href="https://panjiachen.github.io/awesome-bookmarks/" target="_blank" rel="noopener noreferrer">panjiachen<OutboundLink/></a> by 花裤衩</li>\n<li><a href="https://www.code-nav.cn/" target="_blank" rel="noopener noreferrer">编程导航<OutboundLink/></a> by 程序员鱼皮</li>\n<li><a href="https://r2coding.com/" target="_blank" rel="noopener noreferrer">编程自学之路<OutboundLink/></a> by 程序羊</li>\n<li><a href="https://gitee.com/jishupang/web_atlas" target="_blank" rel="noopener noreferrer">前端知识图谱+B站资源整合<OutboundLink/></a> by 技术胖</li>\n<li><a href="https://shengxinjing.cn/" target="_blank" rel="noopener noreferrer">大圣编程自学网<OutboundLink/></a> by 大圣</li>\n<li><a href="https://devtool.tech/" target="_blank" rel="noopener noreferrer">开发者武器库<OutboundLink/></a></li>\n<li><a href="https://www.fly63.com/tool/home.html" target="_blank" rel="noopener noreferrer">工具大全<OutboundLink/></a></li>\n</ul>\n<p align="center">\n<img src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/blog/qrcode.zdqv9mlfc0g.jpg" width="200">\n</p>\n<div class="center-container"><p>关注公众号[有趣研究社]，回复<code>前端资源</code>，获取 <a href="https://github.com/xugaoyi/blog-gitalk-comment/wiki/Front-end-Study" target="_blank" rel="noopener noreferrer">前端学习资料<OutboundLink/></a></p>\n</div>',headersStr:"推荐 文档 社区 社区互动 技巧 博客 电子书 优秀文章 视频 Github 评论系统 前端小工具 代码编辑 Emoji表情 图片工具 思维导图 CSS CDN加速 网站托管 正则 其他 设计 图库 3D 交互 有趣 生成器 元宇宙 教程 产品 实用 Talk 算法 nginx 生活",content:"# 个人收藏夹\n\n\n# 推荐\n\n * panjiachen by 花裤衩\n * 编程导航 by 程序员鱼皮\n * 编程自学之路 by 程序羊\n * 前端知识图谱+B站资源整合 by 技术胖\n * 大圣编程自学网 by 大圣\n * 开发者武器库\n * 工具大全\n\n\n\n关注公众号[有趣研究社]，回复前端资源，获取 前端学习资料\n\n\n# 文档\n\n * MDN | MDN-JS标准内置对象 Web技术权威文档\n * DevDocs Web 开发技术文档，非常不错的学习手册！\n * 现代JavaScript教程 以最新标准为基准的JS教程\n * ES5教程 阮一峰的JS教程\n * ES6教程 阮一峰的ES6教程\n * Bash 脚本教程 阮一峰编写\n * ECMA ECMA官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * Github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * InfoQ 促进软件开发及相关领域知识与创新的传播\n * V2EX 创意工作者们的社区\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 社区互动\n\n * gitter\n * 兔小巢\n\n\n# 技巧\n\n * Google 趋势 查看某项技术或关键字的热度趋势，可用于分析某项技术的发展前景，或对比某两项技术的热度。\n * 百度指数 同上，但百度的数据仅限国内。\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * SoBooks 免费的电子书资源网站\n\n\n# 优秀文章\n\n * 我做系统架构的一些原则 作者对系统架构的方法论总结\n * 灵活运用CSS开发技巧\n * 防御性CSS\n\n\n# 视频\n\n * bilibili B站，上面很多免费教学视频\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学MOOC 涵盖计算机、外语、心理学等专业免费课程\n * egghead 质量还不错的短视频教程，外网\n\n\n# Github\n\n * Repobeats 生成仓库的动态数据统计图\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 Stars 增长曲线\n\n\n# 评论系统\n\n * giscus 由 GitHub Discussions 驱动的评论系统\n\n\n# 前端小工具\n\n * Can I use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌VSCode的在线IDE\n\n\n# Emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * 根据文本匹配emoji\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> 在任意输入框快速打开emoji表情方法：\n> Windows系统下按Win + .\n> Mac系统下按Control + Command + 空格\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * 微图 浏览器端图片压缩，不会上传图片到服务器\n * Squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线AI图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove AI抠图\n * backgroundremover 又一个抠图的\n\n\n# 思维导图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n * plectica 绘制知识图谱\n\n\n# CSS\n\n * 各种CSS生成器和JS代码片段\n\n * CSS Tricks CSS技巧收集与演示\n * CSS生成器\n * CSS渐变生成器\n * CSS3-Box Shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3D字体\n * css-tricks css技巧文章\n * You-need-to-know-css CSS的各种DEMO，很全\n * animista CSS动画可视化工具，复制代码就能用\n * navnav 各种炫酷的CSS动画组件\n\n\n# CDN加速\n\n * jsDelivr 国外的一家优秀的公共 CDN 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n * iHateRegex 正则搜索，细节做得很好\n * 正则迷你书 学习正则的小手册\n\n\n# 其他\n\n * Linux命令手册\n * carbon代码图片生成器 生成好看的代码图片\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove AI抠图，抠图算法很厉害\n * Manypixels 插画\n * Undraw 插画\n * storytale 插画，种类丰富，包含3D插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * Bēhance dribbble 是设计师的微博，Bēhance 是设计师的博客\n * Logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * Flat UI 色表 Flat UI 色表\n * 0to255 颜色梯度\n * Ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * Unsplash 提供免费的高清图片\n * Pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * CSS triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * Lorem Picsum 提供免费的占位图\n * Canva 可画 生成插画、封面、海报、头像等\n * 404页 404页素材\n * collectui 按功能组件分类的设计图\n * smartmockups 产品模板生成工具\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd（免抠元素）\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷 国内优秀的设计作品展示\n * 花瓣\n * 虎克 ps 学习教程\n * beTheme\n * UI 中国\n * wallhaven 壁纸网站-\n\n\n# 3D\n\n * sketchfab 3D模型\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n\n * Little Big Details 同上，一个国外微交互汇集网站\n\n * cruip 登录页的各种页面设计，可以免费下载模板\n\n * Comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 有趣\n\n * 电脑恶搞 收集了一些恶搞小网页，比如xp系统蓝屏、黑客界面等\n * neocities 上面托管了很多有趣的网站\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * FC在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * URL 地址播放 Emojis 动画 在地址栏里面播放 emoji\n * Can't Unsee 强烈建议前端、客户端、UI 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * ascii video 使用ascii编码生成视频动画\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 在线取名 解决取名难问题，超多名字生成\n\n\n# 生成器\n\n * 卡通头像生成器 上传真人头像生成卡通头像\n\n * artbreeder 动漫图生成真人图像\n\n * 声音生成器 生成下雨、咖啡厅、海浪、火车等声音，可几种声音合成\n\n * 诺基亚短信图片生成器\n\n * 到账语音生成器 支付宝到账1亿元\n\n\n# 元宇宙\n\n符合元宇宙特征的几个网站，允许用户拥有虚拟土地，在上面构建自己的世界：\n\n * 沙盒\n * 梦境空间\n * Decentraland\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * Product Hunt 好产品推荐\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * webden 在线网页编辑器，轻便快捷\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * VideoFk VideoFk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * UzerMe 云端办公工具\n * SoBooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * ENFI 下载器 不限速下载器\n * 来画视频 像做 PPT 一样做短视频\n * Arkie 海报制作工具\n * 优品 PPT\n * 比格 PPT\n * 高清免费图片\n * 高清免费图片 2\n * shapedivider 生成波浪分隔线\n * Notion 知识库、快速笔记、TaskList、日记、读书清单，各种类型，应有尽有\n\n\n# Talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# nginx\n\n * nginx 可视化配置工具\n\n\n# 生活\n\n * Ventusky 风雨气温图",normalizedContent:"# 个人收藏夹\n\n\n# 推荐\n\n * panjiachen by 花裤衩\n * 编程导航 by 程序员鱼皮\n * 编程自学之路 by 程序羊\n * 前端知识图谱+b站资源整合 by 技术胖\n * 大圣编程自学网 by 大圣\n * 开发者武器库\n * 工具大全\n\n\n\n关注公众号[有趣研究社]，回复前端资源，获取 前端学习资料\n\n\n# 文档\n\n * mdn | mdn-js标准内置对象 web技术权威文档\n * devdocs web 开发技术文档，非常不错的学习手册！\n * 现代javascript教程 以最新标准为基准的js教程\n * es5教程 阮一峰的js教程\n * es6教程 阮一峰的es6教程\n * bash 脚本教程 阮一峰编写\n * ecma ecma官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * infoq 促进软件开发及相关领域知识与创新的传播\n * v2ex 创意工作者们的社区\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 社区互动\n\n * gitter\n * 兔小巢\n\n\n# 技巧\n\n * google 趋势 查看某项技术或关键字的热度趋势，可用于分析某项技术的发展前景，或对比某两项技术的热度。\n * 百度指数 同上，但百度的数据仅限国内。\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * sobooks 免费的电子书资源网站\n\n\n# 优秀文章\n\n * 我做系统架构的一些原则 作者对系统架构的方法论总结\n * 灵活运用css开发技巧\n * 防御性css\n\n\n# 视频\n\n * bilibili b站，上面很多免费教学视频\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学mooc 涵盖计算机、外语、心理学等专业免费课程\n * egghead 质量还不错的短视频教程，外网\n\n\n# github\n\n * repobeats 生成仓库的动态数据统计图\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 stars 增长曲线\n\n\n# 评论系统\n\n * giscus 由 github discussions 驱动的评论系统\n\n\n# 前端小工具\n\n * can i use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌vscode的在线ide\n\n\n# emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * 根据文本匹配emoji\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> 在任意输入框快速打开emoji表情方法：\n> windows系统下按win + .\n> mac系统下按control + command + 空格\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * 微图 浏览器端图片压缩，不会上传图片到服务器\n * squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线ai图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove ai抠图\n * backgroundremover 又一个抠图的\n\n\n# 思维导图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n * plectica 绘制知识图谱\n\n\n# css\n\n * 各种css生成器和js代码片段\n\n * css tricks css技巧收集与演示\n * css生成器\n * css渐变生成器\n * css3-box shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3d字体\n * css-tricks css技巧文章\n * you-need-to-know-css css的各种demo，很全\n * animista css动画可视化工具，复制代码就能用\n * navnav 各种炫酷的css动画组件\n\n\n# cdn加速\n\n * jsdelivr 国外的一家优秀的公共 cdn 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n * ihateregex 正则搜索，细节做得很好\n * 正则迷你书 学习正则的小手册\n\n\n# 其他\n\n * linux命令手册\n * carbon代码图片生成器 生成好看的代码图片\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove ai抠图，抠图算法很厉害\n * manypixels 插画\n * undraw 插画\n * storytale 插画，种类丰富，包含3d插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * behance dribbble 是设计师的微博，behance 是设计师的博客\n * logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * flat ui 色表 flat ui 色表\n * 0to255 颜色梯度\n * ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * unsplash 提供免费的高清图片\n * pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * css triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * lorem picsum 提供免费的占位图\n * canva 可画 生成插画、封面、海报、头像等\n * 404页 404页素材\n * collectui 按功能组件分类的设计图\n * smartmockups 产品模板生成工具\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd（免抠元素）\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷 国内优秀的设计作品展示\n * 花瓣\n * 虎克 ps 学习教程\n * betheme\n * ui 中国\n * wallhaven 壁纸网站-\n\n\n# 3d\n\n * sketchfab 3d模型\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n\n * little big details 同上，一个国外微交互汇集网站\n\n * cruip 登录页的各种页面设计，可以免费下载模板\n\n * comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 有趣\n\n * 电脑恶搞 收集了一些恶搞小网页，比如xp系统蓝屏、黑客界面等\n * neocities 上面托管了很多有趣的网站\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * fc在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * url 地址播放 emojis 动画 在地址栏里面播放 emoji\n * can't unsee 强烈建议前端、客户端、ui 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * ascii video 使用ascii编码生成视频动画\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 在线取名 解决取名难问题，超多名字生成\n\n\n# 生成器\n\n * 卡通头像生成器 上传真人头像生成卡通头像\n\n * artbreeder 动漫图生成真人图像\n\n * 声音生成器 生成下雨、咖啡厅、海浪、火车等声音，可几种声音合成\n\n * 诺基亚短信图片生成器\n\n * 到账语音生成器 支付宝到账1亿元\n\n\n# 元宇宙\n\n符合元宇宙特征的几个网站，允许用户拥有虚拟土地，在上面构建自己的世界：\n\n * 沙盒\n * 梦境空间\n * decentraland\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * product hunt 好产品推荐\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * webden 在线网页编辑器，轻便快捷\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * videofk videofk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * uzerme 云端办公工具\n * sobooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * enfi 下载器 不限速下载器\n * 来画视频 像做 ppt 一样做短视频\n * arkie 海报制作工具\n * 优品 ppt\n * 比格 ppt\n * 高清免费图片\n * 高清免费图片 2\n * shapedivider 生成波浪分隔线\n * notion 知识库、快速笔记、tasklist、日记、读书清单，各种类型，应有尽有\n\n\n# talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# nginx\n\n * nginx 可视化配置工具\n\n\n# 生活\n\n * ventusky 风雨气温图",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"网站",frontmatter:{title:"网站",permalink:"/pages/beb6c0bd8a66cea6",date:"2020-04-19T11:33:04.000Z",article:!1},regularPath:"/06.%E6%94%B6%E8%97%8F%E5%A4%B9/01.%E7%BD%91%E7%AB%99.html",relativePath:"06.收藏夹/01.网站.md",key:"v-f24f57d4",path:"/pages/beb6c0bd8a66cea6/",headers:[{level:2,title:"推荐",slug:"推荐",normalizedTitle:"推荐",charIndex:12},{level:2,title:"文档",slug:"文档",normalizedTitle:"文档",charIndex:167},{level:2,title:"社区",slug:"社区",normalizedTitle:"社区",charIndex:375},{level:3,title:"社区互动",slug:"社区互动",normalizedTitle:"社区互动",charIndex:596},{level:2,title:"技巧",slug:"技巧",normalizedTitle:"技巧",charIndex:623},{level:2,title:"博客",slug:"博客",normalizedTitle:"博客",charIndex:711},{level:2,title:"电子书",slug:"电子书",normalizedTitle:"电子书",charIndex:775},{level:2,title:"优秀文章",slug:"优秀文章",normalizedTitle:"优秀文章",charIndex:833},{level:2,title:"视频",slug:"视频",normalizedTitle:"视频",charIndex:897},{level:2,title:"Github",slug:"github",normalizedTitle:"github",charIndex:382},{level:2,title:"评论系统",slug:"评论系统",normalizedTitle:"评论系统",charIndex:1148},{level:2,title:"前端小工具",slug:"前端小工具",normalizedTitle:"前端小工具",charIndex:1197},{level:2,title:"代码编辑",slug:"代码编辑",normalizedTitle:"代码编辑",charIndex:1269},{level:2,title:"Emoji表情",slug:"emoji表情",normalizedTitle:"emoji表情",charIndex:1330},{level:2,title:"图片工具",slug:"图片工具",normalizedTitle:"图片工具",charIndex:1493},{level:2,title:"思维导图",slug:"思维导图",normalizedTitle:"思维导图",charIndex:1753},{level:2,title:"CSS",slug:"css",normalizedTitle:"css",charIndex:875},{level:2,title:"CDN加速",slug:"cdn加速",normalizedTitle:"cdn加速",charIndex:2090},{level:2,title:"网站托管",slug:"网站托管",normalizedTitle:"网站托管",charIndex:2150},{level:2,title:"正则",slug:"正则",normalizedTitle:"正则",charIndex:2180},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:2241},{level:2,title:"设计",slug:"设计",normalizedTitle:"设计",charIndex:574},{level:2,title:"图库",slug:"图库",normalizedTitle:"图库",charIndex:3342},{level:2,title:"3D",slug:"_3d",normalizedTitle:"3d",charIndex:1967},{level:2,title:"交互",slug:"交互",normalizedTitle:"交互",charIndex:2420},{level:2,title:"有趣",slug:"有趣",normalizedTitle:"有趣",charIndex:139},{level:2,title:"生成器",slug:"生成器",normalizedTitle:"生成器",charIndex:1839},{level:2,title:"元宇宙",slug:"元宇宙",normalizedTitle:"元宇宙",charIndex:4444},{level:2,title:"教程",slug:"教程",normalizedTitle:"教程",charIndex:251},{level:2,title:"产品",slug:"产品",normalizedTitle:"产品",charIndex:3329},{level:2,title:"实用",slug:"实用",normalizedTitle:"实用",charIndex:4688},{level:2,title:"Talk",slug:"talk",normalizedTitle:"talk",charIndex:5061},{level:2,title:"算法",slug:"算法",normalizedTitle:"算法",charIndex:2330},{level:2,title:"nginx",slug:"nginx",normalizedTitle:"nginx",charIndex:5141},{level:2,title:"生活",slug:"生活",normalizedTitle:"生活",charIndex:5169}],excerpt:'<h1 id="个人收藏夹"><a class="header-anchor" href="#个人收藏夹">#</a> 个人收藏夹</h1>\n<h2 id="推荐"><a class="header-anchor" href="#推荐">#</a> 推荐</h2>\n<ul>\n<li><a href="https://panjiachen.github.io/awesome-bookmarks/" target="_blank" rel="noopener noreferrer">panjiachen<OutboundLink/></a> by 花裤衩</li>\n<li><a href="https://www.code-nav.cn/" target="_blank" rel="noopener noreferrer">编程导航<OutboundLink/></a> by 程序员鱼皮</li>\n<li><a href="https://r2coding.com/" target="_blank" rel="noopener noreferrer">编程自学之路<OutboundLink/></a> by 程序羊</li>\n<li><a href="https://gitee.com/jishupang/web_atlas" target="_blank" rel="noopener noreferrer">前端知识图谱+B站资源整合<OutboundLink/></a> by 技术胖</li>\n<li><a href="https://shengxinjing.cn/" target="_blank" rel="noopener noreferrer">大圣编程自学网<OutboundLink/></a> by 大圣</li>\n<li><a href="https://devtool.tech/" target="_blank" rel="noopener noreferrer">开发者武器库<OutboundLink/></a></li>\n<li><a href="https://www.fly63.com/tool/home.html" target="_blank" rel="noopener noreferrer">工具大全<OutboundLink/></a></li>\n</ul>\n<p align="center">\n<img src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/blog/qrcode.zdqv9mlfc0g.jpg" width="200">\n</p>\n<div class="center-container"><p>关注公众号[有趣研究社]，回复<code>前端资源</code>，获取 <a href="https://github.com/xugaoyi/blog-gitalk-comment/wiki/Front-end-Study" target="_blank" rel="noopener noreferrer">前端学习资料<OutboundLink/></a></p>\n</div>',headersStr:"推荐 文档 社区 社区互动 技巧 博客 电子书 优秀文章 视频 Github 评论系统 前端小工具 代码编辑 Emoji表情 图片工具 思维导图 CSS CDN加速 网站托管 正则 其他 设计 图库 3D 交互 有趣 生成器 元宇宙 教程 产品 实用 Talk 算法 nginx 生活",content:"# 个人收藏夹\n\n\n# 推荐\n\n * panjiachen by 花裤衩\n * 编程导航 by 程序员鱼皮\n * 编程自学之路 by 程序羊\n * 前端知识图谱+B站资源整合 by 技术胖\n * 大圣编程自学网 by 大圣\n * 开发者武器库\n * 工具大全\n\n\n\n关注公众号[有趣研究社]，回复前端资源，获取 前端学习资料\n\n\n# 文档\n\n * MDN | MDN-JS标准内置对象 Web技术权威文档\n * DevDocs Web 开发技术文档，非常不错的学习手册！\n * 现代JavaScript教程 以最新标准为基准的JS教程\n * ES5教程 阮一峰的JS教程\n * ES6教程 阮一峰的ES6教程\n * Bash 脚本教程 阮一峰编写\n * ECMA ECMA官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * Github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * InfoQ 促进软件开发及相关领域知识与创新的传播\n * V2EX 创意工作者们的社区\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 社区互动\n\n * gitter\n * 兔小巢\n\n\n# 技巧\n\n * Google 趋势 查看某项技术或关键字的热度趋势，可用于分析某项技术的发展前景，或对比某两项技术的热度。\n * 百度指数 同上，但百度的数据仅限国内。\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * SoBooks 免费的电子书资源网站\n\n\n# 优秀文章\n\n * 我做系统架构的一些原则 作者对系统架构的方法论总结\n * 灵活运用CSS开发技巧\n * 防御性CSS\n\n\n# 视频\n\n * bilibili B站，上面很多免费教学视频\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学MOOC 涵盖计算机、外语、心理学等专业免费课程\n * egghead 质量还不错的短视频教程，外网\n\n\n# Github\n\n * Repobeats 生成仓库的动态数据统计图\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 Stars 增长曲线\n\n\n# 评论系统\n\n * giscus 由 GitHub Discussions 驱动的评论系统\n\n\n# 前端小工具\n\n * Can I use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌VSCode的在线IDE\n\n\n# Emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * 根据文本匹配emoji\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> 在任意输入框快速打开emoji表情方法：\n> Windows系统下按Win + .\n> Mac系统下按Control + Command + 空格\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * 微图 浏览器端图片压缩，不会上传图片到服务器\n * Squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线AI图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove AI抠图\n * backgroundremover 又一个抠图的\n\n\n# 思维导图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n * plectica 绘制知识图谱\n\n\n# CSS\n\n * 各种CSS生成器和JS代码片段\n\n * CSS Tricks CSS技巧收集与演示\n * CSS生成器\n * CSS渐变生成器\n * CSS3-Box Shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3D字体\n * css-tricks css技巧文章\n * You-need-to-know-css CSS的各种DEMO，很全\n * animista CSS动画可视化工具，复制代码就能用\n * navnav 各种炫酷的CSS动画组件\n\n\n# CDN加速\n\n * jsDelivr 国外的一家优秀的公共 CDN 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n * iHateRegex 正则搜索，细节做得很好\n * 正则迷你书 学习正则的小手册\n\n\n# 其他\n\n * Linux命令手册\n * carbon代码图片生成器 生成好看的代码图片\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove AI抠图，抠图算法很厉害\n * Manypixels 插画\n * Undraw 插画\n * storytale 插画，种类丰富，包含3D插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * Bēhance dribbble 是设计师的微博，Bēhance 是设计师的博客\n * Logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * Flat UI 色表 Flat UI 色表\n * 0to255 颜色梯度\n * Ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * Unsplash 提供免费的高清图片\n * Pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * CSS triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * Lorem Picsum 提供免费的占位图\n * Canva 可画 生成插画、封面、海报、头像等\n * 404页 404页素材\n * collectui 按功能组件分类的设计图\n * smartmockups 产品模板生成工具\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd（免抠元素）\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷 国内优秀的设计作品展示\n * 花瓣\n * 虎克 ps 学习教程\n * beTheme\n * UI 中国\n * wallhaven 壁纸网站-\n\n\n# 3D\n\n * sketchfab 3D模型\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n\n * Little Big Details 同上，一个国外微交互汇集网站\n\n * cruip 登录页的各种页面设计，可以免费下载模板\n\n * Comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 有趣\n\n * 电脑恶搞 收集了一些恶搞小网页，比如xp系统蓝屏、黑客界面等\n * neocities 上面托管了很多有趣的网站\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * FC在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * URL 地址播放 Emojis 动画 在地址栏里面播放 emoji\n * Can't Unsee 强烈建议前端、客户端、UI 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * ascii video 使用ascii编码生成视频动画\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 在线取名 解决取名难问题，超多名字生成\n\n\n# 生成器\n\n * 卡通头像生成器 上传真人头像生成卡通头像\n\n * artbreeder 动漫图生成真人图像\n\n * 声音生成器 生成下雨、咖啡厅、海浪、火车等声音，可几种声音合成\n\n * 诺基亚短信图片生成器\n\n * 到账语音生成器 支付宝到账1亿元\n\n\n# 元宇宙\n\n符合元宇宙特征的几个网站，允许用户拥有虚拟土地，在上面构建自己的世界：\n\n * 沙盒\n * 梦境空间\n * Decentraland\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * Product Hunt 好产品推荐\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * webden 在线网页编辑器，轻便快捷\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * VideoFk VideoFk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * UzerMe 云端办公工具\n * SoBooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * ENFI 下载器 不限速下载器\n * 来画视频 像做 PPT 一样做短视频\n * Arkie 海报制作工具\n * 优品 PPT\n * 比格 PPT\n * 高清免费图片\n * 高清免费图片 2\n * shapedivider 生成波浪分隔线\n * Notion 知识库、快速笔记、TaskList、日记、读书清单，各种类型，应有尽有\n\n\n# Talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# nginx\n\n * nginx 可视化配置工具\n\n\n# 生活\n\n * Ventusky 风雨气温图",normalizedContent:"# 个人收藏夹\n\n\n# 推荐\n\n * panjiachen by 花裤衩\n * 编程导航 by 程序员鱼皮\n * 编程自学之路 by 程序羊\n * 前端知识图谱+b站资源整合 by 技术胖\n * 大圣编程自学网 by 大圣\n * 开发者武器库\n * 工具大全\n\n\n\n关注公众号[有趣研究社]，回复前端资源，获取 前端学习资料\n\n\n# 文档\n\n * mdn | mdn-js标准内置对象 web技术权威文档\n * devdocs web 开发技术文档，非常不错的学习手册！\n * 现代javascript教程 以最新标准为基准的js教程\n * es5教程 阮一峰的js教程\n * es6教程 阮一峰的es6教程\n * bash 脚本教程 阮一峰编写\n * ecma ecma官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * infoq 促进软件开发及相关领域知识与创新的传播\n * v2ex 创意工作者们的社区\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 社区互动\n\n * gitter\n * 兔小巢\n\n\n# 技巧\n\n * google 趋势 查看某项技术或关键字的热度趋势，可用于分析某项技术的发展前景，或对比某两项技术的热度。\n * 百度指数 同上，但百度的数据仅限国内。\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * sobooks 免费的电子书资源网站\n\n\n# 优秀文章\n\n * 我做系统架构的一些原则 作者对系统架构的方法论总结\n * 灵活运用css开发技巧\n * 防御性css\n\n\n# 视频\n\n * bilibili b站，上面很多免费教学视频\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学mooc 涵盖计算机、外语、心理学等专业免费课程\n * egghead 质量还不错的短视频教程，外网\n\n\n# github\n\n * repobeats 生成仓库的动态数据统计图\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 stars 增长曲线\n\n\n# 评论系统\n\n * giscus 由 github discussions 驱动的评论系统\n\n\n# 前端小工具\n\n * can i use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌vscode的在线ide\n\n\n# emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * 根据文本匹配emoji\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> 在任意输入框快速打开emoji表情方法：\n> windows系统下按win + .\n> mac系统下按control + command + 空格\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * 微图 浏览器端图片压缩，不会上传图片到服务器\n * squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线ai图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove ai抠图\n * backgroundremover 又一个抠图的\n\n\n# 思维导图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n * plectica 绘制知识图谱\n\n\n# css\n\n * 各种css生成器和js代码片段\n\n * css tricks css技巧收集与演示\n * css生成器\n * css渐变生成器\n * css3-box shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3d字体\n * css-tricks css技巧文章\n * you-need-to-know-css css的各种demo，很全\n * animista css动画可视化工具，复制代码就能用\n * navnav 各种炫酷的css动画组件\n\n\n# cdn加速\n\n * jsdelivr 国外的一家优秀的公共 cdn 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n * ihateregex 正则搜索，细节做得很好\n * 正则迷你书 学习正则的小手册\n\n\n# 其他\n\n * linux命令手册\n * carbon代码图片生成器 生成好看的代码图片\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove ai抠图，抠图算法很厉害\n * manypixels 插画\n * undraw 插画\n * storytale 插画，种类丰富，包含3d插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * behance dribbble 是设计师的微博，behance 是设计师的博客\n * logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * flat ui 色表 flat ui 色表\n * 0to255 颜色梯度\n * ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * unsplash 提供免费的高清图片\n * pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * css triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * lorem picsum 提供免费的占位图\n * canva 可画 生成插画、封面、海报、头像等\n * 404页 404页素材\n * collectui 按功能组件分类的设计图\n * smartmockups 产品模板生成工具\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd（免抠元素）\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷 国内优秀的设计作品展示\n * 花瓣\n * 虎克 ps 学习教程\n * betheme\n * ui 中国\n * wallhaven 壁纸网站-\n\n\n# 3d\n\n * sketchfab 3d模型\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n\n * little big details 同上，一个国外微交互汇集网站\n\n * cruip 登录页的各种页面设计，可以免费下载模板\n\n * comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 有趣\n\n * 电脑恶搞 收集了一些恶搞小网页，比如xp系统蓝屏、黑客界面等\n * neocities 上面托管了很多有趣的网站\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * fc在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * url 地址播放 emojis 动画 在地址栏里面播放 emoji\n * can't unsee 强烈建议前端、客户端、ui 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * ascii video 使用ascii编码生成视频动画\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 在线取名 解决取名难问题，超多名字生成\n\n\n# 生成器\n\n * 卡通头像生成器 上传真人头像生成卡通头像\n\n * artbreeder 动漫图生成真人图像\n\n * 声音生成器 生成下雨、咖啡厅、海浪、火车等声音，可几种声音合成\n\n * 诺基亚短信图片生成器\n\n * 到账语音生成器 支付宝到账1亿元\n\n\n# 元宇宙\n\n符合元宇宙特征的几个网站，允许用户拥有虚拟土地，在上面构建自己的世界：\n\n * 沙盒\n * 梦境空间\n * decentraland\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * product hunt 好产品推荐\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * webden 在线网页编辑器，轻便快捷\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * videofk videofk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * uzerme 云端办公工具\n * sobooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * enfi 下载器 不限速下载器\n * 来画视频 像做 ppt 一样做短视频\n * arkie 海报制作工具\n * 优品 ppt\n * 比格 ppt\n * 高清免费图片\n * 高清免费图片 2\n * shapedivider 生成波浪分隔线\n * notion 知识库、快速笔记、tasklist、日记、读书清单，各种类型，应有尽有\n\n\n# talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# nginx\n\n * nginx 可视化配置工具\n\n\n# 生活\n\n * ventusky 风雨气温图",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-4d788087",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"常用的前端轮子",frontmatter:{title:"常用的前端轮子",date:"2021-10-09T19:42:02.000Z",permalink:"/pages/47cf96/",article:!1},regularPath:"/06.%E6%94%B6%E8%97%8F%E5%A4%B9/02.%E5%B8%B8%E7%94%A8%E7%9A%84%E5%89%8D%E7%AB%AF%E8%BD%AE%E5%AD%90.html",relativePath:"06.收藏夹/02.常用的前端轮子.md",key:"v-5eeaf1e8",path:"/pages/47cf96/",headers:[{level:2,title:"React UI 组件库",slug:"react-ui-组件库",normalizedTitle:"react ui 组件库",charIndex:2},{level:2,title:"Vue UI组件库",slug:"vue-ui组件库",normalizedTitle:"vue ui组件库",charIndex:68},{level:2,title:"常用效果组件",slug:"常用效果组件",normalizedTitle:"常用效果组件",charIndex:124},{level:2,title:"工具类",slug:"工具类",normalizedTitle:"工具类",charIndex:201},{level:2,title:"Vue工具类",slug:"vue工具类",normalizedTitle:"vue工具类",charIndex:331},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:469}],headersStr:"React UI 组件库 Vue UI组件库 常用效果组件 工具类 Vue工具类 其他",content:"# React UI 组件库\n\n * Ant Design\n * React Bootstrap\n * MATERIAL-UI\n\n\n# Vue UI组件库\n\n * Element UI PC端\n * Vant 移动端\n * View UI\n\n\n# 常用效果组件\n\n * Animate.css 动画库\n * Swiper 轮播组件\n * mescroll 下拉刷新和上拉加载框架-基于原生JS\n\n\n# 工具类\n\n * Lodash.js\n * Day.js 处理日期\n * Timeago.js 相对时间，如N小时前\n * Echarts 百度图表\n * Meditor.md 开源在线 Markdown 编辑器\n * validator.js 验证库\n\n\n# Vue工具类\n\n * vue-draggable 基于Sortable.js实现的vue拖拽插件\n * vue-qr 文本转二维码\n * vue-cropper 图片裁剪插件\n * vue-lazyload 懒加载\n * vue-simple-upload 上传组件\n\n\n# 其他\n\n * H5带笔锋手写签名，支持PC端和移动端",normalizedContent:"# react ui 组件库\n\n * ant design\n * react bootstrap\n * material-ui\n\n\n# vue ui组件库\n\n * element ui pc端\n * vant 移动端\n * view ui\n\n\n# 常用效果组件\n\n * animate.css 动画库\n * swiper 轮播组件\n * mescroll 下拉刷新和上拉加载框架-基于原生js\n\n\n# 工具类\n\n * lodash.js\n * day.js 处理日期\n * timeago.js 相对时间，如n小时前\n * echarts 百度图表\n * meditor.md 开源在线 markdown 编辑器\n * validator.js 验证库\n\n\n# vue工具类\n\n * vue-draggable 基于sortable.js实现的vue拖拽插件\n * vue-qr 文本转二维码\n * vue-cropper 图片裁剪插件\n * vue-lazyload 懒加载\n * vue-simple-upload 上传组件\n\n\n# 其他\n\n * h5带笔锋手写签名，支持pc端和移动端",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-51262ae7",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-9547eff2",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"你知道的越多，不知道的也就越多",frontmatter:{title:"你知道的越多，不知道的也就越多",date:"2020-05-06T15:52:40.000Z",permalink:"/pages/f2e63f",sidebar:"auto",categories:["随笔"],tags:["学习","知识","鸡汤"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E8%B6%8A%E5%A4%9A%EF%BC%8C%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B9%9F%E5%B0%B1%E8%B6%8A%E5%A4%9A.html",relativePath:"_posts/随笔/你知道的越多，不知道的也就越多.md",key:"v-35a1e8e8",path:"/pages/f2e63f/",excerpt:"<p>不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。</p>\n",headersStr:null,content:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n鸡汤1\n\n弱小的人，才习惯嘲讽与否定，而内心强大的人，从不吝啬赞美与鼓励。\n\n鸡汤2\n\n当代青年人都应该摆脱冷气，只管向上走，不必听从自暴自弃者的流言。能做事的做事，能发声的发声。有一份热，发一份光，就像萤火一般，也可以在黑暗里发一点光，不必等候炬火。",normalizedContent:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n鸡汤1\n\n弱小的人，才习惯嘲讽与否定，而内心强大的人，从不吝啬赞美与鼓励。\n\n鸡汤2\n\n当代青年人都应该摆脱冷气，只管向上走，不必听从自暴自弃者的流言。能做事的做事，能发声的发声。有一份热，发一份光，就像萤火一般，也可以在黑暗里发一点光，不必等候炬火。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"我做了一个手写春联小网页，祝大家虎年暴富",frontmatter:{title:"我做了一个手写春联小网页，祝大家虎年暴富",date:"2022-01-28T14:59:51.000Z",permalink:"/pages/829589/",titleTag:"原创",sidebar:"auto",categories:["随笔"],tags:[null]},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E6%88%91%E5%81%9A%E4%BA%86%E4%B8%80%E4%B8%AA%E6%89%8B%E5%86%99%E6%98%A5%E8%81%94%E5%B0%8F%E7%BD%91%E9%A1%B5%EF%BC%8C%E7%A5%9D%E5%A4%A7%E5%AE%B6%E8%99%8E%E5%B9%B4%E6%9A%B4%E5%AF%8C.html",relativePath:"_posts/随笔/我做了一个手写春联小网页，祝大家虎年暴富.md",key:"v-057acb1e",path:"/pages/829589/",headers:[{level:3,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:33},{level:3,title:"产品构思",slug:"产品构思",normalizedTitle:"产品构思",charIndex:195},{level:3,title:"设计",slug:"设计",normalizedTitle:"设计",charIndex:478},{level:3,title:"开发",slug:"开发",normalizedTitle:"开发",charIndex:487}],excerpt:'<p>手写春联：<a href="https://cl.xugaoyi.com/" target="_blank" rel="noopener noreferrer">https://cl.xugaoyi.com/<OutboundLink/></a></p>\n<h3 id="前言"><a class="header-anchor" href="#前言">#</a> 前言</h3>\n<p>虎年春节快到了，首先祝大家新年快乐，轻松暴富。\n最近在网上经常看到生成春联的文章，不过这些小demo要么功能简陋,要么UI特别‘程序员’，满足不了我挑剔的眼光。干脆我自己做一个吧，顺便简单体验一下vite+vue3。（因为页面相对简单，vue组件风格还是使用选项式api，重点还是想把产品快速做出来。）</p>\n',headersStr:"前言 产品构思 设计 开发",content:'手写春联：https://cl.xugaoyi.com/\n\n\n# 前言\n\n虎年春节快到了，首先祝大家新年快乐，轻松暴富。 最近在网上经常看到生成春联的文章，不过这些小demo要么功能简陋,要么UI特别‘程序员’，满足不了我挑剔的眼光。干脆我自己做一个吧，顺便简单体验一下vite+vue3。（因为页面相对简单，vue组件风格还是使用选项式api，重点还是想把产品快速做出来。）\n\n\n\n\n# 产品构思\n\n包含手写春节和生成春联两大功能：\n\n * 手写春联\n   \n   * 模拟用笔写字的字迹\n   * 选择画笔颜色\n   * 调整画笔大小\n   * 清空画布\n   * 撤回笔画\n   * 切换上、下联、横批、福字\n   * 随机切换对联提示\n   * 预览图片和下载\n   * 贴春联海报和下载\n\n * 生成模式\n   \n   * 选择画笔颜色\n   * 挑选生成的对联\n   * 输入对联\n   * 随机切换对联\n   * 贴春联海报和下载\n\n * 其他\n   \n   * 快速切换模式按钮\n   * 可控制的背景音乐\n   * 微信分享网页\n\n\n# 设计\n\n\n\n\n# 开发\n\n * 技术栈\n   * vite (打包&构建)\n   * vue3 (页面开发)\n   * vant（ui）\n   * sass (css)\n   * smooth-signature.js (带笔锋手写库)\n\n<template>\n  <div class="wrap" :class="\'mode-\' + mode" @touchstart="handleTouchstart">\n    \x3c!-- 切换模式按钮 --\x3e\n    <div class="toggle-mode-btn" @click="toggleMode">\n      {{ mode === 1 ? \'手写\' : \'生成\' }}\n      <i class="iconfont icon-qiehuan"></i>\n    </div>\n\n    \x3c!-- 工具栏 --\x3e\n    <div\n      class="actions"\n      :style="{ borderTopRightRadius: colorListVisibility ? \'0\' : \'5px\' }"\n    >\n      \x3c!-- 手写模式显示 --\x3e\n      <template v-if="mode === 1">\n        \x3c!-- 调色板 --\x3e\n        <div class="palette btn-block">\n          <div\n            class="cur-color"\n            @click="togglePalette"\n            :style="{ background: colorList[curColorIndex] }"\n          ></div>\n          <ul class="colorList" v-show="colorListVisibility">\n            <li\n              v-for="(item, index) in colorList"\n              :key="item"\n              :style="{ background: item }"\n              @click="selectColor(index)"\n            ></li>\n          </ul>\n        </div>\n\n        \x3c!-- 滑块 --\x3e\n        <div class="slider-box btn-block">\n          <van-slider\n            v-model="progress"\n            vertical\n            @change="changeProgress"\n            bar-height="28"\n            active-color="transparent"\n            :min="50"\n            :max="150"\n          >\n            <template #button>\n              <div class="custom-button"></div>\n            </template>\n          </van-slider>\n        </div>\n\n        \x3c!-- 清空 --\x3e\n        <div class="btn" @click="handleClear">\n          <i class="iconfont icon-lajitong"></i>\n        </div>\n\n        \x3c!-- 撤销 --\x3e\n        <div class="btn" @click="handleUndo">\n          <i class="iconfont icon-fanhui"></i>\n        </div>\n\n        <div class="line"></div>\n\n        \x3c!-- 切换画布的按钮 --\x3e\n        <div\n          class="btn"\n          :class="{ \'cur-active\': curCanvasIndex === index }"\n          v-for="(item, index) in canvasList"\n          :key="item.name"\n          @click="changeCanvas(index)"\n        >\n          {{ item.name }}\n        </div>\n\n        <div class="line"></div>\n\n        <div class="btn prominent" @click="handlePreview">预览</div>\n        <div class="btn prominent" @click="openPosters">贴联</div>\n      </template>\n\n      \x3c!-- 生成模式显示 --\x3e\n      <template v-else>\n        \x3c!-- 选颜色 --\x3e\n        <div\n          class="color-list-quick"\n          :class="{ active: curColorIndex === index }"\n          v-for="(item, index) in colorList"\n          :key="item"\n          :style="{ background: item }"\n          @click="selectColor(index)"\n        ></div>\n        <div class="line"></div>\n        <div class="btn" @click="showPickBox = true">挑选</div>\n        <div class="btn" @click="showInputBox = true">输入</div>\n\n        \x3c!-- 挑选对联弹窗 --\x3e\n        <van-action-sheet v-model:show="showPickBox" title="请挑选对联">\n          <ul class="duilian-list">\n            <li\n              v-for="(item, index) in duilianList"\n              :key="index"\n              @click="handlePickDuilian(item)"\n            >\n              <span>{{ item.shang }}</span\n              >， <span>{{ item.xia }}</span\n              >。\n              <span>{{ item.heng }}</span>\n            </li>\n          </ul>\n        </van-action-sheet>\n\n        \x3c!-- 输入对联弹窗 --\x3e\n        <van-action-sheet v-model:show="showInputBox" title="请输入对联">\n          <van-form @submit="handleSubmitInput">\n            <van-cell-group inset>\n              <van-field\n                v-model="shanglian"\n                name="shang"\n                label="上联"\n                placeholder="上联"\n                :rules="[\n                  {\n                    required: true,\n                    message: \'请输入7位汉字上联\',\n                    pattern: /^[\\u4e00-\\u9fa5]{7}$/\n                  }\n                ]"\n                clearable\n              />\n              <van-field\n                v-model="xialian"\n                name="xia"\n                label="下联"\n                placeholder="下联"\n                :rules="[\n                  {\n                    required: true,\n                    message: \'请输入7位汉字下联\',\n                    pattern: /^[\\u4e00-\\u9fa5]{7}$/\n                  }\n                ]"\n                clearable\n              />\n              <van-field\n                v-model="hengpi"\n                name="heng"\n                label="横批"\n                placeholder="横批"\n                :rules="[\n                  {\n                    required: true,\n                    message: \'请输入4位汉字横批\',\n                    pattern: /^[\\u4e00-\\u9fa5]{4}$/\n                  }\n                ]"\n                clearable\n              />\n            </van-cell-group>\n            <div style="margin: 16px">\n              <van-button\n                round\n                block\n                type="primary"\n                native-type="submit"\n                color="linear-gradient(to right, #ff6034, #c33825)"\n              >\n                完成\n              </van-button>\n            </div>\n          </van-form>\n        </van-action-sheet>\n      </template>\n    </div>\n\n    \x3c!-- 模式1-春联画布 --\x3e\n    <div\n      v-show="mode === 1"\n      v-for="(item, index) in canvasList"\n      :key="item.name"\n    >\n      <canvas\n        class="canvas"\n        :class="item.className"\n        v-show="curCanvasIndex === index"\n        :style="{\n          marginTop:\n            item.height < clientHeight\n              ? `${(clientHeight - item.height) / 2}px`\n              : 0,\n          marginLeft:\n            item.width < clientWidth ? `${(clientWidth - item.width) / 2}px` : 0\n        }"\n      />\n    </div>\n\n    \x3c!-- 模式2-春联画布 --\x3e\n    <div v-show="mode === 2" class="canvas-mode-2">\n      <div class="row">\n        <canvas id="canvas-top" :width="200 * scale" :height="60 * scale" />\n      </div>\n      <div class="row">\n        <canvas id="canvas-left" :width="60 * scale" :height="364 * scale" />\n        <canvas id="canvas-right" :width="60 * scale" :height="364 * scale" />\n      </div>\n    </div>\n\n    \x3c!-- 贴春联按钮 --\x3e\n    <Button class="btn-posters" @click="openPosters" />\n\n    \x3c!-- footer-当前对联提示 --\x3e\n    <footer v-if="duilian.shang">\n      <div class="refresh-btn" @click="handleRefresh(true)">\n        <i class="iconfont icon-shuaxin" :class="{ rotate: isRotate }"></i>\n      </div>\n      <dl class="duilian">\n        <dt>对联</dt>\n        <dd>\n          <div>{{ duilian.shang }}</div>\n          <div>{{ duilian.xia }}</div>\n        </dd>\n      </dl>\n      <dl>\n        <dt>横批</dt>\n        <dd>{{ duilian.heng }}</dd>\n      </dl>\n    </footer>\n\n    \x3c!-- 分享按钮 --\x3e\n    <div class="share-btn" v-if="isShowShareBtn" @click="isShowShareTip = true">\n      <i class="iconfont icon-fenxiang"></i>\n    </div>\n    \x3c!-- 微信分享提示语 --\x3e\n    <div\n      class="share-tip"\n      v-if="isShowShareTip"\n      @click="isShowShareTip = false"\n    >\n      点击右上角把这个工具分享给朋友\n      <div class="hand">👆</div>\n    </div>\n\n    \x3c!-- 保存tip --\x3e\n    <p v-if="isShowTip" class="download-tip">*长按图片保存或转发</p>\n\n    \x3c!-- 版权 --\x3e\n    <div class="copyright">公众号「有趣研究社」 ©版权所有</div>\n\n    \x3c!-- 载入图片元素，用于快速贴图使用, 注意设置crossorigin="anonymous"解决跨域 --\x3e\n    <div v-if="isReadImages">\n      <img\n        crossorigin="anonymous"\n        v-for="(item, index) in bgList"\n        :src="item"\n        :key="item"\n        class="hide-img"\n        :id="`bg-img-` + index"\n      />\n      <img\n        crossorigin="anonymous"\n        class="hide-img"\n        id="qrcode"\n        src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store2@master/img/qrcode.zul0pldsuao.png"\n      />\n    </div>\n\n    \x3c!-- 背景音乐 --\x3e\n    <audio\n      src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store2@master/cjxq.mp3"\n      id="bgm"\n      ref="bgm"\n      loop\n    />\n    <div\n      class="play-btn"\n      :class="{ paused: !isPlay }"\n      ref="playBtn"\n      @click="handlePlay"\n    >\n      <i class="iconfont icon-yinle"></i>\n    </div>\n  </div>\n\n  <div class="body-bg-img"></div>\n</template>\n\n<script>\nimport { ImagePreview, Notify } from \'vant\'\nimport { isWX, isMobile } from \'@/utils\'\nimport Button from \'@/components/Button.vue\'\nimport dl from \'@/assets/img/yh/dl.jpeg\'\nimport hp from \'@/assets/img/yh/hp.jpeg\'\nimport fz from \'@/assets/img/yh/fz.png\'\n\n// 对联数据\nimport duilianList from \'@/mock/duilian\'\n\nconst PROPORTION = 0.37 // 图片缩小比例\nconst INSTANTIATE_NAME = \'signature\' // 实例名称\nconst MIN_WIDTH = 3 // 画笔最小宽\nconst MAX_WIDTH = 12 // 画笔最大宽\n\n// 海报背景图大小\nconst BG_WIDTH = 750\nconst BG_HEIGHT = 1448\n\n// 贴图定位和大小\nconst POSITION = [\n  { left: 57, top: 510, width: 90, height: 546 }, // 上联\n  { left: 600, top: 510, width: 90, height: 546 }, // 下联\n  { left: 225, top: 345, width: 300, height: 90 }, // 横幅\n  { left: 460, top: 450, width: 130, height: 130 }, // 福字\n]\n\nexport default {\n  name: "Home",\n  components: {\n    Button\n  },\n  data() {\n    return {\n      duilianList,\n      mode: Number(localStorage.getItem(\'mode\')) || 1, // 1 手写，2 生成\n      curCanvasIndex: 0, // 显示哪个画布\n      progress: 100, // 画笔大小的刻度\n      clientWidth: document.documentElement.clientWidth,\n      clientHeight: document.documentElement.clientHeight,\n      canvasList: [\n        {\n          name: \'上联\',\n          className: \'canvas-a\',\n          bgImage: dl,\n          width: 600 * PROPORTION,\n          height: 3640 * PROPORTION,\n        },\n        {\n          name: \'下联\',\n          className: \'canvas-b\',\n          bgImage: dl,\n          width: 600 * PROPORTION,\n          height: 3640 * PROPORTION,\n        },\n        {\n          name: \'横批\',\n          className: \'canvas-c\',\n          bgImage: hp,\n          width: 2000 * PROPORTION,\n          height: 600 * PROPORTION,\n        },\n        {\n          name: \'福字\',\n          className: \'canvas-d\',\n          bgImage: fz,\n          width: 366,\n          height: 366,\n        }\n      ],\n      colorList: [\'#000000\', \'#ffd800\', \'#e8bd48\', \'#ddc08c\',],\n      curColorIndex: 0,\n      colorListVisibility: false, // 画布颜色选择列表可见性\n      isShowTip: false, // 是否显示底部提示语\n      duilian: {}, // 当前对联文本对象\n      isRotate: false, // 刷新icon旋转\n      bgList: [\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/1.4j8qpdnq80i0.jpeg\',\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/4.4460an8ag5o0.jpeg\',\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/5.3axtl4xpvy00.jpeg\',\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/6.2lnbphdqjaq0.jpeg\',\n      ],\n      isReadImages: false, // 延迟加载图片用\n      isShowShareBtn: false, // 是否显示分享按钮\n      isShowShareTip: false, // 是否显示分享提示语\n      isPlay: false, // 是否在播放\n\n      // 模式2\n      canvasTop: null, // 横批\n      canvasLeft: null, // 上联\n      canvasRight: null, // 下联\n      imgObj1: null, // 横批图片对象\n      imgObj2: null, // 上下联图片对象\n      scale: Math.max(window.devicePixelRatio || 1, 2), // 用于增加画布清晰度\n      showPickBox: false, // 挑选对联的弹框\n      showInputBox: false, // 输入对联的弹框\n      shanglian: \'\', // 输入的上联\n      xialian: \'\', // 输入的下联\n      hengpi: \'\', // 输入的横批\n    };\n  },\n  computed: {\n    // 模式1-当前画布实例\n    curCanvasInstantiate() {\n      return this[INSTANTIATE_NAME + this.curCanvasIndex]\n    }\n  },\n  created() {\n    // 微信浏览器显示分享按钮\n    this.isShowShareBtn = isWX()\n  },\n  mounted() {\n    if (!isMobile()) {\n      Notify({ type: \'warning\', message: \'请用移动端打开获得最佳体验\', duration: 6000, });\n    }\n\n    this.initMode1();\n\n    // 初始化对联提示\n    this.handleRefresh();\n\n    this.initMode2();\n\n    // 按钮添加激活时发光效果class\n    const btnEl = document.querySelectorAll(\'.btn,.btn-block\');\n    btnEl.forEach((item) => {\n      item.addEventListener(\'touchstart\', () => {\n        item.classList.add(\'btn-active\')\n      })\n      item.addEventListener(\'touchend\', () => {\n        setTimeout(() => {\n          item.classList.remove(\'btn-active\')\n        }, 100)\n      })\n    })\n\n    // 延迟加载贴图背景\n    setTimeout(() => {\n      this.isReadImages = true\n    }, 1000)\n  },\n\n  watch: {\n    // 切换画笔颜色\n    curColorIndex() {\n      this.curCanvasInstantiate.color = this.colorList[this.curColorIndex]\n      if (this.mode === 2) {\n        this.refreshDuilian()\n      }\n    },\n    // 切换画布时应用当前画笔颜色和大小\n    curCanvasIndex() {\n      this.curCanvasInstantiate.color = this.colorList[this.curColorIndex]\n      this.handleChangeSize()\n      window.scrollTo(0, 0)\n    }\n  },\n\n  methods: {\n    initMode1() {\n      const { colorList, curColorIndex } = this\n      this.canvasList.forEach((item, index) => {\n        const options = {\n          width: item.width,\n          height: item.height,\n          minWidth: MIN_WIDTH, // 画笔最小宽度(px)\n          maxWidth: MAX_WIDTH, // 画笔最大宽度\n          minSpeed: 1.8, // 画笔达到最小宽度所需最小速度(px/ms)，取值范围1.0-10.0\n          color: colorList[curColorIndex],\n          // 新增的配置\n          bgImage: item.bgImage,\n        };\n\n        this[INSTANTIATE_NAME + index] = new SmoothSignature(document.querySelector(\'.\' + item.className), options);\n      })\n    },\n\n    initMode2() {\n      this.canvasTop = document.getElementById(\'canvas-top\').getContext(\'2d\')\n      this.canvasLeft = document.getElementById(\'canvas-left\').getContext(\'2d\')\n      this.canvasRight = document.getElementById(\'canvas-right\').getContext(\'2d\')\n\n      // 设字体样式\n      const font = "36px xs, cursive"\n      this.canvasTop.font = font\n      this.canvasLeft.font = font\n      this.canvasRight.font = font\n\n      // 增强清晰度\n      const { scale } = this\n      this.canvasTop.scale(scale, scale);\n      this.canvasLeft.scale(scale, scale);\n      this.canvasRight.scale(scale, scale);\n\n      // 设背景图\n      this.imgObj1 = new Image()\n      this.imgObj2 = new Image()\n      this.imgObj1.src = hp\n      this.imgObj2.src = dl\n      this.imgObj1.onload = () => {\n        // 贴背景\n        this.canvasTop.drawImage(this.imgObj1, 0, 0, 200, 60)\n\n        // 字体加载完成后\n        document.fonts.ready.then(() => {\n          this.handleTopFillText()\n        });\n      }\n      this.imgObj2.onload = () => {\n        // 贴背景\n        this.canvasLeft.drawImage(this.imgObj2, 0, 0, 60, 364)\n        this.canvasRight.drawImage(this.imgObj2, 0, 0, 60, 364)\n\n        // 字体加载完成后\n        document.fonts.ready.then(() => {\n          this.handleLRFillText(this.canvasLeft, this.duilian.shang)\n          this.handleLRFillText(this.canvasRight, this.duilian.xia)\n        });\n      }\n    },\n\n    // 模式2-刷新对联\n    refreshDuilian() {\n      this.canvasTop.drawImage(this.imgObj1, 0, 0, 200, 60)\n      this.canvasLeft.drawImage(this.imgObj2, 0, 0, 60, 364)\n      this.canvasRight.drawImage(this.imgObj2, 0, 0, 60, 364)\n      this.handleTopFillText()\n      this.handleLRFillText(this.canvasLeft, this.duilian.shang)\n      this.handleLRFillText(this.canvasRight, this.duilian.xia)\n    },\n\n    // 模式2-贴横批\n    handleTopFillText() {\n      // 贴文本\n      this.canvasTop.fillStyle = this.colorList[this.curColorIndex]\n      if (this.duilian.heng) {\n        this.duilian.heng.split(\'\').forEach((item, index) => {\n          const left = 42 * (index + 1) - 22\n          this.canvasTop.fillText(item, left, 40)\n        })\n      }\n    },\n\n    // 模式2-贴上下联\n    handleLRFillText(ctx, text) {\n      ctx.fillStyle = this.colorList[this.curColorIndex]\n      if (text) {\n        text.split(\'\').forEach((item, index) => {\n          const top = 50 * (index + 1) - 8\n          ctx.fillText(item, 13, top)\n        })\n      }\n    },\n\n    // 切换模式\n    toggleMode() {\n      if (this.mode === 1) {\n        this.mode = 2\n        this.refreshDuilian()\n      } else {\n        this.mode = 1\n      }\n      localStorage.setItem(\'mode\', this.mode);\n    },\n\n    // 打开调色板\n    togglePalette() {\n      this.colorListVisibility = !this.colorListVisibility\n    },\n\n    // 关闭调色板\n    handleTouchstart(e) {\n      // 不是点击选择颜色时\n      if (e.path[1]?.classList?.value !== \'colorList\' && e.target.classList?.value !== \'cur-color\') {\n        this.colorListVisibility = false\n      }\n    },\n\n    // 选择颜色\n    selectColor(index) {\n      this.curColorIndex = index\n      this.colorListVisibility = false\n    },\n\n    // 切换画布\n    changeCanvas(index) {\n      this.curCanvasIndex = index\n    },\n\n    // 清空画布\n    handleClear() {\n      this.curCanvasInstantiate.clear();\n    },\n\n    // 撤销笔画\n    handleUndo() {\n      this.curCanvasInstantiate.undo();\n    },\n\n    // 预览\n    handlePreview() {\n      this.showTopTip();\n      this.isShowTip = true\n      const _this = this\n      ImagePreview({\n        images: this.getImageList(),\n        closeable: true,\n        startPosition: this.curCanvasIndex,\n        onClose() {\n          _this.isShowTip = false\n        },\n      });\n    },\n\n    // 打开海报预览\n    openPosters() {\n      // 创建画布\n      const canvas = document.createElement(\'canvas\');\n      canvas.width = BG_WIDTH\n      canvas.height = BG_HEIGHT\n      const ctx = canvas.getContext(\'2d\');\n      const resultImageList = [];\n\n      // 是否隐藏福字\n      const isHideFu = this[INSTANTIATE_NAME + 3].isEmpty()\n      this.bgList.forEach((item, index) => {\n        // 贴背景图\n        ctx.drawImage(document.getElementById(\'bg-img-\' + index), 0, 0, BG_WIDTH, BG_HEIGHT)\n\n        // 贴对联\n        if (this.mode === 1) {\n          this.canvasList.forEach((item, index) => {\n            if (index === 3 && isHideFu) return;\n            const dlCanvas = document.querySelector(\'.\' + item.className)\n            const { left, top, width, height } = POSITION[index]\n            ctx.drawImage(dlCanvas, left, top, width, height)\n          })\n        } else {\n          [\'canvas-left\', \'canvas-right\', \'canvas-top\'].forEach((item, index) => {\n            const dlCanvas = document.getElementById(item)\n            const { left, top, width, height } = POSITION[index]\n            ctx.drawImage(dlCanvas, left, top, width, height)\n          })\n        }\n\n        // 贴二维码\n        ctx.drawImage(document.getElementById("qrcode"), 40, 1280, 580, 136)\n\n        // 贴文本\n        ctx.font = "18px sans-serif"\n        ctx.fillStyle = "#666666"\n        ctx.fillText(\'©公众号「有趣研究社」\', 550, 1420)\n\n        // 导出图片\n        resultImageList.push(canvas.toDataURL(\'image/jpeg\', 0.8))\n      })\n\n      // 打开图片预览\n      this.isShowTip = true\n      const _this = this\n      ImagePreview({\n        images: resultImageList,\n        closeable: true,\n        onClose() {\n          _this.isShowTip = false\n        },\n      });\n      this.showTopTip();\n    },\n\n    // 弹出顶部提示语\n    showTopTip() {\n      if (!sessionStorage.getItem(\'showTip\')) {\n        sessionStorage.setItem(\'showTip\', \'true\');\n        Notify({\n          message: \'长按图片可保存到本地\',\n          color: \'#c33825\',\n          background: \'#eed3ae\',\n        });\n      }\n    },\n\n    // 获取对联图片列表\n    getImageList(type = \'image/png\') {\n      const imageList = []\n      this.canvasList.forEach((item, index) => {\n        if (index === 3) {\n          // `福`字必须是png格式\n          type = \'image/png\'\n        }\n        imageList.push(this[INSTANTIATE_NAME + index].toDataURL(type, 0.8))\n      })\n      return imageList\n    },\n\n    // 进度改变时\n    changeProgress(progress) {\n      this.progress = progress\n      this.handleChangeSize()\n    },\n\n    // 调整画笔大小\n    handleChangeSize() {\n      const { progress } = this\n      this.curCanvasInstantiate.minWidth = MIN_WIDTH * progress / 100\n      this.curCanvasInstantiate.maxWidth = MAX_WIDTH * progress / 100\n    },\n\n    // 刷新对联\n    handleRefresh(rotate) {\n      this.duilian = duilianList[Math.floor(Math.random() * duilianList.length)]\n\n      if (rotate) {\n        if (this.mode === 2) {\n          this.refreshDuilian()\n        }\n        // 使icon旋转\n        this.isRotate = true\n        setTimeout(() => {\n          this.isRotate = false\n        }, 300)\n      }\n    },\n\n    // 播放背景音乐\n    handlePlay() {\n      const { bgm } = this.$refs\n      if (bgm.paused) {\n        bgm.play()\n        this.isPlay = true\n      } else {\n        bgm.pause()\n        this.isPlay = false\n      }\n    },\n\n    // 完成输入对联\n    handleSubmitInput(values) {\n      this.duilian = values\n      this.showInputBox = false\n      this.refreshDuilian()\n    },\n\n    // 完成挑选对联\n    handlePickDuilian(item) {\n      this.duilian = item\n      this.showPickBox = false\n      this.refreshDuilian()\n    }\n  },\n};\n<\/script>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n726\n727\n728\n729\n730\n731\n732\n733\n734\n735\n736\n737\n\n\n更多有趣的小网页欢迎关注公众号有趣研究社:\n\n> 手写春联\n> FC在线模拟器\n> 爱国头像生成器\n> 到账语音生成器',normalizedContent:'手写春联：https://cl.xugaoyi.com/\n\n\n# 前言\n\n虎年春节快到了，首先祝大家新年快乐，轻松暴富。 最近在网上经常看到生成春联的文章，不过这些小demo要么功能简陋,要么ui特别‘程序员’，满足不了我挑剔的眼光。干脆我自己做一个吧，顺便简单体验一下vite+vue3。（因为页面相对简单，vue组件风格还是使用选项式api，重点还是想把产品快速做出来。）\n\n\n\n\n# 产品构思\n\n包含手写春节和生成春联两大功能：\n\n * 手写春联\n   \n   * 模拟用笔写字的字迹\n   * 选择画笔颜色\n   * 调整画笔大小\n   * 清空画布\n   * 撤回笔画\n   * 切换上、下联、横批、福字\n   * 随机切换对联提示\n   * 预览图片和下载\n   * 贴春联海报和下载\n\n * 生成模式\n   \n   * 选择画笔颜色\n   * 挑选生成的对联\n   * 输入对联\n   * 随机切换对联\n   * 贴春联海报和下载\n\n * 其他\n   \n   * 快速切换模式按钮\n   * 可控制的背景音乐\n   * 微信分享网页\n\n\n# 设计\n\n\n\n\n# 开发\n\n * 技术栈\n   * vite (打包&构建)\n   * vue3 (页面开发)\n   * vant（ui）\n   * sass (css)\n   * smooth-signature.js (带笔锋手写库)\n\n<template>\n  <div class="wrap" :class="\'mode-\' + mode" @touchstart="handletouchstart">\n    \x3c!-- 切换模式按钮 --\x3e\n    <div class="toggle-mode-btn" @click="togglemode">\n      {{ mode === 1 ? \'手写\' : \'生成\' }}\n      <i class="iconfont icon-qiehuan"></i>\n    </div>\n\n    \x3c!-- 工具栏 --\x3e\n    <div\n      class="actions"\n      :style="{ bordertoprightradius: colorlistvisibility ? \'0\' : \'5px\' }"\n    >\n      \x3c!-- 手写模式显示 --\x3e\n      <template v-if="mode === 1">\n        \x3c!-- 调色板 --\x3e\n        <div class="palette btn-block">\n          <div\n            class="cur-color"\n            @click="togglepalette"\n            :style="{ background: colorlist[curcolorindex] }"\n          ></div>\n          <ul class="colorlist" v-show="colorlistvisibility">\n            <li\n              v-for="(item, index) in colorlist"\n              :key="item"\n              :style="{ background: item }"\n              @click="selectcolor(index)"\n            ></li>\n          </ul>\n        </div>\n\n        \x3c!-- 滑块 --\x3e\n        <div class="slider-box btn-block">\n          <van-slider\n            v-model="progress"\n            vertical\n            @change="changeprogress"\n            bar-height="28"\n            active-color="transparent"\n            :min="50"\n            :max="150"\n          >\n            <template #button>\n              <div class="custom-button"></div>\n            </template>\n          </van-slider>\n        </div>\n\n        \x3c!-- 清空 --\x3e\n        <div class="btn" @click="handleclear">\n          <i class="iconfont icon-lajitong"></i>\n        </div>\n\n        \x3c!-- 撤销 --\x3e\n        <div class="btn" @click="handleundo">\n          <i class="iconfont icon-fanhui"></i>\n        </div>\n\n        <div class="line"></div>\n\n        \x3c!-- 切换画布的按钮 --\x3e\n        <div\n          class="btn"\n          :class="{ \'cur-active\': curcanvasindex === index }"\n          v-for="(item, index) in canvaslist"\n          :key="item.name"\n          @click="changecanvas(index)"\n        >\n          {{ item.name }}\n        </div>\n\n        <div class="line"></div>\n\n        <div class="btn prominent" @click="handlepreview">预览</div>\n        <div class="btn prominent" @click="openposters">贴联</div>\n      </template>\n\n      \x3c!-- 生成模式显示 --\x3e\n      <template v-else>\n        \x3c!-- 选颜色 --\x3e\n        <div\n          class="color-list-quick"\n          :class="{ active: curcolorindex === index }"\n          v-for="(item, index) in colorlist"\n          :key="item"\n          :style="{ background: item }"\n          @click="selectcolor(index)"\n        ></div>\n        <div class="line"></div>\n        <div class="btn" @click="showpickbox = true">挑选</div>\n        <div class="btn" @click="showinputbox = true">输入</div>\n\n        \x3c!-- 挑选对联弹窗 --\x3e\n        <van-action-sheet v-model:show="showpickbox" title="请挑选对联">\n          <ul class="duilian-list">\n            <li\n              v-for="(item, index) in duilianlist"\n              :key="index"\n              @click="handlepickduilian(item)"\n            >\n              <span>{{ item.shang }}</span\n              >， <span>{{ item.xia }}</span\n              >。\n              <span>{{ item.heng }}</span>\n            </li>\n          </ul>\n        </van-action-sheet>\n\n        \x3c!-- 输入对联弹窗 --\x3e\n        <van-action-sheet v-model:show="showinputbox" title="请输入对联">\n          <van-form @submit="handlesubmitinput">\n            <van-cell-group inset>\n              <van-field\n                v-model="shanglian"\n                name="shang"\n                label="上联"\n                placeholder="上联"\n                :rules="[\n                  {\n                    required: true,\n                    message: \'请输入7位汉字上联\',\n                    pattern: /^[\\u4e00-\\u9fa5]{7}$/\n                  }\n                ]"\n                clearable\n              />\n              <van-field\n                v-model="xialian"\n                name="xia"\n                label="下联"\n                placeholder="下联"\n                :rules="[\n                  {\n                    required: true,\n                    message: \'请输入7位汉字下联\',\n                    pattern: /^[\\u4e00-\\u9fa5]{7}$/\n                  }\n                ]"\n                clearable\n              />\n              <van-field\n                v-model="hengpi"\n                name="heng"\n                label="横批"\n                placeholder="横批"\n                :rules="[\n                  {\n                    required: true,\n                    message: \'请输入4位汉字横批\',\n                    pattern: /^[\\u4e00-\\u9fa5]{4}$/\n                  }\n                ]"\n                clearable\n              />\n            </van-cell-group>\n            <div style="margin: 16px">\n              <van-button\n                round\n                block\n                type="primary"\n                native-type="submit"\n                color="linear-gradient(to right, #ff6034, #c33825)"\n              >\n                完成\n              </van-button>\n            </div>\n          </van-form>\n        </van-action-sheet>\n      </template>\n    </div>\n\n    \x3c!-- 模式1-春联画布 --\x3e\n    <div\n      v-show="mode === 1"\n      v-for="(item, index) in canvaslist"\n      :key="item.name"\n    >\n      <canvas\n        class="canvas"\n        :class="item.classname"\n        v-show="curcanvasindex === index"\n        :style="{\n          margintop:\n            item.height < clientheight\n              ? `${(clientheight - item.height) / 2}px`\n              : 0,\n          marginleft:\n            item.width < clientwidth ? `${(clientwidth - item.width) / 2}px` : 0\n        }"\n      />\n    </div>\n\n    \x3c!-- 模式2-春联画布 --\x3e\n    <div v-show="mode === 2" class="canvas-mode-2">\n      <div class="row">\n        <canvas id="canvas-top" :width="200 * scale" :height="60 * scale" />\n      </div>\n      <div class="row">\n        <canvas id="canvas-left" :width="60 * scale" :height="364 * scale" />\n        <canvas id="canvas-right" :width="60 * scale" :height="364 * scale" />\n      </div>\n    </div>\n\n    \x3c!-- 贴春联按钮 --\x3e\n    <button class="btn-posters" @click="openposters" />\n\n    \x3c!-- footer-当前对联提示 --\x3e\n    <footer v-if="duilian.shang">\n      <div class="refresh-btn" @click="handlerefresh(true)">\n        <i class="iconfont icon-shuaxin" :class="{ rotate: isrotate }"></i>\n      </div>\n      <dl class="duilian">\n        <dt>对联</dt>\n        <dd>\n          <div>{{ duilian.shang }}</div>\n          <div>{{ duilian.xia }}</div>\n        </dd>\n      </dl>\n      <dl>\n        <dt>横批</dt>\n        <dd>{{ duilian.heng }}</dd>\n      </dl>\n    </footer>\n\n    \x3c!-- 分享按钮 --\x3e\n    <div class="share-btn" v-if="isshowsharebtn" @click="isshowsharetip = true">\n      <i class="iconfont icon-fenxiang"></i>\n    </div>\n    \x3c!-- 微信分享提示语 --\x3e\n    <div\n      class="share-tip"\n      v-if="isshowsharetip"\n      @click="isshowsharetip = false"\n    >\n      点击右上角把这个工具分享给朋友\n      <div class="hand">👆</div>\n    </div>\n\n    \x3c!-- 保存tip --\x3e\n    <p v-if="isshowtip" class="download-tip">*长按图片保存或转发</p>\n\n    \x3c!-- 版权 --\x3e\n    <div class="copyright">公众号「有趣研究社」 ©版权所有</div>\n\n    \x3c!-- 载入图片元素，用于快速贴图使用, 注意设置crossorigin="anonymous"解决跨域 --\x3e\n    <div v-if="isreadimages">\n      <img\n        crossorigin="anonymous"\n        v-for="(item, index) in bglist"\n        :src="item"\n        :key="item"\n        class="hide-img"\n        :id="`bg-img-` + index"\n      />\n      <img\n        crossorigin="anonymous"\n        class="hide-img"\n        id="qrcode"\n        src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store2@master/img/qrcode.zul0pldsuao.png"\n      />\n    </div>\n\n    \x3c!-- 背景音乐 --\x3e\n    <audio\n      src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store2@master/cjxq.mp3"\n      id="bgm"\n      ref="bgm"\n      loop\n    />\n    <div\n      class="play-btn"\n      :class="{ paused: !isplay }"\n      ref="playbtn"\n      @click="handleplay"\n    >\n      <i class="iconfont icon-yinle"></i>\n    </div>\n  </div>\n\n  <div class="body-bg-img"></div>\n</template>\n\n<script>\nimport { imagepreview, notify } from \'vant\'\nimport { iswx, ismobile } from \'@/utils\'\nimport button from \'@/components/button.vue\'\nimport dl from \'@/assets/img/yh/dl.jpeg\'\nimport hp from \'@/assets/img/yh/hp.jpeg\'\nimport fz from \'@/assets/img/yh/fz.png\'\n\n// 对联数据\nimport duilianlist from \'@/mock/duilian\'\n\nconst proportion = 0.37 // 图片缩小比例\nconst instantiate_name = \'signature\' // 实例名称\nconst min_width = 3 // 画笔最小宽\nconst max_width = 12 // 画笔最大宽\n\n// 海报背景图大小\nconst bg_width = 750\nconst bg_height = 1448\n\n// 贴图定位和大小\nconst position = [\n  { left: 57, top: 510, width: 90, height: 546 }, // 上联\n  { left: 600, top: 510, width: 90, height: 546 }, // 下联\n  { left: 225, top: 345, width: 300, height: 90 }, // 横幅\n  { left: 460, top: 450, width: 130, height: 130 }, // 福字\n]\n\nexport default {\n  name: "home",\n  components: {\n    button\n  },\n  data() {\n    return {\n      duilianlist,\n      mode: number(localstorage.getitem(\'mode\')) || 1, // 1 手写，2 生成\n      curcanvasindex: 0, // 显示哪个画布\n      progress: 100, // 画笔大小的刻度\n      clientwidth: document.documentelement.clientwidth,\n      clientheight: document.documentelement.clientheight,\n      canvaslist: [\n        {\n          name: \'上联\',\n          classname: \'canvas-a\',\n          bgimage: dl,\n          width: 600 * proportion,\n          height: 3640 * proportion,\n        },\n        {\n          name: \'下联\',\n          classname: \'canvas-b\',\n          bgimage: dl,\n          width: 600 * proportion,\n          height: 3640 * proportion,\n        },\n        {\n          name: \'横批\',\n          classname: \'canvas-c\',\n          bgimage: hp,\n          width: 2000 * proportion,\n          height: 600 * proportion,\n        },\n        {\n          name: \'福字\',\n          classname: \'canvas-d\',\n          bgimage: fz,\n          width: 366,\n          height: 366,\n        }\n      ],\n      colorlist: [\'#000000\', \'#ffd800\', \'#e8bd48\', \'#ddc08c\',],\n      curcolorindex: 0,\n      colorlistvisibility: false, // 画布颜色选择列表可见性\n      isshowtip: false, // 是否显示底部提示语\n      duilian: {}, // 当前对联文本对象\n      isrotate: false, // 刷新icon旋转\n      bglist: [\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/1.4j8qpdnq80i0.jpeg\',\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/4.4460an8ag5o0.jpeg\',\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/5.3axtl4xpvy00.jpeg\',\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/6.2lnbphdqjaq0.jpeg\',\n      ],\n      isreadimages: false, // 延迟加载图片用\n      isshowsharebtn: false, // 是否显示分享按钮\n      isshowsharetip: false, // 是否显示分享提示语\n      isplay: false, // 是否在播放\n\n      // 模式2\n      canvastop: null, // 横批\n      canvasleft: null, // 上联\n      canvasright: null, // 下联\n      imgobj1: null, // 横批图片对象\n      imgobj2: null, // 上下联图片对象\n      scale: math.max(window.devicepixelratio || 1, 2), // 用于增加画布清晰度\n      showpickbox: false, // 挑选对联的弹框\n      showinputbox: false, // 输入对联的弹框\n      shanglian: \'\', // 输入的上联\n      xialian: \'\', // 输入的下联\n      hengpi: \'\', // 输入的横批\n    };\n  },\n  computed: {\n    // 模式1-当前画布实例\n    curcanvasinstantiate() {\n      return this[instantiate_name + this.curcanvasindex]\n    }\n  },\n  created() {\n    // 微信浏览器显示分享按钮\n    this.isshowsharebtn = iswx()\n  },\n  mounted() {\n    if (!ismobile()) {\n      notify({ type: \'warning\', message: \'请用移动端打开获得最佳体验\', duration: 6000, });\n    }\n\n    this.initmode1();\n\n    // 初始化对联提示\n    this.handlerefresh();\n\n    this.initmode2();\n\n    // 按钮添加激活时发光效果class\n    const btnel = document.queryselectorall(\'.btn,.btn-block\');\n    btnel.foreach((item) => {\n      item.addeventlistener(\'touchstart\', () => {\n        item.classlist.add(\'btn-active\')\n      })\n      item.addeventlistener(\'touchend\', () => {\n        settimeout(() => {\n          item.classlist.remove(\'btn-active\')\n        }, 100)\n      })\n    })\n\n    // 延迟加载贴图背景\n    settimeout(() => {\n      this.isreadimages = true\n    }, 1000)\n  },\n\n  watch: {\n    // 切换画笔颜色\n    curcolorindex() {\n      this.curcanvasinstantiate.color = this.colorlist[this.curcolorindex]\n      if (this.mode === 2) {\n        this.refreshduilian()\n      }\n    },\n    // 切换画布时应用当前画笔颜色和大小\n    curcanvasindex() {\n      this.curcanvasinstantiate.color = this.colorlist[this.curcolorindex]\n      this.handlechangesize()\n      window.scrollto(0, 0)\n    }\n  },\n\n  methods: {\n    initmode1() {\n      const { colorlist, curcolorindex } = this\n      this.canvaslist.foreach((item, index) => {\n        const options = {\n          width: item.width,\n          height: item.height,\n          minwidth: min_width, // 画笔最小宽度(px)\n          maxwidth: max_width, // 画笔最大宽度\n          minspeed: 1.8, // 画笔达到最小宽度所需最小速度(px/ms)，取值范围1.0-10.0\n          color: colorlist[curcolorindex],\n          // 新增的配置\n          bgimage: item.bgimage,\n        };\n\n        this[instantiate_name + index] = new smoothsignature(document.queryselector(\'.\' + item.classname), options);\n      })\n    },\n\n    initmode2() {\n      this.canvastop = document.getelementbyid(\'canvas-top\').getcontext(\'2d\')\n      this.canvasleft = document.getelementbyid(\'canvas-left\').getcontext(\'2d\')\n      this.canvasright = document.getelementbyid(\'canvas-right\').getcontext(\'2d\')\n\n      // 设字体样式\n      const font = "36px xs, cursive"\n      this.canvastop.font = font\n      this.canvasleft.font = font\n      this.canvasright.font = font\n\n      // 增强清晰度\n      const { scale } = this\n      this.canvastop.scale(scale, scale);\n      this.canvasleft.scale(scale, scale);\n      this.canvasright.scale(scale, scale);\n\n      // 设背景图\n      this.imgobj1 = new image()\n      this.imgobj2 = new image()\n      this.imgobj1.src = hp\n      this.imgobj2.src = dl\n      this.imgobj1.onload = () => {\n        // 贴背景\n        this.canvastop.drawimage(this.imgobj1, 0, 0, 200, 60)\n\n        // 字体加载完成后\n        document.fonts.ready.then(() => {\n          this.handletopfilltext()\n        });\n      }\n      this.imgobj2.onload = () => {\n        // 贴背景\n        this.canvasleft.drawimage(this.imgobj2, 0, 0, 60, 364)\n        this.canvasright.drawimage(this.imgobj2, 0, 0, 60, 364)\n\n        // 字体加载完成后\n        document.fonts.ready.then(() => {\n          this.handlelrfilltext(this.canvasleft, this.duilian.shang)\n          this.handlelrfilltext(this.canvasright, this.duilian.xia)\n        });\n      }\n    },\n\n    // 模式2-刷新对联\n    refreshduilian() {\n      this.canvastop.drawimage(this.imgobj1, 0, 0, 200, 60)\n      this.canvasleft.drawimage(this.imgobj2, 0, 0, 60, 364)\n      this.canvasright.drawimage(this.imgobj2, 0, 0, 60, 364)\n      this.handletopfilltext()\n      this.handlelrfilltext(this.canvasleft, this.duilian.shang)\n      this.handlelrfilltext(this.canvasright, this.duilian.xia)\n    },\n\n    // 模式2-贴横批\n    handletopfilltext() {\n      // 贴文本\n      this.canvastop.fillstyle = this.colorlist[this.curcolorindex]\n      if (this.duilian.heng) {\n        this.duilian.heng.split(\'\').foreach((item, index) => {\n          const left = 42 * (index + 1) - 22\n          this.canvastop.filltext(item, left, 40)\n        })\n      }\n    },\n\n    // 模式2-贴上下联\n    handlelrfilltext(ctx, text) {\n      ctx.fillstyle = this.colorlist[this.curcolorindex]\n      if (text) {\n        text.split(\'\').foreach((item, index) => {\n          const top = 50 * (index + 1) - 8\n          ctx.filltext(item, 13, top)\n        })\n      }\n    },\n\n    // 切换模式\n    togglemode() {\n      if (this.mode === 1) {\n        this.mode = 2\n        this.refreshduilian()\n      } else {\n        this.mode = 1\n      }\n      localstorage.setitem(\'mode\', this.mode);\n    },\n\n    // 打开调色板\n    togglepalette() {\n      this.colorlistvisibility = !this.colorlistvisibility\n    },\n\n    // 关闭调色板\n    handletouchstart(e) {\n      // 不是点击选择颜色时\n      if (e.path[1]?.classlist?.value !== \'colorlist\' && e.target.classlist?.value !== \'cur-color\') {\n        this.colorlistvisibility = false\n      }\n    },\n\n    // 选择颜色\n    selectcolor(index) {\n      this.curcolorindex = index\n      this.colorlistvisibility = false\n    },\n\n    // 切换画布\n    changecanvas(index) {\n      this.curcanvasindex = index\n    },\n\n    // 清空画布\n    handleclear() {\n      this.curcanvasinstantiate.clear();\n    },\n\n    // 撤销笔画\n    handleundo() {\n      this.curcanvasinstantiate.undo();\n    },\n\n    // 预览\n    handlepreview() {\n      this.showtoptip();\n      this.isshowtip = true\n      const _this = this\n      imagepreview({\n        images: this.getimagelist(),\n        closeable: true,\n        startposition: this.curcanvasindex,\n        onclose() {\n          _this.isshowtip = false\n        },\n      });\n    },\n\n    // 打开海报预览\n    openposters() {\n      // 创建画布\n      const canvas = document.createelement(\'canvas\');\n      canvas.width = bg_width\n      canvas.height = bg_height\n      const ctx = canvas.getcontext(\'2d\');\n      const resultimagelist = [];\n\n      // 是否隐藏福字\n      const ishidefu = this[instantiate_name + 3].isempty()\n      this.bglist.foreach((item, index) => {\n        // 贴背景图\n        ctx.drawimage(document.getelementbyid(\'bg-img-\' + index), 0, 0, bg_width, bg_height)\n\n        // 贴对联\n        if (this.mode === 1) {\n          this.canvaslist.foreach((item, index) => {\n            if (index === 3 && ishidefu) return;\n            const dlcanvas = document.queryselector(\'.\' + item.classname)\n            const { left, top, width, height } = position[index]\n            ctx.drawimage(dlcanvas, left, top, width, height)\n          })\n        } else {\n          [\'canvas-left\', \'canvas-right\', \'canvas-top\'].foreach((item, index) => {\n            const dlcanvas = document.getelementbyid(item)\n            const { left, top, width, height } = position[index]\n            ctx.drawimage(dlcanvas, left, top, width, height)\n          })\n        }\n\n        // 贴二维码\n        ctx.drawimage(document.getelementbyid("qrcode"), 40, 1280, 580, 136)\n\n        // 贴文本\n        ctx.font = "18px sans-serif"\n        ctx.fillstyle = "#666666"\n        ctx.filltext(\'©公众号「有趣研究社」\', 550, 1420)\n\n        // 导出图片\n        resultimagelist.push(canvas.todataurl(\'image/jpeg\', 0.8))\n      })\n\n      // 打开图片预览\n      this.isshowtip = true\n      const _this = this\n      imagepreview({\n        images: resultimagelist,\n        closeable: true,\n        onclose() {\n          _this.isshowtip = false\n        },\n      });\n      this.showtoptip();\n    },\n\n    // 弹出顶部提示语\n    showtoptip() {\n      if (!sessionstorage.getitem(\'showtip\')) {\n        sessionstorage.setitem(\'showtip\', \'true\');\n        notify({\n          message: \'长按图片可保存到本地\',\n          color: \'#c33825\',\n          background: \'#eed3ae\',\n        });\n      }\n    },\n\n    // 获取对联图片列表\n    getimagelist(type = \'image/png\') {\n      const imagelist = []\n      this.canvaslist.foreach((item, index) => {\n        if (index === 3) {\n          // `福`字必须是png格式\n          type = \'image/png\'\n        }\n        imagelist.push(this[instantiate_name + index].todataurl(type, 0.8))\n      })\n      return imagelist\n    },\n\n    // 进度改变时\n    changeprogress(progress) {\n      this.progress = progress\n      this.handlechangesize()\n    },\n\n    // 调整画笔大小\n    handlechangesize() {\n      const { progress } = this\n      this.curcanvasinstantiate.minwidth = min_width * progress / 100\n      this.curcanvasinstantiate.maxwidth = max_width * progress / 100\n    },\n\n    // 刷新对联\n    handlerefresh(rotate) {\n      this.duilian = duilianlist[math.floor(math.random() * duilianlist.length)]\n\n      if (rotate) {\n        if (this.mode === 2) {\n          this.refreshduilian()\n        }\n        // 使icon旋转\n        this.isrotate = true\n        settimeout(() => {\n          this.isrotate = false\n        }, 300)\n      }\n    },\n\n    // 播放背景音乐\n    handleplay() {\n      const { bgm } = this.$refs\n      if (bgm.paused) {\n        bgm.play()\n        this.isplay = true\n      } else {\n        bgm.pause()\n        this.isplay = false\n      }\n    },\n\n    // 完成输入对联\n    handlesubmitinput(values) {\n      this.duilian = values\n      this.showinputbox = false\n      this.refreshduilian()\n    },\n\n    // 完成挑选对联\n    handlepickduilian(item) {\n      this.duilian = item\n      this.showpickbox = false\n      this.refreshduilian()\n    }\n  },\n};\n<\/script>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n726\n727\n728\n729\n730\n731\n732\n733\n734\n735\n736\n737\n\n\n更多有趣的小网页欢迎关注公众号有趣研究社:\n\n> 手写春联\n> fc在线模拟器\n> 爱国头像生成器\n> 到账语音生成器',charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"拥抱生活，拥抱快乐",frontmatter:{title:"拥抱生活，拥抱快乐",date:"2020-06-26T20:40:38.000Z",permalink:"/pages/cd8bde/",sidebar:"auto",categories:["随笔"],tags:["鸡汤"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E6%8B%A5%E6%8A%B1%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%8B%A5%E6%8A%B1%E5%BF%AB%E4%B9%90.html",relativePath:"_posts/随笔/拥抱生活，拥抱快乐.md",key:"v-ccd252e8",path:"/pages/cd8bde/",excerpt:"<p>生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。</p>\n",headersStr:null,content:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n\n不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n\n所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n\n如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n\n所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n\n\n\n> 文章摘录自:B站视频《罗翔说刑法》，链接https://b23.tv/K8ulrE",normalizedContent:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n\n不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n\n所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n\n如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n\n所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n\n\n\n> 文章摘录自:b站视频《罗翔说刑法》，链接https://b23.tv/k8ulre",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"Home",frontmatter:{home:!0,heroText:"文殊院馆藏",tagline:"休对故人思故国，且将新火试新茶。诗酒趁年华"},regularPath:"/",relativePath:"index.md",key:"v-2c233f33",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"ES6-11",frontmatter:{title:"ES6-11",date:"2022-04-10T20:07:34.000Z",permalink:"/pages/2431b2/",categories:["《JavaScript初学》","JavaScript"],tags:["JavaScript"],author:{name:"年华惊风雨",link:"https://github.com/wsy425"}},regularPath:"/%E3%80%8AJavaScript%E3%80%8B/01.%E3%80%8AJavaScript%E5%88%9D%E5%AD%A6%E3%80%8B/05.%20ES6-11.html",relativePath:"《JavaScript》/01.《JavaScript初学》/05. ES6-11.md",key:"v-547c61b3",path:"/pages/2431b2/",headers:[{level:2,title:"1 ES6",slug:"_1-es6",normalizedTitle:"1 es6",charIndex:2},{level:3,title:"1.1 let关键字",slug:"_1-1-let关键字",normalizedTitle:"1.1 let关键字",charIndex:12},{level:3,title:"1.2 const关键字",slug:"_1-2-const关键字",normalizedTitle:"1.2 const关键字",charIndex:103},{level:3,title:"1.3 变量解构赋值",slug:"_1-3-变量解构赋值",normalizedTitle:"1.3 变量解构赋值",charIndex:235},{level:3,title:"1.4 模板字符串",slug:"_1-4-模板字符串",normalizedTitle:"1.4 模板字符串",charIndex:490},{level:3,title:"1.5 简化对象",slug:"_1-5-简化对象",normalizedTitle:"1.5 简化对象",charIndex:588},{level:3,title:"1.6 箭头函数",slug:"_1-6-箭头函数",normalizedTitle:"1.6 箭头函数",charIndex:837},{level:3,title:"1.7 函数参数默认值",slug:"_1-7-函数参数默认值",normalizedTitle:"1.7 函数参数默认值",charIndex:1180},{level:3,title:"1.8 rest参数",slug:"_1-8-rest参数",normalizedTitle:"1.8 rest参数",charIndex:1450},{level:3,title:"1.9 扩展运算符",slug:"_1-9-扩展运算符",normalizedTitle:"1.9 扩展运算符",charIndex:1702},{level:3,title:"1.10 Symbol数据类型",slug:"_1-10-symbol数据类型",normalizedTitle:"1.10 symbol数据类型",charIndex:1919},{level:3,title:"1.11 迭代器",slug:"_1-11-迭代器",normalizedTitle:"1.11 迭代器",charIndex:3044},{level:4,title:"1.11.1 for of使用",slug:"_1-11-1-for-of使用",normalizedTitle:"1.11.1 for of使用",charIndex:3221},{level:4,title:"1.11.2 工作原理",slug:"_1-11-2-工作原理",normalizedTitle:"1.11.2 工作原理",charIndex:3340}],headersStr:"1 ES6 1.1 let关键字 1.2 const关键字 1.3 变量解构赋值 1.4 模板字符串 1.5 简化对象 1.6 箭头函数 1.7 函数参数默认值 1.8 rest参数 1.9 扩展运算符 1.10 Symbol数据类型 1.11 迭代器 1.11.1 for of使用 1.11.2 工作原理",content:"# 1 ES6\n\n\n# 1.1 let关键字\n\n 1. 语法let 变量名\n 2. 变量不能重复声明\n 3. 块级作用域，声明的变量只在代码块里有用\n 4. 不存在变量提升\n 5. 不影响作用域链\n\n\n# 1.2 const关键字\n\n 1. 声明值不能修改的量\n 2. 语法const 变量名=初始值\n 3. 声明时必须赋初始值\n 4. 一般常量使用大写\n 5. 常量值不能修改\n 6. 块级作用域\n 7. 对于数组和对象的元素修改，不算对常量的修改，不会报错\n\n\n# 1.3 变量解构赋值\n\n 1. 允许按照一定模式从数组和对象中提取值，对变量进行赋值\n 2. 数组解构let [zero,one,two.three] = [0,1,2,3]\n 3. 对象解构\n\nconst sample ={\n    name:'sample',\n    age:15,\n    log:function(){\n        console.log('234445')\n    }\n};\nlet {name,age,log}= sample;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 1.4 模板字符串\n\n 1. 新的声明字符串的方式 let str = 字符串\n 2. 内容里可以直接出现换行符\n 3. 可以直接进行变量拼接 let out = ${str}其他字符串\n\n\n# 1.5 简化对象\n\n 1. ES6允许在大括号里直接写入变量和函数，作为对象的属性和方法\n 2. 语法\n\nlet name = '学校'\nlet change = function(){\n    console.log(111111)\n}\nconst school = {\n    name,\n    change,\n    improve(){\n        console.log(\"简化对象里声明函数的语法\")\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 1.6 箭头函数\n\n 1. ES6允许使用箭头定义函数\n 2. 语法let fn = (形参) => {代码体}\n 3. 箭头函数this是静态的，this始终指向函数声明时所在作用域下的this值，不可被改变\n 4. 可以使用call方法调用，但箭头函数this不能被改变\n 5. 箭头函数不能作为构造实例化对象\n 6. 不能使用arguments变量\n 7. 箭头函数简写\n    * 省略小括号，当形参有且只有一个式可以省略 let fn = n =>{return n+n}\n    * 省略花括号，当代码体只有一条语句 let fn =(n) => n*n\n 8. 箭头函数适合与this无关的回调\n 9. 箭头函数不适合与this有关的回调，比如事件回调，对象方法\n\n\n# 1.7 函数参数默认值\n\n 1. 形参初始值，具有默认值的参数一般位置要靠后function add(a,b,c=10){}，放在前面会导致后面的没有默认值的形参在实参个数<形参个数的时候接收不到实参\n 2. 与解构赋值结合\n\nfunction connect({host=\"localhost\",username,password,port}){\n\n}\nconnect({\n    username:'root',\n    password:'root',\n    port:3306\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 1.8 rest参数\n\n 1. ES5中获取实参通过arguments，返回的是对象\n 2. ES6中使用rest参数，需要写形参，返回的是数组\n\nfunction date5(){\n    console.log(arguments)\n}\ndate5('1','2','3')\nfunction date6(...args){\n    console.log(args)\n}\ndate6('1','2','3')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 3. rest参数必须要放在形参的最后\n\n\n# 1.9 扩展运算符\n\n 1. ...扩展运算符能将数组转换为逗号分割的参数序列\n 2. 运用于数组的合并\n 3. 运用于数组的克隆，拷贝的内容有引用数据的话是浅拷贝\n 4. 将伪数组转为真正的数组\n\nconst front = ['1','2']\nconst end = ['3','4']\nconst total = [...front,...end]\nconst copy = [...total]\n\n\n1\n2\n3\n4\n\n\n\n# 1.10 Symbol数据类型\n\n 1. ES6引入了一种新的原始数据类型Symbol，来表示独一无二的值\n 2. 特点\n    1. Symbol的值是唯一的，用来解决命名冲突的问题\n    2. Symbol值不能与其他数据进行运算\n    3. Symbol定义的对象属性不能使用for...in循环遍历，但可以使用Reflect.ownKeys来获取对象的所有键名\n 3. 创建Symbol\n\nlet s = Symbol()\nlet s2 = Symbol('123')\nlet s3 = Symbol('123')\n//s2 != s3\nlet s4 = Symbol.for('123')\nlet s5 = Symbol.for('123')\n//s4 === s5\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 4. 运用向对象添加方法，安全且快速，不会破坏原有属性\n\nlet game = {\n    //此处省略很多，不确定是否有想要添加的同名方法\n    [Symbol('up')]: function(){\n        console.log(11)\n    }\n}\nlet methods = {\n    up: Symbol(),\n    down:Symbol()\n}\ngame[methods.up] = function(){}\ngame[methods.down] = function(){}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n 5. Symbol内置值：控制对象在特定场景下的属性\n\n//hasInstance\nclass Person{\n    static [Symbol.hasInstance](param){\n        console.log(param); //输出o的内容：{}\n        return true;\n    }\n}\nlet o = {};\nconsole.log(o instanceof Person); //输出前面你return的内容：true\n\n//isConcatSpreadable\nconst arr = [1,2,3]\nconst arr2 = [4,5,6]\nconsole.log(arr.concat(arr2)) //输出[1,2,3,4,5,6]\narr2[Symbol.isConcatSpreadable] = false\nconsole.log(arr.concat(arr2)) //输出[1,2,3,[4,5,6]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 1.11 迭代器\n\n 1. 迭代器（Iterator）是一种接口，任何数据结构只要部署Iterator接口就可以完成遍历操作\n 2. for of 循环，Iterator接口主要供for of消费\n 3. 原生具备Iterator接口的数据结构：Array、Arguments、Set、Map、String、TypedArray、NodeList\n\n# 1.11.1 for of使用\n\nconst arr = ['一号','三号','二号']\nfor(let v of arr){\n    console.log(v) //输出'一号' '三号' '二号'\n}\n\n\n1\n2\n3\n4\n\n\n# 1.11.2 工作原理\n\n 1. 创建一个指针对象，指向当前数据结构的起始位置；\n 2. 第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员；\n 3. 接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员；\n 4. 每调用 next 方法返回一个包含 value 和 done 属性的对象；",normalizedContent:"# 1 es6\n\n\n# 1.1 let关键字\n\n 1. 语法let 变量名\n 2. 变量不能重复声明\n 3. 块级作用域，声明的变量只在代码块里有用\n 4. 不存在变量提升\n 5. 不影响作用域链\n\n\n# 1.2 const关键字\n\n 1. 声明值不能修改的量\n 2. 语法const 变量名=初始值\n 3. 声明时必须赋初始值\n 4. 一般常量使用大写\n 5. 常量值不能修改\n 6. 块级作用域\n 7. 对于数组和对象的元素修改，不算对常量的修改，不会报错\n\n\n# 1.3 变量解构赋值\n\n 1. 允许按照一定模式从数组和对象中提取值，对变量进行赋值\n 2. 数组解构let [zero,one,two.three] = [0,1,2,3]\n 3. 对象解构\n\nconst sample ={\n    name:'sample',\n    age:15,\n    log:function(){\n        console.log('234445')\n    }\n};\nlet {name,age,log}= sample;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 1.4 模板字符串\n\n 1. 新的声明字符串的方式 let str = 字符串\n 2. 内容里可以直接出现换行符\n 3. 可以直接进行变量拼接 let out = ${str}其他字符串\n\n\n# 1.5 简化对象\n\n 1. es6允许在大括号里直接写入变量和函数，作为对象的属性和方法\n 2. 语法\n\nlet name = '学校'\nlet change = function(){\n    console.log(111111)\n}\nconst school = {\n    name,\n    change,\n    improve(){\n        console.log(\"简化对象里声明函数的语法\")\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 1.6 箭头函数\n\n 1. es6允许使用箭头定义函数\n 2. 语法let fn = (形参) => {代码体}\n 3. 箭头函数this是静态的，this始终指向函数声明时所在作用域下的this值，不可被改变\n 4. 可以使用call方法调用，但箭头函数this不能被改变\n 5. 箭头函数不能作为构造实例化对象\n 6. 不能使用arguments变量\n 7. 箭头函数简写\n    * 省略小括号，当形参有且只有一个式可以省略 let fn = n =>{return n+n}\n    * 省略花括号，当代码体只有一条语句 let fn =(n) => n*n\n 8. 箭头函数适合与this无关的回调\n 9. 箭头函数不适合与this有关的回调，比如事件回调，对象方法\n\n\n# 1.7 函数参数默认值\n\n 1. 形参初始值，具有默认值的参数一般位置要靠后function add(a,b,c=10){}，放在前面会导致后面的没有默认值的形参在实参个数<形参个数的时候接收不到实参\n 2. 与解构赋值结合\n\nfunction connect({host=\"localhost\",username,password,port}){\n\n}\nconnect({\n    username:'root',\n    password:'root',\n    port:3306\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 1.8 rest参数\n\n 1. es5中获取实参通过arguments，返回的是对象\n 2. es6中使用rest参数，需要写形参，返回的是数组\n\nfunction date5(){\n    console.log(arguments)\n}\ndate5('1','2','3')\nfunction date6(...args){\n    console.log(args)\n}\ndate6('1','2','3')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 3. rest参数必须要放在形参的最后\n\n\n# 1.9 扩展运算符\n\n 1. ...扩展运算符能将数组转换为逗号分割的参数序列\n 2. 运用于数组的合并\n 3. 运用于数组的克隆，拷贝的内容有引用数据的话是浅拷贝\n 4. 将伪数组转为真正的数组\n\nconst front = ['1','2']\nconst end = ['3','4']\nconst total = [...front,...end]\nconst copy = [...total]\n\n\n1\n2\n3\n4\n\n\n\n# 1.10 symbol数据类型\n\n 1. es6引入了一种新的原始数据类型symbol，来表示独一无二的值\n 2. 特点\n    1. symbol的值是唯一的，用来解决命名冲突的问题\n    2. symbol值不能与其他数据进行运算\n    3. symbol定义的对象属性不能使用for...in循环遍历，但可以使用reflect.ownkeys来获取对象的所有键名\n 3. 创建symbol\n\nlet s = symbol()\nlet s2 = symbol('123')\nlet s3 = symbol('123')\n//s2 != s3\nlet s4 = symbol.for('123')\nlet s5 = symbol.for('123')\n//s4 === s5\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 4. 运用向对象添加方法，安全且快速，不会破坏原有属性\n\nlet game = {\n    //此处省略很多，不确定是否有想要添加的同名方法\n    [symbol('up')]: function(){\n        console.log(11)\n    }\n}\nlet methods = {\n    up: symbol(),\n    down:symbol()\n}\ngame[methods.up] = function(){}\ngame[methods.down] = function(){}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n 5. symbol内置值：控制对象在特定场景下的属性\n\n//hasinstance\nclass person{\n    static [symbol.hasinstance](param){\n        console.log(param); //输出o的内容：{}\n        return true;\n    }\n}\nlet o = {};\nconsole.log(o instanceof person); //输出前面你return的内容：true\n\n//isconcatspreadable\nconst arr = [1,2,3]\nconst arr2 = [4,5,6]\nconsole.log(arr.concat(arr2)) //输出[1,2,3,4,5,6]\narr2[symbol.isconcatspreadable] = false\nconsole.log(arr.concat(arr2)) //输出[1,2,3,[4,5,6]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 1.11 迭代器\n\n 1. 迭代器（iterator）是一种接口，任何数据结构只要部署iterator接口就可以完成遍历操作\n 2. for of 循环，iterator接口主要供for of消费\n 3. 原生具备iterator接口的数据结构：array、arguments、set、map、string、typedarray、nodelist\n\n# 1.11.1 for of使用\n\nconst arr = ['一号','三号','二号']\nfor(let v of arr){\n    console.log(v) //输出'一号' '三号' '二号'\n}\n\n\n1\n2\n3\n4\n\n\n# 1.11.2 工作原理\n\n 1. 创建一个指针对象，指向当前数据结构的起始位置；\n 2. 第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员；\n 3. 接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员；\n 4. 每调用 next 方法返回一个包含 value 和 done 属性的对象；",charsets:{cjk:!0}},{title:"JS基础",frontmatter:{title:"JS基础",date:"2022-04-10T20:07:17.000Z",permalink:"/pages/618466/",categories:["《JavaScript初学》","JavaScript"],tags:["JavaScript"],author:{name:"年华惊风雨",link:"https://github.com/wsy425"}},regularPath:"/%E3%80%8AJavaScript%E3%80%8B/01.%E3%80%8AJavaScript%E5%88%9D%E5%AD%A6%E3%80%8B/00.%20JS%E5%9F%BA%E7%A1%80.html",relativePath:"《JavaScript》/01.《JavaScript初学》/00. JS基础.md",key:"v-40e59601",path:"/pages/618466/",headers:[{level:2,title:"1 JS认知",slug:"_1-js认知",normalizedTitle:"1 js认知",charIndex:2},{level:3,title:"1.1 JS组成",slug:"_1-1-js组成",normalizedTitle:"1.1 js组成",charIndex:13},{level:3,title:"1.2 JS书写位置",slug:"_1-2-js书写位置",normalizedTitle:"1.2 js书写位置",charIndex:80},{level:3,title:"1.3 JS注释",slug:"_1-3-js注释",normalizedTitle:"1.3 js注释",charIndex:237},{level:2,title:"2 输入输出语句",slug:"_2-输入输出语句",normalizedTitle:"2 输入输出语句",charIndex:303},{level:3,title:"2.1 alert",slug:"_2-1-alert",normalizedTitle:"2.1 alert",charIndex:316},{level:3,title:"2.2 console",slug:"_2-2-console",normalizedTitle:"2.2 console",charIndex:365},{level:3,title:"2.3 dir",slug:"_2-3-dir",normalizedTitle:"2.3 dir",charIndex:426},{level:3,title:"2.4 prompt",slug:"_2-4-prompt",normalizedTitle:"2.4 prompt",charIndex:481},{level:2,title:"3 变量",slug:"_3-变量",normalizedTitle:"3 变量",charIndex:553},{level:3,title:"3.1 变量的使用",slug:"_3-1-变量的使用",normalizedTitle:"3.1 变量的使用",charIndex:584},{level:4,title:"3.1.1 变量声明",slug:"_3-1-1-变量声明",normalizedTitle:"3.1.1 变量声明",charIndex:597},{level:4,title:"3.1.2 变量赋值",slug:"_3-1-2-变量赋值",normalizedTitle:"3.1.2 变量赋值",charIndex:672},{level:4,title:"3.1.3 变量初始化",slug:"_3-1-3-变量初始化",normalizedTitle:"3.1.3 变量初始化",charIndex:700},{level:4,title:"3.1.4 同时声明",slug:"_3-1-4-同时声明",normalizedTitle:"3.1.4 同时声明",charIndex:733},{level:4,title:"3.1.5 可以不声明直接使用",slug:"_3-1-5-可以不声明直接使用",normalizedTitle:"3.1.5 可以不声明直接使用",charIndex:782},{level:3,title:"3.2 变量命名规范",slug:"_3-2-变量命名规范",normalizedTitle:"3.2 变量命名规范",charIndex:817},{level:3,title:"3.3 检测数据类型",slug:"_3-3-检测数据类型",normalizedTitle:"3.3 检测数据类型",charIndex:892},{level:2,title:"4 数字型Number",slug:"_4-数字型number",normalizedTitle:"4 数字型number",charIndex:921},{level:3,title:"4.1 整型",slug:"_4-1-整型",normalizedTitle:"4.1 整型",charIndex:961},{level:3,title:"4.2 浮点型",slug:"_4-2-浮点型",normalizedTitle:"4.2 浮点型",charIndex:972},{level:3,title:"4.3 数字型进制",slug:"_4-3-数字型进制",normalizedTitle:"4.3 数字型进制",charIndex:984},{level:3,title:"4.4 数字范围",slug:"_4-4-数字范围",normalizedTitle:"4.4 数字范围",charIndex:1029},{level:3,title:"4.5 特殊值",slug:"_4-5-特殊值",normalizedTitle:"4.5 特殊值",charIndex:1074},{level:3,title:"4.6 数字判断",slug:"_4-6-数字判断",normalizedTitle:"4.6 数字判断",charIndex:1134},{level:3,title:"4.7 其他类型转换成数字型",slug:"_4-7-其他类型转换成数字型",normalizedTitle:"4.7 其他类型转换成数字型",charIndex:1168},{level:2,title:"5 字符串型String",slug:"_5-字符串型string",normalizedTitle:"5 字符串型string",charIndex:1357},{level:3,title:"5.1 字符串嵌套",slug:"_5-1-字符串嵌套",normalizedTitle:"5.1 字符串嵌套",charIndex:1383},{level:3,title:"5.2 字符串转义符",slug:"_5-2-字符串转义符",normalizedTitle:"5.2 字符串转义符",charIndex:1411},{level:3,title:"5.3 字符串的拼接",slug:"_5-3-字符串的拼接",normalizedTitle:"5.3 字符串的拼接",charIndex:1457},{level:3,title:"5.4 字符串常用方法",slug:"_5-4-字符串常用方法",normalizedTitle:"5.4 字符串常用方法",charIndex:1538},{level:3,title:"5.5 其他类型转换成字符串",slug:"_5-5-其他类型转换成字符串",normalizedTitle:"5.5 其他类型转换成字符串",charIndex:1744},{level:3,title:"5.6 字符串的不可变",slug:"_5-6-字符串的不可变",normalizedTitle:"5.6 字符串的不可变",charIndex:1812},{level:3,title:"5.7 ES5新增字符串方法",slug:"_5-7-es5新增字符串方法",normalizedTitle:"5.7 es5新增字符串方法",charIndex:1902},{level:4,title:"5.7.1 trim()",slug:"_5-7-1-trim",normalizedTitle:"5.7.1 trim()",charIndex:1920},{level:2,title:"6 布尔型Boolean",slug:"_6-布尔型boolean",normalizedTitle:"6 布尔型boolean",charIndex:1999},{level:3,title:"6.1 其他类型转换成布尔型",slug:"_6-1-其他类型转换成布尔型",normalizedTitle:"6.1 其他类型转换成布尔型",charIndex:2048},{level:2,title:"7 运算符",slug:"_7-运算符",normalizedTitle:"7 运算符",charIndex:2137},{level:3,title:"7.1 算数运算符",slug:"_7-1-算数运算符",normalizedTitle:"7.1 算数运算符",charIndex:2191},{level:3,title:"7.2 递增递减运算符",slug:"_7-2-递增递减运算符",normalizedTitle:"7.2 递增递减运算符",charIndex:2253},{level:3,title:"7.3 比较运算符",slug:"_7-3-比较运算符",normalizedTitle:"7.3 比较运算符",charIndex:2479},{level:3,title:"7.4 逻辑运算符",slug:"_7-4-逻辑运算符",normalizedTitle:"7.4 逻辑运算符",charIndex:2609},{level:4,title:"7.4.1 &&断路",slug:"_7-4-1-断路",normalizedTitle:"7.4.1 &amp;&amp;断路",charIndex:null},{level:4,title:"7.4.2 ||断路",slug:"_7-4-2-断路",normalizedTitle:"7.4.2 ||断路",charIndex:2733},{level:3,title:"7.5 赋值运算符",slug:"_7-5-赋值运算符",normalizedTitle:"7.5 赋值运算符",charIndex:2800},{level:3,title:"7.6 运算符优先级",slug:"_7-6-运算符优先级",normalizedTitle:"7.6 运算符优先级",charIndex:2816},{level:2,title:"8 流程控制",slug:"_8-流程控制",normalizedTitle:"8 流程控制",charIndex:2833},{level:3,title:"8.1 顺序流程控制",slug:"_8-1-顺序流程控制",normalizedTitle:"8.1 顺序流程控制",charIndex:2844},{level:3,title:"8.2 分支流程控制",slug:"_8-2-分支流程控制",normalizedTitle:"8.2 分支流程控制",charIndex:2866},{level:4,title:"8.2.1 if",slug:"_8-2-1-if",normalizedTitle:"8.2.1 if",charIndex:2880},{level:4,title:"8.2.2 if-else双分支",slug:"_8-2-2-if-else双分支",normalizedTitle:"8.2.2 if-else双分支",charIndex:2942},{level:4,title:"8.2.3 多分支语句",slug:"_8-2-3-多分支语句",normalizedTitle:"8.2.3 多分支语句",charIndex:3062},{level:4,title:"8.2.4 三元表达式",slug:"_8-2-4-三元表达式",normalizedTitle:"8.2.4 三元表达式",charIndex:3206},{level:4,title:"8.2.5 switch",slug:"_8-2-5-switch",normalizedTitle:"8.2.5 switch",charIndex:3299},{level:3,title:"8.3 循环流程控制",slug:"_8-3-循环流程控制",normalizedTitle:"8.3 循环流程控制",charIndex:3591},{level:4,title:"8.3.1 for循环",slug:"_8-3-1-for循环",normalizedTitle:"8.3.1 for循环",charIndex:3605},{level:4,title:"8.3.2 while循环",slug:"_8-3-2-while循环",normalizedTitle:"8.3.2 while循环",charIndex:3676},{level:4,title:"8.3.3 do-while循环",slug:"_8-3-3-do-while循环",normalizedTitle:"8.3.3 do-while循环",charIndex:3739},{level:4,title:"8.3.4 continue",slug:"_8-3-4-continue",normalizedTitle:"8.3.4 continue",charIndex:3824},{level:3,title:"8.4 break",slug:"_8-4-break",normalizedTitle:"8.4 break",charIndex:3865},{level:2,title:"9 数组Array",slug:"_9-数组array",normalizedTitle:"9 数组array",charIndex:3893},{level:3,title:"9.1 创建数组",slug:"_9-1-创建数组",normalizedTitle:"9.1 创建数组",charIndex:3907},{level:4,title:"9.1.1  new关键字创建数组",slug:"_9-1-1-new关键字创建数组",normalizedTitle:"9.1.1  new关键字创建数组",charIndex:null},{level:4,title:"9.1.2 利用数组字面量创建数组",slug:"_9-1-2-利用数组字面量创建数组",normalizedTitle:"9.1.2 利用数组字面量创建数组",charIndex:4067},{level:3,title:"9.2 数组索引",slug:"_9-2-数组索引",normalizedTitle:"9.2 数组索引",charIndex:4155},{level:3,title:"9.3 数组长度",slug:"_9-3-数组长度",normalizedTitle:"9.3 数组长度",charIndex:4247},{level:3,title:"9.4 数组新增元素",slug:"_9-4-数组新增元素",normalizedTitle:"9.4 数组新增元素",charIndex:4272},{level:4,title:"9.4.1 修改length长度",slug:"_9-4-1-修改length长度",normalizedTitle:"9.4.1 修改length长度",charIndex:4286},{level:4,title:"9.4.2 增加索引号",slug:"_9-4-2-增加索引号",normalizedTitle:"9.4.2 增加索引号",charIndex:4327},{level:3,title:"9.5 检测是否为数组",slug:"_9-5-检测是否为数组",normalizedTitle:"9.5 检测是否为数组",charIndex:4364},{level:4,title:"9.5.1 instanceof 运算符",slug:"_9-5-1-instanceof-运算符",normalizedTitle:"9.5.1 instanceof 运算符",charIndex:4379},{level:4,title:"9.5.2 .isArray()",slug:"_9-5-2-isarray",normalizedTitle:"9.5.2 .isarray()",charIndex:4433},{level:3,title:"9.6 添加数组元素",slug:"_9-6-添加数组元素",normalizedTitle:"9.6 添加数组元素",charIndex:4497},{level:4,title:"9.6.1 .push()",slug:"_9-6-1-push",normalizedTitle:"9.6.1 .push()",charIndex:4511},{level:4,title:"9.6.2 .unshift()",slug:"_9-6-2-unshift",normalizedTitle:"9.6.2 .unshift()",charIndex:4604},{level:3,title:"9.7 删除数组元素",slug:"_9-7-删除数组元素",normalizedTitle:"9.7 删除数组元素",charIndex:4707},{level:4,title:"9.7.1 .pop()",slug:"_9-7-1-pop",normalizedTitle:"9.7.1 .pop()",charIndex:4721},{level:4,title:"9.7.2 .shift()",slug:"_9-7-2-shift",normalizedTitle:"9.7.2 .shift()",charIndex:4812},{level:3,title:"9.8 数组排序",slug:"_9-8-数组排序",normalizedTitle:"9.8 数组排序",charIndex:4911},{level:4,title:"9.8.1 .reverse()",slug:"_9-8-1-reverse",normalizedTitle:"9.8.1 .reverse()",charIndex:4923},{level:4,title:"9.8.2 .sort()",slug:"_9-8-2-sort",normalizedTitle:"9.8.2 .sort()",charIndex:4972},{level:3,title:"9.9 数组索引",slug:"_9-9-数组索引",normalizedTitle:"9.9 数组索引",charIndex:5160},{level:4,title:"9.9.1 .indexOf()",slug:"_9-9-1-indexof",normalizedTitle:"9.9.1 .indexof()",charIndex:5172},{level:4,title:"9.9.2 .lastIndexOf()",slug:"_9-9-2-lastindexof",normalizedTitle:"9.9.2 .lastindexof()",charIndex:5255},{level:3,title:"9.10 数组转换成字符串",slug:"_9-10-数组转换成字符串",normalizedTitle:"9.10 数组转换成字符串",charIndex:5344},{level:4,title:"9.10.1 toString()",slug:"_9-10-1-tostring",normalizedTitle:"9.10.1 tostring()",charIndex:5361},{level:3,title:"9.10.2 join('分隔符')",slug:"_9-10-2-join-分隔符",normalizedTitle:"9.10.2 join('分隔符')",charIndex:5406},{level:3,title:"9.11 数组切割",slug:"_9-11-数组切割",normalizedTitle:"9.11 数组切割",charIndex:5465},{level:4,title:"9.11.1 .concat()",slug:"_9-11-1-concat",normalizedTitle:"9.11.1 .concat()",charIndex:5478},{level:4,title:"9.11.2 .slice()",slug:"_9-11-2-slice",normalizedTitle:"9.11.2 .slice()",charIndex:5534},{level:4,title:"9.11.3 .splice()",slug:"_9-11-3-splice",normalizedTitle:"9.11.3 .splice()",charIndex:5600},{level:3,title:"9.12 ES5数组新增方法",slug:"_9-12-es5数组新增方法",normalizedTitle:"9.12 es5数组新增方法",charIndex:5659},{level:4,title:"9.12.1 遍历方法",slug:"_9-12-1-遍历方法",normalizedTitle:"9.12.1 遍历方法",charIndex:5677},{level:5,title:"forEach()",slug:"foreach",normalizedTitle:"foreach()",charIndex:5692},{level:5,title:"filter()",slug:"filter",normalizedTitle:"filter()",charIndex:5838},{level:5,title:"some()",slug:"some",normalizedTitle:"some()",charIndex:5972},{level:2,title:"10 函数",slug:"_10-函数",normalizedTitle:"10 函数",charIndex:6165},{level:3,title:"10.1 函数的使用",slug:"_10-1-函数的使用",normalizedTitle:"10.1 函数的使用",charIndex:6197},{level:4,title:"10.1.1 声明函数",slug:"_10-1-1-声明函数",normalizedTitle:"10.1.1 声明函数",charIndex:6211},{level:5,title:"利用函数关键字声明（命名函数）",slug:"利用函数关键字声明-命名函数",normalizedTitle:"利用函数关键字声明（命名函数）",charIndex:6226},{level:5,title:"函数表达式声明（匿名函数）",slug:"函数表达式声明-匿名函数",normalizedTitle:"函数表达式声明（匿名函数）",charIndex:6306},{level:5,title:"通过构造函数生命",slug:"通过构造函数生命",normalizedTitle:"通过构造函数生命",charIndex:6355},{level:4,title:"10.1.2 调用函数",slug:"_10-1-2-调用函数",normalizedTitle:"10.1.2 调用函数",charIndex:6483},{level:5,title:"普通函数",slug:"普通函数",normalizedTitle:"普通函数",charIndex:6498},{level:5,title:"对象里的方法",slug:"对象里的方法",normalizedTitle:"对象里的方法",charIndex:6537},{level:5,title:"构造函数",slug:"构造函数",normalizedTitle:"构造函数",charIndex:6357},{level:5,title:"绑定事件函数",slug:"绑定事件函数",normalizedTitle:"绑定事件函数",charIndex:6590},{level:5,title:"定时器函数",slug:"定时器函数",normalizedTitle:"定时器函数",charIndex:6614},{level:5,title:"立即执行函数",slug:"立即执行函数",normalizedTitle:"立即执行函数",charIndex:6636},{level:3,title:"10.2 函数的参数",slug:"_10-2-函数的参数",normalizedTitle:"10.2 函数的参数",charIndex:6673},{level:4,title:"10.2.1 形参",slug:"_10-2-1-形参",normalizedTitle:"10.2.1 形参",charIndex:6687},{level:4,title:"10.2.2 实参",slug:"_10-2-2-实参",normalizedTitle:"10.2.2 实参",charIndex:6783},{level:4,title:"10.2.3 实参形参的关系",slug:"_10-2-3-实参形参的关系",normalizedTitle:"10.2.3 实参形参的关系",charIndex:6830},{level:3,title:"10.3 函数返回",slug:"_10-3-函数返回",normalizedTitle:"10.3 函数返回",charIndex:6904},{level:3,title:"10.4 arguments",slug:"_10-4-arguments",normalizedTitle:"10.4 arguments",charIndex:7022},{level:3,title:"10.5 函数的this",slug:"_10-5-函数的this",normalizedTitle:"10.5 函数的this",charIndex:7257},{level:4,title:"10.5.1 call()",slug:"_10-5-1-call",normalizedTitle:"10.5.1 call()",charIndex:7352},{level:4,title:"10.5.2 apply()",slug:"_10-5-2-apply",normalizedTitle:"10.5.2 apply()",charIndex:7474},{level:4,title:"10.5.3 bind()",slug:"_10-5-3-bind",normalizedTitle:"10.5.3 bind()",charIndex:7606},{level:3,title:"10.6 高阶函数",slug:"_10-6-高阶函数",normalizedTitle:"10.6 高阶函数",charIndex:7744},{level:2,title:"11 作用域",slug:"_11-作用域",normalizedTitle:"11 作用域",charIndex:7802},{level:3,title:"11.1 作用域概述",slug:"_11-1-作用域概述",normalizedTitle:"11.1 作用域概述",charIndex:7813},{level:3,title:"11.2 变量的作用域",slug:"_11-2-变量的作用域",normalizedTitle:"11.2 变量的作用域",charIndex:7979},{level:4,title:"11.2.1 全局变量",slug:"_11-2-1-全局变量",normalizedTitle:"11.2.1 全局变量",charIndex:7994},{level:4,title:"11.2.2 局部变量",slug:"_11-2-2-局部变量",normalizedTitle:"11.2.2 局部变量",charIndex:8064},{level:4,title:"11.2.3 全局效率",slug:"_11-2-3-全局效率",normalizedTitle:"11.2.3 全局效率",charIndex:8128},{level:3,title:"11.3 块级作用域",slug:"_11-3-块级作用域",normalizedTitle:"11.3 块级作用域",charIndex:8204},{level:3,title:"11.4 作用域链",slug:"_11-4-作用域链",normalizedTitle:"11.4 作用域链",charIndex:8271},{level:2,title:"12 闭包",slug:"_12-闭包",normalizedTitle:"12 闭包",charIndex:8351},{level:3,title:"12.1 变量作用域",slug:"_12-1-变量作用域",normalizedTitle:"12.1 变量作用域",charIndex:8361},{level:3,title:"12.2 闭包定义",slug:"_12-2-闭包定义",normalizedTitle:"12.2 闭包定义",charIndex:8438},{level:3,title:"12.3 闭包作用",slug:"_12-3-闭包作用",normalizedTitle:"12.3 闭包作用",charIndex:8488},{level:2,title:"13 拷贝",slug:"_13-拷贝",normalizedTitle:"13 拷贝",charIndex:8518},{level:3,title:"13.1 浅拷贝",slug:"_13-1-浅拷贝",normalizedTitle:"13.1 浅拷贝",charIndex:8589},{level:3,title:"13.2 深拷贝",slug:"_13-2-深拷贝",normalizedTitle:"13.2 深拷贝",charIndex:8645},{level:2,title:"14 预解析",slug:"_14-预解析",normalizedTitle:"14 预解析",charIndex:9075},{level:3,title:"14.1 JS代码运行",slug:"_14-1-js代码运行",normalizedTitle:"14.1 js代码运行",charIndex:9086},{level:3,title:"14.2 变量预解析",slug:"_14-2-变量预解析",normalizedTitle:"14.2 变量预解析",charIndex:9173},{level:3,title:"14.3 函数预解析",slug:"_14-3-函数预解析",normalizedTitle:"14.3 函数预解析",charIndex:9224},{level:2,title:"15 对象",slug:"_15-对象",normalizedTitle:"15 对象",charIndex:9296},{level:3,title:"15.1 创建对象",slug:"_15-1-创建对象",normalizedTitle:"15.1 创建对象",charIndex:9356},{level:4,title:"15.1.1 利用字面量创建对象",slug:"_15-1-1-利用字面量创建对象",normalizedTitle:"15.1.1 利用字面量创建对象",charIndex:9369},{level:4,title:"15.1.2 利用new Object创建对象",slug:"_15-1-2-利用new-object创建对象",normalizedTitle:"15.1.2 利用new object创建对象",charIndex:9592},{level:4,title:"15.1.3 利用构造函数创建对象",slug:"_15-1-3-利用构造函数创建对象",normalizedTitle:"15.1.3 利用构造函数创建对象",charIndex:9768},{level:3,title:"15.2 使用对象",slug:"_15-2-使用对象",normalizedTitle:"15.2 使用对象",charIndex:10071},{level:4,title:"15.2.1 调用对象属性",slug:"_15-2-1-调用对象属性",normalizedTitle:"15.2.1 调用对象属性",charIndex:10084},{level:4,title:"15.2.2 调用对象方法",slug:"_15-2-2-调用对象方法",normalizedTitle:"15.2.2 调用对象方法",charIndex:10129},{level:3,title:"15.3 new关键字",slug:"_15-3-new关键字",normalizedTitle:"15.3 new关键字",charIndex:10176},{level:3,title:"15.4 遍历对象",slug:"_15-4-遍历对象",normalizedTitle:"15.4 遍历对象",charIndex:10295},{level:3,title:"15.5 ES5新增方法",slug:"_15-5-es5新增方法",normalizedTitle:"15.5 es5新增方法",charIndex:10447},{level:4,title:"15.5.1 Object.definerProperty()",slug:"_15-5-1-object-definerproperty",normalizedTitle:"15.5.1 object.definerproperty()",charIndex:10463},{level:2,title:"16 内置对象",slug:"_16-内置对象",normalizedTitle:"16 内置对象",charIndex:10792},{level:3,title:"16.1 Math内置对象",slug:"_16-1-math内置对象",normalizedTitle:"16.1 math内置对象",charIndex:10891},{level:4,title:"16.1.1 Math常用属性和方法",slug:"_16-1-1-math常用属性和方法",normalizedTitle:"16.1.1 math常用属性和方法",charIndex:10951},{level:3,title:"16.2 日期内置对象",slug:"_16-2-日期内置对象",normalizedTitle:"16.2 日期内置对象",charIndex:11152},{level:4,title:"16.2.1 使用Date",slug:"_16-2-1-使用date",normalizedTitle:"16.2.1 使用date",charIndex:11214},{level:4,title:"16.2.2 参数常用写法",slug:"_16-2-2-参数常用写法",normalizedTitle:"16.2.2 参数常用写法",charIndex:11281},{level:4,title:"16.2.3 日期格式化",slug:"_16-2-3-日期格式化",normalizedTitle:"16.2.3 日期格式化",charIndex:11364},{level:4,title:"16.2.4 获取时间戳",slug:"_16-2-4-获取时间戳",normalizedTitle:"16.2.4 获取时间戳",charIndex:11418},{level:2,title:"17 基本包装类型",slug:"_17-基本包装类型",normalizedTitle:"17 基本包装类型",charIndex:11561},{level:2,title:"18 数据类型",slug:"_18-数据类型",normalizedTitle:"18 数据类型",charIndex:11747},{level:3,title:"18.1 堆和栈",slug:"_18-1-堆和栈",normalizedTitle:"18.1 堆和栈",charIndex:11759},{level:4,title:"18.1.1 栈（操作系统）",slug:"_18-1-1-栈-操作系统",normalizedTitle:"18.1.1 栈（操作系统）",charIndex:11809},{level:4,title:"18.1.2 堆（操作系统）",slug:"_18-1-2-堆-操作系统",normalizedTitle:"18.1.2 堆（操作系统）",charIndex:11897},{level:3,title:"18.2 简单数据类型",slug:"_18-2-简单数据类型",normalizedTitle:"18.2 简单数据类型",charIndex:11965},{level:4,title:"18.2.1 简单数据类型内存分配",slug:"_18-2-1-简单数据类型内存分配",normalizedTitle:"18.2.1 简单数据类型内存分配",charIndex:12094},{level:3,title:"18.3 复杂数据类型",slug:"_18-3-复杂数据类型",normalizedTitle:"18.3 复杂数据类型",charIndex:12150},{level:4,title:"18.3.1 复杂数据类型内存分配",slug:"_18-3-1-复杂数据类型内存分配",normalizedTitle:"18.3.1 复杂数据类型内存分配",charIndex:12233},{level:2,title:"19 面向对象",slug:"_19-面向对象",normalizedTitle:"19 面向对象",charIndex:12300},{level:3,title:"19.1 面向对象编程介绍",slug:"_19-1-面向对象编程介绍",normalizedTitle:"19.1 面向对象编程介绍",charIndex:12312},{level:3,title:"19.2 ES6中的类和对象",slug:"_19-2-es6中的类和对象",normalizedTitle:"19.2 es6中的类和对象",charIndex:12760},{level:4,title:"19.2.1 面向对象的思维特点",slug:"_19-2-1-面向对象的思维特点",normalizedTitle:"19.2.1 面向对象的思维特点",charIndex:12778},{level:4,title:"19.2.2 对象",slug:"_19-2-2-对象",normalizedTitle:"19.2.2 对象",charIndex:12853},{level:4,title:"19.2.3 类class",slug:"_19-2-3-类class",normalizedTitle:"19.2.3 类class",charIndex:12995},{level:4,title:"19.2.4 创建类",slug:"_19-2-4-创建类",normalizedTitle:"19.2.4 创建类",charIndex:13109},{level:4,title:"19.2.5 类constructor构造函数",slug:"_19-2-5-类constructor构造函数",normalizedTitle:"19.2.5 类constructor构造函数",charIndex:13204},{level:4,title:"19.2.6 类添加方法",slug:"_19-2-6-类添加方法",normalizedTitle:"19.2.6 类添加方法",charIndex:13435},{level:4,title:"19.2.7 类的继承",slug:"_19-2-7-类的继承",normalizedTitle:"19.2.7 类的继承",charIndex:13515},{level:5,title:"super关键字",slug:"super关键字",normalizedTitle:"super关键字",charIndex:13614},{level:4,title:"19.2.8 注意点",slug:"_19-2-8-注意点",normalizedTitle:"19.2.8 注意点",charIndex:13759},{level:2,title:"20 构造函数和原型",slug:"_20-构造函数和原型",normalizedTitle:"20 构造函数和原型",charIndex:13911},{level:3,title:"20.1 构造函数",slug:"_20-1-构造函数",normalizedTitle:"20.1 构造函数",charIndex:13932},{level:3,title:"20.2 构造函数原型 prototype",slug:"_20-2-构造函数原型-prototype",normalizedTitle:"20.2 构造函数原型 prototype",charIndex:14331},{level:3,title:"20.3 对象原型_proto_",slug:"_20-3-对象原型-proto",normalizedTitle:"20.3 对象原型_proto_",charIndex:null},{level:3,title:"20.4 构造函数constructor",slug:"_20-4-构造函数constructor",normalizedTitle:"20.4 构造函数constructor",charIndex:14744},{level:3,title:"20.5 构造函数、实例、原型对象三者之间的关系",slug:"_20-5-构造函数、实例、原型对象三者之间的关系",normalizedTitle:"20.5 构造函数、实例、原型对象三者之间的关系",charIndex:14956},{level:3,title:"20.6 原型链",slug:"_20-6-原型链",normalizedTitle:"20.6 原型链",charIndex:14987},{level:3,title:"20.7 成员的查找机制",slug:"_20-7-成员的查找机制",normalizedTitle:"20.7 成员的查找机制",charIndex:15002},{level:3,title:"20.8 原型对象this指向",slug:"_20-8-原型对象this指向",normalizedTitle:"20.8 原型对象this指向",charIndex:15165},{level:3,title:"20.9 扩展内置对象",slug:"_20-9-扩展内置对象",normalizedTitle:"20.9 扩展内置对象",charIndex:15228},{level:2,title:"21 继承",slug:"_21-继承",normalizedTitle:"21 继承",charIndex:15362},{level:3,title:"21.1 call()",slug:"_21-1-call",normalizedTitle:"21.1 call()",charIndex:15425},{level:3,title:"21.2 借用构造函数继承父类型属性",slug:"_21-2-借用构造函数继承父类型属性",normalizedTitle:"21.2 借用构造函数继承父类型属性",charIndex:15561},{level:3,title:"21.3 借用原型对象继承父类型方法",slug:"_21-3-借用原型对象继承父类型方法",normalizedTitle:"21.3 借用原型对象继承父类型方法",charIndex:15883},{level:3,title:"21.4 类的本质",slug:"_21-4-类的本质",normalizedTitle:"21.4 类的本质",charIndex:16219},{level:2,title:"22 严格模式",slug:"_22-严格模式",normalizedTitle:"22 严格模式",charIndex:16403},{level:3,title:"22.1 开启严格模式",slug:"_22-1-开启严格模式",normalizedTitle:"22.1 开启严格模式",charIndex:16638},{level:3,title:"22.2 严格模式变化",slug:"_22-2-严格模式变化",normalizedTitle:"22.2 严格模式变化",charIndex:16762},{level:4,title:"22.2.1 变量规定",slug:"_22-2-1-变量规定",normalizedTitle:"22.2.1 变量规定",charIndex:16777},{level:4,title:"22.2.2 this指向",slug:"_22-2-2-this指向",normalizedTitle:"22.2.2 this指向",charIndex:16829},{level:4,title:"22.2.3 函数变化",slug:"_22-2-3-函数变化",normalizedTitle:"22.2.3 函数变化",charIndex:16950},{level:2,title:"23 正则表达式",slug:"_23-正则表达式",normalizedTitle:"23 正则表达式",charIndex:17008},{level:3,title:"23.1 特点",slug:"_23-1-特点",normalizedTitle:"23.1 特点",charIndex:17065},{level:3,title:"23.2 创建正则表达式",slug:"_23-2-创建正则表达式",normalizedTitle:"23.2 创建正则表达式",charIndex:17124},{level:4,title:"23.2.1 利用RegExp对象来创建",slug:"_23-2-1-利用regexp对象来创建",normalizedTitle:"23.2.1 利用regexp对象来创建",charIndex:17140},{level:4,title:"23.2.2 利用字面量创建",slug:"_23-2-2-利用字面量创建",normalizedTitle:"23.2.2 利用字面量创建",charIndex:17199},{level:3,title:"23.3 测试正则表达式",slug:"_23-3-测试正则表达式",normalizedTitle:"23.3 测试正则表达式",charIndex:17239},{level:3,title:"23.4 正则表达式中的特殊字符",slug:"_23-4-正则表达式中的特殊字符",normalizedTitle:"23.4 正则表达式中的特殊字符",charIndex:17314},{level:4,title:"23.4.1 正则表达式的组成",slug:"_23-4-1-正则表达式的组成",normalizedTitle:"23.4.1 正则表达式的组成",charIndex:17334},{level:4,title:"23.4.2 边界符",slug:"_23-4-2-边界符",normalizedTitle:"23.4.2 边界符",charIndex:17440},{level:4,title:"23.4.3 字符类",slug:"_23-4-3-字符类",normalizedTitle:"23.4.3 字符类",charIndex:17541},{level:4,title:"23.4.4 量词符",slug:"_23-4-4-量词符",normalizedTitle:"23.4.4 量词符",charIndex:17740},{level:4,title:"23.4.5 括号总结",slug:"_23-4-5-括号总结",normalizedTitle:"23.4.5 括号总结",charIndex:17868},{level:4,title:"23.4.6 预定义类",slug:"_23-4-6-预定义类",normalizedTitle:"23.4.6 预定义类",charIndex:17925},{level:3,title:"23.5 正则替换",slug:"_23-5-正则替换",normalizedTitle:"23.5 正则替换",charIndex:18090},{level:4,title:"23.5.1 正则表达式参数",slug:"_23-5-1-正则表达式参数",normalizedTitle:"23.5.1 正则表达式参数",charIndex:18156}],headersStr:"1 JS认知 1.1 JS组成 1.2 JS书写位置 1.3 JS注释 2 输入输出语句 2.1 alert 2.2 console 2.3 dir 2.4 prompt 3 变量 3.1 变量的使用 3.1.1 变量声明 3.1.2 变量赋值 3.1.3 变量初始化 3.1.4 同时声明 3.1.5 可以不声明直接使用 3.2 变量命名规范 3.3 检测数据类型 4 数字型Number 4.1 整型 4.2 浮点型 4.3 数字型进制 4.4 数字范围 4.5 特殊值 4.6 数字判断 4.7 其他类型转换成数字型 5 字符串型String 5.1 字符串嵌套 5.2 字符串转义符 5.3 字符串的拼接 5.4 字符串常用方法 5.5 其他类型转换成字符串 5.6 字符串的不可变 5.7 ES5新增字符串方法 5.7.1 trim() 6 布尔型Boolean 6.1 其他类型转换成布尔型 7 运算符 7.1 算数运算符 7.2 递增递减运算符 7.3 比较运算符 7.4 逻辑运算符 7.4.1 &&断路 7.4.2 ||断路 7.5 赋值运算符 7.6 运算符优先级 8 流程控制 8.1 顺序流程控制 8.2 分支流程控制 8.2.1 if 8.2.2 if-else双分支 8.2.3 多分支语句 8.2.4 三元表达式 8.2.5 switch 8.3 循环流程控制 8.3.1 for循环 8.3.2 while循环 8.3.3 do-while循环 8.3.4 continue 8.4 break 9 数组Array 9.1 创建数组 9.1.1  new关键字创建数组 9.1.2 利用数组字面量创建数组 9.2 数组索引 9.3 数组长度 9.4 数组新增元素 9.4.1 修改length长度 9.4.2 增加索引号 9.5 检测是否为数组 9.5.1 instanceof 运算符 9.5.2 .isArray() 9.6 添加数组元素 9.6.1 .push() 9.6.2 .unshift() 9.7 删除数组元素 9.7.1 .pop() 9.7.2 .shift() 9.8 数组排序 9.8.1 .reverse() 9.8.2 .sort() 9.9 数组索引 9.9.1 .indexOf() 9.9.2 .lastIndexOf() 9.10 数组转换成字符串 9.10.1 toString() 9.10.2 join('分隔符') 9.11 数组切割 9.11.1 .concat() 9.11.2 .slice() 9.11.3 .splice() 9.12 ES5数组新增方法 9.12.1 遍历方法 forEach() filter() some() 10 函数 10.1 函数的使用 10.1.1 声明函数 利用函数关键字声明（命名函数） 函数表达式声明（匿名函数） 通过构造函数生命 10.1.2 调用函数 普通函数 对象里的方法 构造函数 绑定事件函数 定时器函数 立即执行函数 10.2 函数的参数 10.2.1 形参 10.2.2 实参 10.2.3 实参形参的关系 10.3 函数返回 10.4 arguments 10.5 函数的this 10.5.1 call() 10.5.2 apply() 10.5.3 bind() 10.6 高阶函数 11 作用域 11.1 作用域概述 11.2 变量的作用域 11.2.1 全局变量 11.2.2 局部变量 11.2.3 全局效率 11.3 块级作用域 11.4 作用域链 12 闭包 12.1 变量作用域 12.2 闭包定义 12.3 闭包作用 13 拷贝 13.1 浅拷贝 13.2 深拷贝 14 预解析 14.1 JS代码运行 14.2 变量预解析 14.3 函数预解析 15 对象 15.1 创建对象 15.1.1 利用字面量创建对象 15.1.2 利用new Object创建对象 15.1.3 利用构造函数创建对象 15.2 使用对象 15.2.1 调用对象属性 15.2.2 调用对象方法 15.3 new关键字 15.4 遍历对象 15.5 ES5新增方法 15.5.1 Object.definerProperty() 16 内置对象 16.1 Math内置对象 16.1.1 Math常用属性和方法 16.2 日期内置对象 16.2.1 使用Date 16.2.2 参数常用写法 16.2.3 日期格式化 16.2.4 获取时间戳 17 基本包装类型 18 数据类型 18.1 堆和栈 18.1.1 栈（操作系统） 18.1.2 堆（操作系统） 18.2 简单数据类型 18.2.1 简单数据类型内存分配 18.3 复杂数据类型 18.3.1 复杂数据类型内存分配 19 面向对象 19.1 面向对象编程介绍 19.2 ES6中的类和对象 19.2.1 面向对象的思维特点 19.2.2 对象 19.2.3 类class 19.2.4 创建类 19.2.5 类constructor构造函数 19.2.6 类添加方法 19.2.7 类的继承 super关键字 19.2.8 注意点 20 构造函数和原型 20.1 构造函数 20.2 构造函数原型 prototype 20.3 对象原型_proto_ 20.4 构造函数constructor 20.5 构造函数、实例、原型对象三者之间的关系 20.6 原型链 20.7 成员的查找机制 20.8 原型对象this指向 20.9 扩展内置对象 21 继承 21.1 call() 21.2 借用构造函数继承父类型属性 21.3 借用原型对象继承父类型方法 21.4 类的本质 22 严格模式 22.1 开启严格模式 22.2 严格模式变化 22.2.1 变量规定 22.2.2 this指向 22.2.3 函数变化 23 正则表达式 23.1 特点 23.2 创建正则表达式 23.2.1 利用RegExp对象来创建 23.2.2 利用字面量创建 23.3 测试正则表达式 23.4 正则表达式中的特殊字符 23.4.1 正则表达式的组成 23.4.2 边界符 23.4.3 字符类 23.4.4 量词符 23.4.5 括号总结 23.4.6 预定义类 23.5 正则替换 23.5.1 正则表达式参数",content:"# 1 JS认知\n\n\n# 1.1 JS组成\n\n 1. ECMAScript，JS语法\n 2. DOM，页面文档对象模型\n 3. BOM，浏览器对象模型\n\n\n# 1.2 JS书写位置\n\n 1. 行内式\n    * 将单行或少量代买写在HTML标签的事件属性中（以on开头的属性）\n    * HTML中推荐使用双引号，JS中推荐使用单引号\n 2. 内嵌式 <script><\/script>\n 3. 外部式 <script scr=\"my.js\"><\/script>\n\n\n# 1.3 JS注释\n\n 1. 单行注释//（ctrl + /）\n 2. 多行注释/* */（shift + alt + a）\n\n\n# 2 输入输出语句\n\n\n# 2.1 alert\n\n 1. 弹出警示框\n 2. 语法 prompt('弹出的语句');\n\n\n# 2.2 console\n\n 1. 控制台输出，用于测试\n 2. 语法 console.log('输出的语句');\n\n\n# 2.3 dir\n\n 1. 语法console.dir(元素对象);\n 2. 打印DOM返回的元素对象\n\n\n# 2.4 prompt\n\n 1. 弹出输入框\n 2. 语法 prompt('请用户输入的提示语句');\n 3. 输入进来的值是字符串类型\n\n\n# 3 变量\n\n变量用于存放数据，是内存中申请的一段空间\n\n\n# 3.1 变量的使用\n\n# 3.1.1 变量声明\n\n 1. var 变量名;\n 2. var是JS关键字，用于声明变量。使用后计算机自动为变量分配内存空间，不需要程序员管\n\n# 3.1.2 变量赋值\n\n 1. 变量名 = 值;\n\n# 3.1.3 变量初始化\n\n 1. var 变量名 = 值;\n\n# 3.1.4 同时声明\n\nvar 变量名1 = 值,\n    变量2 = 值;\n\n\n1\n2\n\n\n# 3.1.5 可以不声明直接使用\n\n 1. 但是会变成全局变量\n\n\n# 3.2 变量命名规范\n\n 1. 由字母、数字、下划线、美元符号\n 2. 严格区分大小写\n 3. 不能以数字开头\n 4. 不能是关键字和保留字\n\n\n# 3.3 检测数据类型\n\ntypeof 待检测变量\n\n\n# 4 数字型Number\n\n数字类型可以用来保存整数值，也可以保存浮点数\n\n\n# 4.1 整型\n\n\n# 4.2 浮点型\n\n\n# 4.3 数字型进制\n\n 1. 八进制：数字前+0\n 2. 16进制：数字前+0x\n\n\n# 4.4 数字范围\n\n 1. 最大值1.79e+308\n 2. 最小值5e-324\n\n\n# 4.5 特殊值\n\n 1. 无穷大：Infinity\n 2. 无穷小：-Infinity\n 3. 非数字：NaN\n\n\n# 4.6 数字判断\n\n 1. isNaN()判断是不是非数字\n\n\n# 4.7 其他类型转换成数字型\n\n 1. parseInt(字符串型变量)变为整型\n    * 会去除数字之后的其他字符串\n    * 但是不能去除数字之前的字符串\n 2. parseFloat(字符串型变量)变为浮点型\n    * 会去除数字之后的其他字符串\n    * 但是不能去除数字之前的字符串\n 3. Number(变量)\n 4. 利用算术运算隐式转换为数字型\n\n\n# 5 字符串型String\n\n推荐使用单引号\n\n\n# 5.1 字符串嵌套\n\n 1. 外单内双进行嵌套\n\n\n# 5.2 字符串转义符\n\n 1. 换行\\n\n 2. tab缩进\\t\n 3. 空格\\b\n\n\n# 5.3 字符串的拼接\n\n 1. 用+拼接\n 2. 只要有一个部分是字符串，输出都是字符串，和其他数据类型没关系\n 3. 变量可以直接把内容拼接到字符串里\n\n\n# 5.4 字符串常用方法\n\n字符串常用方法\n\n 1. 返回长度字符串名.length\n 2. 返回指定位置字符串内容字符串名.charAt(位置索引)\n 3. 返回指定字符在字符串中首次出现的位置字符串名.indexOf(查找的字符,起始的位置)\n 4. 判断子字符串的存在字符串.includes(子字符串)\n 5. 大小写转换字符串名.toLowerCase()|字符串名.toUpperCase()\n\n\n# 5.5 其他类型转换成字符串\n\n 1. 变量.toString()\n 2. String(变量)函数强制转换\n 3. 加号拼接\n\n\n# 5.6 字符串的不可变\n\n 1. 指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间\n 2. 因为字符串的不可变不要大量拼接字符串\n\n\n# 5.7 ES5新增字符串方法\n\n# 5.7.1 trim()\n\n 1. 从字符串的两端删除空白字符\n 2. 语法str.trim()\n 3. 不影响原字符串本身，返回的是一个新的字符串\n\n\n# 6 布尔型Boolean\n\n 1. true可以当1来看\n 2. false可以当0来看\n\n\n# 6.1 其他类型转换成布尔型\n\n 1. Boolean(变量)\n 2. 代表空的''|0|NaN|null|undefined转换成false\n 3. 其他都是true\n\n\n# 7 运算符\n\n运算符（operator）也称为操作符，用于实现赋值、比较和执行算术运算等功能的符号\n\n\n# 7.1 算数运算符\n\n\n\n 1. 浮点数存在阶段误差，不要判断浮点数是否相等\n 2. 算数运算符的优先级和平时一样\n\n\n# 7.2 递增递减运算符\n\n 1. ++递增，每次加1\n 2. --递减，每次减1\n 3. 前置递增|递减：运算符在变量前面，先计算后输出\n 4. 后置递增|递减：运算符在变量后面，先输出后计算\n\nvar age = 10\nconsole.log(++age + 10); //输出21，前置递增\nage = 10\nconsole.log(age++ + 10); //输出20，后置递增\n// 但是两个age都是11\n\n\n1\n2\n3\n4\n5\n\n\n\n# 7.3 比较运算符\n\n\n\n 1. ==比较的时候会自动转换数据类型\n 2. ===同时要求值和数据类型\n\nconsole.log(18 == '18'); //true\nconsole.log(18 === '18'); //false\n\n\n1\n2\n\n\n\n# 7.4 逻辑运算符\n\n\n\n 1. 短路运算：当有多个表达式时，左边表达式可以确定结果时就不再进行有右边的运算\n\n# 7.4.1 &&断路\n\n 1. 表达式1 && 表达式2\n 2. 表达式1真，返回表达式2\n 3. 表达式1假，返回表达式1\n\n# 7.4.2 ||断路\n\n 1. 表达式1 || 表达式2\n 2. 表达式1真，返回表达式1\n 3. 表达式1假，返回表达式2\n\n\n# 7.5 赋值运算符\n\n\n\n\n# 7.6 运算符优先级\n\n\n\n\n# 8 流程控制\n\n\n# 8.1 顺序流程控制\n\n直接写就好\n\n\n# 8.2 分支流程控制\n\n# 8.2.1 if\n\n 1. 语法结构\n\nif (条件表达式) {\n    条件成立时的执行语句\n}\n\n\n1\n2\n3\n\n\n# 8.2.2 if-else双分支\n\n 1. 语法结构\n\nif (条件表达式) {\n    条件成立时的执行语句\n} else{\n    条件不成立时的执行语句\n}\n\n\n1\n2\n3\n4\n5\n\n 2. if和else里只有一个语句能执行\n\n# 8.2.3 多分支语句\n\n 1. 语法结构\n\nif (条件表达式1) {\n    条件1成立时的执行语句\n} else if (条件表达式2){\n    条件1不成立条件3成立时的执行语句\n} else{\n    所有条件都不成立时的执行语句\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 8.2.4 三元表达式\n\n 1. 语法结构条件表达式 ? 表达式1 : 表达式2\n 2. 执行思路\n    * 条件表达式真，返回表达式1\n    * 条件表达式假，返回表达式2\n\n# 8.2.5 switch\n\n 1. 语法结构\n\nswitch (表达式) {\n    case value1:\n        表达式与value1匹配时的执行语句;\n        break;\n    case value2:\n        表达式与value2匹配时的执行语句;\n        break;\n    default:\n        都不满足时的执行语句;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 2. 匹配的要求是值和数据类型都相等才算匹配\n 3. 要写break，否则switch会认为一直是匹配上的直接执行后续case的执行语句\n\n\n# 8.3 循环流程控制\n\n# 8.3.1 for循环\n\n 1. 语法结构\n\nfor (初始化变量;条件表达式；操作表达式) {\n    循环体\n}\n\n\n1\n2\n3\n\n\n# 8.3.2 while循环\n\n 1. 语法结构\n\nwhile (条件表达式) {\n    循环体\n}\n\n\n1\n2\n3\n\n\n# 8.3.3 do-while循环\n\n 1. 语法结构\n\ndo {\n    循环体\n} while (条件表达式)\n\n\n1\n2\n3\n\n 2. 限制性循环体再判断条件\n\n# 8.3.4 continue\n\n 1. 立即跳出本次循环，继续下一次循环\n\n\n# 8.4 break\n\n 1. 立即跳出整个循环\n\n\n# 9 数组Array\n\n\n# 9.1 创建数组\n\n# 9.1.1 new关键字创建数组\n\n 1. var 数组名 = new Array();\n 2. 通过实例化Array构造对象创建的\n 3. var 数组名 = new Array(n);创建长度为n的空数组\n 4. var 数组名 = new Array(x,y);创建[ x,y]数组\n\n# 9.1.2 利用数组字面量创建数组\n\n 1. 数组字面量[]\n 2. 语法var 数组名 = [];\n 3. 数组里的数据用逗号分隔\n 4. 数组里的数据称为数组元素\n\n\n# 9.2 数组索引\n\n 1. 索引（下标）：用来访问数组元素的序列，从0开始\n 2. 通过索引号访问数组元素数组名[索引号]\n 3. 没有数组元素，访问结果为undefined\n\n\n# 9.3 数组长度\n\n数组名.length\n\n\n# 9.4 数组新增元素\n\n# 9.4.1 修改length长度\n\n数组名.length = 5添加空元素\n\n# 9.4.2 增加索引号\n\n数组名[索引号] = 新加元素追加元素\n\n\n# 9.5 检测是否为数组\n\n# 9.5.1 instanceof 运算符\n\n 1. 语法待检测内容 instanceof Array\n\n# 9.5.2 .isArray()\n\n 1. 语法Array.isArray(待检测内容)\n 2. ie9以上版本才支持\n\n\n# 9.6 添加数组元素\n\n# 9.6.1 .push()\n\n 1. 在尾部添加一个或多个数组元素\n 2. 语法数组.push(添加的元素)\n 3. push完后返回的是新数组的长度\n 4. 原数组也会发生变化\n\n# 9.6.2 .unshift()\n\n 1. 在开头添加一个或多个数组元素\n 2. 语法数组.unshift(添加的元素)\n 3. unshift完后返回的是新数组的长度\n 4. 原数组也会发生变化\n\n\n# 9.7 删除数组元素\n\n# 9.7.1 .pop()\n\n 1. 删除数组最后的一个元素，一次只能删除一个元素\n 2. 语法数组.pop()\n 3. pop完后返回被删除的元素\n 4. 原数组也会发生变化\n\n# 9.7.2 .shift()\n\n 1. 删除数组第一个的一个元素，一次只能删除一个元素\n 2. 语法数组.shift()\n 3. shift完后返回被删除的元素\n 4. 原数组也会发生变化\n\n\n# 9.8 数组排序\n\n# 9.8.1 .reverse()\n\n 1. 翻转数组\n 2. 语法数组.reverse()\n\n# 9.8.2 .sort()\n\n 1. 冒泡排序\n 2. 语法数组.sort()\n 3. 这样排序是先看按照最高位排序，再按后面的位数排序，个位数可以用\n 4. \n\n数组.sort(function(a,b){\n    // 按照升序排序\n    return a-b;\n    // 按照降序排序\n    return b-a;\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 9.9 数组索引\n\n# 9.9.1 .indexOf()\n\n 1. 查找数组中给定元素的第一个索引\n 2. 不存在返回-1\n 3. 语法数组名.indexOf(元素名,查找起始位置)\n\n# 9.9.2 .lastIndexOf()\n\n 1. 查找数组中给定元素的最后一个索引\n 2. 不存在返回-1\n 3. 语法``数组名.lastIndexOf(元素名)`\n\n\n# 9.10 数组转换成字符串\n\n# 9.10.1 toString()\n\n 1. 把数组转换成字符串，逗号分隔每一项\n\n\n# 9.10.2 join('分隔符')\n\n 1. 把数组中的所有元素转换为一个字符串\n 2. 分隔符默认为逗号\n\n\n# 9.11 数组切割\n\n# 9.11.1 .concat()\n\n 1. 连接两个或多个数组\n 2. 返回新数组\n 3. 不影响原数组\n\n# 9.11.2 .slice()\n\n 1. 截取数组\n 2. 返回新数组\n 3. 语法数组名.slice(开始缩印,结束索引)\n\n# 9.11.3 .splice()\n\n 1. 删除数组内元素\n 2. 返回被删除的新数组\n 3. 会影响原数组\n\n\n# 9.12 ES5数组新增方法\n\n# 9.12.1 遍历方法\n\n# forEach()\n\n 1. 语法数值名.forEach(function(value,index,array){})\n 2. value：数组当前项的值\n 3. index：数组当前项的索引\n 4. array：被遍历的数组本身\n 5. 在forEach里面return不会终止迭代\n\n# filter()\n\n 1. 语法数值名.filter(function(value,index,array){})\n 2. filter方法用于创建一个新的数组，新数组中的元素是通过检测指定数组中符合条件的所有元素，主要用于筛选数组\n 3. 返回的是一个新数组\n\n# some()\n\n 1. 语法数值名.some(function(value,index,array){})\n 2. some方法用于检测数组中断额元素是否满足指定条件\n 3. 返回的是一个布尔值。如果查到这个元素，就返回true；如果查不到就返回false\n 4. 如果找到第一个满足条件的元素，则终止循环，不再继续查找\n 5. 在some里面return true会终止迭代\n\n\n# 10 函数\n\n 1. 函数：封装了可被调用实行的代码块\n\n\n# 10.1 函数的使用\n\n# 10.1.1 声明函数\n\n# 利用函数关键字声明（命名函数）\n\n 1. 语法function 函数名(形参){}\n 2. function是声明函数的关键字\n 3. 函数名一般是动词\n\n# 函数表达式声明（匿名函数）\n\n 1. 语法var 变量名 = function(形参){}\n\n# 通过构造函数生命\n\n 1. 语法var 函数名 = new Function('形参','函数体')\n 2. 所有函数都是Function的实例（对象）\n 3. Function里面参数都必须是字符串格式\n 4. 执行效率低，也不方便书写，较少使用\n\n# 10.1.2 调用函数\n\n# 普通函数\n\n 1. 语法函数名();\n 2. 语法函数名.call()\n\n# 对象里的方法\n\n 1. 语法对象.函数名()\n\n# 构造函数\n\n 1. 语法new 构造函数名()\n\n# 绑定事件函数\n\n 1. 触发事件自动调用\n\n# 定时器函数\n\n 1. 定时器自动调用\n\n# 立即执行函数\n\n 1. (function(){})()自动调用\n\n\n# 10.2 函数的参数\n\n# 10.2.1 形参\n\n 1. 函数声明的是形参\n 2. 语法function 函数名(形参1,形参2):{}\n 3. 是一种不用声明的变量\n 4. 形参不赋值时默认为undefined\n\n# 10.2.2 实参\n\n 1. 调用函数的是实参\n 2. 语法函数名(实参1,实参2);\n\n# 10.2.3 实参形参的关系\n\n 1. 形参接受实参的数值\n 2. 形参和实参可以不匹配\n 3. 实参个数多于形参个数，后面的实参直接抛弃\n\n\n# 10.3 函数返回\n\n 1. 语法return 需要返回的结果;\n 2. return具有终止函数的功能\n 3. return只能返回一个值，如果多个值返回最后一个值\n 4. 函数如果没有return，则返回undefined\n\n\n# 10.4 arguments\n\n 1. arguments是当前函数的内置对象，存储了传递的所有实参\n 2. 语法\n\nfunction 函数名():{\n    console.log(arguments)\n    }\n\n\n1\n2\n3\n\n 3. arguments展示形参为一个伪数组\n    * 可以遍历\n    * 具有length属性\n    * 按索引方式储存数据\n    * 不具有数组的push、pop等方法\n 4. 只有函数有arguments对象\n\n\n# 10.5 函数的this\n\n 1. this的指向是当我们调用函数的时候确定的\n 2. 一般指向调用者\n 3. 构造函数里的this和构造函数原型对象里的this都指向生成的实例对象\n\n# 10.5.1 call()\n\n 1. 可以调用函数\n 2. 改变this指向\n 3. 语法函数名.call(this指向,实参)\n 4. 主要作用是实现继承。在子构造函数里用call调用父构造函数父构造函数名.call(this,参数)\n\n# 10.5.2 apply()\n\n 1. 可以调用函数，也可以改变this指向\n 2. 语法函数名.apply(this指向,[实参])\n 3. 实参的传递必须使用数组的方式\n 4. 可以实现数组最大最小值的实现Math.max.apply(Math,数组)\n\n# 10.5.3 bind()\n\n 1. 不会调用函数，但能改变函数内部this指向\n 2. 语法函数名.bind(this指向,实参)\n 3. 返回由指定的this值和初始化参数改造的原函数拷贝\n 4. 应用场景：有的函数不需要立即调用，但又想改变函数内部this指向\n\n\n# 10.6 高阶函数\n\n 1. 高阶函数是对其他函数进行操作的含糊，它接收函数作为参数或将函数作为返回值输出\n\n\n# 11 作用域\n\n\n# 11.1 作用域概述\n\n 1. 作用域：限定代码中用到的名字可用性的代码范围\n 2. 作用域的目的是提高程序的可靠性，减少命名冲突\n 3. 作用域分为全局作用域和局部作用域\n 4. 全局作用域：整个scrip标签或者一个单独的js文件\n 5. 局部作用域：只在函数内部，也可以叫做函数作用域\n 6. 不同作用域下命名不冲突\n\n\n# 11.2 变量的作用域\n\n# 11.2.1 全局变量\n\n 1. 在全局作用域下的变量\n 2. 除了全局状态下声明变量还有在函数内部不声明直接赋值的变量也是全局变量\n\n# 11.2.2 局部变量\n\n 1. 在局部作用域下的变量\n 2. 只能在函数内部使用\n 3. 函数的形参也可以看作局部变量\n\n# 11.2.3 全局效率\n\n 1. 全局变量只有浏览器关闭的时候才会销毁，比较占内存资源\n 2. 局部变量程序执行完毕就会销毁，比较节约内容资源\n\n\n# 11.3 块级作用域\n\n 1. 目前js没有块级作用域\n 2. 在es6时新增了块级作用域\n 3. 块级作用域：用{}包含的\n\n\n# 11.4 作用域链\n\n 1. 内部函数访问外部函数的变量采取的是链式查找的方式来决定是哪个值\n 2. 作用域链：这种链式查找方式结构\n 3. 就近原则\n\n\n# 12 闭包\n\n\n# 12.1 变量作用域\n\n 1. 函数内部可以使用全局变量\n 2. 函数外部不可以使用局部变量\n 3. 当函数执行完毕，本作用域内的局部变量会销毁\n\n\n# 12.2 闭包定义\n\n 1. 闭包(closure)指有权访问另一个函数作用域中变量的函数\n\n\n# 12.3 闭包作用\n\n 1. 延伸了变量的作用范围\n\n\n# 13 拷贝\n\n 1. 浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用，只拷贝地址\n 2. 深拷贝拷贝多层，每一个级别的数据都会拷贝\n\n\n# 13.1 浅拷贝\n\n 1. ES6新语法Object.assign(用于存储的变量名,被拷贝的变量名)\n\n\n# 13.2 深拷贝\n\n 1. 通过递归函数来进行深拷贝\n\nfunction deepCopy(newObj,oldObj){\n    for(var k in oldObj){\n        var item = oldObj[k];\n        if(item instanceof Array){\n            newObj[k] = [];\n            deepCopy(newObj[k],item);\n        }else if(item instanceof Object){\n            newObj[k] = {};\n            deepCopy(newObj[k],item);\n        }else{\n            newObj[k] = item;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 14 预解析\n\n\n# 14.1 JS代码运行\n\n 1. 预解析：js引擎会把里面所有的var还有function提升到当前作用域的最前面\n 2. 代码执行：按照代码书写的顺序从上往下执行\n\n\n# 14.2 变量预解析\n\n 1. 变量预解析又叫变量提升\n 2. 只提升变量声明不提升赋值操作\n\n\n# 14.3 函数预解析\n\n 1. 函数预解析又叫函数提升\n 2. 只提升函数声明不调用\n 3. 函数预解析只适用于用函数关键字声明的情况\n\n\n# 15 对象\n\n 1. 对象是一组无需的相关属性和方法的集合\n 2. 属性：事物的特征\n 3. 方法：事物的行为\n\n\n# 15.1 创建对象\n\n# 15.1.1 利用字面量创建对象\n\n 1. 对象字面量为{}\n\nvar obj = {\n    //属性\n    uname = 'qww', \n    //方法\n    sayHi : function(){\n        console.log('hi');\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 2. 里面的属性或者方法采取键值对的形式\n 3. 多个属性或者方法中间用逗号隔开\n 4. 方法后面跟的是一个匿名函数\n\n# 15.1.2 利用new Object创建对象\n\nvar obj = new Object();\nobj.uname = 'qww';\nobj.sayHi = function(){\n    console.log('hi');\n}\n\n\n1\n2\n3\n4\n5\n\n 1. 利用等号赋值的方法添加对象的属性和方法\n 2. 每个属性和方法之间用分号结束\n\n# 15.1.3 利用构造函数创建对象\n\n 1. 构造函数：把对象里相同的属性和方法抽象出来封装到函数里面\n 2. 语法规范\n\nfunction 构造函数名() {\n    this.属性 = 值;\n    this.方法 = function(){}\n}\nnew 构造函数名();\n\n\n1\n2\n3\n4\n5\n\n 3. 构造函数名字首字母大写\n 4. 构造函数不需要return就可以返回结果\n 5. 调用构造函数必须使用new\n 6. 属性和方法前面必须添加this\n 7. 对象是一个具体的事物，特指某一个；构造函数是一个大类，类似于其他语言的类\n 8. 利用构造函数创建对象的过程也叫对象的实例化\n\n\n# 15.2 使用对象\n\n# 15.2.1 调用对象属性\n\n 1. 对象名.属性名\n 2. 对象名['属性名']\n\n# 15.2.2 调用对象方法\n\n 1. 对象名.方法名()\n 2. 不能忘记添加小括号\n\n\n# 15.3 new关键字\n\n 1. new构造函数可以在内存中创建了一个空的对象\n 2. this指向刚才创建的空对象\n 3. 执行构造函数里面的代码，给空对象添加属性和方法\n 4. 返回这个对象（所以构造函数不需要return）\n\n\n# 15.4 遍历对象\n\n 1. for in语句可以对数组或者对象的属性进行循环操作\n 2. 语法\n\nfor (var k in obj) {\n    console.log(k); //输出的是属性名\n    console.log(obj[k]); //输出的属性值\n}\n\n\n1\n2\n3\n4\n\n\n\n# 15.5 ES5新增方法\n\n# 15.5.1 Object.definerProperty()\n\n 1. 定义对象中新属性或修改原有的属性\n 2. 语法Object.definerProperty(目标对象,属性名,descriptor)\n 3. descriptor表示目标属性所拥有的特性，需要以对象形式书写\n 4. descriptor四个属性\n    * value：设置属性的值，默认为undefined\n    * writable：值是否可以重写，默认为false\n    * enumerable：目标属性是否可以被枚举，默认为false，不允许该属性被遍历出来\n    * configurable：目标属性是否可以被删除或是否可以再次修改特性，默认为false\n\n\n# 16 内置对象\n\n 1. JS中对象分成3种：自定义对象、内置对象、浏览器对象\n 2. 内置对象：JS语言自带的一些对象，供开发者使用，并提供了一些常用的或是最基本的必要功能（属性和方法）\n\n\n# 16.1 Math内置对象\n\n 1. Math不是一个函数对象，不是一个构造器，不需要New来调用，而是直接使用\n\n# 16.1.1 Math常用属性和方法\n\n 1. Math.PI圆周率\n 2. Math.floor()向下取整\n 3. Math.ceil()向上取整\n 4. Math.round()四舍五入，就近取整，-3.5取-3\n 5. Math.abs()绝对值，可以隐式转换，会把字符串转换成数字型\n 6. Math.max/min()最大、最小值\n 7. Math.random()0~1的随机数\n\n\n# 16.2 日期内置对象\n\n 1. Date实例用来处理日期和时间\n 2. Date是一个构造函数，必须使用New调用\n\n# 16.2.1 使用Date\n\n 1. 语法var date = new Date();\n 2. 如果没有参数返回系统的当前时间\n\n# 16.2.2 参数常用写法\n\n 1. 数字型2021,03,09月份会多1，因为从0开始记录\n 2. 字符串型'2021-03-09 16:58:10' 常用\n\n# 16.2.3 日期格式化\n\n\n\n 1. 月份返回的会小1个月\n 2. 返回星期的时候，周日返回的是0\n\n# 16.2.4 获取时间戳\n\n 1. 时间戳是距离1970年1月1日的总毫秒数\n 2. Date.valueOf()\n 3. Date.getTime()\n 4. 可简化为var date1 = +new Date();，最常用的写法\n 5. H5新增的方法Date.now()\n\n\n# 17 基本包装类型\n\n 1. 基本包装类型就是把简单数据类型包装成为了复杂数据类型，使得简单数据类型有了属性和方法\n 2. 过程：\n    * 把简单数据类型包装为复杂数据类型\n    * 把临时变量的值给str\n    * 销毁临时变量\n 3. 为了方便操作基本数据类型，JavaScript提供了三个特殊的引用类型：String、Number和Boolean\n\n\n# 18 数据类型\n\n\n# 18.1 堆和栈\n\n其实JavaScript中没有堆和栈的概念，但可以方便理解代码的执行方式\n\n# 18.1.1 栈（操作系统）\n\n 1. 由操作系统自动分配释放存放函数的参数值、局部变量的值等\n 2. 其操作方式类似于数据结构中的栈\n 3. 简单数据类型存放在栈里面\n\n# 18.1.2 堆（操作系统）\n\n 1. 存储复杂类型（对象）\n 2. 一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收\n\n\n# 18.2 简单数据类型\n\n 1. 简单数据类型又叫作基本数据类型或者值类型\n 2. 值类型：在存储时变量中存储的是值本身\n 3. string、number、boolean、undefined、null\n 4. 简单数据类型null返回的是一个空对象\n\n# 18.2.1 简单数据类型内存分配\n\n 1. 简单数据类型存放在栈里面，里面直接开辟一个空间存放的是值\n\n\n# 18.3 复杂数据类型\n\n 1. 复杂数据类型又叫引用类型\n 2. 通过new关键字创建的对象（系统对象、自定义对象），如Object、Array、Date等\n\n# 18.3.1 复杂数据类型内存分配\n\n 1. 复杂数据类型首先在栈里存放地址，16进制\n 2. 然后栈中的地址指向堆里的数据\n\n\n# 19 面向对象\n\n\n# 19.1 面向对象编程介绍\n\n 1. 面向过程，POP(Process-oriented programming)。\n    * 分析出解决问题所需的步骤，然后用函数把步骤一步步实现，使用的时候再一个个依次调用\n    * 分析好步骤，按照步骤解决问题\n 2. 面向对象，OOP(Object Oriented Programming)\n    * 把事务分解成为一个个对象，然后由对象之间分工与合作\n    * 以对象功能划分问题，而不是步骤\n    * 特点：\n      * 封装性\n      * 继承性\n      * 多态性\n 3. 两者对比\n    * 面向过程 -1 优点：性能比面向对象高，适合跟硬件联系很紧密的东西\n      * 1缺点没：有面向对象易维护、易复用、易扩展\n    * 面向11对象\n      * 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，是系统更佳灵活\n      * 缺点：性能比面向过程低\n\n\n# 19.2 ES6中的类和对象\n\n# 19.2.1 面向对象的思维特点\n\n 1. 抽取（抽象）对象共用的属性和行为组织（封装）成一个类（模板）\n 2. 对类进行实例化，获取类的对象\n\n# 19.2.2 对象\n\n 1. 对象是一个具体的事物\n 2. 在JavaScript中，对象是一组无需的相关属性和方法的集合，所有的事物都是对象\n 3. 对象由属性和方法组成\n    * 属性：事物的特征，在对象中用属性来表示\n    * 方法：事物的行为，在对象中用方法来表示\n\n# 19.2.3 类class\n\n 1. ES6中新增了类的概念，可以使用class关键字声明一个类，之后以这个类来实例化对象\n 2. 类抽象了对象的公共部分，泛指某一大类\n 3. 对象特指某一个，通过类实例化一个具体的对象\n\n# 19.2.4 创建类\n\n 1. 语法class 类名{类内容}\n 2. 类名习惯首字母大写\n 3. 创建实例var 对象名 = new 类名();\n 4. 类必须使用new实例化对象\n\n# 19.2.5 类constructor构造函数\n\n 1. constructor()方法是类的构造函数，用于传递参数，返回实例对象\n 2. 通过new命令生成对象实例，自动调用该方法\n 3. 如果没有显示定义，类内部会自动给我们创建一个constructor()\n 4. 语法\n\nclass 类名 {\n    construction(形参){\n        实参赋值\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n 5. 构造函数不需要加function\n\n# 19.2.6 类添加方法\n\n 1. 把方法直接写在类里面即可\n 2. 类里面所有的函数不需要function\n 3. 在类里面所有函数之间不需要添加逗号\n\n# 19.2.7 类的继承\n\n 1. 子类可以继承父类的属性和方法\n 2. 语法class 子类名 extends 父类名{}\n 3. 继承中存在就近原则，子类有的方法直接调用，没有再去查找父类\n\n# super关键字\n\n 1. 用于访问和调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数\n 2. 语法super()调用父类construction构造函数\n 3. 语法super.父类方法()调用父类的函数函数\n 4. super()必须在子类this之前调用\n\n# 19.2.8 注意点\n\n 1. 在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象\n 2. 类里共有的属性和方法一定要加this使用\n 3. 类中this指向问题\n    * 在construction里面的this指向实例对象\n    * 方法里面的this指向这个方法的调用者\n\n\n# 20 构造函数和原型\n\n面试重点\n\n\n# 20.1 构造函数\n\n 1. 构造函数是一种特殊的函数，主要用来初始化对象。总和new一起使用\n 2. 构造函数用于创建某一类对象，其首字母大写\n 3. 构造函数要和new一起使用才有意义\n 4. new在执行时会做\n    1. 在内存中创建一个新的空对象\n    2. 让this指向这个新的对象\n    3. 执行构造函数里面的代码，给这个新对象添加属性和方法\n    4. 返回这个新对象（所以构造函数里面不需要return）\n 5. 成员：构造函数中的属性和方法\n 6. 静态成员：在构造函数本上添加的成员，只能由构造函数本身来访问。在构造函数本身上添加的成员\n 7. 实例成员：在构造函数内部创建的对象成员，只能由实例化的对象来访问。在构造函数内部通过this添加的成员\n 8. 构造函数存在内存浪费的问题，创建对象的时候会额外开辟空间以存放方法，且各对象同一方法不存放在一起\n\n\n# 20.2 构造函数原型 prototype\n\n 1. 构造函数通过原型分配的函数是所有对象所共享的\n 2. JavaScript规定，每一个构造函数都一个prototype属性，指向另一个对象。这个对象的所有属性和方法都会被构造函数所拥有\n 3. 我们可以把不变的方法直接定义在prototype对象上，这样所有的实例就可以共享这些方法\n\n\n# 20.3 对象原型__proto__\n\n 1. 对象都会有一个属性__proto__指向构造函数的prototype原型对象，这让对象可以使用构造函数原型对象的属性和方法\n 2. 对象的__proto__对象原型和构造函数的prototype原型对象是一样的\n 3. __proto__是一个非标准属性，不能对其赋值\n 4. 对象方法查找规则\n    1. 先查找对象是否存在该方法，有就执行对象上的方法\n    2. 通过__proto__去构造函数原型对象里查找执行\n\n\n# 20.4 构造函数constructor\n\n 1. 对象原型__proto__和构造函数prototype原型对象里面都有一个属性constructor，被称为构造函数，因为它指回构造函数本身\n 2. constructor用于记录该对象引用哪个构造函数，它可以让原型对象重新指向原来的构造函数\n 3. 如果修改了原来的原型对象，给原型对象幅值的是一个对象，则必须手动地使用constructor指回原来的构造函数\n\n\n# 20.5 构造函数、实例、原型对象三者之间的关系\n\n\n\n\n# 20.6 原型链\n\n\n\n\n# 20.7 成员的查找机制\n\n 1. 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性\n 2. 如果没有就查找它的原型（也就是__proto__指向的prototype原型对象）\n 3. 如果还没有就查找原型对象的原型（Object的原型对象）\n 4. 依次类推知道找到Object为止（null）\n\n\n# 20.8 原型对象this指向\n\n 1. 在构造函数中this指向对象实例\n 2. 原型对象里的this指向对象实例\n\n\n# 20.9 扩展内置对象\n\n 1. 通过原型对象，对原来的内置对象进行扩展自定义的方法\n 2. 数组和字符串内置对象不能给原型对象覆盖操作Array.prototype = {}，只能是Array.prototype.XXX = function(){}的方式\n\n\n# 21 继承\n\n 1. ES6之前没有给我们提供extends继承。通过构造函数+原型对象模拟实现继承，被称为组合继承\n\n\n# 21.1 call()\n\n 1. 调用这个函数，并且修改函数运行时的this指向\n 2. 语法fun.call(thisArg, arg1, arg2, ...)\n    * thisArg：当前调用函数this的指向对象\n    * arg1等：传递的其他参数\n\n\n# 21.2 借用构造函数继承父类型属性\n\n 1. 核心原理：通过call()把父类型的this指向子类型的this，这样就可以实现子类型继承父类型的属性\n 2. 语法\n\n//借用父构造函数继承属性\nfunction Father(uname, age) {\n    //此处的this指向父构造函数的对象实例\n    this.uname = uname;\n    this.age = age;\n}\nfunction Son(uname, age) {\n    //将父构造函数的this改成子构造函数的this\n    Father.call(this, uname, age);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 21.3 借用原型对象继承父类型方法\n\n 1. 继承方法不能通过赋值原型对象的方法实现，这样会导致本来只打算在子类型上新定义的方法会同步到父类型上\n 2. 语法\n\n//借用父构造函数继承属性\nfunction Father() {\n}\nFather.prototype.money = function(){\n    console.log(100000)\n}\nSon.prototype = new Father();\n//如果利用对象的形式修改了原型对象，要用constructor指回原来的构造函数\nSon.prototype.constructor = Son;\nfunction Son() {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 21.4 类的本质\n\n 1. class的本质还是一个函数，就是构造函数的另一种写法\n 2. 类有原型对象prototype\n 3. 类的原型对象prototype里有constructor指向类本身\n 4. 类可以通过原型对象的方式添加方法\n 5. 类创造的实例对象有__proto__指向类的原型对象\n 6. ES6类其实就是语法糖，简单写法实现相同功能\n\n\n# 22 严格模式\n\n 1. JavaScript除了提供正常模式外，还提供了严格模式(strict mode)。ES5的严格模式是采用具有限制性JavaScript辩题的一种方式\n 2. 严格模式作用\n    1. 消除了JavaScript语法的一些不合理、不严谨之处\n    2. 消除代码不安全之处\n    3. 提高编译器效率，增加运行速度\n    4. 禁用了ECMAScript的未来版本中可能会定义的一些语法，为新版本的JavaScript做好铺垫\n\n\n# 22.1 开启严格模式\n\n 1. 严格模式可以应用到整个脚本或个别函数中\n 2. 为脚本开启严格模式：在所有语句之前放一个特定语句'use strict'\n 3. 为函数开启严格模式：在函数里的第一行写一个特定语句'use strict'\n\n\n# 22.2 严格模式变化\n\n# 22.2.1 变量规定\n\n 1. 在严格模式下不声明无法赋值变量\n 2. 严禁删除已经声明的变量\n\n# 22.2.2 this指向\n\n 1. 以前在全局作用域函数中的this指向Windows对象\n 2. 严格模式下全局作用域中函数的this指向undefined\n 3. 以前构造函数不加new会当普通函数调用，严格模式下必须使用new\n\n# 22.2.3 函数变化\n\n 1. 函数不能有重名的参数\n 2. 函数必须声明在顶层。ES6会引入块级作用域\n\n\n# 23 正则表达式\n\n正则表达式是用于匹配字符串中字符组合的模式 JavaScript中正则表达式也是对象\n\n\n# 23.1 特点\n\n 1. 灵活性、逻辑性和功能性非常强\n 2. 可以迅速地用既简单的方式达到字符串的复杂控制\n\n\n# 23.2 创建正则表达式\n\n# 23.2.1 利用RegExp对象来创建\n\n 1. 语法var 变量名 = new RegExp(/表达式/)\n\n# 23.2.2 利用字面量创建\n\n 1. 语法var 变量名=/表达式/\n\n\n# 23.3 测试正则表达式\n\n 1. test()正则对象方法，用于检测字符串是否符合该规则\n 2. 语法正则表达式.test(被测试的文本)\n\n\n# 23.4 正则表达式中的特殊字符\n\n# 23.4.1 正则表达式的组成\n\n一个正则表达式可以由简单的字符构成，也可以是简单和特殊字符的组合 特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号 /abc/检测到包含'abc'的内容即可\n\n# 23.4.2 边界符\n\n 1. ^：表示匹配行首的文本\n 2. $：表示匹配行尾的文本\n 3. /^abc/检测到包含以'abc'的内容开头即可\n 4. /^abc$/检测到内容为'abc'才行\n\n# 23.4.3 字符类\n\n 1. 字符类[]表示有一系列字符可供选择，只要匹配其中一个就可以了\n 2. /[abc]/检测到包含'a'或'b'或'c'的内容即可\n 3. /^[abc]$/三选一，只有是a或者是b或者是c这三个字符才返回true\n 4. 字符组合/^[a-zA-Z0-9_-]$/可选择的内容扩展\n 5. 字符组合/^[^a-zA-Z0-9_-]$/如果中括号里面有^表示取反\n\n# 23.4.4 量词符\n\n 1. 量词符用来设定某个模式出现的次数\n 2. *：重复零次或更多次\n 3. +：重复一次或更多次\n 4. ?：重复零次或一次\n 5. {n}：重复n次\n 6. {n,}：重复n次或更多次\n 7. {n,m}：重复n到m次\n\n# 23.4.5 括号总结\n\n 1. 中括号：字符集合匹配\n 2. 大括号：量词符\n 3. 小括号：表示优先级\n\n# 23.4.6 预定义类\n\n预定义类值某些常见模式的简写方式\n\n 1. \\d：匹配0-9之间任一数字\n 2. \\D：匹配所有0-9意外的字符\n 3. \\w：匹配任意的字母、数字和下划线\n 4. \\W：除所有字母、数字和下划线以外的字符\n 5. \\s：匹配空格（包括换行符、制表符、空格符等）\n 6. \\S：匹配非空格的字符\n\n\n# 23.5 正则替换\n\n 1. replace()方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式\n\n# 23.5.1 正则表达式参数\n\n 1. 语法/表达式/[switch]\n 2. switch也称为修饰符，按照什么模式来匹配\n    * g：全局匹配\n    * i：忽略大小写\n    * gi：全局匹配+忽略大小写",normalizedContent:"# 1 js认知\n\n\n# 1.1 js组成\n\n 1. ecmascript，js语法\n 2. dom，页面文档对象模型\n 3. bom，浏览器对象模型\n\n\n# 1.2 js书写位置\n\n 1. 行内式\n    * 将单行或少量代买写在html标签的事件属性中（以on开头的属性）\n    * html中推荐使用双引号，js中推荐使用单引号\n 2. 内嵌式 <script><\/script>\n 3. 外部式 <script scr=\"my.js\"><\/script>\n\n\n# 1.3 js注释\n\n 1. 单行注释//（ctrl + /）\n 2. 多行注释/* */（shift + alt + a）\n\n\n# 2 输入输出语句\n\n\n# 2.1 alert\n\n 1. 弹出警示框\n 2. 语法 prompt('弹出的语句');\n\n\n# 2.2 console\n\n 1. 控制台输出，用于测试\n 2. 语法 console.log('输出的语句');\n\n\n# 2.3 dir\n\n 1. 语法console.dir(元素对象);\n 2. 打印dom返回的元素对象\n\n\n# 2.4 prompt\n\n 1. 弹出输入框\n 2. 语法 prompt('请用户输入的提示语句');\n 3. 输入进来的值是字符串类型\n\n\n# 3 变量\n\n变量用于存放数据，是内存中申请的一段空间\n\n\n# 3.1 变量的使用\n\n# 3.1.1 变量声明\n\n 1. var 变量名;\n 2. var是js关键字，用于声明变量。使用后计算机自动为变量分配内存空间，不需要程序员管\n\n# 3.1.2 变量赋值\n\n 1. 变量名 = 值;\n\n# 3.1.3 变量初始化\n\n 1. var 变量名 = 值;\n\n# 3.1.4 同时声明\n\nvar 变量名1 = 值,\n    变量2 = 值;\n\n\n1\n2\n\n\n# 3.1.5 可以不声明直接使用\n\n 1. 但是会变成全局变量\n\n\n# 3.2 变量命名规范\n\n 1. 由字母、数字、下划线、美元符号\n 2. 严格区分大小写\n 3. 不能以数字开头\n 4. 不能是关键字和保留字\n\n\n# 3.3 检测数据类型\n\ntypeof 待检测变量\n\n\n# 4 数字型number\n\n数字类型可以用来保存整数值，也可以保存浮点数\n\n\n# 4.1 整型\n\n\n# 4.2 浮点型\n\n\n# 4.3 数字型进制\n\n 1. 八进制：数字前+0\n 2. 16进制：数字前+0x\n\n\n# 4.4 数字范围\n\n 1. 最大值1.79e+308\n 2. 最小值5e-324\n\n\n# 4.5 特殊值\n\n 1. 无穷大：infinity\n 2. 无穷小：-infinity\n 3. 非数字：nan\n\n\n# 4.6 数字判断\n\n 1. isnan()判断是不是非数字\n\n\n# 4.7 其他类型转换成数字型\n\n 1. parseint(字符串型变量)变为整型\n    * 会去除数字之后的其他字符串\n    * 但是不能去除数字之前的字符串\n 2. parsefloat(字符串型变量)变为浮点型\n    * 会去除数字之后的其他字符串\n    * 但是不能去除数字之前的字符串\n 3. number(变量)\n 4. 利用算术运算隐式转换为数字型\n\n\n# 5 字符串型string\n\n推荐使用单引号\n\n\n# 5.1 字符串嵌套\n\n 1. 外单内双进行嵌套\n\n\n# 5.2 字符串转义符\n\n 1. 换行\\n\n 2. tab缩进\\t\n 3. 空格\\b\n\n\n# 5.3 字符串的拼接\n\n 1. 用+拼接\n 2. 只要有一个部分是字符串，输出都是字符串，和其他数据类型没关系\n 3. 变量可以直接把内容拼接到字符串里\n\n\n# 5.4 字符串常用方法\n\n字符串常用方法\n\n 1. 返回长度字符串名.length\n 2. 返回指定位置字符串内容字符串名.charat(位置索引)\n 3. 返回指定字符在字符串中首次出现的位置字符串名.indexof(查找的字符,起始的位置)\n 4. 判断子字符串的存在字符串.includes(子字符串)\n 5. 大小写转换字符串名.tolowercase()|字符串名.touppercase()\n\n\n# 5.5 其他类型转换成字符串\n\n 1. 变量.tostring()\n 2. string(变量)函数强制转换\n 3. 加号拼接\n\n\n# 5.6 字符串的不可变\n\n 1. 指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间\n 2. 因为字符串的不可变不要大量拼接字符串\n\n\n# 5.7 es5新增字符串方法\n\n# 5.7.1 trim()\n\n 1. 从字符串的两端删除空白字符\n 2. 语法str.trim()\n 3. 不影响原字符串本身，返回的是一个新的字符串\n\n\n# 6 布尔型boolean\n\n 1. true可以当1来看\n 2. false可以当0来看\n\n\n# 6.1 其他类型转换成布尔型\n\n 1. boolean(变量)\n 2. 代表空的''|0|nan|null|undefined转换成false\n 3. 其他都是true\n\n\n# 7 运算符\n\n运算符（operator）也称为操作符，用于实现赋值、比较和执行算术运算等功能的符号\n\n\n# 7.1 算数运算符\n\n\n\n 1. 浮点数存在阶段误差，不要判断浮点数是否相等\n 2. 算数运算符的优先级和平时一样\n\n\n# 7.2 递增递减运算符\n\n 1. ++递增，每次加1\n 2. --递减，每次减1\n 3. 前置递增|递减：运算符在变量前面，先计算后输出\n 4. 后置递增|递减：运算符在变量后面，先输出后计算\n\nvar age = 10\nconsole.log(++age + 10); //输出21，前置递增\nage = 10\nconsole.log(age++ + 10); //输出20，后置递增\n// 但是两个age都是11\n\n\n1\n2\n3\n4\n5\n\n\n\n# 7.3 比较运算符\n\n\n\n 1. ==比较的时候会自动转换数据类型\n 2. ===同时要求值和数据类型\n\nconsole.log(18 == '18'); //true\nconsole.log(18 === '18'); //false\n\n\n1\n2\n\n\n\n# 7.4 逻辑运算符\n\n\n\n 1. 短路运算：当有多个表达式时，左边表达式可以确定结果时就不再进行有右边的运算\n\n# 7.4.1 &&断路\n\n 1. 表达式1 && 表达式2\n 2. 表达式1真，返回表达式2\n 3. 表达式1假，返回表达式1\n\n# 7.4.2 ||断路\n\n 1. 表达式1 || 表达式2\n 2. 表达式1真，返回表达式1\n 3. 表达式1假，返回表达式2\n\n\n# 7.5 赋值运算符\n\n\n\n\n# 7.6 运算符优先级\n\n\n\n\n# 8 流程控制\n\n\n# 8.1 顺序流程控制\n\n直接写就好\n\n\n# 8.2 分支流程控制\n\n# 8.2.1 if\n\n 1. 语法结构\n\nif (条件表达式) {\n    条件成立时的执行语句\n}\n\n\n1\n2\n3\n\n\n# 8.2.2 if-else双分支\n\n 1. 语法结构\n\nif (条件表达式) {\n    条件成立时的执行语句\n} else{\n    条件不成立时的执行语句\n}\n\n\n1\n2\n3\n4\n5\n\n 2. if和else里只有一个语句能执行\n\n# 8.2.3 多分支语句\n\n 1. 语法结构\n\nif (条件表达式1) {\n    条件1成立时的执行语句\n} else if (条件表达式2){\n    条件1不成立条件3成立时的执行语句\n} else{\n    所有条件都不成立时的执行语句\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 8.2.4 三元表达式\n\n 1. 语法结构条件表达式 ? 表达式1 : 表达式2\n 2. 执行思路\n    * 条件表达式真，返回表达式1\n    * 条件表达式假，返回表达式2\n\n# 8.2.5 switch\n\n 1. 语法结构\n\nswitch (表达式) {\n    case value1:\n        表达式与value1匹配时的执行语句;\n        break;\n    case value2:\n        表达式与value2匹配时的执行语句;\n        break;\n    default:\n        都不满足时的执行语句;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 2. 匹配的要求是值和数据类型都相等才算匹配\n 3. 要写break，否则switch会认为一直是匹配上的直接执行后续case的执行语句\n\n\n# 8.3 循环流程控制\n\n# 8.3.1 for循环\n\n 1. 语法结构\n\nfor (初始化变量;条件表达式；操作表达式) {\n    循环体\n}\n\n\n1\n2\n3\n\n\n# 8.3.2 while循环\n\n 1. 语法结构\n\nwhile (条件表达式) {\n    循环体\n}\n\n\n1\n2\n3\n\n\n# 8.3.3 do-while循环\n\n 1. 语法结构\n\ndo {\n    循环体\n} while (条件表达式)\n\n\n1\n2\n3\n\n 2. 限制性循环体再判断条件\n\n# 8.3.4 continue\n\n 1. 立即跳出本次循环，继续下一次循环\n\n\n# 8.4 break\n\n 1. 立即跳出整个循环\n\n\n# 9 数组array\n\n\n# 9.1 创建数组\n\n# 9.1.1 new关键字创建数组\n\n 1. var 数组名 = new array();\n 2. 通过实例化array构造对象创建的\n 3. var 数组名 = new array(n);创建长度为n的空数组\n 4. var 数组名 = new array(x,y);创建[ x,y]数组\n\n# 9.1.2 利用数组字面量创建数组\n\n 1. 数组字面量[]\n 2. 语法var 数组名 = [];\n 3. 数组里的数据用逗号分隔\n 4. 数组里的数据称为数组元素\n\n\n# 9.2 数组索引\n\n 1. 索引（下标）：用来访问数组元素的序列，从0开始\n 2. 通过索引号访问数组元素数组名[索引号]\n 3. 没有数组元素，访问结果为undefined\n\n\n# 9.3 数组长度\n\n数组名.length\n\n\n# 9.4 数组新增元素\n\n# 9.4.1 修改length长度\n\n数组名.length = 5添加空元素\n\n# 9.4.2 增加索引号\n\n数组名[索引号] = 新加元素追加元素\n\n\n# 9.5 检测是否为数组\n\n# 9.5.1 instanceof 运算符\n\n 1. 语法待检测内容 instanceof array\n\n# 9.5.2 .isarray()\n\n 1. 语法array.isarray(待检测内容)\n 2. ie9以上版本才支持\n\n\n# 9.6 添加数组元素\n\n# 9.6.1 .push()\n\n 1. 在尾部添加一个或多个数组元素\n 2. 语法数组.push(添加的元素)\n 3. push完后返回的是新数组的长度\n 4. 原数组也会发生变化\n\n# 9.6.2 .unshift()\n\n 1. 在开头添加一个或多个数组元素\n 2. 语法数组.unshift(添加的元素)\n 3. unshift完后返回的是新数组的长度\n 4. 原数组也会发生变化\n\n\n# 9.7 删除数组元素\n\n# 9.7.1 .pop()\n\n 1. 删除数组最后的一个元素，一次只能删除一个元素\n 2. 语法数组.pop()\n 3. pop完后返回被删除的元素\n 4. 原数组也会发生变化\n\n# 9.7.2 .shift()\n\n 1. 删除数组第一个的一个元素，一次只能删除一个元素\n 2. 语法数组.shift()\n 3. shift完后返回被删除的元素\n 4. 原数组也会发生变化\n\n\n# 9.8 数组排序\n\n# 9.8.1 .reverse()\n\n 1. 翻转数组\n 2. 语法数组.reverse()\n\n# 9.8.2 .sort()\n\n 1. 冒泡排序\n 2. 语法数组.sort()\n 3. 这样排序是先看按照最高位排序，再按后面的位数排序，个位数可以用\n 4. \n\n数组.sort(function(a,b){\n    // 按照升序排序\n    return a-b;\n    // 按照降序排序\n    return b-a;\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 9.9 数组索引\n\n# 9.9.1 .indexof()\n\n 1. 查找数组中给定元素的第一个索引\n 2. 不存在返回-1\n 3. 语法数组名.indexof(元素名,查找起始位置)\n\n# 9.9.2 .lastindexof()\n\n 1. 查找数组中给定元素的最后一个索引\n 2. 不存在返回-1\n 3. 语法``数组名.lastindexof(元素名)`\n\n\n# 9.10 数组转换成字符串\n\n# 9.10.1 tostring()\n\n 1. 把数组转换成字符串，逗号分隔每一项\n\n\n# 9.10.2 join('分隔符')\n\n 1. 把数组中的所有元素转换为一个字符串\n 2. 分隔符默认为逗号\n\n\n# 9.11 数组切割\n\n# 9.11.1 .concat()\n\n 1. 连接两个或多个数组\n 2. 返回新数组\n 3. 不影响原数组\n\n# 9.11.2 .slice()\n\n 1. 截取数组\n 2. 返回新数组\n 3. 语法数组名.slice(开始缩印,结束索引)\n\n# 9.11.3 .splice()\n\n 1. 删除数组内元素\n 2. 返回被删除的新数组\n 3. 会影响原数组\n\n\n# 9.12 es5数组新增方法\n\n# 9.12.1 遍历方法\n\n# foreach()\n\n 1. 语法数值名.foreach(function(value,index,array){})\n 2. value：数组当前项的值\n 3. index：数组当前项的索引\n 4. array：被遍历的数组本身\n 5. 在foreach里面return不会终止迭代\n\n# filter()\n\n 1. 语法数值名.filter(function(value,index,array){})\n 2. filter方法用于创建一个新的数组，新数组中的元素是通过检测指定数组中符合条件的所有元素，主要用于筛选数组\n 3. 返回的是一个新数组\n\n# some()\n\n 1. 语法数值名.some(function(value,index,array){})\n 2. some方法用于检测数组中断额元素是否满足指定条件\n 3. 返回的是一个布尔值。如果查到这个元素，就返回true；如果查不到就返回false\n 4. 如果找到第一个满足条件的元素，则终止循环，不再继续查找\n 5. 在some里面return true会终止迭代\n\n\n# 10 函数\n\n 1. 函数：封装了可被调用实行的代码块\n\n\n# 10.1 函数的使用\n\n# 10.1.1 声明函数\n\n# 利用函数关键字声明（命名函数）\n\n 1. 语法function 函数名(形参){}\n 2. function是声明函数的关键字\n 3. 函数名一般是动词\n\n# 函数表达式声明（匿名函数）\n\n 1. 语法var 变量名 = function(形参){}\n\n# 通过构造函数生命\n\n 1. 语法var 函数名 = new function('形参','函数体')\n 2. 所有函数都是function的实例（对象）\n 3. function里面参数都必须是字符串格式\n 4. 执行效率低，也不方便书写，较少使用\n\n# 10.1.2 调用函数\n\n# 普通函数\n\n 1. 语法函数名();\n 2. 语法函数名.call()\n\n# 对象里的方法\n\n 1. 语法对象.函数名()\n\n# 构造函数\n\n 1. 语法new 构造函数名()\n\n# 绑定事件函数\n\n 1. 触发事件自动调用\n\n# 定时器函数\n\n 1. 定时器自动调用\n\n# 立即执行函数\n\n 1. (function(){})()自动调用\n\n\n# 10.2 函数的参数\n\n# 10.2.1 形参\n\n 1. 函数声明的是形参\n 2. 语法function 函数名(形参1,形参2):{}\n 3. 是一种不用声明的变量\n 4. 形参不赋值时默认为undefined\n\n# 10.2.2 实参\n\n 1. 调用函数的是实参\n 2. 语法函数名(实参1,实参2);\n\n# 10.2.3 实参形参的关系\n\n 1. 形参接受实参的数值\n 2. 形参和实参可以不匹配\n 3. 实参个数多于形参个数，后面的实参直接抛弃\n\n\n# 10.3 函数返回\n\n 1. 语法return 需要返回的结果;\n 2. return具有终止函数的功能\n 3. return只能返回一个值，如果多个值返回最后一个值\n 4. 函数如果没有return，则返回undefined\n\n\n# 10.4 arguments\n\n 1. arguments是当前函数的内置对象，存储了传递的所有实参\n 2. 语法\n\nfunction 函数名():{\n    console.log(arguments)\n    }\n\n\n1\n2\n3\n\n 3. arguments展示形参为一个伪数组\n    * 可以遍历\n    * 具有length属性\n    * 按索引方式储存数据\n    * 不具有数组的push、pop等方法\n 4. 只有函数有arguments对象\n\n\n# 10.5 函数的this\n\n 1. this的指向是当我们调用函数的时候确定的\n 2. 一般指向调用者\n 3. 构造函数里的this和构造函数原型对象里的this都指向生成的实例对象\n\n# 10.5.1 call()\n\n 1. 可以调用函数\n 2. 改变this指向\n 3. 语法函数名.call(this指向,实参)\n 4. 主要作用是实现继承。在子构造函数里用call调用父构造函数父构造函数名.call(this,参数)\n\n# 10.5.2 apply()\n\n 1. 可以调用函数，也可以改变this指向\n 2. 语法函数名.apply(this指向,[实参])\n 3. 实参的传递必须使用数组的方式\n 4. 可以实现数组最大最小值的实现math.max.apply(math,数组)\n\n# 10.5.3 bind()\n\n 1. 不会调用函数，但能改变函数内部this指向\n 2. 语法函数名.bind(this指向,实参)\n 3. 返回由指定的this值和初始化参数改造的原函数拷贝\n 4. 应用场景：有的函数不需要立即调用，但又想改变函数内部this指向\n\n\n# 10.6 高阶函数\n\n 1. 高阶函数是对其他函数进行操作的含糊，它接收函数作为参数或将函数作为返回值输出\n\n\n# 11 作用域\n\n\n# 11.1 作用域概述\n\n 1. 作用域：限定代码中用到的名字可用性的代码范围\n 2. 作用域的目的是提高程序的可靠性，减少命名冲突\n 3. 作用域分为全局作用域和局部作用域\n 4. 全局作用域：整个scrip标签或者一个单独的js文件\n 5. 局部作用域：只在函数内部，也可以叫做函数作用域\n 6. 不同作用域下命名不冲突\n\n\n# 11.2 变量的作用域\n\n# 11.2.1 全局变量\n\n 1. 在全局作用域下的变量\n 2. 除了全局状态下声明变量还有在函数内部不声明直接赋值的变量也是全局变量\n\n# 11.2.2 局部变量\n\n 1. 在局部作用域下的变量\n 2. 只能在函数内部使用\n 3. 函数的形参也可以看作局部变量\n\n# 11.2.3 全局效率\n\n 1. 全局变量只有浏览器关闭的时候才会销毁，比较占内存资源\n 2. 局部变量程序执行完毕就会销毁，比较节约内容资源\n\n\n# 11.3 块级作用域\n\n 1. 目前js没有块级作用域\n 2. 在es6时新增了块级作用域\n 3. 块级作用域：用{}包含的\n\n\n# 11.4 作用域链\n\n 1. 内部函数访问外部函数的变量采取的是链式查找的方式来决定是哪个值\n 2. 作用域链：这种链式查找方式结构\n 3. 就近原则\n\n\n# 12 闭包\n\n\n# 12.1 变量作用域\n\n 1. 函数内部可以使用全局变量\n 2. 函数外部不可以使用局部变量\n 3. 当函数执行完毕，本作用域内的局部变量会销毁\n\n\n# 12.2 闭包定义\n\n 1. 闭包(closure)指有权访问另一个函数作用域中变量的函数\n\n\n# 12.3 闭包作用\n\n 1. 延伸了变量的作用范围\n\n\n# 13 拷贝\n\n 1. 浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用，只拷贝地址\n 2. 深拷贝拷贝多层，每一个级别的数据都会拷贝\n\n\n# 13.1 浅拷贝\n\n 1. es6新语法object.assign(用于存储的变量名,被拷贝的变量名)\n\n\n# 13.2 深拷贝\n\n 1. 通过递归函数来进行深拷贝\n\nfunction deepcopy(newobj,oldobj){\n    for(var k in oldobj){\n        var item = oldobj[k];\n        if(item instanceof array){\n            newobj[k] = [];\n            deepcopy(newobj[k],item);\n        }else if(item instanceof object){\n            newobj[k] = {};\n            deepcopy(newobj[k],item);\n        }else{\n            newobj[k] = item;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 14 预解析\n\n\n# 14.1 js代码运行\n\n 1. 预解析：js引擎会把里面所有的var还有function提升到当前作用域的最前面\n 2. 代码执行：按照代码书写的顺序从上往下执行\n\n\n# 14.2 变量预解析\n\n 1. 变量预解析又叫变量提升\n 2. 只提升变量声明不提升赋值操作\n\n\n# 14.3 函数预解析\n\n 1. 函数预解析又叫函数提升\n 2. 只提升函数声明不调用\n 3. 函数预解析只适用于用函数关键字声明的情况\n\n\n# 15 对象\n\n 1. 对象是一组无需的相关属性和方法的集合\n 2. 属性：事物的特征\n 3. 方法：事物的行为\n\n\n# 15.1 创建对象\n\n# 15.1.1 利用字面量创建对象\n\n 1. 对象字面量为{}\n\nvar obj = {\n    //属性\n    uname = 'qww', \n    //方法\n    sayhi : function(){\n        console.log('hi');\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 2. 里面的属性或者方法采取键值对的形式\n 3. 多个属性或者方法中间用逗号隔开\n 4. 方法后面跟的是一个匿名函数\n\n# 15.1.2 利用new object创建对象\n\nvar obj = new object();\nobj.uname = 'qww';\nobj.sayhi = function(){\n    console.log('hi');\n}\n\n\n1\n2\n3\n4\n5\n\n 1. 利用等号赋值的方法添加对象的属性和方法\n 2. 每个属性和方法之间用分号结束\n\n# 15.1.3 利用构造函数创建对象\n\n 1. 构造函数：把对象里相同的属性和方法抽象出来封装到函数里面\n 2. 语法规范\n\nfunction 构造函数名() {\n    this.属性 = 值;\n    this.方法 = function(){}\n}\nnew 构造函数名();\n\n\n1\n2\n3\n4\n5\n\n 3. 构造函数名字首字母大写\n 4. 构造函数不需要return就可以返回结果\n 5. 调用构造函数必须使用new\n 6. 属性和方法前面必须添加this\n 7. 对象是一个具体的事物，特指某一个；构造函数是一个大类，类似于其他语言的类\n 8. 利用构造函数创建对象的过程也叫对象的实例化\n\n\n# 15.2 使用对象\n\n# 15.2.1 调用对象属性\n\n 1. 对象名.属性名\n 2. 对象名['属性名']\n\n# 15.2.2 调用对象方法\n\n 1. 对象名.方法名()\n 2. 不能忘记添加小括号\n\n\n# 15.3 new关键字\n\n 1. new构造函数可以在内存中创建了一个空的对象\n 2. this指向刚才创建的空对象\n 3. 执行构造函数里面的代码，给空对象添加属性和方法\n 4. 返回这个对象（所以构造函数不需要return）\n\n\n# 15.4 遍历对象\n\n 1. for in语句可以对数组或者对象的属性进行循环操作\n 2. 语法\n\nfor (var k in obj) {\n    console.log(k); //输出的是属性名\n    console.log(obj[k]); //输出的属性值\n}\n\n\n1\n2\n3\n4\n\n\n\n# 15.5 es5新增方法\n\n# 15.5.1 object.definerproperty()\n\n 1. 定义对象中新属性或修改原有的属性\n 2. 语法object.definerproperty(目标对象,属性名,descriptor)\n 3. descriptor表示目标属性所拥有的特性，需要以对象形式书写\n 4. descriptor四个属性\n    * value：设置属性的值，默认为undefined\n    * writable：值是否可以重写，默认为false\n    * enumerable：目标属性是否可以被枚举，默认为false，不允许该属性被遍历出来\n    * configurable：目标属性是否可以被删除或是否可以再次修改特性，默认为false\n\n\n# 16 内置对象\n\n 1. js中对象分成3种：自定义对象、内置对象、浏览器对象\n 2. 内置对象：js语言自带的一些对象，供开发者使用，并提供了一些常用的或是最基本的必要功能（属性和方法）\n\n\n# 16.1 math内置对象\n\n 1. math不是一个函数对象，不是一个构造器，不需要new来调用，而是直接使用\n\n# 16.1.1 math常用属性和方法\n\n 1. math.pi圆周率\n 2. math.floor()向下取整\n 3. math.ceil()向上取整\n 4. math.round()四舍五入，就近取整，-3.5取-3\n 5. math.abs()绝对值，可以隐式转换，会把字符串转换成数字型\n 6. math.max/min()最大、最小值\n 7. math.random()0~1的随机数\n\n\n# 16.2 日期内置对象\n\n 1. date实例用来处理日期和时间\n 2. date是一个构造函数，必须使用new调用\n\n# 16.2.1 使用date\n\n 1. 语法var date = new date();\n 2. 如果没有参数返回系统的当前时间\n\n# 16.2.2 参数常用写法\n\n 1. 数字型2021,03,09月份会多1，因为从0开始记录\n 2. 字符串型'2021-03-09 16:58:10' 常用\n\n# 16.2.3 日期格式化\n\n\n\n 1. 月份返回的会小1个月\n 2. 返回星期的时候，周日返回的是0\n\n# 16.2.4 获取时间戳\n\n 1. 时间戳是距离1970年1月1日的总毫秒数\n 2. date.valueof()\n 3. date.gettime()\n 4. 可简化为var date1 = +new date();，最常用的写法\n 5. h5新增的方法date.now()\n\n\n# 17 基本包装类型\n\n 1. 基本包装类型就是把简单数据类型包装成为了复杂数据类型，使得简单数据类型有了属性和方法\n 2. 过程：\n    * 把简单数据类型包装为复杂数据类型\n    * 把临时变量的值给str\n    * 销毁临时变量\n 3. 为了方便操作基本数据类型，javascript提供了三个特殊的引用类型：string、number和boolean\n\n\n# 18 数据类型\n\n\n# 18.1 堆和栈\n\n其实javascript中没有堆和栈的概念，但可以方便理解代码的执行方式\n\n# 18.1.1 栈（操作系统）\n\n 1. 由操作系统自动分配释放存放函数的参数值、局部变量的值等\n 2. 其操作方式类似于数据结构中的栈\n 3. 简单数据类型存放在栈里面\n\n# 18.1.2 堆（操作系统）\n\n 1. 存储复杂类型（对象）\n 2. 一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收\n\n\n# 18.2 简单数据类型\n\n 1. 简单数据类型又叫作基本数据类型或者值类型\n 2. 值类型：在存储时变量中存储的是值本身\n 3. string、number、boolean、undefined、null\n 4. 简单数据类型null返回的是一个空对象\n\n# 18.2.1 简单数据类型内存分配\n\n 1. 简单数据类型存放在栈里面，里面直接开辟一个空间存放的是值\n\n\n# 18.3 复杂数据类型\n\n 1. 复杂数据类型又叫引用类型\n 2. 通过new关键字创建的对象（系统对象、自定义对象），如object、array、date等\n\n# 18.3.1 复杂数据类型内存分配\n\n 1. 复杂数据类型首先在栈里存放地址，16进制\n 2. 然后栈中的地址指向堆里的数据\n\n\n# 19 面向对象\n\n\n# 19.1 面向对象编程介绍\n\n 1. 面向过程，pop(process-oriented programming)。\n    * 分析出解决问题所需的步骤，然后用函数把步骤一步步实现，使用的时候再一个个依次调用\n    * 分析好步骤，按照步骤解决问题\n 2. 面向对象，oop(object oriented programming)\n    * 把事务分解成为一个个对象，然后由对象之间分工与合作\n    * 以对象功能划分问题，而不是步骤\n    * 特点：\n      * 封装性\n      * 继承性\n      * 多态性\n 3. 两者对比\n    * 面向过程 -1 优点：性能比面向对象高，适合跟硬件联系很紧密的东西\n      * 1缺点没：有面向对象易维护、易复用、易扩展\n    * 面向11对象\n      * 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，是系统更佳灵活\n      * 缺点：性能比面向过程低\n\n\n# 19.2 es6中的类和对象\n\n# 19.2.1 面向对象的思维特点\n\n 1. 抽取（抽象）对象共用的属性和行为组织（封装）成一个类（模板）\n 2. 对类进行实例化，获取类的对象\n\n# 19.2.2 对象\n\n 1. 对象是一个具体的事物\n 2. 在javascript中，对象是一组无需的相关属性和方法的集合，所有的事物都是对象\n 3. 对象由属性和方法组成\n    * 属性：事物的特征，在对象中用属性来表示\n    * 方法：事物的行为，在对象中用方法来表示\n\n# 19.2.3 类class\n\n 1. es6中新增了类的概念，可以使用class关键字声明一个类，之后以这个类来实例化对象\n 2. 类抽象了对象的公共部分，泛指某一大类\n 3. 对象特指某一个，通过类实例化一个具体的对象\n\n# 19.2.4 创建类\n\n 1. 语法class 类名{类内容}\n 2. 类名习惯首字母大写\n 3. 创建实例var 对象名 = new 类名();\n 4. 类必须使用new实例化对象\n\n# 19.2.5 类constructor构造函数\n\n 1. constructor()方法是类的构造函数，用于传递参数，返回实例对象\n 2. 通过new命令生成对象实例，自动调用该方法\n 3. 如果没有显示定义，类内部会自动给我们创建一个constructor()\n 4. 语法\n\nclass 类名 {\n    construction(形参){\n        实参赋值\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n 5. 构造函数不需要加function\n\n# 19.2.6 类添加方法\n\n 1. 把方法直接写在类里面即可\n 2. 类里面所有的函数不需要function\n 3. 在类里面所有函数之间不需要添加逗号\n\n# 19.2.7 类的继承\n\n 1. 子类可以继承父类的属性和方法\n 2. 语法class 子类名 extends 父类名{}\n 3. 继承中存在就近原则，子类有的方法直接调用，没有再去查找父类\n\n# super关键字\n\n 1. 用于访问和调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数\n 2. 语法super()调用父类construction构造函数\n 3. 语法super.父类方法()调用父类的函数函数\n 4. super()必须在子类this之前调用\n\n# 19.2.8 注意点\n\n 1. 在es6中类没有变量提升，所以必须先定义类，才能通过类实例化对象\n 2. 类里共有的属性和方法一定要加this使用\n 3. 类中this指向问题\n    * 在construction里面的this指向实例对象\n    * 方法里面的this指向这个方法的调用者\n\n\n# 20 构造函数和原型\n\n面试重点\n\n\n# 20.1 构造函数\n\n 1. 构造函数是一种特殊的函数，主要用来初始化对象。总和new一起使用\n 2. 构造函数用于创建某一类对象，其首字母大写\n 3. 构造函数要和new一起使用才有意义\n 4. new在执行时会做\n    1. 在内存中创建一个新的空对象\n    2. 让this指向这个新的对象\n    3. 执行构造函数里面的代码，给这个新对象添加属性和方法\n    4. 返回这个新对象（所以构造函数里面不需要return）\n 5. 成员：构造函数中的属性和方法\n 6. 静态成员：在构造函数本上添加的成员，只能由构造函数本身来访问。在构造函数本身上添加的成员\n 7. 实例成员：在构造函数内部创建的对象成员，只能由实例化的对象来访问。在构造函数内部通过this添加的成员\n 8. 构造函数存在内存浪费的问题，创建对象的时候会额外开辟空间以存放方法，且各对象同一方法不存放在一起\n\n\n# 20.2 构造函数原型 prototype\n\n 1. 构造函数通过原型分配的函数是所有对象所共享的\n 2. javascript规定，每一个构造函数都一个prototype属性，指向另一个对象。这个对象的所有属性和方法都会被构造函数所拥有\n 3. 我们可以把不变的方法直接定义在prototype对象上，这样所有的实例就可以共享这些方法\n\n\n# 20.3 对象原型__proto__\n\n 1. 对象都会有一个属性__proto__指向构造函数的prototype原型对象，这让对象可以使用构造函数原型对象的属性和方法\n 2. 对象的__proto__对象原型和构造函数的prototype原型对象是一样的\n 3. __proto__是一个非标准属性，不能对其赋值\n 4. 对象方法查找规则\n    1. 先查找对象是否存在该方法，有就执行对象上的方法\n    2. 通过__proto__去构造函数原型对象里查找执行\n\n\n# 20.4 构造函数constructor\n\n 1. 对象原型__proto__和构造函数prototype原型对象里面都有一个属性constructor，被称为构造函数，因为它指回构造函数本身\n 2. constructor用于记录该对象引用哪个构造函数，它可以让原型对象重新指向原来的构造函数\n 3. 如果修改了原来的原型对象，给原型对象幅值的是一个对象，则必须手动地使用constructor指回原来的构造函数\n\n\n# 20.5 构造函数、实例、原型对象三者之间的关系\n\n\n\n\n# 20.6 原型链\n\n\n\n\n# 20.7 成员的查找机制\n\n 1. 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性\n 2. 如果没有就查找它的原型（也就是__proto__指向的prototype原型对象）\n 3. 如果还没有就查找原型对象的原型（object的原型对象）\n 4. 依次类推知道找到object为止（null）\n\n\n# 20.8 原型对象this指向\n\n 1. 在构造函数中this指向对象实例\n 2. 原型对象里的this指向对象实例\n\n\n# 20.9 扩展内置对象\n\n 1. 通过原型对象，对原来的内置对象进行扩展自定义的方法\n 2. 数组和字符串内置对象不能给原型对象覆盖操作array.prototype = {}，只能是array.prototype.xxx = function(){}的方式\n\n\n# 21 继承\n\n 1. es6之前没有给我们提供extends继承。通过构造函数+原型对象模拟实现继承，被称为组合继承\n\n\n# 21.1 call()\n\n 1. 调用这个函数，并且修改函数运行时的this指向\n 2. 语法fun.call(thisarg, arg1, arg2, ...)\n    * thisarg：当前调用函数this的指向对象\n    * arg1等：传递的其他参数\n\n\n# 21.2 借用构造函数继承父类型属性\n\n 1. 核心原理：通过call()把父类型的this指向子类型的this，这样就可以实现子类型继承父类型的属性\n 2. 语法\n\n//借用父构造函数继承属性\nfunction father(uname, age) {\n    //此处的this指向父构造函数的对象实例\n    this.uname = uname;\n    this.age = age;\n}\nfunction son(uname, age) {\n    //将父构造函数的this改成子构造函数的this\n    father.call(this, uname, age);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 21.3 借用原型对象继承父类型方法\n\n 1. 继承方法不能通过赋值原型对象的方法实现，这样会导致本来只打算在子类型上新定义的方法会同步到父类型上\n 2. 语法\n\n//借用父构造函数继承属性\nfunction father() {\n}\nfather.prototype.money = function(){\n    console.log(100000)\n}\nson.prototype = new father();\n//如果利用对象的形式修改了原型对象，要用constructor指回原来的构造函数\nson.prototype.constructor = son;\nfunction son() {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 21.4 类的本质\n\n 1. class的本质还是一个函数，就是构造函数的另一种写法\n 2. 类有原型对象prototype\n 3. 类的原型对象prototype里有constructor指向类本身\n 4. 类可以通过原型对象的方式添加方法\n 5. 类创造的实例对象有__proto__指向类的原型对象\n 6. es6类其实就是语法糖，简单写法实现相同功能\n\n\n# 22 严格模式\n\n 1. javascript除了提供正常模式外，还提供了严格模式(strict mode)。es5的严格模式是采用具有限制性javascript辩题的一种方式\n 2. 严格模式作用\n    1. 消除了javascript语法的一些不合理、不严谨之处\n    2. 消除代码不安全之处\n    3. 提高编译器效率，增加运行速度\n    4. 禁用了ecmascript的未来版本中可能会定义的一些语法，为新版本的javascript做好铺垫\n\n\n# 22.1 开启严格模式\n\n 1. 严格模式可以应用到整个脚本或个别函数中\n 2. 为脚本开启严格模式：在所有语句之前放一个特定语句'use strict'\n 3. 为函数开启严格模式：在函数里的第一行写一个特定语句'use strict'\n\n\n# 22.2 严格模式变化\n\n# 22.2.1 变量规定\n\n 1. 在严格模式下不声明无法赋值变量\n 2. 严禁删除已经声明的变量\n\n# 22.2.2 this指向\n\n 1. 以前在全局作用域函数中的this指向windows对象\n 2. 严格模式下全局作用域中函数的this指向undefined\n 3. 以前构造函数不加new会当普通函数调用，严格模式下必须使用new\n\n# 22.2.3 函数变化\n\n 1. 函数不能有重名的参数\n 2. 函数必须声明在顶层。es6会引入块级作用域\n\n\n# 23 正则表达式\n\n正则表达式是用于匹配字符串中字符组合的模式 javascript中正则表达式也是对象\n\n\n# 23.1 特点\n\n 1. 灵活性、逻辑性和功能性非常强\n 2. 可以迅速地用既简单的方式达到字符串的复杂控制\n\n\n# 23.2 创建正则表达式\n\n# 23.2.1 利用regexp对象来创建\n\n 1. 语法var 变量名 = new regexp(/表达式/)\n\n# 23.2.2 利用字面量创建\n\n 1. 语法var 变量名=/表达式/\n\n\n# 23.3 测试正则表达式\n\n 1. test()正则对象方法，用于检测字符串是否符合该规则\n 2. 语法正则表达式.test(被测试的文本)\n\n\n# 23.4 正则表达式中的特殊字符\n\n# 23.4.1 正则表达式的组成\n\n一个正则表达式可以由简单的字符构成，也可以是简单和特殊字符的组合 特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号 /abc/检测到包含'abc'的内容即可\n\n# 23.4.2 边界符\n\n 1. ^：表示匹配行首的文本\n 2. $：表示匹配行尾的文本\n 3. /^abc/检测到包含以'abc'的内容开头即可\n 4. /^abc$/检测到内容为'abc'才行\n\n# 23.4.3 字符类\n\n 1. 字符类[]表示有一系列字符可供选择，只要匹配其中一个就可以了\n 2. /[abc]/检测到包含'a'或'b'或'c'的内容即可\n 3. /^[abc]$/三选一，只有是a或者是b或者是c这三个字符才返回true\n 4. 字符组合/^[a-za-z0-9_-]$/可选择的内容扩展\n 5. 字符组合/^[^a-za-z0-9_-]$/如果中括号里面有^表示取反\n\n# 23.4.4 量词符\n\n 1. 量词符用来设定某个模式出现的次数\n 2. *：重复零次或更多次\n 3. +：重复一次或更多次\n 4. ?：重复零次或一次\n 5. {n}：重复n次\n 6. {n,}：重复n次或更多次\n 7. {n,m}：重复n到m次\n\n# 23.4.5 括号总结\n\n 1. 中括号：字符集合匹配\n 2. 大括号：量词符\n 3. 小括号：表示优先级\n\n# 23.4.6 预定义类\n\n预定义类值某些常见模式的简写方式\n\n 1. \\d：匹配0-9之间任一数字\n 2. \\d：匹配所有0-9意外的字符\n 3. \\w：匹配任意的字母、数字和下划线\n 4. \\w：除所有字母、数字和下划线以外的字符\n 5. \\s：匹配空格（包括换行符、制表符、空格符等）\n 6. \\s：匹配非空格的字符\n\n\n# 23.5 正则替换\n\n 1. replace()方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式\n\n# 23.5.1 正则表达式参数\n\n 1. 语法/表达式/[switch]\n 2. switch也称为修饰符，按照什么模式来匹配\n    * g：全局匹配\n    * i：忽略大小写\n    * gi：全局匹配+忽略大小写",charsets:{cjk:!0}},{title:"简介",frontmatter:{title:"简介",date:"2022-06-27T20:53:33.000Z",permalink:"/pages/9503d3/",categories:["《JavaScript》","《现代JavaScript教程》","JavaScript编程语言"],tags:["JavaScript"]},regularPath:"/%E3%80%8AJavaScript%E3%80%8B/02.%E3%80%8A%E7%8E%B0%E4%BB%A3JavaScript%E6%95%99%E7%A8%8B%E3%80%8B/00.%20JavaScript%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/00.%20%E7%AE%80%E4%BB%8B.html",relativePath:"《JavaScript》/02.《现代JavaScript教程》/00. JavaScript编程语言/00. 简介.md",key:"v-598358ac",path:"/pages/9503d3/",headers:[{level:2,title:"1.1 JavaScript简介",slug:"_1-1-javascript简介",normalizedTitle:"1.1 javascript简介",charIndex:2},{level:3,title:"1.1.1 JavaScript特性",slug:"_1-1-1-javascript特性",normalizedTitle:"1.1.1 javascript特性",charIndex:23},{level:4,title:"JavaScript 引擎",slug:"javascript-引擎",normalizedTitle:"javascript 引擎",charIndex:197},{level:4,title:"JavaScript独特性",slug:"javascript独特性",normalizedTitle:"javascript独特性",charIndex:370},{level:3,title:"1.1.2 浏览器中的JavaScript",slug:"_1-1-2-浏览器中的javascript",normalizedTitle:"1.1.2 浏览器中的javascript",charIndex:480},{level:4,title:"浏览器中JavaScript功能",slug:"浏览器中javascript功能",normalizedTitle:"浏览器中javascript功能",charIndex:583},{level:4,title:"浏览器中JavaScript限制",slug:"浏览器中javascript限制",normalizedTitle:"浏览器中javascript限制",charIndex:816},{level:3,title:"1.1.3 JavaScript的上层语言",slug:"_1-1-3-javascript的上层语言",normalizedTitle:"1.1.3 javascript的上层语言",charIndex:1078},{level:3,title:"1.1.4 总结",slug:"_1-1-4-总结",normalizedTitle:"1.1.4 总结",charIndex:1614}],headersStr:"1.1 JavaScript简介 1.1.1 JavaScript特性 JavaScript 引擎 JavaScript独特性 1.1.2 浏览器中的JavaScript 浏览器中JavaScript功能 浏览器中JavaScript限制 1.1.3 JavaScript的上层语言 1.1.4 总结",content:"# 1.1 JavaScript简介\n\n\n# 1.1.1 JavaScript特性\n\nJavaScript是一种脚本语言，以纯文本形式提供和执行，不需要特殊的准备或编译即可运行\nJavaScript可以被直接写在网页的HTML中，在页面加载时自动执行\nECMAScript是JavaScript的语言规范\nJavaScript 不仅可以在浏览器中执行，也可以在服务端执行，甚至可以在任意搭载了 JavaScript 引擎 的设备中执行\n\n# JavaScript 引擎\n\n * 有时也称作“JavaScript 虚拟机”\n * 不同的引擎有不同的“代号”\n * 引擎的工作流程\n   1. 引擎（如果是浏览器，则引擎被嵌入在其中）读取（“解析”）脚本\n   2. 引擎将脚本转化（“编译”）为机器语言\n   3. 机器代码快速地执行\n\n# JavaScript独特性\n\nJavaScript 是将这三件事结合在一起的唯一的浏览器技术\n\n 1. 与 HTML/CSS 完全集成\n 2. 简单的事，简单地完成\n 3. 被所有的主流浏览器支持，并且默认开启\n\n\n# 1.1.2 浏览器中的JavaScript\n\nJavaScript 的能力很大程度上取决于它运行的环境。例如，Node.js 支持允许 JavaScript 读取/写入任意文件，执行网络请求等的函数\n\n# 浏览器中JavaScript功能\n\n浏览器中的 JavaScript 可以做与网页操作、用户交互和 Web 服务器相关的所有事情\n\n 1. 在网页中添加新的 HTML，修改网页已有内容和网页的样式\n 2. 响应用户的行为，响应鼠标的点击，指针的移动，按键的按动\n 3. 向远程服务器发送网络请求，下载和上传文件（所谓的 AJAX 和 COMET 技术）。\n 4. 获取或设置 cookie，向访问者提出问题或发送消息\n 5. 记住客户端的数据（“本地存储”）\n\n# 浏览器中JavaScript限制\n\n为了用户的（信息）安全，在浏览器中的 JavaScript 的能力是受限的。目的是防止恶意网页获取用户私人信息或损害用户数据\n\n 1. 网页中的 JavaScript 不能读、写、复制和执行硬盘上的任意文件。它没有直接访问操作系统的功能\n 2. 不同的标签页/窗口之间通常互不了解\n 3. JavaScript 可以轻松地通过互联网与当前页面所在的服务器进行通信。但是从其他网站/域的服务器中接收数据的能力被削弱了，需要来自远程服务器的明确协议（在 HTTP header 中）\n\n\n# 1.1.3 JavaScript的上层语言\n\n出现了许多新语言，这些语言在浏览器中执行之前，都会被 编译（转化）成 JavaScript。现代化的工具使得编译速度非常快且透明，实际上允许开发者使用另一种语言编写代码并会将其“自动转换”为 JavaScript。\n\n * CoffeeScript 是 JavaScript 的一种语法糖。它引入了更加简短的语法，使我们可以编写更清晰简洁的代码。通常，Ruby 开发者喜欢它。\n * TypeScript 专注于添加“严格的数据类型”以简化开发，以更好地支持复杂系统的开发。由微软开发。\n * Flow 也添加了数据类型，但是以一种不同的方式。由 Facebook 开发。\n * Dart 是一门独立的语言。它拥有自己的引擎，该引擎可以在非浏览器环境中运行（例如手机应用），它也可以被编译成 JavaScript。由 Google 开发。\n * Brython 是一个 Python 到 JavaScript 的转译器，让我们可以在不使用 JavaScript 的情况下，以纯 Python 编写应用程序。\n * Kotlin 是一个现代、简洁且安全的编程语言，编写出的应用程序可以在浏览器和 Node 环境中运行。\n\n\n# 1.1.4 总结\n\n * JavaScript 最开始是专门为浏览器设计的一门语言，但是现在也被用于很多其他的环境。\n * JavaScript 作为被应用最广泛的浏览器语言，且与 HTML/CSS 完全集成，具有独特的地位。\n * 有很多其他的语言可以被“编译”成 JavaScript，这些语言还提供了更多的功能。建议最好了解一下这些语言，至少在掌握了 JavaScript 之后大致的了解一下。",normalizedContent:"# 1.1 javascript简介\n\n\n# 1.1.1 javascript特性\n\njavascript是一种脚本语言，以纯文本形式提供和执行，不需要特殊的准备或编译即可运行\njavascript可以被直接写在网页的html中，在页面加载时自动执行\necmascript是javascript的语言规范\njavascript 不仅可以在浏览器中执行，也可以在服务端执行，甚至可以在任意搭载了 javascript 引擎 的设备中执行\n\n# javascript 引擎\n\n * 有时也称作“javascript 虚拟机”\n * 不同的引擎有不同的“代号”\n * 引擎的工作流程\n   1. 引擎（如果是浏览器，则引擎被嵌入在其中）读取（“解析”）脚本\n   2. 引擎将脚本转化（“编译”）为机器语言\n   3. 机器代码快速地执行\n\n# javascript独特性\n\njavascript 是将这三件事结合在一起的唯一的浏览器技术\n\n 1. 与 html/css 完全集成\n 2. 简单的事，简单地完成\n 3. 被所有的主流浏览器支持，并且默认开启\n\n\n# 1.1.2 浏览器中的javascript\n\njavascript 的能力很大程度上取决于它运行的环境。例如，node.js 支持允许 javascript 读取/写入任意文件，执行网络请求等的函数\n\n# 浏览器中javascript功能\n\n浏览器中的 javascript 可以做与网页操作、用户交互和 web 服务器相关的所有事情\n\n 1. 在网页中添加新的 html，修改网页已有内容和网页的样式\n 2. 响应用户的行为，响应鼠标的点击，指针的移动，按键的按动\n 3. 向远程服务器发送网络请求，下载和上传文件（所谓的 ajax 和 comet 技术）。\n 4. 获取或设置 cookie，向访问者提出问题或发送消息\n 5. 记住客户端的数据（“本地存储”）\n\n# 浏览器中javascript限制\n\n为了用户的（信息）安全，在浏览器中的 javascript 的能力是受限的。目的是防止恶意网页获取用户私人信息或损害用户数据\n\n 1. 网页中的 javascript 不能读、写、复制和执行硬盘上的任意文件。它没有直接访问操作系统的功能\n 2. 不同的标签页/窗口之间通常互不了解\n 3. javascript 可以轻松地通过互联网与当前页面所在的服务器进行通信。但是从其他网站/域的服务器中接收数据的能力被削弱了，需要来自远程服务器的明确协议（在 http header 中）\n\n\n# 1.1.3 javascript的上层语言\n\n出现了许多新语言，这些语言在浏览器中执行之前，都会被 编译（转化）成 javascript。现代化的工具使得编译速度非常快且透明，实际上允许开发者使用另一种语言编写代码并会将其“自动转换”为 javascript。\n\n * coffeescript 是 javascript 的一种语法糖。它引入了更加简短的语法，使我们可以编写更清晰简洁的代码。通常，ruby 开发者喜欢它。\n * typescript 专注于添加“严格的数据类型”以简化开发，以更好地支持复杂系统的开发。由微软开发。\n * flow 也添加了数据类型，但是以一种不同的方式。由 facebook 开发。\n * dart 是一门独立的语言。它拥有自己的引擎，该引擎可以在非浏览器环境中运行（例如手机应用），它也可以被编译成 javascript。由 google 开发。\n * brython 是一个 python 到 javascript 的转译器，让我们可以在不使用 javascript 的情况下，以纯 python 编写应用程序。\n * kotlin 是一个现代、简洁且安全的编程语言，编写出的应用程序可以在浏览器和 node 环境中运行。\n\n\n# 1.1.4 总结\n\n * javascript 最开始是专门为浏览器设计的一门语言，但是现在也被用于很多其他的环境。\n * javascript 作为被应用最广泛的浏览器语言，且与 html/css 完全集成，具有独特的地位。\n * 有很多其他的语言可以被“编译”成 javascript，这些语言还提供了更多的功能。建议最好了解一下这些语言，至少在掌握了 javascript 之后大致的了解一下。",charsets:{cjk:!0}},{title:"Web APIs",frontmatter:{title:"Web APIs",date:"2022-04-10T20:08:36.000Z",permalink:"/pages/f2f3bd/",categories:["《JavaScript初学》","JavaScript初学"],tags:["JavaScript"],author:{name:"年华惊风雨",link:"https://github.com/wsy425"}},regularPath:"/%E3%80%8AJavaScript%E3%80%8B/01.%E3%80%8AJavaScript%E5%88%9D%E5%AD%A6%E3%80%8B/10.%20Web%20APIs.html",relativePath:"《JavaScript》/01.《JavaScript初学》/10. Web APIs.md",key:"v-4ef11850",path:"/pages/f2f3bd/",headers:[{level:2,title:"1 DOM",slug:"_1-dom",normalizedTitle:"1 dom",charIndex:2},{level:3,title:"1.1 DOM相关概念",slug:"_1-1-dom相关概念",normalizedTitle:"1.1 dom相关概念",charIndex:12},{level:3,title:"1.2 获取元素",slug:"_1-2-获取元素",normalizedTitle:"1.2 获取元素",charIndex:202},{level:4,title:"1.2.1 根据ID获取",slug:"_1-2-1-根据id获取",normalizedTitle:"1.2.1 根据id获取",charIndex:214},{level:4,title:"1.2.2 根据标签名获取",slug:"_1-2-2-根据标签名获取",normalizedTitle:"1.2.2 根据标签名获取",charIndex:312},{level:4,title:"1.2.3 根据类选择器获取",slug:"_1-2-3-根据类选择器获取",normalizedTitle:"1.2.3 根据类选择器获取",charIndex:566},{level:4,title:"1.2.4 根据选择器直接获取第一个",slug:"_1-2-4-根据选择器直接获取第一个",normalizedTitle:"1.2.4 根据选择器直接获取第一个",charIndex:675},{level:4,title:"1.2.5 根据选择器直接获取全部",slug:"_1-2-5-根据选择器直接获取全部",normalizedTitle:"1.2.5 根据选择器直接获取全部",charIndex:791},{level:4,title:"1.2.6 获取body和html元素",slug:"_1-2-6-获取body和html元素",normalizedTitle:"1.2.6 获取body和html元素",charIndex:908},{level:3,title:"1.3 事件基础",slug:"_1-3-事件基础",normalizedTitle:"1.3 事件基础",charIndex:996},{level:4,title:"1.3.1 事件三要素",slug:"_1-3-1-事件三要素",normalizedTitle:"1.3.1 事件三要素",charIndex:1065},{level:4,title:"1.3.2 执行事件的步骤",slug:"_1-3-2-执行事件的步骤",normalizedTitle:"1.3.2 执行事件的步骤",charIndex:1246},{level:3,title:"1.4 操作元素",slug:"_1-4-操作元素",normalizedTitle:"1.4 操作元素",charIndex:1444},{level:4,title:"1.4.1 修改元素内容",slug:"_1-4-1-修改元素内容",normalizedTitle:"1.4.1 修改元素内容",charIndex:1474},{level:4,title:"1.4.2 修改元素属性",slug:"_1-4-2-修改元素属性",normalizedTitle:"1.4.2 修改元素属性",charIndex:1696},{level:4,title:"1.4.3 修改样式属性",slug:"_1-4-3-修改样式属性",normalizedTitle:"1.4.3 修改样式属性",charIndex:1988},{level:4,title:"1.4.4 H5自定义属性",slug:"_1-4-4-h5自定义属性",normalizedTitle:"1.4.4 h5自定义属性",charIndex:2150},{level:3,title:"1.5 节点操作",slug:"_1-5-节点操作",normalizedTitle:"1.5 节点操作",charIndex:2320},{level:4,title:"1.5.1 节点层次",slug:"_1-5-1-节点层次",normalizedTitle:"1.5.1 节点层次",charIndex:2458},{level:4,title:"1.5.2 创建节点",slug:"_1-5-2-创建节点",normalizedTitle:"1.5.2 创建节点",charIndex:3053},{level:4,title:"1.5.3 添加节点",slug:"_1-5-3-添加节点",normalizedTitle:"1.5.3 添加节点",charIndex:3252},{level:4,title:"1.5.4 删除节点",slug:"_1-5-4-删除节点",normalizedTitle:"1.5.4 删除节点",charIndex:3349},{level:4,title:"1.5.5 复制节点",slug:"_1-5-5-复制节点",normalizedTitle:"1.5.5 复制节点",charIndex:3399},{level:3,title:"1.6 事件高级",slug:"_1-6-事件高级",normalizedTitle:"1.6 事件高级",charIndex:3546},{level:4,title:"1.6.1 注册事件",slug:"_1-6-1-注册事件",normalizedTitle:"1.6.1 注册事件",charIndex:3558},{level:5,title:"传统方式",slug:"传统方式",normalizedTitle:"传统方式",charIndex:3572},{level:5,title:"方法监听",slug:"方法监听",normalizedTitle:"方法监听",charIndex:3659},{level:4,title:"1.6.2 删除事件",slug:"_1-6-2-删除事件",normalizedTitle:"1.6.2 删除事件",charIndex:3903},{level:5,title:"传统方式",slug:"传统方式-2",normalizedTitle:"传统方式",charIndex:3572},{level:5,title:"方法监听",slug:"方法监听-2",normalizedTitle:"方法监听",charIndex:3659},{level:4,title:"1.6.3 DOM事件流",slug:"_1-6-3-dom事件流",normalizedTitle:"1.6.3 dom事件流",charIndex:4015},{level:4,title:"1.6.4 事件对象",slug:"_1-6-4-事件对象",normalizedTitle:"1.6.4 事件对象",charIndex:4448},{level:4,title:"1.6.5 事件委托",slug:"_1-6-5-事件委托",normalizedTitle:"1.6.5 事件委托",charIndex:4893},{level:4,title:"1.6.6 鼠标事件对象",slug:"_1-6-6-鼠标事件对象",normalizedTitle:"1.6.6 鼠标事件对象",charIndex:5032},{level:4,title:"1.6.7 常用键盘事件",slug:"_1-6-7-常用键盘事件",normalizedTitle:"1.6.7 常用键盘事件",charIndex:5249},{level:4,title:"1.6.8 键盘事件对象",slug:"_1-6-8-键盘事件对象",normalizedTitle:"1.6.8 键盘事件对象",charIndex:5423},{level:2,title:"2 BOM",slug:"_2-bom",normalizedTitle:"2 bom",charIndex:5490},{level:3,title:"2.1 BOM相关概念",slug:"_2-1-bom相关概念",normalizedTitle:"2.1 bom相关概念",charIndex:5500},{level:4,title:"2.1.1 BOM的构成",slug:"_2-1-1-bom的构成",normalizedTitle:"2.1.1 bom的构成",charIndex:5696},{level:3,title:"2.2 window对象常见事件",slug:"_2-2-window对象常见事件",normalizedTitle:"2.2 window对象常见事件",charIndex:5935},{level:4,title:"2.2.1 窗口加载事件",slug:"_2-2-1-窗口加载事件",normalizedTitle:"2.2.1 窗口加载事件",charIndex:5955},{level:4,title:"2.2.2 调整窗口大小事件",slug:"_2-2-2-调整窗口大小事件",normalizedTitle:"2.2.2 调整窗口大小事件",charIndex:6317},{level:3,title:"2.3 定时器",slug:"_2-3-定时器",normalizedTitle:"2.3 定时器",charIndex:6528},{level:4,title:"2.3.1 两种定时器",slug:"_2-3-1-两种定时器",normalizedTitle:"2.3.1 两种定时器",charIndex:6539},{level:4,title:"2.3.2 setTimeout()",slug:"_2-3-2-settimeout",normalizedTitle:"2.3.2 settimeout()",charIndex:6590},{level:4,title:"2.3.3 停止setTimeout()定时器",slug:"_2-3-3-停止settimeout-定时器",normalizedTitle:"2.3.3 停止settimeout()定时器",charIndex:6841},{level:4,title:"2.3.4 setInterval()",slug:"_2-3-4-setinterval",normalizedTitle:"2.3.4 setinterval()",charIndex:6988},{level:4,title:"2.3.5 停止setInterval()定时器",slug:"_2-3-5-停止setinterval-定时器",normalizedTitle:"2.3.5 停止setinterval()定时器",charIndex:7097},{level:4,title:"2.3.6 this",slug:"_2-3-6-this",normalizedTitle:"2.3.6 this",charIndex:7186},{level:3,title:"2.4 JS执行队列",slug:"_2-4-js执行队列",normalizedTitle:"2.4 js执行队列",charIndex:7345},{level:4,title:"2.4.1 JS是单线程",slug:"_2-4-1-js是单线程",normalizedTitle:"2.4.1 js是单线程",charIndex:7359},{level:4,title:"2.4.2 同步和异步",slug:"_2-4-2-同步和异步",normalizedTitle:"2.4.2 同步和异步",charIndex:7516},{level:4,title:"2.4.3 JS执行机制",slug:"_2-4-3-js执行机制",normalizedTitle:"2.4.3 js执行机制",charIndex:7904},{level:3,title:"2.5 location对象",slug:"_2-5-location对象",normalizedTitle:"2.5 location对象",charIndex:8076},{level:4,title:"2.5.1 URL",slug:"_2-5-1-url",normalizedTitle:"2.5.1 url",charIndex:8190},{level:4,title:"2.5.2 location对象的属性",slug:"_2-5-2-location对象的属性",normalizedTitle:"2.5.2 location对象的属性",charIndex:8474},{level:4,title:"2.5.3 location对象的方法",slug:"_2-5-3-location对象的方法",normalizedTitle:"2.5.3 location对象的方法",charIndex:8499},{level:3,title:"2.5.4 navigator对象",slug:"_2-5-4-navigator对象",normalizedTitle:"2.5.4 navigator对象",charIndex:8525},{level:3,title:"2.5.5 history对象",slug:"_2-5-5-history对象",normalizedTitle:"2.5.5 history对象",charIndex:8632},{level:2,title:"3 PC网页特效",slug:"_3-pc网页特效",normalizedTitle:"3 pc网页特效",charIndex:8782},{level:3,title:"3.1 元素三大系列",slug:"_3-1-元素三大系列",normalizedTitle:"3.1 元素三大系列",charIndex:8795},{level:4,title:"3.1.1 元素偏移量offset系列",slug:"_3-1-1-元素偏移量offset系列",normalizedTitle:"3.1.1 元素偏移量offset系列",charIndex:8809},{level:5,title:"offsetLeft与offsetTop",slug:"offsetleft与offsettop",normalizedTitle:"offsetleft与offsettop",charIndex:8923},{level:5,title:"offsetWidth与offsetHeight",slug:"offsetwidth与offsetheight",normalizedTitle:"offsetwidth与offsetheight",charIndex:9001},{level:5,title:"offsetParent",slug:"offsetparent",normalizedTitle:"offsetparent",charIndex:9063},{level:5,title:"offset与style区别",slug:"offset与style区别",normalizedTitle:"offset与style区别",charIndex:9118},{level:4,title:"3.1.2 元素可视区client系列",slug:"_3-1-2-元素可视区client系列",normalizedTitle:"3.1.2 元素可视区client系列",charIndex:9369},{level:5,title:"clientTop与clientLeft",slug:"clienttop与clientleft",normalizedTitle:"clienttop与clientleft",charIndex:9431},{level:5,title:"clientWidth与clientHight",slug:"clientwidth与clienthight",normalizedTitle:"clientwidth与clienthight",charIndex:9478},{level:4,title:"3.1.3 元素滚动scroll系列",slug:"_3-1-3-元素滚动scroll系列",normalizedTitle:"3.1.3 元素滚动scroll系列",charIndex:9562},{level:5,title:"scrollTop与scrollLeft",slug:"scrolltop与scrollleft",normalizedTitle:"scrolltop与scrollleft",charIndex:9681},{level:5,title:"scrollWidth与scrollHight",slug:"scrollwidth与scrollhight",normalizedTitle:"scrollwidth与scrollhight",charIndex:9739},{level:4,title:"3.1.4 立即执行函数",slug:"_3-1-4-立即执行函数",normalizedTitle:"3.1.4 立即执行函数",charIndex:9827},{level:4,title:"3.1.5 moseenter和mouseover区别",slug:"_3-1-5-moseenter和mouseover区别",normalizedTitle:"3.1.5 moseenter和mouseover区别",charIndex:9966},{level:5,title:"mouseenter",slug:"mouseenter",normalizedTitle:"mouseenter",charIndex:4421},{level:5,title:"mouseover",slug:"mouseover",normalizedTitle:"mouseover",charIndex:3787},{level:3,title:"3.2 动画函数",slug:"_3-2-动画函数",normalizedTitle:"3.2 动画函数",charIndex:10179},{level:4,title:"3.2.1 动画实现原理",slug:"_3-2-1-动画实现原理",normalizedTitle:"3.2.1 动画实现原理",charIndex:10191},{level:4,title:"3.2.2 动画函数简单封装",slug:"_3-2-2-动画函数简单封装",normalizedTitle:"3.2.2 动画函数简单封装",charIndex:10324},{level:4,title:"3.2.3 缓动动画",slug:"_3-2-3-缓动动画",normalizedTitle:"3.2.3 缓动动画",charIndex:10370},{level:4,title:"3.2.4 动画函数添加回调函数",slug:"_3-2-4-动画函数添加回调函数",normalizedTitle:"3.2.4 动画函数添加回调函数",charIndex:10463},{level:4,title:"3.2.5 动画函数封装",slug:"_3-2-5-动画函数封装",normalizedTitle:"3.2.5 动画函数封装",charIndex:10579}],headersStr:"1 DOM 1.1 DOM相关概念 1.2 获取元素 1.2.1 根据ID获取 1.2.2 根据标签名获取 1.2.3 根据类选择器获取 1.2.4 根据选择器直接获取第一个 1.2.5 根据选择器直接获取全部 1.2.6 获取body和html元素 1.3 事件基础 1.3.1 事件三要素 1.3.2 执行事件的步骤 1.4 操作元素 1.4.1 修改元素内容 1.4.2 修改元素属性 1.4.3 修改样式属性 1.4.4 H5自定义属性 1.5 节点操作 1.5.1 节点层次 1.5.2 创建节点 1.5.3 添加节点 1.5.4 删除节点 1.5.5 复制节点 1.6 事件高级 1.6.1 注册事件 传统方式 方法监听 1.6.2 删除事件 传统方式 方法监听 1.6.3 DOM事件流 1.6.4 事件对象 1.6.5 事件委托 1.6.6 鼠标事件对象 1.6.7 常用键盘事件 1.6.8 键盘事件对象 2 BOM 2.1 BOM相关概念 2.1.1 BOM的构成 2.2 window对象常见事件 2.2.1 窗口加载事件 2.2.2 调整窗口大小事件 2.3 定时器 2.3.1 两种定时器 2.3.2 setTimeout() 2.3.3 停止setTimeout()定时器 2.3.4 setInterval() 2.3.5 停止setInterval()定时器 2.3.6 this 2.4 JS执行队列 2.4.1 JS是单线程 2.4.2 同步和异步 2.4.3 JS执行机制 2.5 location对象 2.5.1 URL 2.5.2 location对象的属性 2.5.3 location对象的方法 2.5.4 navigator对象 2.5.5 history对象 3 PC网页特效 3.1 元素三大系列 3.1.1 元素偏移量offset系列 offsetLeft与offsetTop offsetWidth与offsetHeight offsetParent offset与style区别 3.1.2 元素可视区client系列 clientTop与clientLeft clientWidth与clientHight 3.1.3 元素滚动scroll系列 scrollTop与scrollLeft scrollWidth与scrollHight 3.1.4 立即执行函数 3.1.5 moseenter和mouseover区别 mouseenter mouseover 3.2 动画函数 3.2.1 动画实现原理 3.2.2 动画函数简单封装 3.2.3 缓动动画 3.2.4 动画函数添加回调函数 3.2.5 动画函数封装",content:"# 1 DOM\n\n\n# 1.1 DOM相关概念\n\n 1. DOM:文档对象模型（Document Object Model），是W3C组织推荐的处理可扩展标记语言的标准编程接口\n 2. DOM树：\n    1. 文档：一个界面就是一个文档，document\n    2. 元素：页面内的标签，element\n    3. 节点：网页中所有内容，node\n    4. DOM将以上元素都看作对象\n\n\n# 1.2 获取元素\n\n# 1.2.1 根据ID获取\n\n 1. 语法getElementById(id)\n 2. id是一个大小写敏感的字符串\n 3. 返回匹配ID 的element对象\n 4. 找不到则返回null\n\n# 1.2.2 根据标签名获取\n\n 1. 语法getElementsByTagName(标签名)\n 2. 标签名要求输入大小写敏感字符串\n 3. 返回获取元素对象的集合，以伪数组形式存储\n 4. 得到的元素对象是动态的\n 5. 找不到返回空的伪数组\n 6. 可以通过指定父元素查询特定父元素内的标签元素\n\nvar ol = document.getElementsByTagName('ol');\nconsole.log(ol[0].getElementsByTagName('ul'));\n\n\n1\n2\n\n\n# 1.2.3 根据类选择器获取\n\n 1. HTML5才支持\n 2. 语法getElementsByClassName(类名)\n 3. 类名要求输入大小写敏感字符串\n 4. 返回获取元素对象的集合，以伪数组形式存储\n\n# 1.2.4 根据选择器直接获取第一个\n\n 1. HTML5才支持\n 2. 语法querySelector(选择器名)\n 3. 返回指定选择器的第一个元素对象\n 4. 选择器名要求输入大小写敏感字符串，需要加符号表明选择器类型\n\n# 1.2.5 根据选择器直接获取全部\n\n 1. HTML5才支持\n 2. 语法querySelectorAll(选择器名)\n 3. 返回指定选择器的所有元素对象\n 4. 选择器名要求输入大小写敏感字符串，需要加符号表明选择器类型\n\n# 1.2.6 获取body和html元素\n\n 1. document.body获取body标签\n 2. document.documentElement获取html标签\n\n\n# 1.3 事件基础\n\n 1. 事件：一种被JavaScript侦测到的行为\n 2. 事件由三部分组成：事件源；事件类型；事件处理程序\n\n# 1.3.1 事件三要素\n\n 1. 事件源：事件被触发的对象\n 2. 事件类型：如何被触发\n 3. 事件处理程序：通过一个函数赋值的方式完成\n 4. 例子\n\nvar btn = document.getElementById('btn');\nbtn.onclick = function(){\n    alert('弹出对话框')\n}\n\n\n1\n2\n3\n4\n\n\n# 1.3.2 执行事件的步骤\n\n 1. 获取事件源var div = document.querySelector('div')\n 2. 注册事件（绑定事件）div.onclick\n 3. 添加事件处理程序（采取函数赋值形式）div.onclick = function(){}\n 4. 常见鼠标事件\n 5. 事件补充\n    * onfocus获取焦点\n    * onblur失去焦点\n\n\n# 1.4 操作元素\n\n 1. 可以不用事件直接使用元素\n\n# 1.4.1 修改元素内容\n\n 1. element.innerText\n    * 语法DOM.innerText = 内容\n    * 不识别HTML标签，里面的标签会直接显示\n    * 可以获取元素的内容，会去除空格和换行\n 2. element.innerHTML\n    * 语法DOM.innerHTML = 内容\n    * 识别HTML标签\n    * 用的多，是W3C标准\n    * 可以获取元素内容，保留空格和换行\n\n# 1.4.2 修改元素属性\n\n 1. 语法DOM.属性 = 内容\n    * 获取的是内置的属性值，元素本身自带的属性\n 2. 第二种得到元素属性的方法DOM.getAttribute('属性')\n    * 可以获取自定义属性\n 3. 第二种更改元素属性值的方法DOM.setAttribute('属性','值')\n    * 主要针对于自定义属性\n 4. 移除属性值DOM.removeAttribute('属性')\n 5. 表单元素操纵\n    * 使用表单自己的属性改变里面的内容\n    * 改变表单值使用value属性\n    * 表单被禁用使用disabled属性\n\n# 1.4.3 修改样式属性\n\n 1. element.style 行内样式操作\n    * style里的属性采用驼峰命名法\n    * 产生的是行内样式，css权重比较高\n 2. element.className 类名样式操作\n    * 将当前元素类名进行修改，是直接替换的\n    * 要添加新的类可以使用+=\n\n# 1.4.4 H5自定义属性\n\n 1. 规定自定义属性以data-开头并赋值\n 2. 新增一种获取自定义属性方法DOM.dataset.data后面的属性名或者DOM.dataset[data后面的属性名]\n 3. dataset是一个存放了所有以data开头自定义属性的集合\n 4. 自定义属性中有多个-，获取的时候采取驼峰命名法\n\n\n# 1.5 节点操作\n\n 1. 节点至少拥有nodeType节点类型、nodeName节点名称和nodeValue节点值这三个基本属性\n 2. nodeType\n    * 元素节点为1\n    * 属性节点为2\n    * 文本节点为3（文本节点包含文字、空格、换行等）\n\n# 1.5.1 节点层次\n\n 1. 利用DOM树可以把节点划分为不同的层次关系\n 2. 父级节点\n    * 语法DOM.parentNode\n    * 得到的是离元素最近的父级节点\n 3. 子节点\n    * 语法DOM.childNodes\n    * 得到的子节点集合，包含元素节点、文本节点等\n    * 要获得里面的元素节点需要专门处理\n    * 子元素节点语法DOM.children，不是标准方法\n    * 获取第一个子节点DOM.firstChild\n    * 获取最后一个子节点DOM.lastChild\n    * 获取第一个子元素节点DOM.firstElementChildIE9以上才支持\n    * 获取最后一个子元素节点DOM.lastElementChildIE9以上才支持\n 4. 兄弟节点\n    * 语法DOM.nextSibling，得到下一个兄弟节点，包括文本节点\n    * 语法DOM.previousSibling，得到上一个兄弟节点，包括文本节点。找不到则返回null\n    * 语法DOM.nextElementSibling，得到下一个元素兄弟节点，找不到则返回null，IE9以上才支持\n    * 语法DOM.previousElementSibling，得到上一个元素兄弟节点，找不到则返回null，IE9以上才支持\n\n# 1.5.2 创建节点\n\n 1. document.write('标签')\n    * 文档执行完毕会导致页面全部重绘，会重新创建新的页面\n 2. DOM.createElement('节点名')\n    * 需要通过添加节点使用\n    * 创建新元素，效率高\n 3. DOM.innerHTML = '标签'\n    * 本质是拼接字符串，效率低\n    * 但如果使用数组拼接，效率最高\n\n# 1.5.3 添加节点\n\n 1. DOM.appendChild(变量)添加到父节点的子节点的末尾\n 2. DOM.insertBefore(变量,指定元素)添加到父节点的指定子节点的前面\n\n# 1.5.4 删除节点\n\n 1. DOM.removeChild(子节点)从DOM中删除子节点\n\n# 1.5.5 复制节点\n\n 1. DOM.cloneNode()返回调用该方法节点的一个副本\n 2. 需要通过添加节点使用\n 3. 括号参数\n    * 空或者false，则是浅拷贝。只克隆复制节点本身，不克隆里面的子节点\n    * true，则是深拷贝。隆复制节点本身和里面的子节点\n\n\n# 1.6 事件高级\n\n# 1.6.1 注册事件\n\n# 传统方式\n\n 1. 利用on开头的事件\n 2. 特点：注册事件的唯一性\n 3. 同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数\n\n# 方法监听\n\n 1. w3c标准 推荐方式\n 2. DOM.addEventListener(type,listener[,useCapture])是一个方法\n 3. 同一个元素同一个事件可以注册多个监听器\n 4. type：事件类型字符串，比如click、mouseover，注意不要带on\n 5. listener：事件处理函数，事件发生时，会调用该监听函数\n    * 如果是写调用函数的名字，不需要加()\n 6. useCapture：可选参数，是一个布尔值，默认false\n\n# 1.6.2 删除事件\n\n# 传统方式\n\n 1. DOM.onclick = null;\n\n# 方法监听\n\n 1. DOM.removeEventListener(type,listener[,useCapture])\n\n# 1.6.3 DOM事件流\n\n 1. 事件流描述的是从页面中接收事件的顺序\n 2. 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流\n 3. 分成三个阶段：捕获阶段、当前目标阶段和冒泡阶段\n    * 捕获：由DOM最顶层节点开始，逐级向下传播到最具体的元素接收的过程\n    * 目标\n    * 冒泡：事件开始时由最具体的元素接收，然后逐层向上传播到DOM最顶层节点的过程\n 4. JS代码只能执行捕获或者冒泡其中的一个阶段\n 5. onclick和attachEvent只能得到冒泡阶段\n 6. addEventListener(type,listener[ ,useCapture])\n    * 第三个参数如果是true，表示在事件捕获阶段调用事件处理程序\n    * false表示在事件冒泡阶段调用事件处理\n 7. 有些事件是没有冒泡的，比如onblur、onfocus、onmouseenter、onmouseleave\n\n# 1.6.4 事件对象\n\n 1. event就是一个事件对象，写在侦听函数的小括号里，当作形参来看待\n 2. 事件对象只有有了事件才会存在，是系统给我们自动创建的，不需要传递参数\n 3. 事件对象是事件的一系列相关数据的集合\n 4. 事件对象可以自己命名\n 5. 事件对象也有兼容性问题，ie678要使用window.event\n 6. 常见属性方法\n    * e.target：返回触发事件的对象（标准） PS：this是绑定事件的对象，和这个有区别\n    * e.scrElement：返回触发事件的对象（ie678）\n    * e.type：返回事件的类型，不带on\n    * e.cancelBubble：该属性阻止冒泡（非标准ie678）\n    * e.returnValue：该属性阻止默认事件（非标准ie678）\n    * e.preventDefault()：该方法阻止默认事件（标准）\n    * e.stopPropagation()：阻止冒泡（标准）\n\n# 1.6.5 事件委托\n\n 1. 事件委托也称为事件代理，在jQuery里面称为事件委派\n 2. 事件委托原理：不是每个自建店单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点\n 3. 事件委托的作用：只操作一次DOM，提高了程序的性能\n\n# 1.6.6 鼠标事件对象\n\n 1. e.clientX：返回鼠标相对于浏览器窗口可视区的X坐标\n 2. e.clientY：返回鼠标相对于浏览器窗口可视区的Y坐标\n 3. e.pageX：返回鼠标相对于文档页面的X坐标（ie9+支持）\n 4. e.pageY：返回鼠标相对于文档页面的Y坐标（ie9+支持）\n 5. e.screenX：返回鼠标相对于电脑屏幕的X坐标\n 6. e.screenY：返回鼠标相对于电脑屏幕的Y坐标\n\n# 1.6.7 常用键盘事件\n\n 1. DOM.onkeyup：某个键盘按键被松开时触发，不区分大小写\n 2. DOM.onkeydown：某个键盘按键被按下时触发，不区分大小写\n 3. DOM.onkeypress：耨个键盘按键被按下时触发（不能识别功能键），区分大小写\n 4. 三个事件的执行顺序，先执行down再执行press最后执行up\n\n# 1.6.8 键盘事件对象\n\n 1. e.keyCode：返回按键对应的ASCII码值，不区分大小写时是输出大写的ASCII码\n\n\n# 2 BOM\n\n\n# 2.1 BOM相关概念\n\n 1. BOM（Browser Object Model）浏览器对象模型，它提供了独立于内容而与浏览器进行交互的对象，其核心对象是window\n 2. BOM由一系列对象构成，并且每个对象都提供了很多方法与属性\n 3. BOM缺乏标准，JavaScript语法的标准化祖师是ECMA，DOM的标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分\n\n# 2.1.1 BOM的构成\n\n 1. BOM比DOM更大，包含DOM\n 2. window：\n    * document\n    * location\n    * navigation\n    * screen\n    * history\n 3. window对象是浏览器的顶级对象，具有双重角色\n    * 是JS访问浏览器窗口的一个接口\n    * 是一个全局对象，定义在全局作用域中的变量、函数都会变成window对象的属性和方法。调用的时候可以省略window\n\n\n# 2.2 window对象常见事件\n\n# 2.2.1 窗口加载事件\n\n 1. 语法window.onload = function(){}或者window.addEventListener(\"load\",function(){})\n 2. window.onload是窗口加载事件，当文档内容完全加载完成才会触发该事件\n 3. 有了window.onload就可以吧JS代码写到页面元素的上方\n 4. window.onload传统注册事件方式只能写一次，如果有多个会以最后一个为准\n 5. 如果使用addEventListener没有个数限值\n 6. 有一个类似的事件document.addEventListener('DOMContentLoaded',function(){})，仅当DOM加载完成，不包括样式表，图片，flash等，ie9以上才支持\n\n# 2.2.2 调整窗口大小事件\n\n 1. 语法window.onresize = function(){}或者window.addEventListener(\"resize\",function(){})\n 2. window.onresize是调整窗口大小加载事件\n 3. 只要窗口大小发生像素变化，就会触发这个事件\n 4. 经常利用这个事件完成响应式布局。window.innerWidth属性对应当前屏幕的宽度\n\n\n# 2.3 定时器\n\n# 2.3.1 两种定时器\n\n 1. setTimeout()\n 2. setInterval()\n\n# 2.3.2 setTimeout()\n\n 1. 语法window.setTimeout(调用函数,[延迟的毫秒数])\n 2. 用于设置一个定时器，该定时器在定时器到期后执行调用函数\n 3. 延时时间单位是毫秒，单位不用写。整体可以省略，默认是0\n 4. 调用函数可以直接写函数，也可以写函数名，还可以写函数名()但不推荐\n 5. 页面中会存在很多定时器，需要给定时器加标识符\n 6. setTimeout里的调用函数也称为回调函数callback。这个函数需要等待事件，时间到了才去调用这个函数\n\n# 2.3.3 停止setTimeout()定时器\n\n 1. 语法window.clearTimeout(timeout ID)\n 2. clearTimeout()方法取消了先前通过调用setTimeout()建立的定时器\n 3. window可以省略\n 4. 括号里面的是定时器的标识符\n\n# 2.3.4 setInterval()\n\n 1. 语法window.setInterval(调用函数,[间隔的毫秒数])\n 2. setInterval()方法重复调用一个函数，每隔一段时间就去调用一次回调函数\n\n# 2.3.5 停止setInterval()定时器\n\n 1. 语法window.clearInterval(interval ID)\n 2. 与停止setTimeout一致\n\n# 2.3.6 this\n\n 1. 函数定义的时候无法确认，函数被调用的时候才能确定this指向谁，一般指向调用它的对象\n 2. 全局作用域或者普通函数中this指向全局对象window\n 3. 定时器里面的this指向window\n 4. 在方法中this指向方法\n 5. 构造函数中this指向构造函数的实例\n\n\n# 2.4 JS执行队列\n\n# 2.4.1 JS是单线程\n\n 1. JavaScript语言的一大特点是单线程，就是同一个时间只能做一件事\n 2. 是因为JavaScript是为了操作DOM，必须先添加再删除，所以必须是单线程\n 3. 单线程意味着所有任务需要排队，带来的问题是JS执行时间过长，页面渲染不连贯，导致页面渲染加载阻塞的感觉\n\n# 2.4.2 同步和异步\n\n 1. 为了解决JS执行过长渲染不连贯的问题，利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，JS出现同步和异步\n 2. 同步：前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的\n 3. 异步：在做一件事的同事还可以处理其他的事情\n 4. JS把任务分成两种\n    * 同步任务：同步任务都在主线程上执行，形成一个执行栈\n    * 异步任务：JS的异步任务是通过回调函数实现的\n    * 常见的异步任务\n      * 普通事件，click、resize\n      * 资源加载，load、error\n      * 定时器，setInterval、setTimeout\n    * 异步任务相关回调函数添加到任务队列中（任务队列也叫消息队列）\n\n# 2.4.3 JS执行机制\n\n 1. 先执行执行栈中的同步任务\n 2. 遇到回调函数把异步任务放入任务队列中\n 3. 一旦执行栈中的所有同步任务执行完毕，系统就会按次序速去任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行\n 4. 事件循环(event loop)：由于主线程不断的重复获得任务、执行任务的机制\n\n\n# 2.5 location对象\n\n 1. window对象给我们提供了一个location属性用于获取或设置窗体的URL，并且可以用于解析URL\n 2. 因为这个属性返回的是一个对象，所以将这个属性称为location对象\n\n# 2.5.1 URL\n\n 1. 统一资源定位符是互联网上标准资源的地址\n 2. 一般语法格式protocol://host[:port]/path/[?query]#fragment\n 3. protocol:通信协议 常用的http，ftp，maito等\n 4. host：主机(域名)\n 5. port：端口号，可选，省略时使用方案的默认端口\n 6. path：路径，由零活多个'/'符号隔开的字符串，一般用来表示主机上的一个目录或文件地址\n 7. query：参数，以键值对的相识，通过&符号分隔开\n 8. fragment:片段，#后面内容常见于连接锚点\n\n# 2.5.2 location对象的属性\n\n\n\n# 2.5.3 location对象的方法\n\n\n\n\n# 2.5.4 navigator对象\n\n 1. navigator对象包含浏览器的相关信息\n 2. navigator对象最常用的属性是userAgent，返回有客户机发送服务器的user-agent头部值\n\n\n# 2.5.5 history对象\n\n 1. window对象提供一个history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）\n 2. back()：后退功能\n 3. forward()：前进功能\n 4. go(参数)：前进后退功能。参数是1前进1个页面，-1后退1个页面\n\n\n# 3 PC网页特效\n\n\n# 3.1 元素三大系列\n\n# 3.1.1 元素偏移量offset系列\n\n 1. 使用offset系列相关属性可以动态地得到该元素的位置、大小\n 2. 获得元素距离带有定位父元素的位置\n 3. 获得元素自身的大小（宽度高度）\n 4. 返回的数值不带单位\n\n# offsetLeft与offsetTop\n\n 1. 各自返回元素相对于有定位父元素的上方、左边偏移量\n 2. 如果没有定位的父元素，则以body为准\n\n# offsetWidth与offsetHeight\n\n 1. 各自返回元素包括padding、边框、内容区的宽度、高度\n\n# offsetParent\n\n 1. 返回该元素带有定位的父级元素\n 2. 父级都没有定位则返回body\n\n# offset与style区别\n\n 1. offset\n    * 可以得到任意样式表中的样式值\n    * 获得的数值没有段位\n    * offsetWidth包含padding、border和width\n    * 只能读属性不能赋值\n    * 更合适获取元素大小位置\n 2. style\n    * 只能得到行内样式表中的样式值\n    * 获得带有单位的字符串\n    * style.width不包含padding和border\n    * 可读写属性\n    * 更适合给元素赋值\n\n# 3.1.2 元素可视区client系列\n\n 1. 使用client系列的相关属性可以动态得到元素边框大小、元素大小等\n\n# clientTop与clientLeft\n\n 1. 各自返回元素包括上边、左边边框大小\n\n# clientWidth与clientHight\n\n 1. 各自返回元素包括padding、内容区的宽度、高度\n 2. 与offset最大的区别就是不包含边框大小\n\n# 3.1.3 元素滚动scroll系列\n\n 1. 使用scroll系列的相关属性可以动态地得到该元素的大小、滚动距离等\n 2. 滚动条滚动会触发onscroll事件\n 3. 页面的滚动距离使用window.pageXOffset获得\n\n# scrollTop与scrollLeft\n\n 1. 各自返回被卷去的上侧、左侧距离\n 2. 返回数值不带单位\n\n# scrollWidth与scrollHight\n\n 1. 各自返回自身实际宽度、高度，不含边框\n 2. 返回数值不带单位\n 3. 返回的是包含内容overflow的大小\n\n# 3.1.4 立即执行函数\n\n 1. 不需要调用，立马能够自己执行的函数\n 2. 语法1(function() {})()\n 3. 语法2(function() {}())\n 4. 立即执行函数最大的作用是独立创建了一个作用域\n 5. 所有变量都是局部变量，不存在命名冲突\n\n# 3.1.5 moseenter和mouseover区别\n\n# mouseenter\n\n 1. 当鼠标移动到元素上时会触发mouseenter事件\n 2. mouseenter只在经过自身盒子时触发\n 3. 不会有冒泡的概念\n 4. 搭配使用的是mouseleave，同样不会冒泡\n\n# mouseover\n\n 1. 当鼠标移动到元素上时会触发mouseover事件\n 2. 不仅经过自身盒子会触发，经过子盒子也会触发\n\n\n# 3.2 动画函数\n\n# 3.2.1 动画实现原理\n\n通过定时器setInterval()不断移动盒子位置\n\n 1. 获得盒子当前的位置\n 2. 让盒子在当前位置上加移动距离\n 3. 加一个结束定时器的条件\n 4. 注意此元素需要添加定位，才能使用element.style.left\n\n# 3.2.2 动画函数简单封装\n\n 1. 函数需要传递2个参数，动画对象和移动到的距离\n\n# 3.2.3 缓动动画\n\n 1. 原理：让元素运动有所变化，最常见的是让速度慢慢停下\n 2. 核心算法：每次移动步长=Math.ceil/floor((目标值-现在的位置)/10)\n\n# 3.2.4 动画函数添加回调函数\n\n 1. 回调函数原理：函数作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程叫做回调\n 2. 可以把函数当做一个参数输入另一个函数中\n\n# 3.2.5 动画函数封装\n\n 1. 单独创建一个JS文件\n 2. 把函数写在里面\n 3. 在html中引入JS文件",normalizedContent:"# 1 dom\n\n\n# 1.1 dom相关概念\n\n 1. dom:文档对象模型（document object model），是w3c组织推荐的处理可扩展标记语言的标准编程接口\n 2. dom树：\n    1. 文档：一个界面就是一个文档，document\n    2. 元素：页面内的标签，element\n    3. 节点：网页中所有内容，node\n    4. dom将以上元素都看作对象\n\n\n# 1.2 获取元素\n\n# 1.2.1 根据id获取\n\n 1. 语法getelementbyid(id)\n 2. id是一个大小写敏感的字符串\n 3. 返回匹配id 的element对象\n 4. 找不到则返回null\n\n# 1.2.2 根据标签名获取\n\n 1. 语法getelementsbytagname(标签名)\n 2. 标签名要求输入大小写敏感字符串\n 3. 返回获取元素对象的集合，以伪数组形式存储\n 4. 得到的元素对象是动态的\n 5. 找不到返回空的伪数组\n 6. 可以通过指定父元素查询特定父元素内的标签元素\n\nvar ol = document.getelementsbytagname('ol');\nconsole.log(ol[0].getelementsbytagname('ul'));\n\n\n1\n2\n\n\n# 1.2.3 根据类选择器获取\n\n 1. html5才支持\n 2. 语法getelementsbyclassname(类名)\n 3. 类名要求输入大小写敏感字符串\n 4. 返回获取元素对象的集合，以伪数组形式存储\n\n# 1.2.4 根据选择器直接获取第一个\n\n 1. html5才支持\n 2. 语法queryselector(选择器名)\n 3. 返回指定选择器的第一个元素对象\n 4. 选择器名要求输入大小写敏感字符串，需要加符号表明选择器类型\n\n# 1.2.5 根据选择器直接获取全部\n\n 1. html5才支持\n 2. 语法queryselectorall(选择器名)\n 3. 返回指定选择器的所有元素对象\n 4. 选择器名要求输入大小写敏感字符串，需要加符号表明选择器类型\n\n# 1.2.6 获取body和html元素\n\n 1. document.body获取body标签\n 2. document.documentelement获取html标签\n\n\n# 1.3 事件基础\n\n 1. 事件：一种被javascript侦测到的行为\n 2. 事件由三部分组成：事件源；事件类型；事件处理程序\n\n# 1.3.1 事件三要素\n\n 1. 事件源：事件被触发的对象\n 2. 事件类型：如何被触发\n 3. 事件处理程序：通过一个函数赋值的方式完成\n 4. 例子\n\nvar btn = document.getelementbyid('btn');\nbtn.onclick = function(){\n    alert('弹出对话框')\n}\n\n\n1\n2\n3\n4\n\n\n# 1.3.2 执行事件的步骤\n\n 1. 获取事件源var div = document.queryselector('div')\n 2. 注册事件（绑定事件）div.onclick\n 3. 添加事件处理程序（采取函数赋值形式）div.onclick = function(){}\n 4. 常见鼠标事件\n 5. 事件补充\n    * onfocus获取焦点\n    * onblur失去焦点\n\n\n# 1.4 操作元素\n\n 1. 可以不用事件直接使用元素\n\n# 1.4.1 修改元素内容\n\n 1. element.innertext\n    * 语法dom.innertext = 内容\n    * 不识别html标签，里面的标签会直接显示\n    * 可以获取元素的内容，会去除空格和换行\n 2. element.innerhtml\n    * 语法dom.innerhtml = 内容\n    * 识别html标签\n    * 用的多，是w3c标准\n    * 可以获取元素内容，保留空格和换行\n\n# 1.4.2 修改元素属性\n\n 1. 语法dom.属性 = 内容\n    * 获取的是内置的属性值，元素本身自带的属性\n 2. 第二种得到元素属性的方法dom.getattribute('属性')\n    * 可以获取自定义属性\n 3. 第二种更改元素属性值的方法dom.setattribute('属性','值')\n    * 主要针对于自定义属性\n 4. 移除属性值dom.removeattribute('属性')\n 5. 表单元素操纵\n    * 使用表单自己的属性改变里面的内容\n    * 改变表单值使用value属性\n    * 表单被禁用使用disabled属性\n\n# 1.4.3 修改样式属性\n\n 1. element.style 行内样式操作\n    * style里的属性采用驼峰命名法\n    * 产生的是行内样式，css权重比较高\n 2. element.classname 类名样式操作\n    * 将当前元素类名进行修改，是直接替换的\n    * 要添加新的类可以使用+=\n\n# 1.4.4 h5自定义属性\n\n 1. 规定自定义属性以data-开头并赋值\n 2. 新增一种获取自定义属性方法dom.dataset.data后面的属性名或者dom.dataset[data后面的属性名]\n 3. dataset是一个存放了所有以data开头自定义属性的集合\n 4. 自定义属性中有多个-，获取的时候采取驼峰命名法\n\n\n# 1.5 节点操作\n\n 1. 节点至少拥有nodetype节点类型、nodename节点名称和nodevalue节点值这三个基本属性\n 2. nodetype\n    * 元素节点为1\n    * 属性节点为2\n    * 文本节点为3（文本节点包含文字、空格、换行等）\n\n# 1.5.1 节点层次\n\n 1. 利用dom树可以把节点划分为不同的层次关系\n 2. 父级节点\n    * 语法dom.parentnode\n    * 得到的是离元素最近的父级节点\n 3. 子节点\n    * 语法dom.childnodes\n    * 得到的子节点集合，包含元素节点、文本节点等\n    * 要获得里面的元素节点需要专门处理\n    * 子元素节点语法dom.children，不是标准方法\n    * 获取第一个子节点dom.firstchild\n    * 获取最后一个子节点dom.lastchild\n    * 获取第一个子元素节点dom.firstelementchildie9以上才支持\n    * 获取最后一个子元素节点dom.lastelementchildie9以上才支持\n 4. 兄弟节点\n    * 语法dom.nextsibling，得到下一个兄弟节点，包括文本节点\n    * 语法dom.previoussibling，得到上一个兄弟节点，包括文本节点。找不到则返回null\n    * 语法dom.nextelementsibling，得到下一个元素兄弟节点，找不到则返回null，ie9以上才支持\n    * 语法dom.previouselementsibling，得到上一个元素兄弟节点，找不到则返回null，ie9以上才支持\n\n# 1.5.2 创建节点\n\n 1. document.write('标签')\n    * 文档执行完毕会导致页面全部重绘，会重新创建新的页面\n 2. dom.createelement('节点名')\n    * 需要通过添加节点使用\n    * 创建新元素，效率高\n 3. dom.innerhtml = '标签'\n    * 本质是拼接字符串，效率低\n    * 但如果使用数组拼接，效率最高\n\n# 1.5.3 添加节点\n\n 1. dom.appendchild(变量)添加到父节点的子节点的末尾\n 2. dom.insertbefore(变量,指定元素)添加到父节点的指定子节点的前面\n\n# 1.5.4 删除节点\n\n 1. dom.removechild(子节点)从dom中删除子节点\n\n# 1.5.5 复制节点\n\n 1. dom.clonenode()返回调用该方法节点的一个副本\n 2. 需要通过添加节点使用\n 3. 括号参数\n    * 空或者false，则是浅拷贝。只克隆复制节点本身，不克隆里面的子节点\n    * true，则是深拷贝。隆复制节点本身和里面的子节点\n\n\n# 1.6 事件高级\n\n# 1.6.1 注册事件\n\n# 传统方式\n\n 1. 利用on开头的事件\n 2. 特点：注册事件的唯一性\n 3. 同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数\n\n# 方法监听\n\n 1. w3c标准 推荐方式\n 2. dom.addeventlistener(type,listener[,usecapture])是一个方法\n 3. 同一个元素同一个事件可以注册多个监听器\n 4. type：事件类型字符串，比如click、mouseover，注意不要带on\n 5. listener：事件处理函数，事件发生时，会调用该监听函数\n    * 如果是写调用函数的名字，不需要加()\n 6. usecapture：可选参数，是一个布尔值，默认false\n\n# 1.6.2 删除事件\n\n# 传统方式\n\n 1. dom.onclick = null;\n\n# 方法监听\n\n 1. dom.removeeventlistener(type,listener[,usecapture])\n\n# 1.6.3 dom事件流\n\n 1. 事件流描述的是从页面中接收事件的顺序\n 2. 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即dom事件流\n 3. 分成三个阶段：捕获阶段、当前目标阶段和冒泡阶段\n    * 捕获：由dom最顶层节点开始，逐级向下传播到最具体的元素接收的过程\n    * 目标\n    * 冒泡：事件开始时由最具体的元素接收，然后逐层向上传播到dom最顶层节点的过程\n 4. js代码只能执行捕获或者冒泡其中的一个阶段\n 5. onclick和attachevent只能得到冒泡阶段\n 6. addeventlistener(type,listener[ ,usecapture])\n    * 第三个参数如果是true，表示在事件捕获阶段调用事件处理程序\n    * false表示在事件冒泡阶段调用事件处理\n 7. 有些事件是没有冒泡的，比如onblur、onfocus、onmouseenter、onmouseleave\n\n# 1.6.4 事件对象\n\n 1. event就是一个事件对象，写在侦听函数的小括号里，当作形参来看待\n 2. 事件对象只有有了事件才会存在，是系统给我们自动创建的，不需要传递参数\n 3. 事件对象是事件的一系列相关数据的集合\n 4. 事件对象可以自己命名\n 5. 事件对象也有兼容性问题，ie678要使用window.event\n 6. 常见属性方法\n    * e.target：返回触发事件的对象（标准） ps：this是绑定事件的对象，和这个有区别\n    * e.screlement：返回触发事件的对象（ie678）\n    * e.type：返回事件的类型，不带on\n    * e.cancelbubble：该属性阻止冒泡（非标准ie678）\n    * e.returnvalue：该属性阻止默认事件（非标准ie678）\n    * e.preventdefault()：该方法阻止默认事件（标准）\n    * e.stoppropagation()：阻止冒泡（标准）\n\n# 1.6.5 事件委托\n\n 1. 事件委托也称为事件代理，在jquery里面称为事件委派\n 2. 事件委托原理：不是每个自建店单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点\n 3. 事件委托的作用：只操作一次dom，提高了程序的性能\n\n# 1.6.6 鼠标事件对象\n\n 1. e.clientx：返回鼠标相对于浏览器窗口可视区的x坐标\n 2. e.clienty：返回鼠标相对于浏览器窗口可视区的y坐标\n 3. e.pagex：返回鼠标相对于文档页面的x坐标（ie9+支持）\n 4. e.pagey：返回鼠标相对于文档页面的y坐标（ie9+支持）\n 5. e.screenx：返回鼠标相对于电脑屏幕的x坐标\n 6. e.screeny：返回鼠标相对于电脑屏幕的y坐标\n\n# 1.6.7 常用键盘事件\n\n 1. dom.onkeyup：某个键盘按键被松开时触发，不区分大小写\n 2. dom.onkeydown：某个键盘按键被按下时触发，不区分大小写\n 3. dom.onkeypress：耨个键盘按键被按下时触发（不能识别功能键），区分大小写\n 4. 三个事件的执行顺序，先执行down再执行press最后执行up\n\n# 1.6.8 键盘事件对象\n\n 1. e.keycode：返回按键对应的ascii码值，不区分大小写时是输出大写的ascii码\n\n\n# 2 bom\n\n\n# 2.1 bom相关概念\n\n 1. bom（browser object model）浏览器对象模型，它提供了独立于内容而与浏览器进行交互的对象，其核心对象是window\n 2. bom由一系列对象构成，并且每个对象都提供了很多方法与属性\n 3. bom缺乏标准，javascript语法的标准化祖师是ecma，dom的标准化组织是w3c，bom最初是netscape浏览器标准的一部分\n\n# 2.1.1 bom的构成\n\n 1. bom比dom更大，包含dom\n 2. window：\n    * document\n    * location\n    * navigation\n    * screen\n    * history\n 3. window对象是浏览器的顶级对象，具有双重角色\n    * 是js访问浏览器窗口的一个接口\n    * 是一个全局对象，定义在全局作用域中的变量、函数都会变成window对象的属性和方法。调用的时候可以省略window\n\n\n# 2.2 window对象常见事件\n\n# 2.2.1 窗口加载事件\n\n 1. 语法window.onload = function(){}或者window.addeventlistener(\"load\",function(){})\n 2. window.onload是窗口加载事件，当文档内容完全加载完成才会触发该事件\n 3. 有了window.onload就可以吧js代码写到页面元素的上方\n 4. window.onload传统注册事件方式只能写一次，如果有多个会以最后一个为准\n 5. 如果使用addeventlistener没有个数限值\n 6. 有一个类似的事件document.addeventlistener('domcontentloaded',function(){})，仅当dom加载完成，不包括样式表，图片，flash等，ie9以上才支持\n\n# 2.2.2 调整窗口大小事件\n\n 1. 语法window.onresize = function(){}或者window.addeventlistener(\"resize\",function(){})\n 2. window.onresize是调整窗口大小加载事件\n 3. 只要窗口大小发生像素变化，就会触发这个事件\n 4. 经常利用这个事件完成响应式布局。window.innerwidth属性对应当前屏幕的宽度\n\n\n# 2.3 定时器\n\n# 2.3.1 两种定时器\n\n 1. settimeout()\n 2. setinterval()\n\n# 2.3.2 settimeout()\n\n 1. 语法window.settimeout(调用函数,[延迟的毫秒数])\n 2. 用于设置一个定时器，该定时器在定时器到期后执行调用函数\n 3. 延时时间单位是毫秒，单位不用写。整体可以省略，默认是0\n 4. 调用函数可以直接写函数，也可以写函数名，还可以写函数名()但不推荐\n 5. 页面中会存在很多定时器，需要给定时器加标识符\n 6. settimeout里的调用函数也称为回调函数callback。这个函数需要等待事件，时间到了才去调用这个函数\n\n# 2.3.3 停止settimeout()定时器\n\n 1. 语法window.cleartimeout(timeout id)\n 2. cleartimeout()方法取消了先前通过调用settimeout()建立的定时器\n 3. window可以省略\n 4. 括号里面的是定时器的标识符\n\n# 2.3.4 setinterval()\n\n 1. 语法window.setinterval(调用函数,[间隔的毫秒数])\n 2. setinterval()方法重复调用一个函数，每隔一段时间就去调用一次回调函数\n\n# 2.3.5 停止setinterval()定时器\n\n 1. 语法window.clearinterval(interval id)\n 2. 与停止settimeout一致\n\n# 2.3.6 this\n\n 1. 函数定义的时候无法确认，函数被调用的时候才能确定this指向谁，一般指向调用它的对象\n 2. 全局作用域或者普通函数中this指向全局对象window\n 3. 定时器里面的this指向window\n 4. 在方法中this指向方法\n 5. 构造函数中this指向构造函数的实例\n\n\n# 2.4 js执行队列\n\n# 2.4.1 js是单线程\n\n 1. javascript语言的一大特点是单线程，就是同一个时间只能做一件事\n 2. 是因为javascript是为了操作dom，必须先添加再删除，所以必须是单线程\n 3. 单线程意味着所有任务需要排队，带来的问题是js执行时间过长，页面渲染不连贯，导致页面渲染加载阻塞的感觉\n\n# 2.4.2 同步和异步\n\n 1. 为了解决js执行过长渲染不连贯的问题，利用多核cpu的计算能力，html5提出web worker标准，允许javascript脚本创建多个线程，js出现同步和异步\n 2. 同步：前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的\n 3. 异步：在做一件事的同事还可以处理其他的事情\n 4. js把任务分成两种\n    * 同步任务：同步任务都在主线程上执行，形成一个执行栈\n    * 异步任务：js的异步任务是通过回调函数实现的\n    * 常见的异步任务\n      * 普通事件，click、resize\n      * 资源加载，load、error\n      * 定时器，setinterval、settimeout\n    * 异步任务相关回调函数添加到任务队列中（任务队列也叫消息队列）\n\n# 2.4.3 js执行机制\n\n 1. 先执行执行栈中的同步任务\n 2. 遇到回调函数把异步任务放入任务队列中\n 3. 一旦执行栈中的所有同步任务执行完毕，系统就会按次序速去任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行\n 4. 事件循环(event loop)：由于主线程不断的重复获得任务、执行任务的机制\n\n\n# 2.5 location对象\n\n 1. window对象给我们提供了一个location属性用于获取或设置窗体的url，并且可以用于解析url\n 2. 因为这个属性返回的是一个对象，所以将这个属性称为location对象\n\n# 2.5.1 url\n\n 1. 统一资源定位符是互联网上标准资源的地址\n 2. 一般语法格式protocol://host[:port]/path/[?query]#fragment\n 3. protocol:通信协议 常用的http，ftp，maito等\n 4. host：主机(域名)\n 5. port：端口号，可选，省略时使用方案的默认端口\n 6. path：路径，由零活多个'/'符号隔开的字符串，一般用来表示主机上的一个目录或文件地址\n 7. query：参数，以键值对的相识，通过&符号分隔开\n 8. fragment:片段，#后面内容常见于连接锚点\n\n# 2.5.2 location对象的属性\n\n\n\n# 2.5.3 location对象的方法\n\n\n\n\n# 2.5.4 navigator对象\n\n 1. navigator对象包含浏览器的相关信息\n 2. navigator对象最常用的属性是useragent，返回有客户机发送服务器的user-agent头部值\n\n\n# 2.5.5 history对象\n\n 1. window对象提供一个history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）\n 2. back()：后退功能\n 3. forward()：前进功能\n 4. go(参数)：前进后退功能。参数是1前进1个页面，-1后退1个页面\n\n\n# 3 pc网页特效\n\n\n# 3.1 元素三大系列\n\n# 3.1.1 元素偏移量offset系列\n\n 1. 使用offset系列相关属性可以动态地得到该元素的位置、大小\n 2. 获得元素距离带有定位父元素的位置\n 3. 获得元素自身的大小（宽度高度）\n 4. 返回的数值不带单位\n\n# offsetleft与offsettop\n\n 1. 各自返回元素相对于有定位父元素的上方、左边偏移量\n 2. 如果没有定位的父元素，则以body为准\n\n# offsetwidth与offsetheight\n\n 1. 各自返回元素包括padding、边框、内容区的宽度、高度\n\n# offsetparent\n\n 1. 返回该元素带有定位的父级元素\n 2. 父级都没有定位则返回body\n\n# offset与style区别\n\n 1. offset\n    * 可以得到任意样式表中的样式值\n    * 获得的数值没有段位\n    * offsetwidth包含padding、border和width\n    * 只能读属性不能赋值\n    * 更合适获取元素大小位置\n 2. style\n    * 只能得到行内样式表中的样式值\n    * 获得带有单位的字符串\n    * style.width不包含padding和border\n    * 可读写属性\n    * 更适合给元素赋值\n\n# 3.1.2 元素可视区client系列\n\n 1. 使用client系列的相关属性可以动态得到元素边框大小、元素大小等\n\n# clienttop与clientleft\n\n 1. 各自返回元素包括上边、左边边框大小\n\n# clientwidth与clienthight\n\n 1. 各自返回元素包括padding、内容区的宽度、高度\n 2. 与offset最大的区别就是不包含边框大小\n\n# 3.1.3 元素滚动scroll系列\n\n 1. 使用scroll系列的相关属性可以动态地得到该元素的大小、滚动距离等\n 2. 滚动条滚动会触发onscroll事件\n 3. 页面的滚动距离使用window.pagexoffset获得\n\n# scrolltop与scrollleft\n\n 1. 各自返回被卷去的上侧、左侧距离\n 2. 返回数值不带单位\n\n# scrollwidth与scrollhight\n\n 1. 各自返回自身实际宽度、高度，不含边框\n 2. 返回数值不带单位\n 3. 返回的是包含内容overflow的大小\n\n# 3.1.4 立即执行函数\n\n 1. 不需要调用，立马能够自己执行的函数\n 2. 语法1(function() {})()\n 3. 语法2(function() {}())\n 4. 立即执行函数最大的作用是独立创建了一个作用域\n 5. 所有变量都是局部变量，不存在命名冲突\n\n# 3.1.5 moseenter和mouseover区别\n\n# mouseenter\n\n 1. 当鼠标移动到元素上时会触发mouseenter事件\n 2. mouseenter只在经过自身盒子时触发\n 3. 不会有冒泡的概念\n 4. 搭配使用的是mouseleave，同样不会冒泡\n\n# mouseover\n\n 1. 当鼠标移动到元素上时会触发mouseover事件\n 2. 不仅经过自身盒子会触发，经过子盒子也会触发\n\n\n# 3.2 动画函数\n\n# 3.2.1 动画实现原理\n\n通过定时器setinterval()不断移动盒子位置\n\n 1. 获得盒子当前的位置\n 2. 让盒子在当前位置上加移动距离\n 3. 加一个结束定时器的条件\n 4. 注意此元素需要添加定位，才能使用element.style.left\n\n# 3.2.2 动画函数简单封装\n\n 1. 函数需要传递2个参数，动画对象和移动到的距离\n\n# 3.2.3 缓动动画\n\n 1. 原理：让元素运动有所变化，最常见的是让速度慢慢停下\n 2. 核心算法：每次移动步长=math.ceil/floor((目标值-现在的位置)/10)\n\n# 3.2.4 动画函数添加回调函数\n\n 1. 回调函数原理：函数作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程叫做回调\n 2. 可以把函数当做一个参数输入另一个函数中\n\n# 3.2.5 动画函数封装\n\n 1. 单独创建一个js文件\n 2. 把函数写在里面\n 3. 在html中引入js文件",charsets:{cjk:!0}},{title:"JavaScript基础知识",frontmatter:{title:"JavaScript基础知识",date:"2022-06-27T20:55:40.000Z",permalink:"/pages/f7ae59/",categories:["《JavaScript》","《现代JavaScript教程》","JavaScript编程语言"],tags:["JavaScript"]},regularPath:"/%E3%80%8AJavaScript%E3%80%8B/02.%E3%80%8A%E7%8E%B0%E4%BB%A3JavaScript%E6%95%99%E7%A8%8B%E3%80%8B/00.%20JavaScript%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.%20JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html",relativePath:"《JavaScript》/02.《现代JavaScript教程》/00. JavaScript编程语言/01. JavaScript基础知识.md",key:"v-606287cc",path:"/pages/f7ae59/",headers:[{level:2,title:"2.1 运行脚本",slug:"_2-1-运行脚本",normalizedTitle:"2.1 运行脚本",charIndex:2},{level:3,title:"2.1.1 script标签",slug:"_2-1-1-script标签",normalizedTitle:"2.1.1 script标签",charIndex:15},{level:3,title:"2.1.2 script标签属性",slug:"_2-1-2-script标签属性",normalizedTitle:"2.1.2 script标签属性",charIndex:144},{level:4,title:"type 特性：<script type=…>",slug:"type-特性-script-type",normalizedTitle:"type 特性：<script type=…>",charIndex:216},{level:4,title:"language 特性：<script language=…>",slug:"language-特性-script-language",normalizedTitle:"language 特性：<script language=…>",charIndex:308},{level:4,title:"脚本前后的注释",slug:"脚本前后的注释",normalizedTitle:"脚本前后的注释",charIndex:396},{level:3,title:"2.1.3 外部脚本",slug:"_2-1-3-外部脚本",normalizedTitle:"2.1.3 外部脚本",charIndex:594},{level:4,title:"src路径",slug:"src路径",normalizedTitle:"src路径",charIndex:697},{level:4,title:"外部脚本加载",slug:"外部脚本加载",normalizedTitle:"外部脚本加载",charIndex:787},{level:3,title:"2.1.4 总结",slug:"_2-1-4-总结",normalizedTitle:"2.1.4 总结",charIndex:930},{level:2,title:"2.2 代码结构",slug:"_2-2-代码结构",normalizedTitle:"2.2 代码结构",charIndex:1094},{level:3,title:"2.2.1 语句",slug:"_2-2-1-语句",normalizedTitle:"2.2.1 语句",charIndex:1107},{level:3,title:"2.2.2 分号",slug:"_2-2-2-分号",normalizedTitle:"2.2.2 分号",charIndex:1202},{level:4,title:"自动分号插入",slug:"自动分号插入",normalizedTitle:"自动分号插入",charIndex:1249},{level:3,title:"2.2.3 注释",slug:"_2-2-3-注释",normalizedTitle:"2.2.3 注释",charIndex:1482},{level:2,title:"2.3 现代模式",slug:"_2-3-现代模式",normalizedTitle:"2.3 现代模式",charIndex:1651},{level:2,title:"2.4 变量",slug:"_2-4-变量",normalizedTitle:"2.4 变量",charIndex:1929},{level:3,title:"2.4.1 变量使用",slug:"_2-4-1-变量使用",normalizedTitle:"2.4.1 变量使用",charIndex:1952},{level:4,title:"变量声明",slug:"变量声明",normalizedTitle:"变量声明",charIndex:1966},{level:4,title:"变量赋值",slug:"变量赋值",normalizedTitle:"变量赋值",charIndex:2167},{level:4,title:"变量访问",slug:"变量访问",normalizedTitle:"变量访问",charIndex:2206},{level:3,title:"2.4.2 变量命名",slug:"_2-4-2-变量命名",normalizedTitle:"2.4.2 变量命名",charIndex:2242},{level:4,title:"变量命名限制",slug:"变量命名限制",normalizedTitle:"变量命名限制",charIndex:2256},{level:3,title:"2.4.3 常量",slug:"_2-4-3-常量",normalizedTitle:"2.4.3 常量",charIndex:2429},{level:4,title:"大写形式的常数",slug:"大写形式的常数",normalizedTitle:"大写形式的常数",charIndex:2516},{level:3,title:"2.4.4 总结",slug:"_2-4-4-总结",normalizedTitle:"2.4.4 总结",charIndex:2580},{level:2,title:"2.5 数据类型",slug:"_2-5-数据类型",normalizedTitle:"2.5 数据类型",charIndex:2789},{level:3,title:"2.5.1 动态类型",slug:"_2-5-1-动态类型",normalizedTitle:"2.5.1 动态类型",charIndex:2802},{level:3,title:"2.5.2 Number",slug:"_2-5-2-number",normalizedTitle:"2.5.2 number",charIndex:2972},{level:4,title:"Infinity",slug:"infinity",normalizedTitle:"infinity",charIndex:3095},{level:4,title:"NaN",slug:"nan",normalizedTitle:"nan",charIndex:3116},{level:3,title:"2.5.3 BigInt",slug:"_2-5-3-bigint",normalizedTitle:"2.5.3 bigint",charIndex:3421},{level:3,title:"2.5.4 String",slug:"_2-5-4-string",normalizedTitle:"2.5.4 string",charIndex:3580},{level:4,title:"反引号",slug:"反引号",normalizedTitle:"反引号",charIndex:3661},{level:3,title:"2.5.5 Boolean",slug:"_2-5-5-boolean",normalizedTitle:"2.5.5 boolean",charIndex:4071},{level:3,title:"2.5.6 null值",slug:"_2-5-6-null值",normalizedTitle:"2.5.6 null值",charIndex:4133},{level:3,title:"2.5.7 undefined值",slug:"_2-5-7-undefined值",normalizedTitle:"2.5.7 undefined值",charIndex:4306},{level:3,title:"2.5.8 Object",slug:"_2-5-8-object",normalizedTitle:"2.5.8 object",charIndex:4520},{level:3,title:"2.5.9 Symbol",slug:"_2-5-9-symbol",normalizedTitle:"2.5.9 symbol",charIndex:4632},{level:3,title:"2.5.10 typeof 运算符",slug:"_2-5-10-typeof-运算符",normalizedTitle:"2.5.10 typeof 运算符",charIndex:4672},{level:3,title:"2.5.11 总结",slug:"_2-5-11-总结",normalizedTitle:"2.5.11 总结",charIndex:5634},{level:2,title:"2.6 交互",slug:"_2-6-交互",normalizedTitle:"2.6 交互",charIndex:6153},{level:3,title:"2.6.1 alert",slug:"_2-6-1-alert",normalizedTitle:"2.6.1 alert",charIndex:6164},{level:3,title:"2.6.2 prompt",slug:"_2-6-2-prompt",normalizedTitle:"2.6.2 prompt",charIndex:6302},{level:4,title:"title",slug:"title",normalizedTitle:"title",charIndex:6350},{level:4,title:"default",slug:"default",normalizedTitle:"default",charIndex:6358},{level:3,title:"2.6.2 confirm",slug:"_2-6-2-confirm",normalizedTitle:"2.6.2 confirm",charIndex:6619},{level:3,title:"2.6.3 总结",slug:"_2-6-3-总结",normalizedTitle:"2.6.3 总结",charIndex:6742}],headersStr:"2.1 运行脚本 2.1.1 script标签 2.1.2 script标签属性 type 特性：<script type=…> language 特性：<script language=…> 脚本前后的注释 2.1.3 外部脚本 src路径 外部脚本加载 2.1.4 总结 2.2 代码结构 2.2.1 语句 2.2.2 分号 自动分号插入 2.2.3 注释 2.3 现代模式 2.4 变量 2.4.1 变量使用 变量声明 变量赋值 变量访问 2.4.2 变量命名 变量命名限制 2.4.3 常量 大写形式的常数 2.4.4 总结 2.5 数据类型 2.5.1 动态类型 2.5.2 Number Infinity NaN 2.5.3 BigInt 2.5.4 String 反引号 2.5.5 Boolean 2.5.6 null值 2.5.7 undefined值 2.5.8 Object 2.5.9 Symbol 2.5.10 typeof 运算符 2.5.11 总结 2.6 交互 2.6.1 alert 2.6.2 prompt title default 2.6.2 confirm 2.6.3 总结",content:'# 2.1 运行脚本\n\n\n# 2.1.1 script标签\n\n我们几乎可以使用 <script> 标签将 JavaScript 程序插入到 HTML 文档的任何位置。\n<script>标签中包裹了 JavaScript 代码，当浏览器遇到 <script> 标签，代码会自动运行\n\n\n# 2.1.2 script标签属性\n\n<script> 标签有一些现在很少用到的特性（attribute），但是我们可以在老代码中找到它们\n\n# type 特性：<script type=…>\n\n在老的 HTML4 标准中，要求 script 标签有 type 特性。通常是 type="text/javascript"。\n\n# language 特性：<script language=…>\n\n这个特性是为了显示脚本使用的语言。这个特性现在已经没有任何意义，因为语言默认就是 JavaScript\n\n# 脚本前后的注释\n\n在非常古老的书籍和指南中，你可能会在 <script> 标签里面找到注释，就像这样：\n\n<script type="text/javascript">\x3c!--\n    ...\n//--\x3e<\/script>\n\n\n1\n2\n3\n\n\n这些注释是用于不支持 <script> 标签的古老的浏览器隐藏 JavaScript 代码的。由于最近 15 年内发布的浏览器都没有这样的问题\n\n\n# 2.1.3 外部脚本\n\n脚本文件可以通过 src 特性（attribute）添加到 HTML 文件中\n\n<script src="/path/to/script.js"><\/script>\n\n\n1\n\n\n# src路径\n\n 1. /path脚本文件从网站根目录开始的绝对路径\n 2. ./path脚本文件对于当前页面的相对路径\n 3. https://path完整的 URL 地址\n\n# 外部脚本加载\n\n 1. 浏览器会下载外部脚本，并将它保存到浏览器缓存中\n 2. 其他页面想要相同的脚本就会从缓存中获取，而不是下载它。所以文件实际上只会下载一次\n 3. 可以节省流量，并使得页面（加载）更快\n\n警告\n\n如果设置了 src 特性，script 标签内容将会被忽略\n\n\n# 2.1.4 总结\n\n 1. 我们可以使用一个 <script> 标签将 JavaScript 代码添加到页面中。\n 2. type 和 language 特性（attribute）不是必需的。\n 3. 外部的脚本可以通过 <script src="path/to/script.js"><\/script> 的方式插入。\n\n\n# 2.2 代码结构\n\n\n# 2.2.1 语句\n\n语句是执行行为（action）的语法结构和命令。\n我们可以在代码中编写任意数量的语句。语句之间可以使用分号进行分割。\n通常，每条语句独占一行，以提高代码的可读性\n\n\n# 2.2.2 分号\n\n当存在换行符（line break）时，在大多数情况下可以省略分号\n\n# 自动分号插入\n\nJavaScript 将换行符理解成“隐式”的分号 在大多数情况下，换行意味着一个分号。但是“大多数情况”并不意味着“总是”\n\nalert(3 +\n1\n+ 2);\n\n\n1\n2\n3\n\n\n存在 JavaScript 无法确定是否真的需要自动插入分号的情况\n\nalert("Hello")\n[1, 2].forEach(alert);\n// 会理解为\nalert("Hello")[1, 2].forEach(alert);\n\n\n1\n2\n3\n4\n\n\n\n# 2.2.3 注释\n\n单行注释以两个正斜杠字符 // 开始 多行注释以一个正斜杠和星号开始 “/*” 并以一个星号和正斜杠结束 “*/”\n\n提示\n\n在大多数的编辑器中，一行代码可以使用 Ctrl+/ 快捷键进行单行注释，诸如 Ctrl+Shift+/ 的快捷键可以进行多行注释（选择代码，然后按下快捷键）\n\n警告\n\n不支持注释嵌套\n\n\n# 2.3 现代模式\n\nES5 规范增加了新的语言特性并且修改了一些已经存在的特性。为了保证旧的功能能够使用，大部分的修改是默认不生效的。你需要一个特殊的指令 —— "use strict" 来明确地激活这些特性\n"use strict" 或者 \'use strict\'。当它处于脚本文件的顶部时，则整个脚本文件都将以“现代”模式进行工作\n"use strict" 可以被放在函数体的开头。这样则可以只在该函数中启用严格模式\n\n警告\n\n请确保 "use strict" 出现在脚本的最顶部，否则严格模式可能无法启用 没有办法取消 use strict\n\n\n# 2.4 变量\n\n变量是数据的命名存储\n\n\n# 2.4.1 变量使用\n\n# 变量声明\n\n声明或者定义一个名为massage的变量let massage\n\n可以将变量定义和赋值合并成一行let message = \'Hello!\'\n\n也可以在一行中声明多个变量let user = \'John\', age = 25, message = \'Hello\';\n\n多次声明\n\n声明两次会触发 error\n\n一个变量应该只被声明一次。\n\n对同一个变量进行重复声明会触发 error\n\n# 变量赋值\n\n对massage变量赋值message = \'Hello\'\n\n# 变量访问\n\n访问massage变量alert(massage)\n\n\n# 2.4.2 变量命名\n\n# 变量命名限制\n\n 1. 变量名称必须仅包含字母、数字、符号 $ 和 _\n 2. 首字符必须非数字\n\n如果命名包括多个单词，通常采用驼峰式命名法（camelCase）\njs中变量名区分大小写\n\n保留字\n\njs中存在保留字无法用作变量命名\n\n警告\n\n未采用use strict时可以通过直接赋值的方式使程序自动声明变量\n但严格模式下则会报错\n\n\n# 2.4.3 常量\n\n声明一个常数（不变）变量，通常使用 const 而非 let\n使用 const 声明的变量称为“常量”。它们不能被修改，如果你尝试修改就会发现报错\n\n# 大写形式的常数\n\n一般代码执行前就知晓且不变的数据用大写形式的常量存储，在代码执行过程中得到的不变的数据用普通常量存储\n\n\n# 2.4.4 总结\n\n我们可以使用 var、let 或 const 声明变量来存储数据。\n\n * let — 现代的变量声明方式。\n * var — 老旧的变量声明方式。一般情况下，我们不会再使用它。但是，我们会在 老旧的 "var" 章节介绍 var 和 let 的微妙差别，以防你需要它们。\n * const — 类似于 let，但是变量的值无法被修改。 变量应当以一种容易理解变量内部是什么的方式进行命名\n\n\n# 2.5 数据类型\n\n\n# 2.5.1 动态类型\n\nJavaScript 中的值都具有特定的类型\n在 JavaScript 中有 8 种基本的数据类型（译注：7 种原始类型和 1 种引用类型）\nJavaScript是动态类型（dynamically typed）的编程语言，虽然编程语言中有不同的数据类型，但是你定义的变量并不会在定义后，被限制为某一数据类型\n\n\n# 2.5.2 Number\n\nnumber 类型代表整数和浮点数 数字可以有很多操作，比如，乘法 *、除法 /、加法 +、减法 - 等等。\n除了常规的数字，还包括所谓的“特殊数值（“special numeric values”）”也属于这种类型：Infinity、-Infinity 和 NaN\n\n# Infinity\n\nInfinity 代表数学概念中的 无穷大 ∞。是一个比任何数字都大的特殊值\n我们可以通过除以 0 来得到它\n或者在代码中直接使用它\n\n# NaN\n\nNaN 代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果\nNaN 是粘性的。任何对 NaN 的进一步数学运算都会返回 NaN\n\nNaN数学运算的例外\n\nNaN ** 0 结果为 1\n\n提示\n\n在 JavaScript 中做数学运算是安全的。我们可以做任何事：除以 0，将非数字字符串视为数字，等等。\n\n脚本永远不会因为一个致命的错误（“死亡”）而停止。最坏的情况下，我们会得到 NaN 的结果。\n\n\n# 2.5.3 BigInt\n\n"number" 类型无法表示大于 (253-1)（即 9007199254740991），或小于 -(253-1) 的整数\nBigInt 类型是最近被添加到 JavaScript 语言中的，用于表示任意长度的整数。\n\n可以通过将 n 附加到整数字段的末尾来创建 BigInt 值\n\n\n# 2.5.4 String\n\n在 JavaScript 中，有三种包含字符串的方式。\n\n 1. 双引号："Hello".\n 2. 单引号：\'Hello\'.\n 3. 反引号：`Hello`.\n\n双引号和单引号都是“简单”引用，在 JavaScript 中两者几乎没有什么差别\n\n# 反引号\n\n反引号是 功能扩展 引号。它们允许我们通过将变量和表达式包装在 ${…} 中，来将它们嵌入到字符串中\n\nlet name = "John";\n// 嵌入一个变量\nalert( `Hello, *!*${name}*/!*!` ); // Hello, John!\n// 嵌入一个表达式\nalert( `the result is *!*${1 + 2}*/!*` ); // the result is 3\n\n\n1\n2\n3\n4\n5\n\n\n${…} 内的表达式会被计算，计算结果会成为字符串的一部分。可以在 ${…} 内放置任何东西：诸如名为 name 的变量，或者诸如 1 + 2 的算数表达式，或者其他一些更复杂的\n\n注意\n\n需要注意的是，这仅仅在反引号内有效，其他引号不允许这种嵌入\n\n\n# 2.5.5 Boolean\n\nboolean 类型仅包含两个值：true 和 false\n布尔值也可作为比较的结果\n\n\n# 2.5.6 null值\n\n特殊的 null 值不属于上述任何一种类型。\n它构成了一个独立的类型，只包含 null 值\n相比较于其他编程语言，JavaScript 中的 null 不是一个“对不存在的 object 的引用”或者 “null 指针”。\nJavaScript 中的 null 仅仅是一个代表“无”、“空”或“值未知”的特殊值\n\n\n# 2.5.7 undefined值\n\n特殊值 undefined 和 null 一样自成类型\n\nundefined 的含义是 未被赋值\n\n如果一个变量已被声明，但未被赋值，那么它的值就是 undefined\n\n注意\n\n从技术上讲，可以显式地将 undefined 赋值给变量 但是不建议这样做。通常，使用 null 将一个“空”或者“未知”的值写入变量中，而 undefined 则保留作为未进行初始化的事物的默认初始值\n\n\n# 2.5.8 Object\n\nobject 类型是一个特殊的类型，其他所有的数据类型都被称为“原始类型”，因为它们的值只包含一个单独的内容（字符串、数字或者其他）。相反，object 则用于储存数据集合和更复杂的实体\n\n\n# 2.5.9 Symbol\n\nsymbol 类型用于创建对象的唯一标识符\n\n\n# 2.5.10 typeof 运算符\n\ntypeof 运算符返回参数的类型\n\n\n\n\n\n\n\n\n \n \n\n\n\ntypeof undefined // "undefined"\ntypeof 0 // "number"\ntypeof 10n // "bigint"\ntypeof true // "boolean"\ntypeof "foo" // "string"\ntypeof Symbol("id") // "symbol"\ntypeof Math // "object"  (1)\ntypeof null // "object"  (2)\ntypeof alert // "function"  (3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\ntypeof null\n\ntypeof null 的结果为 "object"。这是官方承认的 typeof 的错误，这个问题来自于 JavaScript 语言的早期阶段，并为了兼容性而保留了下来。null 绝对不是一个 object。null 有自己的类型，它是一个特殊值。typeof 的行为在这里是错误的。\n\nfunction\n\ntypeof alert 的结果是 "function"，因为 alert 在 JavaScript 语言中是一个函数。我们会在下一章学习函数，那时我们会了解到，在 JavaScript 语言中没有一个特别的 "function" 类型。函数隶属于 object 类型。但是 typeof 会对函数区分对待，并返回 "function"。这也是来自于 JavaScript 语言早期的问题。从技术上讲，这种行为是不正确的，但在实际编程中却非常方便\n\n`typeof(x)` 语法\n\n你可能还会遇到另一种语法：typeof(x)。它与 typeof x 相同。\n简单点说：typeof 是一个操作符，不是一个函数。这里的括号不是 typeof 的一部分。它是数学运算分组的括号。\n通常，这样的括号里包含的是一个数学表达式，例如 (2 + 2)，但这里它只包含一个参数 (x)。从语法上讲，它们允许在 typeof 运算符和其参数之间不打空格，有些人喜欢这样的风格。\n有些人更喜欢用 typeof(x)，尽管 typeof x 语法更为常见\n\n\n# 2.5.11 总结\n\nJavaScript 中有八种基本的数据类型（译注：前七种为基本数据类型，也称为原始类型，而 object 为复杂数据类型）。\n\n * number 用于任何类型的数字：整数或浮点数，在 ±(253-1) 范围内的整数。\n * bigint 用于任意长度的整数。\n * string 用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型。\n * boolean 用于 true 和 false。\n * null 用于未知的值 —— 只有一个 null 值的独立类型。\n * undefined 用于未定义的值 —— 只有一个 undefined 值的独立类型。\n * symbol 用于唯一的标识符。\n * object 用于更复杂的数据结构。\n\n我们可以通过 typeof 运算符查看存储在变量中的数据类型。\n\n * 通常用作 typeof x，但 typeof(x) 也可行。\n * 以字符串的形式返回类型名称，例如 "string"。\n * typeof null 会返回 "object" —— 这是 JavaScript 编程语言的一个错误，实际上它并不是一个 object\n\n\n# 2.6 交互\n\n\n# 2.6.1 alert\n\n浏览器中显示一条信息，并等待用户按下”OK”\n弹出的这个带有信息的小窗口被称为 模态窗。"modal" 意味着用户不能与页面的其他部分（例如点击其他按钮等）进行交互，直到他们处理完窗口。在上面示例这种情况下 —— 直到用户点击“确定”按钮。\n\n\n# 2.6.2 prompt\n\nprompt 函数接收两个参数：\n\nresult = prompt(title, [default]);\n\n\n1\n\n\n浏览器会显示一个带有文本消息的模态窗口，还有 input 框和确定/取消按钮。\n访问者可以在提示输入栏中输入一些内容，然后按“确定”键。然后我们在 result 中获取该文本。或者他们可以按取消键或按 key:Esc 键取消输入，然后我们得到 null 作为 result。\nprompt 将返回用户在 input 框内输入的文本，如果用户取消了输入，则返回 null\n\n# title\n\n显示给用户的文本\n\n# default\n\n可选的第二个参数，指定 input 框的初始值\n\n\n# 2.6.2 confirm\n\nresult = confirm(question);\n\n\n1\n\n\nconfirm 函数显示一个带有 question 以及确定和取消两个按钮的模态窗口。\n\n点击确定返回 true，点击取消返回 false\n\n\n# 2.6.3 总结\n\n我们学习了与用户交互的 3 个浏览器的特定函数：\n\nalert : 显示信息。\n\nprompt : 显示信息要求用户输入文本。点击确定返回文本，点击取消或按下 key:Esc 键返回 null。\n\nconfirm : 显示信息等待用户点击确定或取消。点击确定返回 true，点击取消或按下 key:Esc 键返回 false。\n\n这些方法都是模态的：它们暂停脚本的执行，并且不允许用户与该页面的其余部分进行交互，直到窗口被解除。\n\n上述所有方法共有两个限制：\n\n 1. 模态窗口的确切位置由浏览器决定。通常在页面中心。\n 2. 窗口的确切外观也取决于浏览器。我们不能修改它。',normalizedContent:'# 2.1 运行脚本\n\n\n# 2.1.1 script标签\n\n我们几乎可以使用 <script> 标签将 javascript 程序插入到 html 文档的任何位置。\n<script>标签中包裹了 javascript 代码，当浏览器遇到 <script> 标签，代码会自动运行\n\n\n# 2.1.2 script标签属性\n\n<script> 标签有一些现在很少用到的特性（attribute），但是我们可以在老代码中找到它们\n\n# type 特性：<script type=…>\n\n在老的 html4 标准中，要求 script 标签有 type 特性。通常是 type="text/javascript"。\n\n# language 特性：<script language=…>\n\n这个特性是为了显示脚本使用的语言。这个特性现在已经没有任何意义，因为语言默认就是 javascript\n\n# 脚本前后的注释\n\n在非常古老的书籍和指南中，你可能会在 <script> 标签里面找到注释，就像这样：\n\n<script type="text/javascript">\x3c!--\n    ...\n//--\x3e<\/script>\n\n\n1\n2\n3\n\n\n这些注释是用于不支持 <script> 标签的古老的浏览器隐藏 javascript 代码的。由于最近 15 年内发布的浏览器都没有这样的问题\n\n\n# 2.1.3 外部脚本\n\n脚本文件可以通过 src 特性（attribute）添加到 html 文件中\n\n<script src="/path/to/script.js"><\/script>\n\n\n1\n\n\n# src路径\n\n 1. /path脚本文件从网站根目录开始的绝对路径\n 2. ./path脚本文件对于当前页面的相对路径\n 3. https://path完整的 url 地址\n\n# 外部脚本加载\n\n 1. 浏览器会下载外部脚本，并将它保存到浏览器缓存中\n 2. 其他页面想要相同的脚本就会从缓存中获取，而不是下载它。所以文件实际上只会下载一次\n 3. 可以节省流量，并使得页面（加载）更快\n\n警告\n\n如果设置了 src 特性，script 标签内容将会被忽略\n\n\n# 2.1.4 总结\n\n 1. 我们可以使用一个 <script> 标签将 javascript 代码添加到页面中。\n 2. type 和 language 特性（attribute）不是必需的。\n 3. 外部的脚本可以通过 <script src="path/to/script.js"><\/script> 的方式插入。\n\n\n# 2.2 代码结构\n\n\n# 2.2.1 语句\n\n语句是执行行为（action）的语法结构和命令。\n我们可以在代码中编写任意数量的语句。语句之间可以使用分号进行分割。\n通常，每条语句独占一行，以提高代码的可读性\n\n\n# 2.2.2 分号\n\n当存在换行符（line break）时，在大多数情况下可以省略分号\n\n# 自动分号插入\n\njavascript 将换行符理解成“隐式”的分号 在大多数情况下，换行意味着一个分号。但是“大多数情况”并不意味着“总是”\n\nalert(3 +\n1\n+ 2);\n\n\n1\n2\n3\n\n\n存在 javascript 无法确定是否真的需要自动插入分号的情况\n\nalert("hello")\n[1, 2].foreach(alert);\n// 会理解为\nalert("hello")[1, 2].foreach(alert);\n\n\n1\n2\n3\n4\n\n\n\n# 2.2.3 注释\n\n单行注释以两个正斜杠字符 // 开始 多行注释以一个正斜杠和星号开始 “/*” 并以一个星号和正斜杠结束 “*/”\n\n提示\n\n在大多数的编辑器中，一行代码可以使用 ctrl+/ 快捷键进行单行注释，诸如 ctrl+shift+/ 的快捷键可以进行多行注释（选择代码，然后按下快捷键）\n\n警告\n\n不支持注释嵌套\n\n\n# 2.3 现代模式\n\nes5 规范增加了新的语言特性并且修改了一些已经存在的特性。为了保证旧的功能能够使用，大部分的修改是默认不生效的。你需要一个特殊的指令 —— "use strict" 来明确地激活这些特性\n"use strict" 或者 \'use strict\'。当它处于脚本文件的顶部时，则整个脚本文件都将以“现代”模式进行工作\n"use strict" 可以被放在函数体的开头。这样则可以只在该函数中启用严格模式\n\n警告\n\n请确保 "use strict" 出现在脚本的最顶部，否则严格模式可能无法启用 没有办法取消 use strict\n\n\n# 2.4 变量\n\n变量是数据的命名存储\n\n\n# 2.4.1 变量使用\n\n# 变量声明\n\n声明或者定义一个名为massage的变量let massage\n\n可以将变量定义和赋值合并成一行let message = \'hello!\'\n\n也可以在一行中声明多个变量let user = \'john\', age = 25, message = \'hello\';\n\n多次声明\n\n声明两次会触发 error\n\n一个变量应该只被声明一次。\n\n对同一个变量进行重复声明会触发 error\n\n# 变量赋值\n\n对massage变量赋值message = \'hello\'\n\n# 变量访问\n\n访问massage变量alert(massage)\n\n\n# 2.4.2 变量命名\n\n# 变量命名限制\n\n 1. 变量名称必须仅包含字母、数字、符号 $ 和 _\n 2. 首字符必须非数字\n\n如果命名包括多个单词，通常采用驼峰式命名法（camelcase）\njs中变量名区分大小写\n\n保留字\n\njs中存在保留字无法用作变量命名\n\n警告\n\n未采用use strict时可以通过直接赋值的方式使程序自动声明变量\n但严格模式下则会报错\n\n\n# 2.4.3 常量\n\n声明一个常数（不变）变量，通常使用 const 而非 let\n使用 const 声明的变量称为“常量”。它们不能被修改，如果你尝试修改就会发现报错\n\n# 大写形式的常数\n\n一般代码执行前就知晓且不变的数据用大写形式的常量存储，在代码执行过程中得到的不变的数据用普通常量存储\n\n\n# 2.4.4 总结\n\n我们可以使用 var、let 或 const 声明变量来存储数据。\n\n * let — 现代的变量声明方式。\n * var — 老旧的变量声明方式。一般情况下，我们不会再使用它。但是，我们会在 老旧的 "var" 章节介绍 var 和 let 的微妙差别，以防你需要它们。\n * const — 类似于 let，但是变量的值无法被修改。 变量应当以一种容易理解变量内部是什么的方式进行命名\n\n\n# 2.5 数据类型\n\n\n# 2.5.1 动态类型\n\njavascript 中的值都具有特定的类型\n在 javascript 中有 8 种基本的数据类型（译注：7 种原始类型和 1 种引用类型）\njavascript是动态类型（dynamically typed）的编程语言，虽然编程语言中有不同的数据类型，但是你定义的变量并不会在定义后，被限制为某一数据类型\n\n\n# 2.5.2 number\n\nnumber 类型代表整数和浮点数 数字可以有很多操作，比如，乘法 *、除法 /、加法 +、减法 - 等等。\n除了常规的数字，还包括所谓的“特殊数值（“special numeric values”）”也属于这种类型：infinity、-infinity 和 nan\n\n# infinity\n\ninfinity 代表数学概念中的 无穷大 ∞。是一个比任何数字都大的特殊值\n我们可以通过除以 0 来得到它\n或者在代码中直接使用它\n\n# nan\n\nnan 代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果\nnan 是粘性的。任何对 nan 的进一步数学运算都会返回 nan\n\nnan数学运算的例外\n\nnan ** 0 结果为 1\n\n提示\n\n在 javascript 中做数学运算是安全的。我们可以做任何事：除以 0，将非数字字符串视为数字，等等。\n\n脚本永远不会因为一个致命的错误（“死亡”）而停止。最坏的情况下，我们会得到 nan 的结果。\n\n\n# 2.5.3 bigint\n\n"number" 类型无法表示大于 (253-1)（即 9007199254740991），或小于 -(253-1) 的整数\nbigint 类型是最近被添加到 javascript 语言中的，用于表示任意长度的整数。\n\n可以通过将 n 附加到整数字段的末尾来创建 bigint 值\n\n\n# 2.5.4 string\n\n在 javascript 中，有三种包含字符串的方式。\n\n 1. 双引号："hello".\n 2. 单引号：\'hello\'.\n 3. 反引号：`hello`.\n\n双引号和单引号都是“简单”引用，在 javascript 中两者几乎没有什么差别\n\n# 反引号\n\n反引号是 功能扩展 引号。它们允许我们通过将变量和表达式包装在 ${…} 中，来将它们嵌入到字符串中\n\nlet name = "john";\n// 嵌入一个变量\nalert( `hello, *!*${name}*/!*!` ); // hello, john!\n// 嵌入一个表达式\nalert( `the result is *!*${1 + 2}*/!*` ); // the result is 3\n\n\n1\n2\n3\n4\n5\n\n\n${…} 内的表达式会被计算，计算结果会成为字符串的一部分。可以在 ${…} 内放置任何东西：诸如名为 name 的变量，或者诸如 1 + 2 的算数表达式，或者其他一些更复杂的\n\n注意\n\n需要注意的是，这仅仅在反引号内有效，其他引号不允许这种嵌入\n\n\n# 2.5.5 boolean\n\nboolean 类型仅包含两个值：true 和 false\n布尔值也可作为比较的结果\n\n\n# 2.5.6 null值\n\n特殊的 null 值不属于上述任何一种类型。\n它构成了一个独立的类型，只包含 null 值\n相比较于其他编程语言，javascript 中的 null 不是一个“对不存在的 object 的引用”或者 “null 指针”。\njavascript 中的 null 仅仅是一个代表“无”、“空”或“值未知”的特殊值\n\n\n# 2.5.7 undefined值\n\n特殊值 undefined 和 null 一样自成类型\n\nundefined 的含义是 未被赋值\n\n如果一个变量已被声明，但未被赋值，那么它的值就是 undefined\n\n注意\n\n从技术上讲，可以显式地将 undefined 赋值给变量 但是不建议这样做。通常，使用 null 将一个“空”或者“未知”的值写入变量中，而 undefined 则保留作为未进行初始化的事物的默认初始值\n\n\n# 2.5.8 object\n\nobject 类型是一个特殊的类型，其他所有的数据类型都被称为“原始类型”，因为它们的值只包含一个单独的内容（字符串、数字或者其他）。相反，object 则用于储存数据集合和更复杂的实体\n\n\n# 2.5.9 symbol\n\nsymbol 类型用于创建对象的唯一标识符\n\n\n# 2.5.10 typeof 运算符\n\ntypeof 运算符返回参数的类型\n\n\n\n\n\n\n\n\n \n \n\n\n\ntypeof undefined // "undefined"\ntypeof 0 // "number"\ntypeof 10n // "bigint"\ntypeof true // "boolean"\ntypeof "foo" // "string"\ntypeof symbol("id") // "symbol"\ntypeof math // "object"  (1)\ntypeof null // "object"  (2)\ntypeof alert // "function"  (3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\ntypeof null\n\ntypeof null 的结果为 "object"。这是官方承认的 typeof 的错误，这个问题来自于 javascript 语言的早期阶段，并为了兼容性而保留了下来。null 绝对不是一个 object。null 有自己的类型，它是一个特殊值。typeof 的行为在这里是错误的。\n\nfunction\n\ntypeof alert 的结果是 "function"，因为 alert 在 javascript 语言中是一个函数。我们会在下一章学习函数，那时我们会了解到，在 javascript 语言中没有一个特别的 "function" 类型。函数隶属于 object 类型。但是 typeof 会对函数区分对待，并返回 "function"。这也是来自于 javascript 语言早期的问题。从技术上讲，这种行为是不正确的，但在实际编程中却非常方便\n\n`typeof(x)` 语法\n\n你可能还会遇到另一种语法：typeof(x)。它与 typeof x 相同。\n简单点说：typeof 是一个操作符，不是一个函数。这里的括号不是 typeof 的一部分。它是数学运算分组的括号。\n通常，这样的括号里包含的是一个数学表达式，例如 (2 + 2)，但这里它只包含一个参数 (x)。从语法上讲，它们允许在 typeof 运算符和其参数之间不打空格，有些人喜欢这样的风格。\n有些人更喜欢用 typeof(x)，尽管 typeof x 语法更为常见\n\n\n# 2.5.11 总结\n\njavascript 中有八种基本的数据类型（译注：前七种为基本数据类型，也称为原始类型，而 object 为复杂数据类型）。\n\n * number 用于任何类型的数字：整数或浮点数，在 ±(253-1) 范围内的整数。\n * bigint 用于任意长度的整数。\n * string 用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型。\n * boolean 用于 true 和 false。\n * null 用于未知的值 —— 只有一个 null 值的独立类型。\n * undefined 用于未定义的值 —— 只有一个 undefined 值的独立类型。\n * symbol 用于唯一的标识符。\n * object 用于更复杂的数据结构。\n\n我们可以通过 typeof 运算符查看存储在变量中的数据类型。\n\n * 通常用作 typeof x，但 typeof(x) 也可行。\n * 以字符串的形式返回类型名称，例如 "string"。\n * typeof null 会返回 "object" —— 这是 javascript 编程语言的一个错误，实际上它并不是一个 object\n\n\n# 2.6 交互\n\n\n# 2.6.1 alert\n\n浏览器中显示一条信息，并等待用户按下”ok”\n弹出的这个带有信息的小窗口被称为 模态窗。"modal" 意味着用户不能与页面的其他部分（例如点击其他按钮等）进行交互，直到他们处理完窗口。在上面示例这种情况下 —— 直到用户点击“确定”按钮。\n\n\n# 2.6.2 prompt\n\nprompt 函数接收两个参数：\n\nresult = prompt(title, [default]);\n\n\n1\n\n\n浏览器会显示一个带有文本消息的模态窗口，还有 input 框和确定/取消按钮。\n访问者可以在提示输入栏中输入一些内容，然后按“确定”键。然后我们在 result 中获取该文本。或者他们可以按取消键或按 key:esc 键取消输入，然后我们得到 null 作为 result。\nprompt 将返回用户在 input 框内输入的文本，如果用户取消了输入，则返回 null\n\n# title\n\n显示给用户的文本\n\n# default\n\n可选的第二个参数，指定 input 框的初始值\n\n\n# 2.6.2 confirm\n\nresult = confirm(question);\n\n\n1\n\n\nconfirm 函数显示一个带有 question 以及确定和取消两个按钮的模态窗口。\n\n点击确定返回 true，点击取消返回 false\n\n\n# 2.6.3 总结\n\n我们学习了与用户交互的 3 个浏览器的特定函数：\n\nalert : 显示信息。\n\nprompt : 显示信息要求用户输入文本。点击确定返回文本，点击取消或按下 key:esc 键返回 null。\n\nconfirm : 显示信息等待用户点击确定或取消。点击确定返回 true，点击取消或按下 key:esc 键返回 false。\n\n这些方法都是模态的：它们暂停脚本的执行，并且不允许用户与该页面的其余部分进行交互，直到窗口被解除。\n\n上述所有方法共有两个限制：\n\n 1. 模态窗口的确切位置由浏览器决定。通常在页面中心。\n 2. 窗口的确切外观也取决于浏览器。我们不能修改它。',charsets:{cjk:!0}},{title:"JavaScript基础语法",frontmatter:{title:"JavaScript基础语法",date:"2022-06-28T18:57:55.000Z",permalink:"/pages/d2d293/",categories:["《JavaScript》","《现代JavaScript教程》","JavaScript编程语言"],tags:["JavaScript"]},regularPath:"/%E3%80%8AJavaScript%E3%80%8B/02.%E3%80%8A%E7%8E%B0%E4%BB%A3JavaScript%E6%95%99%E7%A8%8B%E3%80%8B/00.%20JavaScript%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.%20JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",relativePath:"《JavaScript》/02.《现代JavaScript教程》/00. JavaScript编程语言/02. JavaScript基础语法.md",key:"v-486f5f39",path:"/pages/d2d293/",headers:[{level:2,title:"3.1 类型转换",slug:"_3-1-类型转换",normalizedTitle:"3.1 类型转换",charIndex:2},{level:3,title:"3.1.1 字符串转换",slug:"_3-1-1-字符串转换",normalizedTitle:"3.1.1 字符串转换",charIndex:93},{level:3,title:"3.1.2 数字型转换",slug:"_3-1-2-数字型转换",normalizedTitle:"3.1.2 数字型转换",charIndex:340},{level:3,title:"3.1.3 布尔型转换",slug:"_3-1-3-布尔型转换",normalizedTitle:"3.1.3 布尔型转换",charIndex:1082},{level:3,title:"3.1.4 总结",slug:"_3-1-4-总结",normalizedTitle:"3.1.4 总结",charIndex:1433},{level:2,title:"3.2 基础运算符",slug:"_3-2-基础运算符",normalizedTitle:"3.2 基础运算符",charIndex:1808},{level:3,title:"3.2.1 运算符相关术语",slug:"_3-2-1-运算符相关术语",normalizedTitle:"3.2.1 运算符相关术语",charIndex:1822},{level:4,title:"运算元",slug:"运算元",normalizedTitle:"运算元",charIndex:1839},{level:4,title:"一元运算符",slug:"一元运算符",normalizedTitle:"一元运算符",charIndex:1914},{level:4,title:"二元运算符",slug:"二元运算符",normalizedTitle:"二元运算符",charIndex:2010},{level:3,title:"3.2.2 数学运算符",slug:"_3-2-2-数学运算符",normalizedTitle:"3.2.2 数学运算符",charIndex:2106},{level:4,title:"取余 %",slug:"取余",normalizedTitle:"取余 %",charIndex:2169},{level:4,title:"求幂 **",slug:"求幂",normalizedTitle:"求幂 **",charIndex:2178},{level:3,title:"3.2.3  用二元运算符 + 连接字符串",slug:"_3-2-3-用二元运算符-连接字符串",normalizedTitle:"3.2.3  用二元运算符 + 连接字符串",charIndex:null},{level:3,title:"3.2.4 数字转化，一元运算符 +",slug:"_3-2-4-数字转化-一元运算符",normalizedTitle:"3.2.4 数字转化，一元运算符 +",charIndex:3072},{level:3,title:"3.2.5 运算符优先级",slug:"_3-2-5-运算符优先级",normalizedTitle:"3.2.5 运算符优先级",charIndex:3387},{level:3,title:"3.2.6 赋值运算符",slug:"_3-2-6-赋值运算符",normalizedTitle:"3.2.6 赋值运算符",charIndex:3745},{level:4,title:"赋值 = 返回一个值",slug:"赋值-返回一个值",normalizedTitle:"赋值 = 返回一个值",charIndex:3857},{level:4,title:"链式赋值（Chaining assignments）",slug:"链式赋值-chaining-assignments",normalizedTitle:"链式赋值（chaining assignments）",charIndex:4150},{level:3,title:"3.2.7 原地修改",slug:"_3-2-7-原地修改",normalizedTitle:"3.2.7 原地修改",charIndex:4347},{level:3,title:"3.2.8 自增/自减",slug:"_3-2-8-自增-自减",normalizedTitle:"3.2.8 自增/自减",charIndex:4672},{level:4,title:"自增++",slug:"自增",normalizedTitle:"自增++",charIndex:4687},{level:4,title:"自减--",slug:"自减",normalizedTitle:"自减--",charIndex:4809},{level:4,title:"前置与后置",slug:"前置与后置",normalizedTitle:"前置与后置",charIndex:4965},{level:3,title:"3.2.9 位运算符",slug:"_3-2-9-位运算符",normalizedTitle:"3.2.9 位运算符",charIndex:5516},{level:3,title:"3.2.10 逗号运算符",slug:"_3-2-10-逗号运算符",normalizedTitle:"3.2.10 逗号运算符",charIndex:5638},{level:2,title:"3.3 比较运算符",slug:"_3-3-比较运算符",normalizedTitle:"3.3 比较运算符",charIndex:6001},{level:3,title:"3.3.1 比较运算符结果为Boolean 类型",slug:"_3-3-1-比较运算符结果为boolean-类型",normalizedTitle:"3.3.1 比较运算符结果为boolean 类型",charIndex:6176},{level:3,title:"3.3.2 字符串比较",slug:"_3-3-2-字符串比较",normalizedTitle:"3.3.2 字符串比较",charIndex:6429},{level:3,title:"3.3.3 不同类型间的比较",slug:"_3-3-3-不同类型间的比较",normalizedTitle:"3.3.3 不同类型间的比较",charIndex:7024},{level:3,title:"3.3.4 严格相等",slug:"_3-3-4-严格相等",normalizedTitle:"3.3.4 严格相等",charIndex:7588},{level:3,title:"3.3.5 对 null 和 undefined 进行比较",slug:"_3-3-5-对-null-和-undefined-进行比较",normalizedTitle:"3.3.5 对 null 和 undefined 进行比较",charIndex:7844},{level:4,title:"null vs 0",slug:"null-vs-0",normalizedTitle:"null vs 0",charIndex:8200},{level:4,title:"undefined",slug:"undefined",normalizedTitle:"undefined",charIndex:664},{level:2,title:"3.4 条件分支",slug:"_3-4-条件分支",normalizedTitle:"3.4 条件分支",charIndex:8846},{level:3,title:'3.4.1 "if" 语句',slug:"_3-4-1-if-语句",normalizedTitle:"3.4.1 &quot;if&quot; 语句",charIndex:null},{level:3,title:"3.4.2 布尔转换",slug:"_3-4-2-布尔转换",normalizedTitle:"3.4.2 布尔转换",charIndex:9019},{level:3,title:'3.4.3 "else" 语句',slug:"_3-4-3-else-语句",normalizedTitle:"3.4.3 &quot;else&quot; 语句",charIndex:null},{level:3,title:'3.4.4 多个条件："else if"',slug:"_3-4-4-多个条件-else-if",normalizedTitle:"3.4.4 多个条件：&quot;else if&quot;",charIndex:null},{level:3,title:"3.4.5 条件运算符 '?'",slug:"_3-4-5-条件运算符",normalizedTitle:"3.4.5 条件运算符 '?'",charIndex:9468},{level:3,title:"3.4.6 多个 '?'",slug:"_3-4-6-多个",normalizedTitle:"3.4.6 多个 '?'",charIndex:9614},{level:3,title:"3.4.6 '?' 的非常规使用",slug:"_3-4-6-的非常规使用",normalizedTitle:"3.4.6 '?' 的非常规使用",charIndex:10069},{level:2,title:"3.5 逻辑运算符",slug:"_3-5-逻辑运算符",normalizedTitle:"3.5 逻辑运算符",charIndex:10332},{level:3,title:"3.5.1 ||（或）",slug:"_3-5-1-或",normalizedTitle:"3.5.1 ||（或）",charIndex:10457},{level:4,title:"或运算寻找第一个真值",slug:"或运算寻找第一个真值",normalizedTitle:"或运算寻找第一个真值",charIndex:10687},{level:3,title:"3.5.2 &&（与）",slug:"_3-5-2-与",normalizedTitle:"3.5.2 &amp;&amp;（与）",charIndex:null},{level:4,title:"与运算寻找第一个假值",slug:"与运算寻找第一个假值",normalizedTitle:"与运算寻找第一个假值",charIndex:12048},{level:3,title:"3.5.3 !（非）",slug:"_3-5-3-非",normalizedTitle:"3.5.3 !（非）",charIndex:12705},{level:4,title:"!!",slug:"",normalizedTitle:"!!",charIndex:12920},{level:3,title:"3.5.4 空值合并运算符 '??'",slug:"_3-5-4-空值合并运算符",normalizedTitle:"3.5.4 空值合并运算符 '??'",charIndex:12954},{level:4,title:"与 || 比较",slug:"与-比较",normalizedTitle:"与 || 比较",charIndex:13528},{level:4,title:"优先级",slug:"优先级",normalizedTitle:"优先级",charIndex:3396},{level:4,title:"?? 与 && 或 || 一起使用",slug:"与-或-一起使用",normalizedTitle:"?? 与 &amp;&amp; 或 || 一起使用",charIndex:null},{level:2,title:"3.6 循环",slug:"_3-6-循环",normalizedTitle:"3.6 循环",charIndex:13739},{level:3,title:"3.6.1 while循环",slug:"_3-6-1-while循环",normalizedTitle:"3.6.1 while循环",charIndex:13750},{level:3,title:"3.6.2 do...while循环",slug:"_3-6-2-do-while循环",normalizedTitle:"3.6.2 do...while循环",charIndex:13983},{level:3,title:"3.6.3 for循环",slug:"_3-6-3-for循环",normalizedTitle:"3.6.3 for循环",charIndex:14137},{level:4,title:"内联变量声明",slug:"内联变量声明",normalizedTitle:"内联变量声明",charIndex:14394},{level:4,title:"省略语句段",slug:"省略语句段",normalizedTitle:"省略语句段",charIndex:14540},{level:3,title:"3.6.4 break",slug:"_3-6-4-break",normalizedTitle:"3.6.4 break",charIndex:14717},{level:3,title:"3.6.5 continue",slug:"_3-6-5-continue",normalizedTitle:"3.6.5 continue",charIndex:14985},{level:3,title:"3.6.6 break/continue 标签",slug:"_3-6-6-break-continue-标签",normalizedTitle:"3.6.6 break/continue 标签",charIndex:15367},{level:2,title:"3.7 switch",slug:"_3-7-switch",normalizedTitle:"3.7 switch",charIndex:15906},{level:3,title:"3.7.1 switch语法",slug:"_3-7-1-switch语法",normalizedTitle:"3.7.1 switch语法",charIndex:15944},{level:3,title:"3.7.2 switch中的break",slug:"_3-7-2-switch中的break",normalizedTitle:"3.7.2 switch中的break",charIndex:16626},{level:3,title:"3.7.3 case分组",slug:"_3-7-3-case分组",normalizedTitle:"3.7.3 case分组",charIndex:17166},{level:3,title:"3.7.4 switch严格相等",slug:"_3-7-4-switch严格相等",normalizedTitle:"3.7.4 switch严格相等",charIndex:17609},{level:2,title:"3.8 函数",slug:"_3-8-函数",normalizedTitle:"3.8 函数",charIndex:17666},{level:3,title:"3.8.1 函数声明",slug:"_3-8-1-函数声明",normalizedTitle:"3.8.1 函数声明",charIndex:17677},{level:3,title:"3.8.2 局部变量",slug:"_3-8-2-局部变量",normalizedTitle:"3.8.2 局部变量",charIndex:17850},{level:3,title:"3.8.3 外部变量",slug:"_3-8-3-外部变量",normalizedTitle:"3.8.3 外部变量",charIndex:18078},{level:4,title:"外部变量读写",slug:"外部变量读写",normalizedTitle:"外部变量读写",charIndex:18092},{level:5,title:"外部变量遮蔽",slug:"外部变量遮蔽",normalizedTitle:"外部变量遮蔽",charIndex:18398},{level:3,title:"3.8.4 参数",slug:"_3-8-4-参数",normalizedTitle:"3.8.4 参数",charIndex:18716},{level:4,title:"形参与实参",slug:"形参与实参",normalizedTitle:"形参与实参",charIndex:18728},{level:4,title:"形参默认值",slug:"形参默认值",normalizedTitle:"形参默认值",charIndex:19173},{level:3,title:"3.8.5 返回值",slug:"_3-8-5-返回值",normalizedTitle:"3.8.5 返回值",charIndex:19818},{level:3,title:"3.8.6 函数表达式",slug:"_3-8-6-函数表达式",normalizedTitle:"3.8.6 函数表达式",charIndex:20540},{level:4,title:"函数是一个值",slug:"函数是一个值",normalizedTitle:"函数是一个值",charIndex:20734},{level:4,title:"函数声明vs函数表达式",slug:"函数声明vs函数表达式",normalizedTitle:"函数声明vs函数表达式",charIndex:20953},{level:3,title:"3.8.7 回调函数",slug:"_3-8-7-回调函数",normalizedTitle:"3.8.7 回调函数",charIndex:21069},{level:3,title:"3.8.8 箭头函数",slug:"_3-8-8-箭头函数",normalizedTitle:"3.8.8 箭头函数",charIndex:21208},{level:4,title:"多行箭头函数",slug:"多行箭头函数",normalizedTitle:"多行箭头函数",charIndex:21766}],headersStr:"3.1 类型转换 3.1.1 字符串转换 3.1.2 数字型转换 3.1.3 布尔型转换 3.1.4 总结 3.2 基础运算符 3.2.1 运算符相关术语 运算元 一元运算符 二元运算符 3.2.2 数学运算符 取余 % 求幂 ** 3.2.3  用二元运算符 + 连接字符串 3.2.4 数字转化，一元运算符 + 3.2.5 运算符优先级 3.2.6 赋值运算符 赋值 = 返回一个值 链式赋值（Chaining assignments） 3.2.7 原地修改 3.2.8 自增/自减 自增++ 自减-- 前置与后置 3.2.9 位运算符 3.2.10 逗号运算符 3.3 比较运算符 3.3.1 比较运算符结果为Boolean 类型 3.3.2 字符串比较 3.3.3 不同类型间的比较 3.3.4 严格相等 3.3.5 对 null 和 undefined 进行比较 null vs 0 undefined 3.4 条件分支 3.4.1 \"if\" 语句 3.4.2 布尔转换 3.4.3 \"else\" 语句 3.4.4 多个条件：\"else if\" 3.4.5 条件运算符 '?' 3.4.6 多个 '?' 3.4.6 '?' 的非常规使用 3.5 逻辑运算符 3.5.1 ||（或） 或运算寻找第一个真值 3.5.2 &&（与） 与运算寻找第一个假值 3.5.3 !（非） !! 3.5.4 空值合并运算符 '??' 与 || 比较 优先级 ?? 与 && 或 || 一起使用 3.6 循环 3.6.1 while循环 3.6.2 do...while循环 3.6.3 for循环 内联变量声明 省略语句段 3.6.4 break 3.6.5 continue 3.6.6 break/continue 标签 3.7 switch 3.7.1 switch语法 3.7.2 switch中的break 3.7.3 case分组 3.7.4 switch严格相等 3.8 函数 3.8.1 函数声明 3.8.2 局部变量 3.8.3 外部变量 外部变量读写 外部变量遮蔽 3.8.4 参数 形参与实参 形参默认值 3.8.5 返回值 3.8.6 函数表达式 函数是一个值 函数声明vs函数表达式 3.8.7 回调函数 3.8.8 箭头函数 多行箭头函数",content:'# 3.1 类型转换\n\n大多数情况下，运算符和函数会自动将赋予它们的值转换为正确的类型。\n\n比如，alert 会自动将任何值都转换为字符串以进行显示。算术运算符会将值转换为数字\n\n\n# 3.1.1 字符串转换\n\nalert(value) 将 value 转换为字符串类型，然后显示这个值\n我们也可以显式地调用 String(value) 来将 value 转换为字符串类型\n\n\n\n\n \n \n\n\nlet value = true;\nalert(typeof value); // boolean\nvalue = String(value); // 现在，值是一个字符串形式的 "true"\nalert(typeof value); // string\n\n\n1\n2\n3\n4\n\n\n\n# 3.1.2 数字型转换\n\n在算术函数和表达式中，会自动进行 number 类型转换\n\nalert( "6" / "2" ); // 3, string 类型的值被自动转换成 number 类型后进行计算\n\n\n1\n\n\n我们也可以使用 Number(value) 显式地将这个 value 转换为 number 类型\n\nlet str = "123";\nalert(typeof str); // string\nlet num = Number(str); // 变成 number 类型 123\nalert(typeof num); // number\n\n\n1\n2\n3\n4\n\n\nnumber 类型转换规则：\n\n值              变成……\nundefined      NaN\nnull           0\ntrue 和 false   1 and 0\nstring         去掉首尾空格后的纯数字字符串中含有的数字。如果剩余字符串为空，则转换结果为\n               0。否则，将会从剩余字符串中“读取”数字。当类型转换出现 error 时返回 NaN。\n\nalert( Number("   123   ") ); // 123\nalert( Number("123z") );      // NaN（从字符串“读取”数字，读到 "z" 时出现错误）\nalert( Number(true) );        // 1\nalert( Number(false) );       // 0\n\n\n1\n2\n3\n4\n\n\n注意\n\n请注意 null 和 undefined 在这有点不同：null 变成数字 0，undefined 变成 NaN\n\n\n# 3.1.3 布尔型转换\n\n它发生在逻辑运算中（稍后我们将进行条件判断和其他类似的东西），但是也可以通过调用 Boolean(value) 显式地进行转换\n\n值                             变成……\n0, null, undefined, NaN, ""   false\n其他值                           true\n\nalert( Boolean(1) ); // true\nalert( Boolean(0) ); // false\nalert( Boolean("hello") ); // true\nalert( Boolean("") ); // false\n\n\n1\n2\n3\n4\n\n\n注意\n\n包含 0 的字符串 "0" 是 true\n\n\n# 3.1.4 总结\n\n有三种常用的类型转换：转换为 string 类型、转换为 number 类型和转换为 boolean 类型。\n\n字符串转换 —— 转换发生在输出内容的时候，也可以通过 String(value) 进行显式转换。原始类型值的 string 类型转换通常是很明显的。\n\n数字型转换 —— 转换发生在进行算术操作时，也可以通过 Number(value) 进行显式转换\n\n布尔型转换 —— 转换发生在进行逻辑操作时，也可以通过 Boolean(value) 进行显式转换\n\n上述的大多数规则都容易理解和记忆。人们通常会犯错误的值得注意的例子有以下几个：\n\n * 对 undefined 进行数字型转换时，输出结果为 NaN，而非 0。\n * 对 "0" 和只有空格的字符串（比如：" "）进行布尔型转换时，输出结果为 true\n\n\n# 3.2 基础运算符\n\n\n# 3.2.1 运算符相关术语\n\n# 运算元\n\n运算符应用的对象。比如说乘法运算 5 * 2，有两个运算元：左运算元 5 和右运算元 2。有时候人们也称其为“参数”而不是“运算元”\n\n# 一元运算符\n\n如果一个运算符对应的只有一个运算元，那么它是 一元运算符\n\nlet x = 1;\nx = -x;\nalert( x ); // -1，一元负号运算符生效\n\n\n1\n2\n3\n\n\n# 二元运算符\n\n如果一个运算符拥有两个运算元，那么它是 二元运算符\n\nlet x = 1, y = 3;\nalert( y - x ); // 2，二元运算符减号做减运算\n\n\n1\n2\n\n\n\n# 3.2.2 数学运算符\n\n支持以下数学运算：\n\n * 加法 +,\n * 减法 -,\n * 乘法 *,\n * 除法 /,\n * 取余 %,\n * 求幂 **.\n\n# 取余 %\n\na % b 的结果是 a 整除 b 的 余数\n\nalert( 5 % 2 ); // 1，5 除以 2 的余数\nalert( 8 % 3 ); // 2，8 除以 3 的余数\n\n\n1\n2\n\n\n# 求幂 **\n\n求幂运算 a ** b 将 a 提升至 a 的 b 次幂\n\nalert( 2 ** 2 ); // 2² = 4\nalert( 2 ** 3 ); // 2³ = 8\nalert( 2 ** 4 ); // 2⁴ = 16\n\n\n1\n2\n3\n\n\n\n# 3.2.3 用二元运算符 + 连接字符串\n\n通常，加号 + 用于求和。\n\n但是如果加号 + 被应用于字符串，它将合并（连接）各个字符串：\n\nlet s = "my" + "string";\nalert(s); // mystring\n\n\n1\n2\n\n\n注意：只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串。\n\n举个例子：\n\nalert( \'1\' + 2 ); // "12"\nalert( 2 + \'1\' ); // "21"\n\n\n1\n2\n\n\nalert(2 + 2 + \'1\' ); // "41"，不是 "221"\n\n\n1\n\n\n在这里，运算符是按顺序工作。第一个 + 将两个数字相加，所以返回 4，然后下一个 + 将字符串 1 加入其中，所以就是 4 + \'1\' = \'41\'。\n\nalert(\'1\' + 2 + 2); // "122"，不是 "14"\n\n\n1\n\n\n这里，第一个操作数是一个字符串，所以编译器将其他两个操作数也视为了字符串。2 被与 \'1\' 连接到了一起，也就是像 \'1\' + 2 = "12" 然后 "12" + 2 = "122" 这样。\n\n二元 + 是唯一一个以这种方式支持字符串的运算符。其他算术运算符只对数字起作用，并且总是将其运算元转换为数字。\n\n下面是减法和除法运算的示例：\n\nalert( 6 - \'2\' ); // 4，将 \'2\' 转换为数字\nalert( \'6\' / \'2\' ); // 3，将两个运算元都转换为数字\n\n\n1\n2\n\n\n\n# 3.2.4 数字转化，一元运算符 +\n\n加号 + 有两种形式。一种是上面我们刚刚讨论的二元运算符，还有一种是一元运算符。\n\n一元运算符加号，或者说，加号 + 应用于单个值，对数字没有任何作用。但是如果运算元不是数字，加号 + 则会将其转化为数字。\n\n例如：\n\n\n\n\n\n\n\n\n \n \n\n\n// 对数字无效\nlet x = 1;\nalert( +x ); // 1\nlet y = -2;\nalert( +y ); // -2\n// 转化非数字\nalert( +true ); // 1\nalert( +"" );   // 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n它的效果和 Number(...) 相同，但是更加简短\n\n\n# 3.2.5 运算符优先级\n\n这是一个摘抄自 Mozilla 的 优先级表（你没有必要把这全记住，但要记住一元运算符优先级高于二元运算符）：\n\n优先级   名称     符号\n...   ...    ...\n15    一元加号   +\n15    一元负号   -\n14    求幂     **\n13    乘号     *\n13    除号     /\n12    加号     +\n12    减号     -\n...   ...    ...\n2     赋值符    =\n...   ...    ...\n\n我们可以看到，“一元加号运算符”的优先级是 15，高于“二元加号运算符”的优先级 12。这也是为什么表达式 "+apples + +oranges" 中的一元加号先生效，然后才是二元加法\n\n\n# 3.2.6 赋值运算符\n\n赋值符号 = 也是一个运算符。从优先级表中可以看到它的优先级非常低，只有 2。\n\n所以当我们赋值时，比如 x = 2 * 2 + 1，所有的计算先执行，然后 = 才执行，将计算结果存储到 x\n\n# 赋值 = 返回一个值\n\n在 JavaScript 中，所有运算符都会返回一个值。这对于 + 和 - 来说是显而易见的，但对于 = 来说也是如此\n\n语句 x = value 将值 value 写入 x 然后返回 value。\n\n下面是一个在复杂语句中使用赋值的例子：\n\n\n\n\n \n\n\n\n\nlet a = 1;\nlet b = 2;\nlet c = 3 - (a = b + 1);\nalert( a ); // 3\nalert( c ); // 0\n\n\n1\n2\n3\n4\n5\n\n\n上面这个例子，(a = b + 1) 的结果是赋给 a 的值（也就是 3）。然后该值被用于进一步的运算\n\n# 链式赋值（Chaining assignments）\n\nlet a, b, c;\na = b = c = 2 + 2;\nalert( a ); // 4\nalert( b ); // 4\nalert( c ); // 4\n\n\n1\n2\n3\n4\n5\n\n\n链式赋值从右到左进行计算。首先，对最右边的表达式 2 + 2 求值，然后将其赋给左边的变量：c、b 和 a。最后，所有的变量共享一个值\n\n\n# 3.2.7 原地修改\n\n我们经常需要对一个变量做运算，并将新的结果存储在同一个变量中\n\n可以使用运算符 += 和 *= 来缩写这种表示，所有算术和位运算符都有简短的“修改并赋值”运算符\n\nlet n = 2;\nn += 5; // 现在 n = 7（等同于 n = n + 5）\nn *= 2; // 现在 n = 14（等同于 n = n * 2）\nalert( n ); // 14\n\n\n1\n2\n3\n4\n\n\n这类运算符的优先级与普通赋值运算符的优先级相同，所以它们在大多数其他运算之后执行：\n\nlet n = 2;\nn *= 3 + 5;\nalert( n ); // 16 （右边部分先被计算，等同于 n *= 8）\n\n\n1\n2\n3\n\n\n\n# 3.2.8 自增/自减\n\n# 自增++\n\n将变量与 1 相加\n\nlet counter = 2;\ncounter++;      // 和 counter = counter + 1 效果一样，但是更洁\nalert( counter ); // 3\n\n\n1\n2\n3\n\n\n# 自减--\n\nlet counter = 2;\ncounter--;      // 和 counter = counter - 1 效果一样，但是更洁\nalert( counter ); // 1\n\n\n1\n2\n3\n\n\n只用于变量\n\n自增/自减只能应用于变量。试一下，将其应用于数值（比如 5++）则会报错\n\n# 前置与后置\n\n运算符 ++ 和 -- 可以置于变量前，也可以置于变量后。\n\n * 当运算符置于变量后，被称为“后置形式”：counter++。\n * 当运算符置于变量前，被称为“前置形式”：++counter。\n\nlet counter = 1;\nlet a = ++counter; // (*)\nalert(a); // 2\n\n\n1\n2\n3\n\n\n(*) 所在的行是前置形式 ++counter，对 counter 做自增运算，返回的是新的值 2。因此 alert 显示的是 2。\n\n下面让我们看看后置形式：\n\nlet counter = 1;\nlet a = counter++; // (*) 将 ++counter 改为 counter++\nalert(a); // 1\n\n\n1\n2\n3\n\n\n(*) 所在的行是后置形式 counter++，它同样对 counter 做加法，但是返回的是 旧值（做加法之前的值）。因此 alert 显示的是 1。\n\n自增/自减和其它运算符的对比\n\n++/-- 运算符同样可以在表达式内部使用。它们的优先级比绝大部分的算数运算符要高。 举个例子：\n\nlet counter = 1;\nalert( 2 * ++counter ); // 4\n\n\n1\n2\n\n\n\n# 3.2.9 位运算符\n\n下面是位运算符：\n\n * 按位与 ( & )\n * 按位或 ( | )\n * 按位异或 ( ^ )\n * 按位非 ( ~ )\n * 左移 ( << )\n * 右移 ( >> )\n * 无符号右移 ( >>> )\n\n\n# 3.2.10 逗号运算符\n\n逗号运算符能让我们处理多个语句，使用 , 将它们分开。每个语句都运行了，但是只有最后的语句的结果会被返回\n\n\n\n\n\n\nlet a = (1 + 2, 3 + 4);\nalert( a ); // 7（3 + 4 的结果）\n\n\n1\n2\n\n\n这里，第一个语句 1 + 2 运行了，但是它的结果被丢弃了。随后计算 3 + 4，并且该计算结果被返回\n\n逗号运算符的优先级非常低\n\n请注意逗号运算符的优先级非常低，比 = 还要低，因此上面你的例子中圆括号非常重要。 如果没有圆括号：a = 1 + 2, 3 + 4 会先执行 +，将数值相加得到 a = 3, 7，然后赋值运算符 = 执行 a = 3，然后逗号之后的数值 7 不会再执行，它被忽略掉了。相当于 (a = 1 + 2), 3 + 4。\n\n\n# 3.3 比较运算符\n\n * 大于 / 小于：a > b，a < b。\n * 大于等于 / 小于等于：a >= b，a <= b。\n * 检查两个值的相等：a == b，请注意双等号 == 表示相等性检查，而单等号 a = b 表示赋值。\n * 检查两个值不相等：不相等在数学中的符号是 ≠，但在 JavaScript 中写成 a != b。\n\n\n# 3.3.1 比较运算符结果为Boolean 类型\n\n所有比较运算符均返回布尔值：\n\n * true —— 表示“yes（是）”，“correct（正确）”或“the truth（真）”。\n * false —— 表示“no（否）”，“wrong（错误）”或“not the truth（非真）”。\n\n和其他类型的值一样，比较的结果可以被赋值给任意变量\n\nlet result = 5 > 4; // 把比较的结果赋值给 result\nalert( result ); // true\n\n\n1\n2\n\n\n\n# 3.3.2 字符串比较\n\n在比较字符串的大小时，JavaScript 会使用“字典（dictionary）”或“词典（lexicographical）”顺序进行判定，字符串是按字符（母）逐个进行比较的\n\nalert( \'Z\' > \'A\' ); // true\nalert( \'Glow\' > \'Glee\' ); // true\nalert( \'Bee\' > \'Be\' ); // true\n\n\n1\n2\n3\n\n\n字符串的比较算法非常简单：\n\n 1. 首先比较两个字符串的首位字符大小。\n 2. 如果一方字符较大（或较小），则该字符串大于（或小于）另一个字符串。算法结束。\n 3. 否则，如果两个字符串的首位字符相等，则继续取出两个字符串各自的后一位字符进行比较。\n 4. 重复上述步骤进行比较，直到比较完成某字符串的所有字符为止。\n 5. 如果两个字符串的字符同时用完，那么则判定它们相等，否则未结束（还有未比较的字符）的字符串更大\n\n非真正的字典顺序，而是 Unicode 编码顺序\n\n在上面的算法中，比较大小的逻辑与字典或电话簿中的排序很像，但也不完全相同。\n比如说，字符串比较对字母大小写是敏感的。大写的 "A" 并不等于小写的 "a"。哪一个更大呢？实际上小写的 "a" 更大。这是因为在 JavaScript 使用的内部编码表中（Unicode），小写字母的字符索引值更大\n\n\n# 3.3.3 不同类型间的比较\n\n当对不同类型的值进行比较时，JavaScript 会首先将其转化为数字（number）再判定大小\n\nalert( \'2\' > 1 ); // true，字符串 \'2\' 会被转化为数字 2\nalert( \'01\' == 1 ); // true，字符串 \'01\' 会被转化为数字 1\nalert( true == 1 ); // true\nalert( false == 0 ); // true\n\n\n1\n2\n3\n4\n\n\n一个有趣的现象\n\n有时候，以下两种情况会同时发生：\n\n * 若直接比较两个值，其结果是相等的。\n * 若把两个值转为布尔值，它们可能得出完全相反的结果，即一个是 true，一个是 false。 例如：\n\nlet a = 0;\nalert( Boolean(a) ); // false\nlet b = "0";\nalert( Boolean(b) ); // true\nalert(a == b); // true!\n\n\n1\n2\n3\n4\n5\n\n\n对于 JavaScript 而言，这种现象其实挺正常的。因为 JavaScript 会把待比较的值转化为数字后再做比较（因此 "0" 变成了 0）。若只是将一个变量转化为 Boolean 值，则会使用其他的类型转换规则。\n\n\n# 3.3.4 严格相等\n\n普通的相等性检查 == 存在一个问题，它不能区分出 0 和 false,也同样无法区分空字符串和 false\n这是因为在比较不同类型的值时，处于相等判断符号 == 两侧的值会先被转化为数字。空字符串和 false 也是如此，转化后它们都为数字 0\n严格相等运算符 === 在进行比较时不会做任何的类型转换。\n\nalert( 0 === false ); // false，因为被比较值的数据类型不同\n\n\n1\n\n\n同样的，与“不相等”符号 != 类似，“严格不相等”表示为 !==\n\n\n# 3.3.5 对 null 和 undefined 进行比较\n\n当使用严格相等 === 比较二者时 : 它们不相等，因为它们属于不同的类型。\n\n```js run\nalert( null === undefined ); // false\n```\n\n\n当使用非严格相等 == 比较二者时 : JavaScript 存在一个特殊的规则，会判定它们相等。它们俩就像“一对恋人”，仅仅等于对方而不等于其他任何的值（只在非严格相等下成立）。\n\n```js run\nalert( null == undefined ); // true\n```\n\n\n当使用数学式或其他比较方法 < > <= >= 时： : null/undefined 会被转化为数字：null 被转化为 0，undefined 被转化为 NaN。\n\n# null vs 0\n\n\n\n\n \n\n\nalert( null > 0 );  // (1) false\nalert( null == 0 ); // (2) false\nalert( null >= 0 ); // (3) true\n\n\n1\n2\n3\n\n\n相等性检查 == 和普通比较符 > < >= <= 的代码逻辑是相互独立的\n进行值的比较时，null 会被转化为数字，因此它被转化为了 0。这就是为什么（3）中 null >= 0 返回值是 true，（1）中 null > 0 返回值是 false。\nundefined 和 null 在相等性检查 == 中不会进行任何的类型转换，它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值。这就解释了为什么（2）中 null == 0 会返回 false。\n\n# undefined\n\nalert( undefined > 0 ); // false (1)\nalert( undefined < 0 ); // false (2)\nalert( undefined == 0 ); // false (3)\n\n\n1\n2\n3\n\n\n(1) 和 (2) 都返回 false 是因为 undefined 在比较中被转换为了 NaN，而 NaN 是一个特殊的数值型值，它与任何值进行比较都会返回 false\n(3) 返回 false 是因为这是一个相等性检查，而 undefined 只与 null 相等，不会与其他值相等\n\n\n# 3.4 条件分支\n\n\n# 3.4.1 "if" 语句\n\nif(...) 语句计算括号里的条件表达式，如果计算结果是 true，就会执行对应的代码块\n\nif (year == 2015) {\n  alert( "That\'s correct!" );\n  alert( "You\'re so smart!" );\n}\n\n\n1\n2\n3\n4\n\n\n\n# 3.4.2 布尔转换\n\nif (…) 语句会计算圆括号内的表达式，并将计算结果转换为布尔型\n\n\n# 3.4.3 "else" 语句\n\nif 语句有时会包含一个可选的 "else" 块。如果判断条件不成立，就会执行它内部的代码\n\n\n# 3.4.4 多个条件："else if"\n\n有时我们需要测试一个条件的几个变体。我们可以通过使用 else if 子句实现\n\nlet year = prompt(\'In which year was ECMAScript-2015 specification published?\', \'\');\nif (year < 2015) {\n  alert( \'Too early...\' );\n} else if (year > 2015) {\n  alert( \'Too late\' );\n} else {\n  alert( \'Exactly!\' );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n可以有更多的 else if 块。结尾的 else 是可选的\n\n\n# 3.4.5 条件运算符 \'?\'\n\n问号 ? 有时它被称为三元运算符，被称为“三元”是因为该运算符中有三个操作数\n\nlet result = condition ? value1 : value2;\n\n\n1\n\n\n计算条件结果，如果结果为真，则返回 value1，否则返回 value2\n\n\n# 3.4.6 多个 \'?\'\n\n使用一系列问号 ? 运算符可以返回一个取决于多个条件的值\n\nlet age = prompt(\'age?\', 18);\nlet message = (age < 3) ? \'Hi, baby!\' :\n  (age < 18) ? \'Hello!\' :\n  (age < 100) ? \'Greetings!\' :\n  \'What an unusual age!\';\nalert( message );\n\n\n1\n2\n3\n4\n5\n6\n\n 1. 第一个问号检查 age < 3。\n 2. 如果为真 — 返回 \'Hi, baby!\'。否则，会继续执行冒号 ":" 后的表达式，检查 age < 18。\n 3. 如果为真 — 返回 \'Hello!\'。否则，会继续执行下一个冒号 ":" 后的表达式，检查 age < 100。\n 4. 如果为真 — 返回 \'Greetings!\'。否则，会继续执行最后一个冒号 ":" 后面的表达式，返回 \'What an unusual age!\'\n\n\n# 3.4.6 \'?\' 的非常规使用\n\n有时可以使用问号 ? 来代替 if 语句\n\nlet company = prompt(\'Which company created JavaScript?\', \'\');\n(company == \'Netscape\') ?\n   alert(\'Right!\') : alert(\'Wrong.\');\n\n\n1\n2\n3\n\n\n根据条件 company ==\'Netscape\'，要么执行 ? 后面的第一个表达式并显示对应内容，要么执行第二个表达式并显示对应内容\n不建议这样使用问号运算符。\n\n\n# 3.5 逻辑运算符\n\nJavaScript 中有四个逻辑运算符：||（或），&&（与），!（非），??（空值合并运算符）\n虽然它们被称为“逻辑”运算符，但这些运算符却可以被应用于任意类型的值，而不仅仅是布尔值。它们的结果也同样可以是任意类型\n\n\n# 3.5.1 ||（或）\n\n两个竖线符号表示“或”运算符：\n\nresult = a || b;\n\n\n1\n\n\nalert( true || true );   // true\nalert( false || true );  // true\nalert( true || false );  // true\nalert( false || false ); // false\n\n\n1\n2\n3\n4\n\n\n如果操作数不是布尔值，那么它将会被转化为布尔值来参与运算\n\n# 或运算寻找第一个真值\n\n给定多个参与或运算的值：\n\nresult = value1 || value2 || value3;\n\n\n1\n\n\n或运算符 || 做了如下的事情：\n\n * 从左到右依次计算操作数。\n * 处理每一个操作数时，都将其转化为布尔值。如果结果是 true，就停止计算，返回这个操作数的初始值。\n * 如果所有的操作数都被计算过（也就是，转换结果都是 false），则返回最后一个操作数。\n\n返回的值是操作数的初始形式，不会做布尔转换。\n\n换句话说，一个或运算 || 的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值\n\nalert( 1 || 0 ); // 1（1 是真值）\nalert( null || 1 ); // 1（1 是第一个真值）\nalert( null || 0 || 1 ); // 1（第一个真值）\nalert( undefined || null || 0 ); // 0（都是假值，返回最后一个值）\n\n\n1\n2\n3\n4\n\n\n 1. 获取变量列表或者表达式中的第一个真值 我们用或运算 || 来选择有数据的那一个，并显示出来（如果没有设置，则用 "Anonymous"）：\n    \n    \n    \n    \n    \n     \n    \n    \n    let firstName = "";\n    let lastName = "";\n    let nickName = "SuperCoder";\n    alert( firstName || lastName || nickName || "Anonymous"); // SuperCoder\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. 短路求值（Short-circuit evaluation） || 对其参数进行处理，直到达到第一个真值，然后立即返回该值，而无需处理其他参数\n    \n    true || alert("not printed");\n    false || alert("printed");\n    \n    \n    1\n    2\n    \n    \n    在第一行中，或运算符 || 在遇到 true 时立即停止运算，所以 alert 没有运行\n\n\n# 3.5.2 &&（与）\n\n两个 & 符号表示 && 与运算符\n\nresult = a && b;\n\n\n1\n\n\n在传统的编程中，当两个操作数都是真值时，与运算返回 true，否则返回 false：\n\nalert( true && true );   // true\nalert( false && true );  // false\nalert( true && false );  // false\nalert( false && false ); // false\n\n\n1\n2\n3\n4\n\n\n就像或运算一样，与运算的操作数可以是任意类型的值：\n\nif (1 && 0) { // 作为 true && false 来执行\n  alert( "won\'t work, because the result is falsy" );\n}\n\n\n1\n2\n3\n\n\n# 与运算寻找第一个假值\n\nresult = value1 && value2 && value3;\n\n\n1\n\n\n与运算 && 做了如下的事：\n\n * 从左到右依次计算操作数。\n * 在处理每一个操作数时，都将其转化为布尔值。如果结果是 false，就停止计算，并返回这个操作数的初始值。\n * 如果所有的操作数都被计算过（例如都是真值），则返回最后一个操作数。\n\n换句话说，与运算返回第一个假值，如果没有假值就返回最后一个值\n\n// 如果第一个操作数是真值，\n// 与运算返回第二个操作数：\nalert( 1 && 0 ); // 0\nalert( 1 && 5 ); // 5\n// 如果第一个操作数是假值，\n// 与运算将直接返回它。第二个操作数会被忽略\nalert( null && 5 ); // null\nalert( 0 && "no matter what" ); // 0\n\nalert( 1 && 2 && null && 3 ); // null\n//如果所有的值都是真值，最后一个值将会被返回\nalert( 1 && 2 && 3 ); // 3，最后一个值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n与运算 `&&` 在或运算 `||` 之前进行\n\n与运算 && 的优先级比或运算 || 要高。\n所以代码 a && b || c && d 跟 && 表达式加了括号完全一样：(a && b) || (c && d)\n\n注意\n\n不要用 || 或 && 来取代 if\n\n\n# 3.5.3 !（非）\n\n感叹符号 ! 表示布尔非运算符\n\nresult = !value;\n\n\n1\n\n\n逻辑非运算符接受一个参数，并按如下运作：\n\n 1. 将操作数转化为布尔类型：true/false。\n 2. 返回相反的值\n\nalert( !true ); // false\nalert( !0 ); // true\n\n\n1\n2\n\n\n非运算符 ! 的优先级在所有逻辑运算符里面最高，所以它总是在 && 和 || 之前执行\n\n# !!\n\n两个非运算 !! 有时候用来将某个值转化为布尔类型\n\n\n# 3.5.4 空值合并运算符 \'??\'\n\n空值合并运算符（nullish coalescing operator）的写法为两个问号 ??\n由于它对待 null 和 undefined 的方式类似，所以在本文中我们将使用一个特殊的术语对其进行表示。为简洁起见，当一个值既不是 null 也不是 undefined 时，我们将其称为“已定义的（defined）”\n\na ?? b 的结果是：\n\n * 如果 a 是已定义的，则结果为 a，\n * 如果 a 不是已定义的，则结果为 b\n\nlet user;\nalert(user ?? "匿名"); // 匿名（user 未定义）\n\n\n1\n2\n\n\nlet user = "John";\nalert(user ?? "匿名"); // John（user 已定义）\n\n\n1\n2\n\n\n我们还可以使用 ?? 序列从一系列的值中选择出第一个非 null/undefined 的值\n\nlet firstName = null;\nlet lastName = null;\nlet nickName = "Supercoder";\n// 显示第一个已定义的值：\nalert(firstName ?? lastName ?? nickName ?? "匿名"); // Supercoder\n\n\n1\n2\n3\n4\n5\n\n\n# 与 || 比较\n\n或运算符 || 可以以与 ?? 运算符相同的方式使用\n\n它们之间重要的区别是：\n\n * || 返回第一个 真 值。\n * ?? 返回第一个 已定义的 值\n\n# 优先级\n\n?? 运算符的优先级与 || 相同，它们的的优先级都为 4\n\n# ?? 与 && 或 || 一起使用\n\n出于安全原因，JavaScript 禁止将 ?? 运算符与 && 和 || 运算符一起使用，除非使用括号明确指定了优先级\n\n\n# 3.6 循环\n\n\n# 3.6.1 while循环\n\nwhile 循环的语法如下：当 condition 为真时，执行循环体的 code。\n\nwhile (condition) {\n  // 代码\n  // 所谓的“循环体” \n}\n\n\n1\n2\n3\n4\n\n\n在 while 中的循环条件会被计算，计算结果会被转化为布尔值。\n单行循环体不需要大括号"，如果循环体只有一条语句，则可以省略大括号 {…}：\n\nlet i = 3;\nwhile (i) alert(i--);\n\n\n1\n2\n\n\n\n# 3.6.2 do...while循环\n\n使用 do..while 语法可以将条件检查移至循环体 下面：\n\ndo {\n  // 循环体\n} while (condition);\n\n\n1\n2\n3\n\n\n循环首先执行循环体，然后检查条件，当条件为真时，重复执行循环体\n不管条件是否为真，循环体 至少执行一次\n\n\n# 3.6.3 for循环\n\nfor (begin; condition; step) {\n  // ……循环体……\n}\n\n\n1\n2\n3\n\n\n语句段                     \nbegin       let i = 0   进入循环时执行一次。\ncondition   i < 3       在每次循环迭代之前检查，如果为 false，停止循环。\nbody（循环体）   alert(i)    条件为真时，重复运行。\nstep        i++         在每次循环体迭代后执行。\n\n# 内联变量声明\n\n“计数”变量 i 是在循环中声明的。这叫做“内联”变量声明。这样的变量只在循环中可见。\n\nfor (let i = 0; i < 3; i++) {\n  alert(i); // 0, 1, 2\n}\nalert(i); // 错误，没有这个变量。\n\n\n1\n2\n3\n4\n\n\n# 省略语句段\n\nfor 循环的任何语句段都可以被省略\n\nlet i = 0; // 我们已经声明了 i 并对它进行了赋值\nfor (; i < 3; i++) { // 不再需要 "begin" 语句段\n  alert( i ); // 0, 1, 2\n}\n\n\n1\n2\n3\n4\n\n\n注意\n\n请注意 for 的两个 ; 必须存在，否则会出现语法错误\n\n\n# 3.6.4 break\n\n循环中随时都可以使用 break 指令强制退出\n\nlet sum = 0;\nwhile (true) {\n  let value = +prompt("Enter a number", \'\');\n  if (!value) break; \n  sum += value;\n}\nalert( \'Sum: \' + sum );\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n根据需要，"无限循环 + break" 的组合非常适用于不必在循环开始/结束时检查条件，但需要在中间甚至是主体的多个位置进行条件检查的情况。\n\n\n# 3.6.5 continue\n\ncontinue 指令是 break 的“轻量版”。它不会停掉整个循环。而是停止当前这一次迭代，并强制启动新一轮循环（如果条件允许的话）\n\nfor (let i = 0; i < 10; i++) {\n  //如果为真，跳过循环体的剩余部分。\n  if (i % 2 == 0) continue;\n  alert(i); // 1，然后 3，5，7，9\n}\n\n\n1\n2\n3\n4\n5\n\n\n禁止 `break/continue` 在 ‘?’ 的右边\n\n请注意非表达式的语法结构不能与三元运算符 ? 一起使用。特别是 break/continue 这样的指令是不允许这样使用的\n\n(i > 5) ? alert(i) : continue; // continue 不允许在这个位置,代码会停止运行，并显示有语法错误\n\n\n1\n\n\n\n# 3.6.6 break/continue 标签\n\n使用标签可以一次从多层嵌套的循环中跳出来\n标签 是在循环之前带有冒号的标识符：\n\nlabelName: for (...) {\n  ...\n}\n\n\n1\n2\n3\n\n\nbreak <labelName> 语句跳出循环至标签处：\n\nouter:for (let i = 0; i < 3; i++) {\n  for (let j = 0; j < 3; j++) {\n    let input = prompt(`Value at coords (${i},${j})`, \'\');\n    // 如果是空字符串或被取消，则中断并跳出这两个循环。\n    if (!input) break outer; // (*)\n    // 用得到的值做些事……\n  }\n}\nalert(\'Done!\');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n标签并不允许“跳到”所有位置\n\nbreak 指令必须在代码块内。从技术上讲，任何被标记的代码块都有效，例如：\n\nlabel: {\n  // ...\n  break label; // 有效\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n\n\ncontinue 只有在循环内部才可行\n\n\n# 3.7 switch\n\nswitch 语句可以替代多个 if 判断\n\n\n# 3.7.1 switch语法\n\nswitch 语句有至少一个 case 代码块和一个可选的 default 代码块。\n\nswitch(x) {\n  case \'value1\':  // if (x === \'value1\')\n    ...\n    [break]\n  case \'value2\':  // if (x === \'value2\')\n    ...\n    [break]\n  default:\n    ...\n    [break]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 比较 x 值与第一个 case（也就是 value1）是否严格相等，然后比较第二个 case（value2）以此类推\n * 如果相等，switch 语句就执行相应 case 下的代码块，直到遇到最靠近的 break 语句（或者直到 switch 语句末尾）\n * 如果没有符合的 case，则执行 default 代码块（如果 default 存在）\n\n任何表达式都可以成为 `switch/case` 的参数\n\nswitch 和 case 都允许任意表达式。\n\nlet a = "1";\nlet b = 0;\nswitch (+a) {\n  case b + 1:\n    alert("this runs, because +a is 1, exactly equals b+1");\n    break;\n  default:\n    alert("this doesn\'t run");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.7.2 switch中的break\n\nlet a = 2 + 2;\nswitch (a) {\n  case 3:\n    alert( \'Too small\' );\n    break;\n  case 4:\n    alert( \'Exactly!\' );\n    break;\n  case 5:\n    alert( \'Too big\' );\n    break;\n  default:\n    alert( "I don\'t know such values" );\n}//输出Exactly!\nswitch (a) {\n  case 3:\n    alert( \'Too small\' );\n  case 4:\n    alert( \'Exactly!\' );\n  case 5:\n    alert( \'Too big\' );\n  default:\n    alert( "I don\'t know such values" );\n}//输出Exactly! Too big I don\'t know such values\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 3.7.3 case分组\n\n共享同一段代码的几个 case 分支可以被分为一组\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n\n\nlet a = 3;\nswitch (a) {\n  case 4:\n    alert(\'Right!\');\n    break;\n  case 3: // (*) 下面这两个 case 被分在一组\n  case 5:\n    alert(\'Wrong!\');\n    alert("Why don\'t you take a math class?");\n    break;\n  default:\n    alert(\'The result is strange. Really.\');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nswitch/case 有通过 case 进行“分组”的能力，其实是 switch 语句没有 break 时的副作用。因为没有 break，case 3 会从 (*) 行执行到 case 5\n\n\n# 3.7.4 switch严格相等\n\nswitch的相等是严格相等。被比较的值必须是相同的类型才能进行匹配\n\n\n# 3.8 函数\n\n\n# 3.8.1 函数声明\n\nfunction 关键字首先出现，然后是 函数名，然后是括号之间的 参数 列表，最后是花括号之间的代码（即“函数体”）\n\nfunction showMessage() {\n  alert( \'Hello everyone!\' );\n}\n\n\n1\n2\n3\n\n\n我们的新函数可以通过名称调用：showMessage()\n\n\n# 3.8.2 局部变量\n\n在函数中声明的变量只在该函数内部可见\n\nfunction showMessage() {\n  let message = "Hello, I\'m JavaScript!"; // 局部变量\n  alert( message );\n}\nshowMessage(); // Hello, I\'m JavaScript!\nalert( message ); // <-- 错误！变量是函数的局部变量\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.8.3 外部变量\n\n# 外部变量读写\n\n函数对外部变量拥有全部的访问权限。函数可以读写外部变量\n\nlet userName = \'John\';\nfunction showMessage() {\n  userName = "Bob"; // (1) 改变外部变量\n  let message = \'Hello, \' + *!*userName*/!*;\n  alert(message);\n}\nalert( userName ); // *!*John*/!* 在函数调用之前\nshowMessage();\nalert( userName ); // *!*Bob*/!*，值被函数修改了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 外部变量遮蔽\n\n只有在没有局部变量的情况下才会使用外部变量。如果在函数内部声明了同名变量，那么函数会 遮蔽 外部变量\n\nlet userName = \'John\';\nfunction showMessage() {\n  let userName = "Bob"; // 声明一个局部变量\n  let message = \'Hello, \' + userName; // Bob\n  alert(message);\n}\n// 函数会创建并使用它自己的 userName\nshowMessage();\nalert( userName ); // John，未被更改，函数没有访问外部变量。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.8.4 参数\n\n# 形参与实参\n\n我们可以通过参数将任意数据传递给函数\n函数被调用的时候，给定值被复制到了局部变量的形参上，然后函数使用它们进行计算\n函数执行中会修改函数内的局部变量，但不会修改传递进来的实参，因为函数修改的是复制的实参值副本\n\nfunction showMessage(from, text) {\n  from = \'*\' + from + \'*\'; // 让 "from" 看起来更优雅\n  alert( from + \': \' + text );\n}\nlet from = "Ann";\nshowMessage(from, "Hello"); // *Ann*: Hello\n// "from" 值相同，函数修改了一个局部的副本。\nalert( from ); // Ann\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 形参（parameter）是函数声明中括号内列出的变量（它是函数声明时的术语）\n * 实参（argument）是调用函数时传递给函数的值（它是函数调用时的术语）\n\n# 形参默认值\n\n如果一个函数被调用，但有参数（argument）未被提供，那么相应的值就会变成 undefined\n我们可以使用 = 为函数声明中的参数指定所谓的“默认”（如果对应参数的值未被传递则使用）值\n\nfunction showMessage(from, text = "no text given") {\n  alert( from + ": " + text );\n}\nshowMessage("Ann"); // Ann: no text given\n\n\n1\n2\n3\n4\n\n\n在 JavaScript 老代码中的默认参数\n\n几年前，JavaScript 不支持默认参数的语法。所以人们使用其他方式来设置默认参数\n显式地检查 undefined：\n\nfunction showMessage(from, text) {\n  if (text === undefined) {\n    text = \'no text given\';\n  }\n  alert( from + ": " + text );\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n……或者使用 || 运算符：\n\nfunction showMessage(from, text) {\n  // 如果 text 的值为假值，则分配默认值\n  // 这样赋值 text == "" 与 text 无值相同\n  text = text || \'no text given\';\n  ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.8.5 返回值\n\n函数可以将一个值返回到调用代码中作为结果\n指令 return 可以在函数的任意位置。当执行到达时，函数停止，并将值返回给调用代码（分配给上述代码中的 result）\n只使用 return 但没有返回值也是可行的。但这会导致函数立即退出\n\n空值的 `return` 或没有 `return` 的函数返回值为 `undefined`\n\nfunction doNothing1() { /* 没有代码 */ }\nalert( doNothing1() === undefined ); // true\nfunction doNothing2() {\n  return;\n}\nalert( doNothing2() === undefined ); // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n不要在 `return` 与返回值之间添加新行\n\nJavaScript 默认会在 return 之后加上分号，如果添加空行就会导致返回值变成空值\n\nreturn\n  (some + long + expression + or + whatever * f(a) + f(b))\n// 等价于\nreturn;\n (some + long + expression + or + whatever * f(a) + f(b))\n\n\n1\n2\n3\n4\n5\n\n\n如果我们想要将返回的表达式写成跨多行的形式，那么应该在 return 的同一行开始写此表达式\n\nreturn (\n  some + long + expression\n  + or +\n  whatever * f(a) + f(b)\n  )\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3.8.6 函数表达式\n\n函数表达式是一种创建函数的语法，它允许我们在任何表达式的中间创建一个新函数\n\nlet sayHi = function() {\n  alert( "Hello" );\n};\n\n\n1\n2\n3\n\n\n由于函数创建发生在赋值表达式的上下文中（在 = 的右侧），因此这是一个 函数表达式。\n\n请注意，function 关键字后面没有函数名。函数表达式允许省略函数名\n\n# 函数是一个值\n\n无论函数是如何创建的，函数都是一个值\n我们还可以用 alert 打印这个变量的值：\n\nfunction sayHi() {\n  alert( "Hello" );\n}\nalert( sayHi ); // 显示函数代码\n\n\n1\n2\n3\n4\n\n\n最后一行代码并不会运行函数，因为 sayHi 后没有括号\n在 JavaScript 中，函数是一个值，所以我们可以把它当成值对待。上面代码显示了一段字符串值，即函数的源码\n\n# 函数声明vs函数表达式\n\n函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用\n在函数声明被定义之前，它就可以被调用\n严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。\n\n\n# 3.8.7 回调函数\n\n在一个函数中将其他的函数当做参数传入，被传入的函数就是被称为 回调函数 或简称 回调\n\n一个函数是表示一个“行为”的值\n\n字符串或数字等常规值代表 数据。\n函数可以被视为一个 行为（action）。\n我们可以在变量之间传递它们，并在需要时运行。\n\n\n# 3.8.8 箭头函数\n\n创建了一个函数 func，它接受参数 arg1..argN，然后使用参数对右侧的 expression 求值并返回其结果。\n\nlet func = (arg1, arg2, ..., argN) => expression;\n\n\n1\n\n\nlet sum = (a, b) => a + b;\n/* 这个箭头函数是下面这个函数的更短的版本：\nlet sum = function(a, b) {\n  return a + b;\n};\n*/\nalert( sum(1, 2) ); // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n * 如果我们只有一个参数，还可以省略掉参数外的圆括号，使代码更短。\n   \n   let double = n => n * 2;\n   // 差不多等同于：let double = function(n) { return n * 2 }\n   alert( double(3) ); // 6\n   \n   \n   1\n   2\n   3\n   \n\n * 如果没有参数，括号则是空的（但括号必须保留）：\n   \n   let sayHi = () => alert("Hello!");\n   sayHi();\n   \n   \n   1\n   2\n   \n\n# 多行箭头函数\n\n我们可以使用花括号将它们括起来。主要区别在于，用花括号括起来之后，需要包含 return 才能返回值（就像常规函数一样）\n\nlet sum = (a, b) => {  // 花括号表示开始一个多行函数\n  let result = a + b;\n  return result; // 如果我们使用了花括号，那么我们需要一个显式的 “return”\n};\nalert( sum(1, 2) ); // 3\n\n\n1\n2\n3\n4\n5\n',normalizedContent:'# 3.1 类型转换\n\n大多数情况下，运算符和函数会自动将赋予它们的值转换为正确的类型。\n\n比如，alert 会自动将任何值都转换为字符串以进行显示。算术运算符会将值转换为数字\n\n\n# 3.1.1 字符串转换\n\nalert(value) 将 value 转换为字符串类型，然后显示这个值\n我们也可以显式地调用 string(value) 来将 value 转换为字符串类型\n\n\n\n\n \n \n\n\nlet value = true;\nalert(typeof value); // boolean\nvalue = string(value); // 现在，值是一个字符串形式的 "true"\nalert(typeof value); // string\n\n\n1\n2\n3\n4\n\n\n\n# 3.1.2 数字型转换\n\n在算术函数和表达式中，会自动进行 number 类型转换\n\nalert( "6" / "2" ); // 3, string 类型的值被自动转换成 number 类型后进行计算\n\n\n1\n\n\n我们也可以使用 number(value) 显式地将这个 value 转换为 number 类型\n\nlet str = "123";\nalert(typeof str); // string\nlet num = number(str); // 变成 number 类型 123\nalert(typeof num); // number\n\n\n1\n2\n3\n4\n\n\nnumber 类型转换规则：\n\n值              变成……\nundefined      nan\nnull           0\ntrue 和 false   1 and 0\nstring         去掉首尾空格后的纯数字字符串中含有的数字。如果剩余字符串为空，则转换结果为\n               0。否则，将会从剩余字符串中“读取”数字。当类型转换出现 error 时返回 nan。\n\nalert( number("   123   ") ); // 123\nalert( number("123z") );      // nan（从字符串“读取”数字，读到 "z" 时出现错误）\nalert( number(true) );        // 1\nalert( number(false) );       // 0\n\n\n1\n2\n3\n4\n\n\n注意\n\n请注意 null 和 undefined 在这有点不同：null 变成数字 0，undefined 变成 nan\n\n\n# 3.1.3 布尔型转换\n\n它发生在逻辑运算中（稍后我们将进行条件判断和其他类似的东西），但是也可以通过调用 boolean(value) 显式地进行转换\n\n值                             变成……\n0, null, undefined, nan, ""   false\n其他值                           true\n\nalert( boolean(1) ); // true\nalert( boolean(0) ); // false\nalert( boolean("hello") ); // true\nalert( boolean("") ); // false\n\n\n1\n2\n3\n4\n\n\n注意\n\n包含 0 的字符串 "0" 是 true\n\n\n# 3.1.4 总结\n\n有三种常用的类型转换：转换为 string 类型、转换为 number 类型和转换为 boolean 类型。\n\n字符串转换 —— 转换发生在输出内容的时候，也可以通过 string(value) 进行显式转换。原始类型值的 string 类型转换通常是很明显的。\n\n数字型转换 —— 转换发生在进行算术操作时，也可以通过 number(value) 进行显式转换\n\n布尔型转换 —— 转换发生在进行逻辑操作时，也可以通过 boolean(value) 进行显式转换\n\n上述的大多数规则都容易理解和记忆。人们通常会犯错误的值得注意的例子有以下几个：\n\n * 对 undefined 进行数字型转换时，输出结果为 nan，而非 0。\n * 对 "0" 和只有空格的字符串（比如：" "）进行布尔型转换时，输出结果为 true\n\n\n# 3.2 基础运算符\n\n\n# 3.2.1 运算符相关术语\n\n# 运算元\n\n运算符应用的对象。比如说乘法运算 5 * 2，有两个运算元：左运算元 5 和右运算元 2。有时候人们也称其为“参数”而不是“运算元”\n\n# 一元运算符\n\n如果一个运算符对应的只有一个运算元，那么它是 一元运算符\n\nlet x = 1;\nx = -x;\nalert( x ); // -1，一元负号运算符生效\n\n\n1\n2\n3\n\n\n# 二元运算符\n\n如果一个运算符拥有两个运算元，那么它是 二元运算符\n\nlet x = 1, y = 3;\nalert( y - x ); // 2，二元运算符减号做减运算\n\n\n1\n2\n\n\n\n# 3.2.2 数学运算符\n\n支持以下数学运算：\n\n * 加法 +,\n * 减法 -,\n * 乘法 *,\n * 除法 /,\n * 取余 %,\n * 求幂 **.\n\n# 取余 %\n\na % b 的结果是 a 整除 b 的 余数\n\nalert( 5 % 2 ); // 1，5 除以 2 的余数\nalert( 8 % 3 ); // 2，8 除以 3 的余数\n\n\n1\n2\n\n\n# 求幂 **\n\n求幂运算 a ** b 将 a 提升至 a 的 b 次幂\n\nalert( 2 ** 2 ); // 2² = 4\nalert( 2 ** 3 ); // 2³ = 8\nalert( 2 ** 4 ); // 2⁴ = 16\n\n\n1\n2\n3\n\n\n\n# 3.2.3 用二元运算符 + 连接字符串\n\n通常，加号 + 用于求和。\n\n但是如果加号 + 被应用于字符串，它将合并（连接）各个字符串：\n\nlet s = "my" + "string";\nalert(s); // mystring\n\n\n1\n2\n\n\n注意：只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串。\n\n举个例子：\n\nalert( \'1\' + 2 ); // "12"\nalert( 2 + \'1\' ); // "21"\n\n\n1\n2\n\n\nalert(2 + 2 + \'1\' ); // "41"，不是 "221"\n\n\n1\n\n\n在这里，运算符是按顺序工作。第一个 + 将两个数字相加，所以返回 4，然后下一个 + 将字符串 1 加入其中，所以就是 4 + \'1\' = \'41\'。\n\nalert(\'1\' + 2 + 2); // "122"，不是 "14"\n\n\n1\n\n\n这里，第一个操作数是一个字符串，所以编译器将其他两个操作数也视为了字符串。2 被与 \'1\' 连接到了一起，也就是像 \'1\' + 2 = "12" 然后 "12" + 2 = "122" 这样。\n\n二元 + 是唯一一个以这种方式支持字符串的运算符。其他算术运算符只对数字起作用，并且总是将其运算元转换为数字。\n\n下面是减法和除法运算的示例：\n\nalert( 6 - \'2\' ); // 4，将 \'2\' 转换为数字\nalert( \'6\' / \'2\' ); // 3，将两个运算元都转换为数字\n\n\n1\n2\n\n\n\n# 3.2.4 数字转化，一元运算符 +\n\n加号 + 有两种形式。一种是上面我们刚刚讨论的二元运算符，还有一种是一元运算符。\n\n一元运算符加号，或者说，加号 + 应用于单个值，对数字没有任何作用。但是如果运算元不是数字，加号 + 则会将其转化为数字。\n\n例如：\n\n\n\n\n\n\n\n\n \n \n\n\n// 对数字无效\nlet x = 1;\nalert( +x ); // 1\nlet y = -2;\nalert( +y ); // -2\n// 转化非数字\nalert( +true ); // 1\nalert( +"" );   // 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n它的效果和 number(...) 相同，但是更加简短\n\n\n# 3.2.5 运算符优先级\n\n这是一个摘抄自 mozilla 的 优先级表（你没有必要把这全记住，但要记住一元运算符优先级高于二元运算符）：\n\n优先级   名称     符号\n...   ...    ...\n15    一元加号   +\n15    一元负号   -\n14    求幂     **\n13    乘号     *\n13    除号     /\n12    加号     +\n12    减号     -\n...   ...    ...\n2     赋值符    =\n...   ...    ...\n\n我们可以看到，“一元加号运算符”的优先级是 15，高于“二元加号运算符”的优先级 12。这也是为什么表达式 "+apples + +oranges" 中的一元加号先生效，然后才是二元加法\n\n\n# 3.2.6 赋值运算符\n\n赋值符号 = 也是一个运算符。从优先级表中可以看到它的优先级非常低，只有 2。\n\n所以当我们赋值时，比如 x = 2 * 2 + 1，所有的计算先执行，然后 = 才执行，将计算结果存储到 x\n\n# 赋值 = 返回一个值\n\n在 javascript 中，所有运算符都会返回一个值。这对于 + 和 - 来说是显而易见的，但对于 = 来说也是如此\n\n语句 x = value 将值 value 写入 x 然后返回 value。\n\n下面是一个在复杂语句中使用赋值的例子：\n\n\n\n\n \n\n\n\n\nlet a = 1;\nlet b = 2;\nlet c = 3 - (a = b + 1);\nalert( a ); // 3\nalert( c ); // 0\n\n\n1\n2\n3\n4\n5\n\n\n上面这个例子，(a = b + 1) 的结果是赋给 a 的值（也就是 3）。然后该值被用于进一步的运算\n\n# 链式赋值（chaining assignments）\n\nlet a, b, c;\na = b = c = 2 + 2;\nalert( a ); // 4\nalert( b ); // 4\nalert( c ); // 4\n\n\n1\n2\n3\n4\n5\n\n\n链式赋值从右到左进行计算。首先，对最右边的表达式 2 + 2 求值，然后将其赋给左边的变量：c、b 和 a。最后，所有的变量共享一个值\n\n\n# 3.2.7 原地修改\n\n我们经常需要对一个变量做运算，并将新的结果存储在同一个变量中\n\n可以使用运算符 += 和 *= 来缩写这种表示，所有算术和位运算符都有简短的“修改并赋值”运算符\n\nlet n = 2;\nn += 5; // 现在 n = 7（等同于 n = n + 5）\nn *= 2; // 现在 n = 14（等同于 n = n * 2）\nalert( n ); // 14\n\n\n1\n2\n3\n4\n\n\n这类运算符的优先级与普通赋值运算符的优先级相同，所以它们在大多数其他运算之后执行：\n\nlet n = 2;\nn *= 3 + 5;\nalert( n ); // 16 （右边部分先被计算，等同于 n *= 8）\n\n\n1\n2\n3\n\n\n\n# 3.2.8 自增/自减\n\n# 自增++\n\n将变量与 1 相加\n\nlet counter = 2;\ncounter++;      // 和 counter = counter + 1 效果一样，但是更洁\nalert( counter ); // 3\n\n\n1\n2\n3\n\n\n# 自减--\n\nlet counter = 2;\ncounter--;      // 和 counter = counter - 1 效果一样，但是更洁\nalert( counter ); // 1\n\n\n1\n2\n3\n\n\n只用于变量\n\n自增/自减只能应用于变量。试一下，将其应用于数值（比如 5++）则会报错\n\n# 前置与后置\n\n运算符 ++ 和 -- 可以置于变量前，也可以置于变量后。\n\n * 当运算符置于变量后，被称为“后置形式”：counter++。\n * 当运算符置于变量前，被称为“前置形式”：++counter。\n\nlet counter = 1;\nlet a = ++counter; // (*)\nalert(a); // 2\n\n\n1\n2\n3\n\n\n(*) 所在的行是前置形式 ++counter，对 counter 做自增运算，返回的是新的值 2。因此 alert 显示的是 2。\n\n下面让我们看看后置形式：\n\nlet counter = 1;\nlet a = counter++; // (*) 将 ++counter 改为 counter++\nalert(a); // 1\n\n\n1\n2\n3\n\n\n(*) 所在的行是后置形式 counter++，它同样对 counter 做加法，但是返回的是 旧值（做加法之前的值）。因此 alert 显示的是 1。\n\n自增/自减和其它运算符的对比\n\n++/-- 运算符同样可以在表达式内部使用。它们的优先级比绝大部分的算数运算符要高。 举个例子：\n\nlet counter = 1;\nalert( 2 * ++counter ); // 4\n\n\n1\n2\n\n\n\n# 3.2.9 位运算符\n\n下面是位运算符：\n\n * 按位与 ( & )\n * 按位或 ( | )\n * 按位异或 ( ^ )\n * 按位非 ( ~ )\n * 左移 ( << )\n * 右移 ( >> )\n * 无符号右移 ( >>> )\n\n\n# 3.2.10 逗号运算符\n\n逗号运算符能让我们处理多个语句，使用 , 将它们分开。每个语句都运行了，但是只有最后的语句的结果会被返回\n\n\n\n\n\n\nlet a = (1 + 2, 3 + 4);\nalert( a ); // 7（3 + 4 的结果）\n\n\n1\n2\n\n\n这里，第一个语句 1 + 2 运行了，但是它的结果被丢弃了。随后计算 3 + 4，并且该计算结果被返回\n\n逗号运算符的优先级非常低\n\n请注意逗号运算符的优先级非常低，比 = 还要低，因此上面你的例子中圆括号非常重要。 如果没有圆括号：a = 1 + 2, 3 + 4 会先执行 +，将数值相加得到 a = 3, 7，然后赋值运算符 = 执行 a = 3，然后逗号之后的数值 7 不会再执行，它被忽略掉了。相当于 (a = 1 + 2), 3 + 4。\n\n\n# 3.3 比较运算符\n\n * 大于 / 小于：a > b，a < b。\n * 大于等于 / 小于等于：a >= b，a <= b。\n * 检查两个值的相等：a == b，请注意双等号 == 表示相等性检查，而单等号 a = b 表示赋值。\n * 检查两个值不相等：不相等在数学中的符号是 =，但在 javascript 中写成 a != b。\n\n\n# 3.3.1 比较运算符结果为boolean 类型\n\n所有比较运算符均返回布尔值：\n\n * true —— 表示“yes（是）”，“correct（正确）”或“the truth（真）”。\n * false —— 表示“no（否）”，“wrong（错误）”或“not the truth（非真）”。\n\n和其他类型的值一样，比较的结果可以被赋值给任意变量\n\nlet result = 5 > 4; // 把比较的结果赋值给 result\nalert( result ); // true\n\n\n1\n2\n\n\n\n# 3.3.2 字符串比较\n\n在比较字符串的大小时，javascript 会使用“字典（dictionary）”或“词典（lexicographical）”顺序进行判定，字符串是按字符（母）逐个进行比较的\n\nalert( \'z\' > \'a\' ); // true\nalert( \'glow\' > \'glee\' ); // true\nalert( \'bee\' > \'be\' ); // true\n\n\n1\n2\n3\n\n\n字符串的比较算法非常简单：\n\n 1. 首先比较两个字符串的首位字符大小。\n 2. 如果一方字符较大（或较小），则该字符串大于（或小于）另一个字符串。算法结束。\n 3. 否则，如果两个字符串的首位字符相等，则继续取出两个字符串各自的后一位字符进行比较。\n 4. 重复上述步骤进行比较，直到比较完成某字符串的所有字符为止。\n 5. 如果两个字符串的字符同时用完，那么则判定它们相等，否则未结束（还有未比较的字符）的字符串更大\n\n非真正的字典顺序，而是 unicode 编码顺序\n\n在上面的算法中，比较大小的逻辑与字典或电话簿中的排序很像，但也不完全相同。\n比如说，字符串比较对字母大小写是敏感的。大写的 "a" 并不等于小写的 "a"。哪一个更大呢？实际上小写的 "a" 更大。这是因为在 javascript 使用的内部编码表中（unicode），小写字母的字符索引值更大\n\n\n# 3.3.3 不同类型间的比较\n\n当对不同类型的值进行比较时，javascript 会首先将其转化为数字（number）再判定大小\n\nalert( \'2\' > 1 ); // true，字符串 \'2\' 会被转化为数字 2\nalert( \'01\' == 1 ); // true，字符串 \'01\' 会被转化为数字 1\nalert( true == 1 ); // true\nalert( false == 0 ); // true\n\n\n1\n2\n3\n4\n\n\n一个有趣的现象\n\n有时候，以下两种情况会同时发生：\n\n * 若直接比较两个值，其结果是相等的。\n * 若把两个值转为布尔值，它们可能得出完全相反的结果，即一个是 true，一个是 false。 例如：\n\nlet a = 0;\nalert( boolean(a) ); // false\nlet b = "0";\nalert( boolean(b) ); // true\nalert(a == b); // true!\n\n\n1\n2\n3\n4\n5\n\n\n对于 javascript 而言，这种现象其实挺正常的。因为 javascript 会把待比较的值转化为数字后再做比较（因此 "0" 变成了 0）。若只是将一个变量转化为 boolean 值，则会使用其他的类型转换规则。\n\n\n# 3.3.4 严格相等\n\n普通的相等性检查 == 存在一个问题，它不能区分出 0 和 false,也同样无法区分空字符串和 false\n这是因为在比较不同类型的值时，处于相等判断符号 == 两侧的值会先被转化为数字。空字符串和 false 也是如此，转化后它们都为数字 0\n严格相等运算符 === 在进行比较时不会做任何的类型转换。\n\nalert( 0 === false ); // false，因为被比较值的数据类型不同\n\n\n1\n\n\n同样的，与“不相等”符号 != 类似，“严格不相等”表示为 !==\n\n\n# 3.3.5 对 null 和 undefined 进行比较\n\n当使用严格相等 === 比较二者时 : 它们不相等，因为它们属于不同的类型。\n\n```js run\nalert( null === undefined ); // false\n```\n\n\n当使用非严格相等 == 比较二者时 : javascript 存在一个特殊的规则，会判定它们相等。它们俩就像“一对恋人”，仅仅等于对方而不等于其他任何的值（只在非严格相等下成立）。\n\n```js run\nalert( null == undefined ); // true\n```\n\n\n当使用数学式或其他比较方法 < > <= >= 时： : null/undefined 会被转化为数字：null 被转化为 0，undefined 被转化为 nan。\n\n# null vs 0\n\n\n\n\n \n\n\nalert( null > 0 );  // (1) false\nalert( null == 0 ); // (2) false\nalert( null >= 0 ); // (3) true\n\n\n1\n2\n3\n\n\n相等性检查 == 和普通比较符 > < >= <= 的代码逻辑是相互独立的\n进行值的比较时，null 会被转化为数字，因此它被转化为了 0。这就是为什么（3）中 null >= 0 返回值是 true，（1）中 null > 0 返回值是 false。\nundefined 和 null 在相等性检查 == 中不会进行任何的类型转换，它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值。这就解释了为什么（2）中 null == 0 会返回 false。\n\n# undefined\n\nalert( undefined > 0 ); // false (1)\nalert( undefined < 0 ); // false (2)\nalert( undefined == 0 ); // false (3)\n\n\n1\n2\n3\n\n\n(1) 和 (2) 都返回 false 是因为 undefined 在比较中被转换为了 nan，而 nan 是一个特殊的数值型值，它与任何值进行比较都会返回 false\n(3) 返回 false 是因为这是一个相等性检查，而 undefined 只与 null 相等，不会与其他值相等\n\n\n# 3.4 条件分支\n\n\n# 3.4.1 "if" 语句\n\nif(...) 语句计算括号里的条件表达式，如果计算结果是 true，就会执行对应的代码块\n\nif (year == 2015) {\n  alert( "that\'s correct!" );\n  alert( "you\'re so smart!" );\n}\n\n\n1\n2\n3\n4\n\n\n\n# 3.4.2 布尔转换\n\nif (…) 语句会计算圆括号内的表达式，并将计算结果转换为布尔型\n\n\n# 3.4.3 "else" 语句\n\nif 语句有时会包含一个可选的 "else" 块。如果判断条件不成立，就会执行它内部的代码\n\n\n# 3.4.4 多个条件："else if"\n\n有时我们需要测试一个条件的几个变体。我们可以通过使用 else if 子句实现\n\nlet year = prompt(\'in which year was ecmascript-2015 specification published?\', \'\');\nif (year < 2015) {\n  alert( \'too early...\' );\n} else if (year > 2015) {\n  alert( \'too late\' );\n} else {\n  alert( \'exactly!\' );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n可以有更多的 else if 块。结尾的 else 是可选的\n\n\n# 3.4.5 条件运算符 \'?\'\n\n问号 ? 有时它被称为三元运算符，被称为“三元”是因为该运算符中有三个操作数\n\nlet result = condition ? value1 : value2;\n\n\n1\n\n\n计算条件结果，如果结果为真，则返回 value1，否则返回 value2\n\n\n# 3.4.6 多个 \'?\'\n\n使用一系列问号 ? 运算符可以返回一个取决于多个条件的值\n\nlet age = prompt(\'age?\', 18);\nlet message = (age < 3) ? \'hi, baby!\' :\n  (age < 18) ? \'hello!\' :\n  (age < 100) ? \'greetings!\' :\n  \'what an unusual age!\';\nalert( message );\n\n\n1\n2\n3\n4\n5\n6\n\n 1. 第一个问号检查 age < 3。\n 2. 如果为真 — 返回 \'hi, baby!\'。否则，会继续执行冒号 ":" 后的表达式，检查 age < 18。\n 3. 如果为真 — 返回 \'hello!\'。否则，会继续执行下一个冒号 ":" 后的表达式，检查 age < 100。\n 4. 如果为真 — 返回 \'greetings!\'。否则，会继续执行最后一个冒号 ":" 后面的表达式，返回 \'what an unusual age!\'\n\n\n# 3.4.6 \'?\' 的非常规使用\n\n有时可以使用问号 ? 来代替 if 语句\n\nlet company = prompt(\'which company created javascript?\', \'\');\n(company == \'netscape\') ?\n   alert(\'right!\') : alert(\'wrong.\');\n\n\n1\n2\n3\n\n\n根据条件 company ==\'netscape\'，要么执行 ? 后面的第一个表达式并显示对应内容，要么执行第二个表达式并显示对应内容\n不建议这样使用问号运算符。\n\n\n# 3.5 逻辑运算符\n\njavascript 中有四个逻辑运算符：||（或），&&（与），!（非），??（空值合并运算符）\n虽然它们被称为“逻辑”运算符，但这些运算符却可以被应用于任意类型的值，而不仅仅是布尔值。它们的结果也同样可以是任意类型\n\n\n# 3.5.1 ||（或）\n\n两个竖线符号表示“或”运算符：\n\nresult = a || b;\n\n\n1\n\n\nalert( true || true );   // true\nalert( false || true );  // true\nalert( true || false );  // true\nalert( false || false ); // false\n\n\n1\n2\n3\n4\n\n\n如果操作数不是布尔值，那么它将会被转化为布尔值来参与运算\n\n# 或运算寻找第一个真值\n\n给定多个参与或运算的值：\n\nresult = value1 || value2 || value3;\n\n\n1\n\n\n或运算符 || 做了如下的事情：\n\n * 从左到右依次计算操作数。\n * 处理每一个操作数时，都将其转化为布尔值。如果结果是 true，就停止计算，返回这个操作数的初始值。\n * 如果所有的操作数都被计算过（也就是，转换结果都是 false），则返回最后一个操作数。\n\n返回的值是操作数的初始形式，不会做布尔转换。\n\n换句话说，一个或运算 || 的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值\n\nalert( 1 || 0 ); // 1（1 是真值）\nalert( null || 1 ); // 1（1 是第一个真值）\nalert( null || 0 || 1 ); // 1（第一个真值）\nalert( undefined || null || 0 ); // 0（都是假值，返回最后一个值）\n\n\n1\n2\n3\n4\n\n\n 1. 获取变量列表或者表达式中的第一个真值 我们用或运算 || 来选择有数据的那一个，并显示出来（如果没有设置，则用 "anonymous"）：\n    \n    \n    \n    \n    \n     \n    \n    \n    let firstname = "";\n    let lastname = "";\n    let nickname = "supercoder";\n    alert( firstname || lastname || nickname || "anonymous"); // supercoder\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. 短路求值（short-circuit evaluation） || 对其参数进行处理，直到达到第一个真值，然后立即返回该值，而无需处理其他参数\n    \n    true || alert("not printed");\n    false || alert("printed");\n    \n    \n    1\n    2\n    \n    \n    在第一行中，或运算符 || 在遇到 true 时立即停止运算，所以 alert 没有运行\n\n\n# 3.5.2 &&（与）\n\n两个 & 符号表示 && 与运算符\n\nresult = a && b;\n\n\n1\n\n\n在传统的编程中，当两个操作数都是真值时，与运算返回 true，否则返回 false：\n\nalert( true && true );   // true\nalert( false && true );  // false\nalert( true && false );  // false\nalert( false && false ); // false\n\n\n1\n2\n3\n4\n\n\n就像或运算一样，与运算的操作数可以是任意类型的值：\n\nif (1 && 0) { // 作为 true && false 来执行\n  alert( "won\'t work, because the result is falsy" );\n}\n\n\n1\n2\n3\n\n\n# 与运算寻找第一个假值\n\nresult = value1 && value2 && value3;\n\n\n1\n\n\n与运算 && 做了如下的事：\n\n * 从左到右依次计算操作数。\n * 在处理每一个操作数时，都将其转化为布尔值。如果结果是 false，就停止计算，并返回这个操作数的初始值。\n * 如果所有的操作数都被计算过（例如都是真值），则返回最后一个操作数。\n\n换句话说，与运算返回第一个假值，如果没有假值就返回最后一个值\n\n// 如果第一个操作数是真值，\n// 与运算返回第二个操作数：\nalert( 1 && 0 ); // 0\nalert( 1 && 5 ); // 5\n// 如果第一个操作数是假值，\n// 与运算将直接返回它。第二个操作数会被忽略\nalert( null && 5 ); // null\nalert( 0 && "no matter what" ); // 0\n\nalert( 1 && 2 && null && 3 ); // null\n//如果所有的值都是真值，最后一个值将会被返回\nalert( 1 && 2 && 3 ); // 3，最后一个值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n与运算 `&&` 在或运算 `||` 之前进行\n\n与运算 && 的优先级比或运算 || 要高。\n所以代码 a && b || c && d 跟 && 表达式加了括号完全一样：(a && b) || (c && d)\n\n注意\n\n不要用 || 或 && 来取代 if\n\n\n# 3.5.3 !（非）\n\n感叹符号 ! 表示布尔非运算符\n\nresult = !value;\n\n\n1\n\n\n逻辑非运算符接受一个参数，并按如下运作：\n\n 1. 将操作数转化为布尔类型：true/false。\n 2. 返回相反的值\n\nalert( !true ); // false\nalert( !0 ); // true\n\n\n1\n2\n\n\n非运算符 ! 的优先级在所有逻辑运算符里面最高，所以它总是在 && 和 || 之前执行\n\n# !!\n\n两个非运算 !! 有时候用来将某个值转化为布尔类型\n\n\n# 3.5.4 空值合并运算符 \'??\'\n\n空值合并运算符（nullish coalescing operator）的写法为两个问号 ??\n由于它对待 null 和 undefined 的方式类似，所以在本文中我们将使用一个特殊的术语对其进行表示。为简洁起见，当一个值既不是 null 也不是 undefined 时，我们将其称为“已定义的（defined）”\n\na ?? b 的结果是：\n\n * 如果 a 是已定义的，则结果为 a，\n * 如果 a 不是已定义的，则结果为 b\n\nlet user;\nalert(user ?? "匿名"); // 匿名（user 未定义）\n\n\n1\n2\n\n\nlet user = "john";\nalert(user ?? "匿名"); // john（user 已定义）\n\n\n1\n2\n\n\n我们还可以使用 ?? 序列从一系列的值中选择出第一个非 null/undefined 的值\n\nlet firstname = null;\nlet lastname = null;\nlet nickname = "supercoder";\n// 显示第一个已定义的值：\nalert(firstname ?? lastname ?? nickname ?? "匿名"); // supercoder\n\n\n1\n2\n3\n4\n5\n\n\n# 与 || 比较\n\n或运算符 || 可以以与 ?? 运算符相同的方式使用\n\n它们之间重要的区别是：\n\n * || 返回第一个 真 值。\n * ?? 返回第一个 已定义的 值\n\n# 优先级\n\n?? 运算符的优先级与 || 相同，它们的的优先级都为 4\n\n# ?? 与 && 或 || 一起使用\n\n出于安全原因，javascript 禁止将 ?? 运算符与 && 和 || 运算符一起使用，除非使用括号明确指定了优先级\n\n\n# 3.6 循环\n\n\n# 3.6.1 while循环\n\nwhile 循环的语法如下：当 condition 为真时，执行循环体的 code。\n\nwhile (condition) {\n  // 代码\n  // 所谓的“循环体” \n}\n\n\n1\n2\n3\n4\n\n\n在 while 中的循环条件会被计算，计算结果会被转化为布尔值。\n单行循环体不需要大括号"，如果循环体只有一条语句，则可以省略大括号 {…}：\n\nlet i = 3;\nwhile (i) alert(i--);\n\n\n1\n2\n\n\n\n# 3.6.2 do...while循环\n\n使用 do..while 语法可以将条件检查移至循环体 下面：\n\ndo {\n  // 循环体\n} while (condition);\n\n\n1\n2\n3\n\n\n循环首先执行循环体，然后检查条件，当条件为真时，重复执行循环体\n不管条件是否为真，循环体 至少执行一次\n\n\n# 3.6.3 for循环\n\nfor (begin; condition; step) {\n  // ……循环体……\n}\n\n\n1\n2\n3\n\n\n语句段                     \nbegin       let i = 0   进入循环时执行一次。\ncondition   i < 3       在每次循环迭代之前检查，如果为 false，停止循环。\nbody（循环体）   alert(i)    条件为真时，重复运行。\nstep        i++         在每次循环体迭代后执行。\n\n# 内联变量声明\n\n“计数”变量 i 是在循环中声明的。这叫做“内联”变量声明。这样的变量只在循环中可见。\n\nfor (let i = 0; i < 3; i++) {\n  alert(i); // 0, 1, 2\n}\nalert(i); // 错误，没有这个变量。\n\n\n1\n2\n3\n4\n\n\n# 省略语句段\n\nfor 循环的任何语句段都可以被省略\n\nlet i = 0; // 我们已经声明了 i 并对它进行了赋值\nfor (; i < 3; i++) { // 不再需要 "begin" 语句段\n  alert( i ); // 0, 1, 2\n}\n\n\n1\n2\n3\n4\n\n\n注意\n\n请注意 for 的两个 ; 必须存在，否则会出现语法错误\n\n\n# 3.6.4 break\n\n循环中随时都可以使用 break 指令强制退出\n\nlet sum = 0;\nwhile (true) {\n  let value = +prompt("enter a number", \'\');\n  if (!value) break; \n  sum += value;\n}\nalert( \'sum: \' + sum );\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n根据需要，"无限循环 + break" 的组合非常适用于不必在循环开始/结束时检查条件，但需要在中间甚至是主体的多个位置进行条件检查的情况。\n\n\n# 3.6.5 continue\n\ncontinue 指令是 break 的“轻量版”。它不会停掉整个循环。而是停止当前这一次迭代，并强制启动新一轮循环（如果条件允许的话）\n\nfor (let i = 0; i < 10; i++) {\n  //如果为真，跳过循环体的剩余部分。\n  if (i % 2 == 0) continue;\n  alert(i); // 1，然后 3，5，7，9\n}\n\n\n1\n2\n3\n4\n5\n\n\n禁止 `break/continue` 在 ‘?’ 的右边\n\n请注意非表达式的语法结构不能与三元运算符 ? 一起使用。特别是 break/continue 这样的指令是不允许这样使用的\n\n(i > 5) ? alert(i) : continue; // continue 不允许在这个位置,代码会停止运行，并显示有语法错误\n\n\n1\n\n\n\n# 3.6.6 break/continue 标签\n\n使用标签可以一次从多层嵌套的循环中跳出来\n标签 是在循环之前带有冒号的标识符：\n\nlabelname: for (...) {\n  ...\n}\n\n\n1\n2\n3\n\n\nbreak <labelname> 语句跳出循环至标签处：\n\nouter:for (let i = 0; i < 3; i++) {\n  for (let j = 0; j < 3; j++) {\n    let input = prompt(`value at coords (${i},${j})`, \'\');\n    // 如果是空字符串或被取消，则中断并跳出这两个循环。\n    if (!input) break outer; // (*)\n    // 用得到的值做些事……\n  }\n}\nalert(\'done!\');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n标签并不允许“跳到”所有位置\n\nbreak 指令必须在代码块内。从技术上讲，任何被标记的代码块都有效，例如：\n\nlabel: {\n  // ...\n  break label; // 有效\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n\n\ncontinue 只有在循环内部才可行\n\n\n# 3.7 switch\n\nswitch 语句可以替代多个 if 判断\n\n\n# 3.7.1 switch语法\n\nswitch 语句有至少一个 case 代码块和一个可选的 default 代码块。\n\nswitch(x) {\n  case \'value1\':  // if (x === \'value1\')\n    ...\n    [break]\n  case \'value2\':  // if (x === \'value2\')\n    ...\n    [break]\n  default:\n    ...\n    [break]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 比较 x 值与第一个 case（也就是 value1）是否严格相等，然后比较第二个 case（value2）以此类推\n * 如果相等，switch 语句就执行相应 case 下的代码块，直到遇到最靠近的 break 语句（或者直到 switch 语句末尾）\n * 如果没有符合的 case，则执行 default 代码块（如果 default 存在）\n\n任何表达式都可以成为 `switch/case` 的参数\n\nswitch 和 case 都允许任意表达式。\n\nlet a = "1";\nlet b = 0;\nswitch (+a) {\n  case b + 1:\n    alert("this runs, because +a is 1, exactly equals b+1");\n    break;\n  default:\n    alert("this doesn\'t run");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.7.2 switch中的break\n\nlet a = 2 + 2;\nswitch (a) {\n  case 3:\n    alert( \'too small\' );\n    break;\n  case 4:\n    alert( \'exactly!\' );\n    break;\n  case 5:\n    alert( \'too big\' );\n    break;\n  default:\n    alert( "i don\'t know such values" );\n}//输出exactly!\nswitch (a) {\n  case 3:\n    alert( \'too small\' );\n  case 4:\n    alert( \'exactly!\' );\n  case 5:\n    alert( \'too big\' );\n  default:\n    alert( "i don\'t know such values" );\n}//输出exactly! too big i don\'t know such values\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 3.7.3 case分组\n\n共享同一段代码的几个 case 分支可以被分为一组\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n\n\nlet a = 3;\nswitch (a) {\n  case 4:\n    alert(\'right!\');\n    break;\n  case 3: // (*) 下面这两个 case 被分在一组\n  case 5:\n    alert(\'wrong!\');\n    alert("why don\'t you take a math class?");\n    break;\n  default:\n    alert(\'the result is strange. really.\');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nswitch/case 有通过 case 进行“分组”的能力，其实是 switch 语句没有 break 时的副作用。因为没有 break，case 3 会从 (*) 行执行到 case 5\n\n\n# 3.7.4 switch严格相等\n\nswitch的相等是严格相等。被比较的值必须是相同的类型才能进行匹配\n\n\n# 3.8 函数\n\n\n# 3.8.1 函数声明\n\nfunction 关键字首先出现，然后是 函数名，然后是括号之间的 参数 列表，最后是花括号之间的代码（即“函数体”）\n\nfunction showmessage() {\n  alert( \'hello everyone!\' );\n}\n\n\n1\n2\n3\n\n\n我们的新函数可以通过名称调用：showmessage()\n\n\n# 3.8.2 局部变量\n\n在函数中声明的变量只在该函数内部可见\n\nfunction showmessage() {\n  let message = "hello, i\'m javascript!"; // 局部变量\n  alert( message );\n}\nshowmessage(); // hello, i\'m javascript!\nalert( message ); // <-- 错误！变量是函数的局部变量\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.8.3 外部变量\n\n# 外部变量读写\n\n函数对外部变量拥有全部的访问权限。函数可以读写外部变量\n\nlet username = \'john\';\nfunction showmessage() {\n  username = "bob"; // (1) 改变外部变量\n  let message = \'hello, \' + *!*username*/!*;\n  alert(message);\n}\nalert( username ); // *!*john*/!* 在函数调用之前\nshowmessage();\nalert( username ); // *!*bob*/!*，值被函数修改了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 外部变量遮蔽\n\n只有在没有局部变量的情况下才会使用外部变量。如果在函数内部声明了同名变量，那么函数会 遮蔽 外部变量\n\nlet username = \'john\';\nfunction showmessage() {\n  let username = "bob"; // 声明一个局部变量\n  let message = \'hello, \' + username; // bob\n  alert(message);\n}\n// 函数会创建并使用它自己的 username\nshowmessage();\nalert( username ); // john，未被更改，函数没有访问外部变量。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.8.4 参数\n\n# 形参与实参\n\n我们可以通过参数将任意数据传递给函数\n函数被调用的时候，给定值被复制到了局部变量的形参上，然后函数使用它们进行计算\n函数执行中会修改函数内的局部变量，但不会修改传递进来的实参，因为函数修改的是复制的实参值副本\n\nfunction showmessage(from, text) {\n  from = \'*\' + from + \'*\'; // 让 "from" 看起来更优雅\n  alert( from + \': \' + text );\n}\nlet from = "ann";\nshowmessage(from, "hello"); // *ann*: hello\n// "from" 值相同，函数修改了一个局部的副本。\nalert( from ); // ann\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 形参（parameter）是函数声明中括号内列出的变量（它是函数声明时的术语）\n * 实参（argument）是调用函数时传递给函数的值（它是函数调用时的术语）\n\n# 形参默认值\n\n如果一个函数被调用，但有参数（argument）未被提供，那么相应的值就会变成 undefined\n我们可以使用 = 为函数声明中的参数指定所谓的“默认”（如果对应参数的值未被传递则使用）值\n\nfunction showmessage(from, text = "no text given") {\n  alert( from + ": " + text );\n}\nshowmessage("ann"); // ann: no text given\n\n\n1\n2\n3\n4\n\n\n在 javascript 老代码中的默认参数\n\n几年前，javascript 不支持默认参数的语法。所以人们使用其他方式来设置默认参数\n显式地检查 undefined：\n\nfunction showmessage(from, text) {\n  if (text === undefined) {\n    text = \'no text given\';\n  }\n  alert( from + ": " + text );\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n……或者使用 || 运算符：\n\nfunction showmessage(from, text) {\n  // 如果 text 的值为假值，则分配默认值\n  // 这样赋值 text == "" 与 text 无值相同\n  text = text || \'no text given\';\n  ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.8.5 返回值\n\n函数可以将一个值返回到调用代码中作为结果\n指令 return 可以在函数的任意位置。当执行到达时，函数停止，并将值返回给调用代码（分配给上述代码中的 result）\n只使用 return 但没有返回值也是可行的。但这会导致函数立即退出\n\n空值的 `return` 或没有 `return` 的函数返回值为 `undefined`\n\nfunction donothing1() { /* 没有代码 */ }\nalert( donothing1() === undefined ); // true\nfunction donothing2() {\n  return;\n}\nalert( donothing2() === undefined ); // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n不要在 `return` 与返回值之间添加新行\n\njavascript 默认会在 return 之后加上分号，如果添加空行就会导致返回值变成空值\n\nreturn\n  (some + long + expression + or + whatever * f(a) + f(b))\n// 等价于\nreturn;\n (some + long + expression + or + whatever * f(a) + f(b))\n\n\n1\n2\n3\n4\n5\n\n\n如果我们想要将返回的表达式写成跨多行的形式，那么应该在 return 的同一行开始写此表达式\n\nreturn (\n  some + long + expression\n  + or +\n  whatever * f(a) + f(b)\n  )\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3.8.6 函数表达式\n\n函数表达式是一种创建函数的语法，它允许我们在任何表达式的中间创建一个新函数\n\nlet sayhi = function() {\n  alert( "hello" );\n};\n\n\n1\n2\n3\n\n\n由于函数创建发生在赋值表达式的上下文中（在 = 的右侧），因此这是一个 函数表达式。\n\n请注意，function 关键字后面没有函数名。函数表达式允许省略函数名\n\n# 函数是一个值\n\n无论函数是如何创建的，函数都是一个值\n我们还可以用 alert 打印这个变量的值：\n\nfunction sayhi() {\n  alert( "hello" );\n}\nalert( sayhi ); // 显示函数代码\n\n\n1\n2\n3\n4\n\n\n最后一行代码并不会运行函数，因为 sayhi 后没有括号\n在 javascript 中，函数是一个值，所以我们可以把它当成值对待。上面代码显示了一段字符串值，即函数的源码\n\n# 函数声明vs函数表达式\n\n函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用\n在函数声明被定义之前，它就可以被调用\n严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。\n\n\n# 3.8.7 回调函数\n\n在一个函数中将其他的函数当做参数传入，被传入的函数就是被称为 回调函数 或简称 回调\n\n一个函数是表示一个“行为”的值\n\n字符串或数字等常规值代表 数据。\n函数可以被视为一个 行为（action）。\n我们可以在变量之间传递它们，并在需要时运行。\n\n\n# 3.8.8 箭头函数\n\n创建了一个函数 func，它接受参数 arg1..argn，然后使用参数对右侧的 expression 求值并返回其结果。\n\nlet func = (arg1, arg2, ..., argn) => expression;\n\n\n1\n\n\nlet sum = (a, b) => a + b;\n/* 这个箭头函数是下面这个函数的更短的版本：\nlet sum = function(a, b) {\n  return a + b;\n};\n*/\nalert( sum(1, 2) ); // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n * 如果我们只有一个参数，还可以省略掉参数外的圆括号，使代码更短。\n   \n   let double = n => n * 2;\n   // 差不多等同于：let double = function(n) { return n * 2 }\n   alert( double(3) ); // 6\n   \n   \n   1\n   2\n   3\n   \n\n * 如果没有参数，括号则是空的（但括号必须保留）：\n   \n   let sayhi = () => alert("hello!");\n   sayhi();\n   \n   \n   1\n   2\n   \n\n# 多行箭头函数\n\n我们可以使用花括号将它们括起来。主要区别在于，用花括号括起来之后，需要包含 return 才能返回值（就像常规函数一样）\n\nlet sum = (a, b) => {  // 花括号表示开始一个多行函数\n  let result = a + b;\n  return result; // 如果我们使用了花括号，那么我们需要一个显式的 “return”\n};\nalert( sum(1, 2) ); // 3\n\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0}},{title:"Object对象",frontmatter:{title:"Object对象",date:"2022-07-07T17:09:02.000Z",permalink:"/pages/ad315d/",categories:["《JavaScript》","《现代JavaScript教程》","JavaScript编程语言"],tags:["JavaScript"]},regularPath:"/%E3%80%8AJavaScript%E3%80%8B/02.%E3%80%8A%E7%8E%B0%E4%BB%A3JavaScript%E6%95%99%E7%A8%8B%E3%80%8B/00.%20JavaScript%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/03.%20Object%E5%AF%B9%E8%B1%A1.html",relativePath:"《JavaScript》/02.《现代JavaScript教程》/00. JavaScript编程语言/03. Object对象.md",key:"v-05fdb0ec",path:"/pages/ad315d/",headers:[{level:2,title:"4.1 对象基础",slug:"_4-1-对象基础",normalizedTitle:"4.1 对象基础",charIndex:2},{level:3,title:"4.1.1 创建对象",slug:"_4-1-1-创建对象",normalizedTitle:"4.1.1 创建对象",charIndex:15},{level:3,title:"4.1.2 键值对",slug:"_4-1-2-键值对",normalizedTitle:"4.1.2 键值对",charIndex:142},{level:4,title:"点符号访问属性值",slug:"点符号访问属性值",normalizedTitle:"点符号访问属性值",charIndex:367},{level:4,title:"delete 操作符移除属性",slug:"delete-操作符移除属性",normalizedTitle:"delete 操作符移除属性",charIndex:454},{level:4,title:"多词属性",slug:"多词属性",normalizedTitle:"多词属性",charIndex:495},{level:3,title:"4.1.3 []",slug:"_4-1-3",normalizedTitle:"4.1.3 []",charIndex:621},{level:4,title:"多词属性",slug:"多词属性-2",normalizedTitle:"多词属性",charIndex:495},{level:4,title:"变量 key由表达式得到",slug:"变量-key由表达式得到",normalizedTitle:"变量 key由表达式得到",charIndex:933},{level:3,title:"4.1.4 计算属性",slug:"_4-1-4-计算属性",normalizedTitle:"4.1.4 计算属性",charIndex:1182},{level:3,title:"4.1.5 属性值简写",slug:"_4-1-5-属性值简写",normalizedTitle:"4.1.5 属性值简写",charIndex:1401},{level:3,title:"4.1.6 属性名称限制",slug:"_4-1-6-属性名称限制",normalizedTitle:"4.1.6 属性名称限制",charIndex:1620},{level:3,title:'4.1.7  属性存在性测试，"in" 操作符',slug:"_4-1-7-属性存在性测试-in-操作符",normalizedTitle:"4.1.7  属性存在性测试，&quot;in&quot; 操作符",charIndex:null},{level:3,title:"4.1.8 for..in",slug:"_4-1-8-for-in",normalizedTitle:"4.1.8 for..in",charIndex:2125},{level:2,title:"4.2 对象引用和复制",slug:"_4-2-对象引用和复制",normalizedTitle:"4.2 对象引用和复制",charIndex:2240},{level:3,title:"4.2.1 对象通过引用比较",slug:"_4-2-1-对象通过引用比较",normalizedTitle:"4.2.1 对象通过引用比较",charIndex:2410},{level:3,title:"4.2.2 Object.assign,克隆与合并",slug:"_4-2-2-object-assign-克隆与合并",normalizedTitle:"4.2.2 object.assign,克隆与合并",charIndex:2621},{level:3,title:"4.2.3 深层克隆",slug:"_4-2-3-深层克隆",normalizedTitle:"4.2.3 深层克隆",charIndex:3725},{level:2,title:"4.3 垃圾回收",slug:"_4-3-垃圾回收",normalizedTitle:"4.3 垃圾回收",charIndex:4402},{level:3,title:"4.3.1 可达性（Reachability）",slug:"_4-3-1-可达性-reachability",normalizedTitle:"4.3.1 可达性（reachability）",charIndex:4449},{level:3,title:"4.3.2  简单的例子",slug:"_4-3-2-简单的例子",normalizedTitle:"4.3.2  简单的例子",charIndex:null},{level:3,title:"4.3.3 两个引用",slug:"_4-3-3-两个引用",normalizedTitle:"4.3.3 两个引用",charIndex:5002},{level:3,title:"4.3.4 相互关联的对象",slug:"_4-3-4-相互关联的对象",normalizedTitle:"4.3.4 相互关联的对象",charIndex:5198},{level:3,title:"4.3.5 无法到达的岛屿",slug:"_4-3-5-无法到达的岛屿",normalizedTitle:"4.3.5 无法到达的岛屿",charIndex:5636},{level:3,title:"4.3.6 垃圾回收内部算法",slug:"_4-3-6-垃圾回收内部算法",normalizedTitle:"4.3.6 垃圾回收内部算法",charIndex:5724},{level:2,title:"4.4 对象方法，this",slug:"_4-4-对象方法-this",normalizedTitle:"4.4 对象方法，this",charIndex:6364},{level:3,title:"4.4.1 对象方法示例",slug:"_4-4-1-对象方法示例",normalizedTitle:"4.4.1 对象方法示例",charIndex:6419},{level:4,title:"方法简写",slug:"方法简写",normalizedTitle:"方法简写",charIndex:6804},{level:3,title:"4.4.2 方法中的this",slug:"_4-4-2-方法中的this",normalizedTitle:"4.4.2 方法中的this",charIndex:7026},{level:3,title:'4.4.3 "this" 不受限制',slug:"_4-4-3-this-不受限制",normalizedTitle:"4.4.3 &quot;this&quot; 不受限制",charIndex:null},{level:3,title:'4.4.4 箭头函数没有自己的 "this"',slug:"_4-4-4-箭头函数没有自己的-this",normalizedTitle:"4.4.4 箭头函数没有自己的 &quot;this&quot;",charIndex:null},{level:2,title:"4.5 构造器与new",slug:"_4-5-构造器与new",normalizedTitle:"4.5 构造器与new",charIndex:8658},{level:3,title:"4.5.1 构造函数",slug:"_4-5-1-构造函数",normalizedTitle:"4.5.1 构造函数",charIndex:8674},{level:3,title:"4.5.2 构造器模式测试：new.target",slug:"_4-5-2-构造器模式测试-new-target",normalizedTitle:"4.5.2 构造器模式测试：new.target",charIndex:9177},{level:3,title:"4.5.3 构造器的 return",slug:"_4-5-3-构造器的-return",normalizedTitle:"4.5.3 构造器的 return",charIndex:9687},{level:3,title:"4.5.4 构造器中的方法",slug:"_4-5-4-构造器中的方法",normalizedTitle:"4.5.4 构造器中的方法",charIndex:10247},{level:2,title:"4.6 可选链 ?.",slug:"_4-6-可选链",normalizedTitle:"4.6 可选链 ?.",charIndex:10575},{level:3,title:"4.6.1 可选链语法",slug:"_4-6-1-可选链语法",normalizedTitle:"4.6.1 可选链语法",charIndex:10635},{level:3,title:"4.6.2 短路效应",slug:"_4-6-2-短路效应",normalizedTitle:"4.6.2 短路效应",charIndex:11018},{level:3,title:"4.6.3 其它变体：?.()，?.[]",slug:"_4-6-3-其它变体",normalizedTitle:"4.6.3 其它变体：?.()，?.[]",charIndex:11221},{level:2,title:"4.7 symbol 类型",slug:"_4-7-symbol-类型",normalizedTitle:"4.7 symbol 类型",charIndex:11691},{level:3,title:"4.7.1 symbol",slug:"_4-7-1-symbol",normalizedTitle:"4.7.1 symbol",charIndex:11757},{level:3,title:"4.7.2 “隐藏”属性",slug:"_4-7-2-隐藏-属性",normalizedTitle:"4.7.2 “隐藏”属性",charIndex:12533},{level:4,title:"对象字面量中的 symbol",slug:"对象字面量中的-symbol",normalizedTitle:"对象字面量中的 symbol",charIndex:12737},{level:4,title:"symbol 在 for..in 中会被跳过",slug:"symbol-在-for-in-中会被跳过",normalizedTitle:"symbol 在 for..in 中会被跳过",charIndex:12937},{level:3,title:"4.7.3 全局 symbol",slug:"_4-7-3-全局-symbol",normalizedTitle:"4.7.3 全局 symbol",charIndex:13281},{level:4,title:"Symbol.keyFor",slug:"symbol-keyfor",normalizedTitle:"symbol.keyfor",charIndex:13707},{level:3,title:"4.7.4 系统 symbol",slug:"_4-7-4-系统-symbol",normalizedTitle:"4.7.4 系统 symbol",charIndex:14121},{level:2,title:"4.8 对象 — 原始值转换",slug:"_4-8-对象-原始值转换",normalizedTitle:"4.8 对象 — 原始值转换",charIndex:14302},{level:3,title:"4.8.1 转换规则",slug:"_4-8-1-转换规则",normalizedTitle:"4.8.1 转换规则",charIndex:14434},{level:3,title:"4.8.2 hint",slug:"_4-8-2-hint",normalizedTitle:"4.8.2 hint",charIndex:14651},{level:3,title:"4.8.3 Symbol.toPrimitive",slug:"_4-8-3-symbol-toprimitive",normalizedTitle:"4.8.3 symbol.toprimitive",charIndex:15706},{level:3,title:"4.8.4 toString/valueOf",slug:"_4-8-4-tostring-valueof",normalizedTitle:"4.8.4 tostring/valueof",charIndex:16155},{level:4,title:"转换可以返回任何原始类型",slug:"转换可以返回任何原始类型",normalizedTitle:"转换可以返回任何原始类型",charIndex:16512}],headersStr:'4.1 对象基础 4.1.1 创建对象 4.1.2 键值对 点符号访问属性值 delete 操作符移除属性 多词属性 4.1.3 [] 多词属性 变量 key由表达式得到 4.1.4 计算属性 4.1.5 属性值简写 4.1.6 属性名称限制 4.1.7  属性存在性测试，"in" 操作符 4.1.8 for..in 4.2 对象引用和复制 4.2.1 对象通过引用比较 4.2.2 Object.assign,克隆与合并 4.2.3 深层克隆 4.3 垃圾回收 4.3.1 可达性（Reachability） 4.3.2  简单的例子 4.3.3 两个引用 4.3.4 相互关联的对象 4.3.5 无法到达的岛屿 4.3.6 垃圾回收内部算法 4.4 对象方法，this 4.4.1 对象方法示例 方法简写 4.4.2 方法中的this 4.4.3 "this" 不受限制 4.4.4 箭头函数没有自己的 "this" 4.5 构造器与new 4.5.1 构造函数 4.5.2 构造器模式测试：new.target 4.5.3 构造器的 return 4.5.4 构造器中的方法 4.6 可选链 ?. 4.6.1 可选链语法 4.6.2 短路效应 4.6.3 其它变体：?.()，?.[] 4.7 symbol 类型 4.7.1 symbol 4.7.2 “隐藏”属性 对象字面量中的 symbol symbol 在 for..in 中会被跳过 4.7.3 全局 symbol Symbol.keyFor 4.7.4 系统 symbol 4.8 对象 — 原始值转换 4.8.1 转换规则 4.8.2 hint 4.8.3 Symbol.toPrimitive 4.8.4 toString/valueOf 转换可以返回任何原始类型',content:'# 4.1 对象基础\n\n\n# 4.1.1 创建对象\n\n我们可以用下面两种语法，构造函数或字面量中的任一种来创建一个空的对象\n\nlet user = new Object(); // “构造函数” 的语法\nlet user = {};  // “字面量” 的语法\n\n\n1\n2\n\n\n\n# 4.1.2 键值对\n\n我们可以在创建对象的时候，立即将一些属性以键值对的形式放到 {...} 中\n\nlet user = {     // 一个对象\n  name: "John",  // 键 "name"，值 "John"\n  age: 30        // 键 "age"，值 30\n};\n\n\n1\n2\n3\n4\n\n\n属性有键（或者也可以叫做“名字”或“标识符”），位于冒号 ":" 的前面，值在冒号的右边\n可以随时添加、删除和读取属性值\n\n# 点符号访问属性值\n\n// 读取文件的属性：\nalert( user.name ); // John\nalert( user.age ); // 30\n\n\n1\n2\n3\n\n\n# delete 操作符移除属性\n\ndelete user.age;\n\n\n1\n\n\n# 多词属性\n\n多字词语来作为属性名，但必须给它们加上引号\n\nlet user = {\n  name: "John",\n  age: 30,\n  "likes birds": true  // 多词属性名必须加引号\n};\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.1.3 []\n\n# 多词属性\n\n多词属性，点操作就不能用\n\n// 这将提示有语法错误\nuser.likes birds = true\n\n\n1\n2\n\n\n点符号要求 key 是有效的变量标识符。这意味着：不包含空格，不以数字开头，也不包含特殊字符（允许使用 $ 和 _）\n\nlet user = {};\n// 设置\nuser["likes birds"] = true;\n// 读取\nalert(user["likes birds"]); // true\n// 删除\ndelete user["likes birds"];\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n请注意方括号中的字符串要放在引号中，单引号或双引号都可以\n\n# 变量 key由表达式得到\n\nlet user = {\n  name: "John",\n  age: 30\n};\nlet key = prompt("What do you want to know about the user?", "name");\n// 访问变量\nalert( user[key] ); // John（如果输入 "name"）\nlet key = "name";\nalert( user.key ) // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4.1.4 计算属性\n\n当创建一个对象时，我们可以在对象字面量中使用方括号。这叫做 计算属性\n\n\n\n\n\n \n\n\n\nlet fruit = prompt("Which fruit to buy?", "apple");\nlet bag = {\n  [fruit]: 5, // 属性名是从 fruit 变量中得到的\n};\nalert( bag.apple ); // 5 如果 fruit="apple"\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.1.5 属性值简写\n\n属性名跟变量名一样。这种通过变量生成属性的应用场景很常见，在这有一种特殊的 属性值缩写 方法，使属性名变得更短\n\n\n\n\n \n \n\n\n\n\n\nfunction makeUser(name, age) {\n  return {\n    name, // 与 name: name 相同\n    age,  // 与 age: age 相同\n    // ...\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4.1.6 属性名称限制\n\n变量名不能是编程语言的某个保留字，如 "for"、"let"、"return" 等，但对象的属性名并不受此限制\n属性名可以是任何字符串或者 symbol。\n其他类型会被自动地转换为字符串\n\n\n# 4.1.7 属性存在性测试，"in" 操作符\n\nJavaScript 的对象有一个需要注意的特性：能够被访问任何属性。即使属性不存在也不会报错！\n读取不存在的属性只会得到 undefined\n检查属性是否存在的操作符 "in"\n\n"key" in object\n\n\n1\n\n\n注意\n\n请注意，in 的左边必须是 属性名。通常是一个带引号的字符串\n如果我们省略引号，就意味着左边是一个变量，它应该包含要判断的实际属性名\n\n属性存在，但存储的值是 undefined 的时候，使用undefined判断属性存在与否会有问题：\n\nlet obj = {\n  test: undefined\n};\nalert( obj.test ); // 显示 undefined，所以属性不存在？\nalert( "test" in obj ); // true，属性存在！\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.1.8 for..in\n\n为了遍历一个对象的所有键（key），可以使用一个特殊形式的循环：for..in\n\nfor (key in object) {\n  // 对此对象属性中的每个键执行的代码\n}\n\n\n1\n2\n3\n\n\n\n# 4.2 对象引用和复制\n\n对象与原始类型的根本区别之一是，对象是“通过引用”存储和复制的，而原始类型：字符串、数字、布尔值等 —— 总是“作为一个整体”复制\n赋值了对象的变量存储的不是对象本身，而是该对象“在内存中的地址” —— 换句话说就是对该对象的“引用”。\n当一个对象变量被复制 —— 引用被复制，而该对象自身并没有被复制。\n\n\n# 4.2.1 对象通过引用比较\n\n仅当两个对象为同一对象时，两者才相等\n\nlet a = {};\nlet b = a; // 复制引用\nalert( a == b ); // true，都引用同一对象\nalert( a === b ); // true\n\nlet c = {};\nlet d = {}; // 两个独立的对象\nalert( c == d ); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 4.2.2 Object.assign,克隆与合并\n\n拷贝一个对象变量会又创建一个对相同对象的引用\n要复制一个对象需要创建一个新对象，并通过遍历现有属性的结构，在原始类型值的层面，将其复制到新对象，以复制已有对象的结构\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n\n\nlet user = {\n  name: "John",\n  age: 30\n};\nlet clone = {}; // 新的空对象\n// 将 user 中所有的属性拷贝到其中\nfor (let key in user) {\n  clone[key] = user[key];\n}\n// 现在 clone 是带有相同内容的完全独立的对象\nclone.name = "Pete"; // 改变了其中的数据\nalert( user.name ); // 原来的对象中的 name 属性依然是 John\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n我们也可以使用 Object.assign 方法来达成同样的效果\n\nObject.assign(dest, [src1, src2, src3...])\n\n\n1\n\n * 第一个参数 dest 是指目标对象。\n * 更后面的参数 src1, ..., srcN（可按需传递多个参数）是源对象。\n * 该方法将所有源对象的属性拷贝到目标对象 dest 中。换句话说，从第二个开始的所有参数的属性都被拷贝到第一个参数的对象中。\n * 调用结果返回 dest。\n\n我们可以用它来合并多个对象：\n\n\n\n\n\n \n \n\n\n\nlet user = { name: "John" };\nlet permissions1 = { canView: true };\nlet permissions2 = { canEdit: true };\n// 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中\nObject.assign(user, permissions1, permissions2);\n// 现在 user = { name: "John", canView: true, canEdit: true }\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果被拷贝的属性的属性名已经存在，那么它会被覆盖：\n\nlet user = { name: "John" };\nObject.assign(user, { name: "Pete" });\nalert(user.name); // 现在 user = { name: "Pete" }\n\n\n1\n2\n3\n\n\n\n# 4.2.3 深层克隆\n\n如果对象中的属性存在对象，那么该属性会被以引用形式拷贝\n\nlet user = {\n  name: "John",\n  sizes: {\n    height: 182,\n    width: 50\n  }\n};\nlet clone = Object.assign({}, user);\nalert( user.sizes === clone.sizes ); // true，同一个对象\n// user 和 clone 分享同一个 sizes\nuser.sizes.width++;       // 通过其中一个改变属性值\nalert(clone.sizes.width); // 51，能从另外一个看到变更的结果\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n为了解决这个问题，我们应该使用一个拷贝循环来检查 user[key] 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的深拷贝。\n\nconst 声明的对象是可以被修改的\n\n通过引用对对象进行存储的一个重要的副作用是声明为 const 的对象 可以 被修改。\n例如：\n\nconst user = {\n  name: "John"\n};\n*!*\nuser.name = "Pete"; // (*)\n*/!*\nalert(user.name); // Pete\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n看起来 (*) 行的代码会触发一个错误，但实际并没有。user 的值是一个常量，它必须始终引用同一个对象，但该对象的属性可以被自由修改\n\n\n# 4.3 垃圾回收\n\n对于开发者来说，JavaScript 的内存管理是自动的、无形的\n\n\n# 4.3.1 可达性（Reachability）\n\nJavaScript 中主要的内存管理概念是 可达性 “可达”值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的\n\n 1. 这里列出固有的可达值的基本集合，这些值明显不能被释放。\n    \n    比方说：\n    \n    * 当前执行的函数，它的局部变量和参数。\n    * 当前嵌套调用链上的其他函数、它们的局部变量和参数。\n    * 全局变量。\n    * （还有一些内部的）\n    \n    这些值被称作 根（roots）。\n\n 2. 如果一个值可以通过引用链从根访问任何其他值，则认为该值是可达的\n\n\n# 4.3.2 简单的例子\n\n// user 具有对这个对象的引用\nlet user = {\n  name: "John"\n};\nuser = null;\n\n\n1\n2\n3\n4\n5\n\n\n全局变量 "user" 引用了对象 {name："John"}（为简洁起见，我们称它为 John）。John 的 "name" 属性存储一个原始值，所以它被写在对象内部。\n如果 user 的值被重写了，这个引用就没了。John 变成不可达的了。因为没有引用了，就不能访问到它了。垃圾回收器会认为它是垃圾数据并进行回收，然后释放内存。\n\n\n\n# 4.3.3 两个引用\n\n我们把 user 的引用复制给 admin：\n\n// user 具有对这个对象的引用\nlet user = {\n  name: "John"\n};\nlet admin = user;\nuser = null;\n\n\n1\n2\n3\n4\n5\n6\n\n\n对象仍然可以被通过 admin 这个全局变量访问到，所以对象还在内存中。如果我们又重写了 admin，对象就会被删除\n\n\n# 4.3.4 相互关联的对象\n\nfunction marry(man, woman) {\n  woman.husband = man;\n  man.wife = woman;\n  return {\n    father: man,\n    mother: woman\n  }\n}\nlet family = marry({\n  name: "John"\n}, {\n  name: "Ann"\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nmarry 函数通过让两个对象相互引用使它们“结婚”了，并返回了一个包含这两个对象的新对象。\n由此产生的内存结构\n现在让我们移除两个引用：\n\ndelete family.father;\ndelete family.mother.husband;\n\n\n1\n2\n\n\n对外引用不重要，只有传入引用才可以使对象可达。所以，John 现在是不可达的，并且将被从内存中删除，同时 John 的所有数据也将变得不可达\n\n\n# 4.3.5 无法到达的岛屿\n\n几个对象相互引用，但外部没有对其任意对象的引用，这些对象也可能是不可达的，并被从内存中删除\n\nfamily = null;\n\n\n1\n\n\n\n\n\n# 4.3.6 垃圾回收内部算法\n\n垃圾回收的基本算法被称为 "mark-and-sweep"。\n\n定期执行以下“垃圾回收”步骤：\n\n * 垃圾收集器找到所有的根，并“标记”（记住）它们。\n * 然后它遍历并“标记”来自它们的所有引用。\n * 然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。\n * ……如此操作，直到所有可达的（从根部）引用都被访问到。\n * 没有被标记的对象都会被删除。\n\n这是垃圾收集工作的概念。JavaScript 引擎做了许多优化，使垃圾回收运行速度更快，并且不影响正常代码运行。\n\n一些优化建议：\n\n * 分代收集（Generational collection）—— 对象被分成两组：“新的”和“旧的”。许多对象出现，完成它们的工作并很快死去，它们可以很快被清理。那些长期存活的对象会变得“老旧”，而且被检查的频次也会减少。\n * 增量收集（Incremental collection）—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。所以引擎试图将垃圾收集工作分成几部分来做。然后将这几部分会逐一进行处理。这需要它们之间有额外的标记来追踪变化，但是这样会有许多微小的延迟而不是一个大的延迟。\n * 闲时收集（Idle-time collection）—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。\n\n\n# 4.4 对象方法，this\n\n在 JavaScript 中，行为（action）由属性中的函数来表示\n\n\n# 4.4.1 对象方法示例\n\n作为对象属性的函数被称为 方法\n\nlet user = {\n  name: "John",\n  age: 30\n};\nuser.sayHi = function() {\n  alert("Hello!");\n};\nuser.sayHi(); // Hello!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用函数表达式创建了一个函数，并将其指定给对象的 user.sayHi 属性 也可以使用预先声明的函数作为方法\n\nlet user = {\n  // ...\n};\n// 首先，声明函数\nfunction sayHi() {\n  alert("Hello!");\n}\n// 然后将其作为一个方法添加\nuser.sayHi = sayHi;\nuser.sayHi(); // Hello!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 方法简写\n\n在对象字面量中，有一种更短的（声明）方法的语法\n\nuser = {\n  sayHi: function() {\n    alert("Hello");\n  }\n};\n// 方法简写看起来更好，对吧？\nlet user = {\n  sayHi() { // 与 "sayHi: function(){...}" 一样\n    alert("Hello");\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 4.4.2 方法中的this\n\n为了访问该对象，方法中可以使用 this 关键字。 this 的值就是在点之前的这个对象，即调用该方法的对象\n\nlet user = {\n  name: "John",\n  age: 30,\n  sayHi() {\n    // "this" 指的是“当前的对象”\n    alert(this.name);\n  }\n};\nuser.sayHi(); // John\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n技术上讲，也可以在不使用 this 的情况下，通过外部变量名来引用它。但这样的代码是不可靠的\n\nlet user = {\n  name: "John",\n  age: 30,\n  sayHi() {\n    alert( user.name ); // 导致错误\n  }\n};\nlet admin = user;\nuser = null; // 重写让其更明显\nadmin.sayHi(); // TypeError: Cannot read property \'name\' of null\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 4.4.3 "this" 不受限制\n\nJavaScript 中的 this 可以用于任何函数，即使它不是对象的方法 this 的值是在代码运行时计算出来的，它取决于代码上下文。\n\n例如，这里相同的函数被分配给两个不同的对象，在调用中有着不同的 "this" 值：\n\nlet user = { name: "John" };\nlet admin = { name: "Admin" };\nfunction sayHi() {\n  alert( this.name );\n}\n// 在两个对象中使用相同的函数\nuser.f = sayHi;\nadmin.f = sayHi;\n// 这两个调用有不同的 this 值\n// 函数内部的 "this" 是“点符号前面”的那个对象\nuser.f(); // John（this == user）\nadmin.f(); // Admin（this == admin）\nadmin[\'f\'](); // Admin（使用点符号或方括号语法来访问这个方法，都没有关系。）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果 obj.f() 被调用了，则 this 在 f 函数调用期间是 obj。所以在上面的例子中 this 先是 user，之后是 admin\n\n在没有对象的情况下调用：`this == undefined`\n\nfunction sayHi() {\n  alert(this);\n}\nsayHi(); // undefined\n\n\n1\n2\n3\n4\n\n\n在这种情况下，严格模式下的 this 值为 undefined。如果我们尝试访问 this.name，将会报错。 在非严格模式的情况下，this 将会是 全局对象（浏览器中的 window）。这是一个历史行为，"use strict" 已经将其修复了\n\n\n# 4.4.4 箭头函数没有自己的 "this"\n\n箭头函数有些特别：它们没有自己的 this。如果我们在这样的函数中引用 this，this 值取决于外部“正常的”函数。\n\n举个例子，这里的 arrow() 使用的 this 来自于外部的 user.sayHi() 方法：\n\nlet user = {\n  firstName: "Ilya",\n  sayHi() {\n    let arrow = () => alert(this.firstName);\n    arrow();\n  }\n};\nuser.sayHi(); // Ilya\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这是箭头函数的一个特性，当我们并不想要一个独立的 this，反而想从外部上下文中获取时，它很有用\n\n\n# 4.5 构造器与new\n\n\n# 4.5.1 构造函数\n\n构造函数在技术上是常规函数。不过有两个约定：\n\n 1. 它们的命名以大写字母开头。\n 2. 它们只能由 "new" 操作符来执行\n\nfunction User(name) {\n  this.name = name;\n  this.isAdmin = false;\n}\nlet user = new User("Jack");\nalert(user.name); // Jack\nalert(user.isAdmin); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当一个函数被使用 new 操作符执行时，它按照以下步骤：\n\n 1. 一个新的空对象被创建并分配给 this。\n 2. 函数体执行。通常它会修改 this，为其添加新的属性。\n 3. 返回 this 的值\n\nfunction User(name) {\n  // this = {};（隐式创建）\n  // 添加属性到 this\n  this.name = name;\n  this.isAdmin = false;\n  // return this;（隐式返回）\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4.5.2 构造器模式测试：new.target\n\n在一个函数内部，我们可以使用 new.target 属性来检查它是否被使用 new 进行调用了。\n\n对于常规调用，它为 undefined，对于使用 new 的调用，则等于该函数：\n\nfunction User() {\n  alert(new.target);\n}\n// 不带 "new"：\nUser(); // undefined\n// 带 "new"：\nnew User(); // function User { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n我们也可以让 new 调用和常规调用做相同的工作，像这样：\n\nfunction User(name) {\n  if (!new.target) { // 如果你没有通过 new 运行我\n    return new User(name); // ……我会给你添加 new\n  }\n  this.name = name;\n}\nlet john = User("John"); // 将调用重定向到新用户\nalert(john.name); // John\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 4.5.3 构造器的 return\n\n通常，构造器没有 return 语句。它们的任务是将所有必要的东西写入 this，并自动转换为结果。\n\n但是，如果这有一个 return 语句，那么规则就简单了：\n\n * 如果 return 返回的是一个对象，则返回这个对象，而不是 this。\n * 如果 return 返回的是一个原始类型，则忽略\n\nfunction BigUser() {\n  this.name = "John";\n  return { name: "Godzilla" };  // <-- 返回这个对象\n}\nalert( new BigUser().name );  // Godzilla，得到了那个对象\n\nfunction SmallUser() {\n  this.name = "John";\n  return; // <-- 返回 this\n}\nalert( new SmallUser().name );  // John\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n省略括号\n\n如果没有参数，我们可以省略 new 后的括号：\n\nlet user = new User; // <-- 没有参数\n// 等同于\nlet user = new User();\n\n\n1\n2\n3\n\n\n\n# 4.5.4 构造器中的方法\n\n我们不仅可以将属性添加到 this 中，还可以添加方法\n\nfunction User(name) {\n  this.name = name;\n  this.sayHi = function() {\n    alert( "My name is: " + this.name );\n  };\n}\nlet john = new User("John");\njohn.sayHi(); // My name is: John\n/*\njohn = {\n   name: "John",\n   sayHi: function() { ... }\n}\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 4.6 可选链 ?.\n\n可选链 ?. 是一种访问嵌套对象属性的安全的方式。即使中间的属性不存在，也不会出现错误\n\n\n# 4.6.1 可选链语法\n\n如果可选链 ?. 前面的值为 undefined 或者 null，它会停止运算并返回 undefined 例如 value?.prop：\n\n * 如果 value 存在，则结果与 value.prop 相同，\n * 否则（当 value 为 undefined/null 时）则返回 undefined\n\n请注意：?. 语法使其前面的值成为可选值，但不会对其后面的起作用\n\n`?.` 前的变量必须已声明\n\n如果未声明变量 user，那么 user?.anything 会触发一个错误：\n\n// ReferenceError: user is not defined\nuser?.address;\n\n\n1\n2\n\n\n?. 前的变量必须已声明（例如 let/const/var user 或作为一个函数参数）。可选链仅适用于已声明的变量\n\n\n# 4.6.2 短路效应\n\n如果 ?. 左边部分不存在，就会立即停止运算（“短路效应”）。\n\n因此，如果在 ?. 的右侧有任何进一步的函数调用或操作，它们均不会执行。\n\nlet user = null;\nlet x = 0;\nuser?.sayHi(x++); // 没有 "user"，因此代码执行没有到达 sayHi 调用和 x++\nalert(x); // 0，值没有增加\n\n\n1\n2\n3\n4\n\n\n\n# 4.6.3 其它变体：?.()，?.[]\n\n可选链 ?. 不是一个运算符，而是一个特殊的语法结构。它还可以与函数和方括号一起使用\n\nlet userAdmin = {\n  admin() {\n    alert("I am admin");\n  }\n};\nlet userGuest = {};\nuserAdmin.admin?.(); // I am admin\nuserGuest.admin?.(); // 啥都没发生（没有这样的方法）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n此外，我们还可以将 ?. 跟 delete 一起使用：\n\ndelete user?.name; // 如果 user 存在，则删除 user.name\n\n\n1\n\n\n我们可以使用 `?.` 来安全地读取或删除，但不能写入\n\n可选链 ?. 不能用在赋值语句的左侧。\n\nlet user = null;\nuser?.name = "John"; // Error，不起作用\n// 因为它在计算的是：undefined = "John"\n\n\n1\n2\n3\n\n\n\n# 4.7 symbol 类型\n\n根据规范，只有两种原始类型可以用作对象属性键：\n\n * 字符串类型\n * symbol 类型\n\n\n# 4.7.1 symbol\n\n"symbol" 值表示唯一的标识符。\n\n可以使用 Symbol() 来创建这种类型的值：\n\nlet id = Symbol();\n\n\n1\n\n\n创建时，我们可以给 symbol 一个描述（也称为 symbol 名），这在代码调试时非常有用：\n\n// id 是描述为 "id" 的 symbol\nlet id = Symbol("id");\n\n\n1\n2\n\n\nsymbol 保证是唯一的。即使我们创建了许多具有相同描述的 symbol，它们的值也是不同。描述只是一个标签，不影响任何东西 两个描述相同的 symbol —— 它们不相等：\n\nlet id1 = Symbol("id");\nlet id2 = Symbol("id");\nalert(id1 == id2); // false\n\n\n1\n2\n3\n\n\nsymbol 不会被自动转换为字符串\n\nJavaScript 中的大多数值都支持字符串的隐式转换\n\nlet id = Symbol("id");\nalert(id); // 类型错误：无法将 symbol 值转换为字符串。\n\n\n1\n2\n\n\n这是一种防止混乱的“语言保护”，因为字符串和 symbol 有本质上的不同，不应该意外地将它们转换成另一个 如果我们真的想显示一个 symbol，我们需要在它上面调用 .toString()，如下所示：\n\nlet id = Symbol("id");\nalert(id.toString()); // Symbol(id)，现在它有效了\n\n\n1\n2\n\n\n或者获取 symbol.description 属性，只显示描述（description）：\n\nlet id = Symbol("id");\nalert(id.description); // id\n\n\n1\n2\n\n\n\n# 4.7.2 “隐藏”属性\n\nsymbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性\n\nlet user = { // 属于另一个代码\n  name: "John"\n};\nlet id = Symbol("id");\nuser[id] = 1;\nalert( user[id] ); // 我们可以使用 symbol 作为键来访问数据\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 对象字面量中的 symbol\n\n如果我们要在对象字面量 {...} 中使用 symbol，则需要使用方括号把它括起来。\n\n就像这样：\n\nlet id = Symbol("id");\nlet user = {\n  name: "John",\n  [id]: 123 // 而不是 "id"：123\n};\n\n\n1\n2\n3\n4\n5\n\n\n这是因为我们需要变量 id 的值作为键，而不是字符串 "id"\n\n# symbol 在 for..in 中会被跳过\n\nsymbol 属性不参与 for..in 循环\n\nlet id = Symbol("id");\nlet user = {\n  name: "John",\n  age: 30,\n  [id]: 123\n};\nfor (let key in user) alert(key); // name, age（没有 symbol）\n// 使用 symbol 任务直接访问\nalert( "Direct: " + user[id] );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nObject.keys(user) 也会忽略它们。这是一般“隐藏符号属性”原则的一部分 相反，Object.assign 会同时复制字符串和 symbol 属性\n\n\n# 4.7.3 全局 symbol\n\n有一个 全局 symbol 注册表。我们可以在其中创建 symbol 并在稍后访问它们，它可以确保每次访问相同名字的 symbol 时，返回的都是相同的 symbol 要从注册表中读取（不存在则创建）symbol，请使用 Symbol.for(key)。\n\n该调用会检查全局注册表，如果有一个描述为 key 的 symbol，则返回该 symbol，否则将创建一个新 symbol（Symbol(key)），并通过给定的 key 将其存储在注册表中\n\n// 从全局注册表中读取\nlet id = Symbol.for("id"); // 如果该 symbol 不存在，则创建它\n// 再次读取（可能是在代码中的另一个位置）\nlet idAgain = Symbol.for("id");\n// 相同的 symbol\nalert( id === idAgain ); // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n# Symbol.keyFor\n\n对于全局 symbol，不仅有 Symbol.for(key) 按名字返回一个 symbol，还有一个反向调用：Symbol.keyFor(sym)，它的作用完全反过来：通过全局 symbol 返回一个名字\n\n// 通过 name 获取 symbol\nlet sym = Symbol.for("name");\nlet sym2 = Symbol.for("id");\n// 通过 symbol 获取 name\nalert( Symbol.keyFor(sym) ); // name\nalert( Symbol.keyFor(sym2) ); // id\n\n\n1\n2\n3\n4\n5\n6\n\n\nSymbol.keyFor 内部使用全局 symbol 注册表来查找 symbol 的键。所以它不适用于非全局 symbol。如果 symbol 不是全局的，它将无法找到它并返回 undefined\n\n\n# 4.7.4 系统 symbol\n\nJavaScript 内部有很多“系统” symbol，我们可以使用它们来微调对象的各个方面 众所周知的 symbol 表的规范中：\n\n * Symbol.hasInstance\n * Symbol.isConcatSpreadable\n * Symbol.iterator\n * Symbol.toPrimitive\n\n\n# 4.8 对象 — 原始值转换\n\n当对象相加 obj1 + obj2，相减 obj1 - obj2，或者使用 alert(obj) 打印时会发生什么？ 在此类运算的情况下，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果（也是一个原始值）\n\n\n# 4.8.1 转换规则\n\n 1. 没有转换为布尔值。所有的对象在布尔上下文（context）中均为 true，就这么简单。只有字符串和数字转换。\n 2. 数字转换发生在对象相减或应用数学函数时。例如，Date 对象（将在 info:date 一章中介绍）可以相减，date1 - date2 的结果是两个日期之间的差值。\n 3. 至于字符串转换 —— 通常发生在我们像 alert(obj) 这样输出一个对象和类似的上下文中。\n\n\n# 4.8.2 hint\n\n类型转换在各种情况下有三种变体。它们被称为 "hint"\n\n"string" : 对象到字符串的转换，当我们对期望一个字符串的对象执行操作时，如 "alert"：\n\n```js\n// 输出\nalert(obj);\n// 将对象作为属性键\nanotherObj[obj] = 123;\n```\n\n\n"number" : 对象到数字的转换，例如当我们进行数学运算时：\n\n```js\n// 显式转换\nlet num = Number(obj);\n// 数学运算（除了二元加法）\nlet n = +obj; // 一元加法\nlet delta = date1 - date2;\n// 小于/大于的比较\nlet greater = user1 > user2;\n```\n\n大多数内建的数学函数也包括这种转换。\n\n\n"default" : 在少数情况下发生，当运算符“不确定”期望值的类型时。\n\n例如，二元加法 `+` 可用于字符串（连接），也可以用于数字（相加）。因此，当二元加法得到对象类型的参数时，它将依据 `"default"` hint 来对其进行转换。\n\n此外，如果对象被用于与字符串、数字或 symbol 进行 `==` 比较，这时到底应该进行哪种转换也不是很明确，因此使用 `"default"` hint。\n\n```js\n// 二元加法使用默认 hint\nlet total = obj1 + obj2;\n// obj == number 使用默认 hint\nif (user == 1) { ... };\n```\n\n像 `<` 和 `>` 这样的小于/大于比较运算符，也可以同时用于字符串和数字。不过，它们使用 "number" hint，而不是 "default"。这是历史原因。  \n\n\n为了进行转换，JavaScript 尝试查找并调用三个对象方法：\n\n 1. 调用 obj[Symbol.toPrimitive](hint) —— 带有 symbol 键 Symbol.toPrimitive（系统 symbol）的方法，如果这个方法存在的话，\n 2. 否则，如果 hint 是 "string" —— 尝试调用 obj.toString() 或 obj.valueOf()，无论哪个存在。\n 3. 否则，如果 hint 是 "number" 或 "default" —— 尝试调用 obj.valueOf() 或 obj.toString()，无论哪个存在。\n\n\n# 4.8.3 Symbol.toPrimitive\n\n如果 Symbol.toPrimitive 方法存在，则它会被用于所有 hint，无需更多其他方法。\n\n例如，这里 user 对象实现了它：\n\nlet user = {\n  name: "John",\n  money: 1000,\n  [Symbol.toPrimitive](hint) {\n    alert(`hint: ${hint}`);\n    return hint == "string" ? `{name: "${this.name}"}` : this.money;\n  }\n};\n// 转换演示：\nalert(user); // hint: string -> {name: "John"}\nalert(+user); // hint: number -> 1000\nalert(user + 500); // hint: default -> 1500\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 4.8.4 toString/valueOf\n\n如果没有 Symbol.toPrimitive，那么 JavaScript 将尝试寻找 toString 和 valueOf 方法：\n\n * 对于 "string" hint：调用 toString 方法，如果它不存在，则调用 valueOf 方法（因此，对于字符串转换，优先调用 toString）。\n * 对于其他 hint：调用 valueOf 方法，如果它不存在，则调用 toString 方法（因此，对于数学运算，优先调用 valueOf 方法）。\n\n默认情况下，普通对象具有 toString 和 valueOf 方法：\n\n * toString 方法返回一个字符串 "[object Object]"。\n * valueOf 方法返回对象自身。\n\n# 转换可以返回任何原始类型\n\n关于所有原始转换方法，有一个重要的点需要知道，就是它们不一定会返回 "hint" 的原始值。\n\n没有限制 toString() 是否返回字符串，或 Symbol.toPrimitive 方法是否为 "number" hint 返回数字。\n\n唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象',normalizedContent:'# 4.1 对象基础\n\n\n# 4.1.1 创建对象\n\n我们可以用下面两种语法，构造函数或字面量中的任一种来创建一个空的对象\n\nlet user = new object(); // “构造函数” 的语法\nlet user = {};  // “字面量” 的语法\n\n\n1\n2\n\n\n\n# 4.1.2 键值对\n\n我们可以在创建对象的时候，立即将一些属性以键值对的形式放到 {...} 中\n\nlet user = {     // 一个对象\n  name: "john",  // 键 "name"，值 "john"\n  age: 30        // 键 "age"，值 30\n};\n\n\n1\n2\n3\n4\n\n\n属性有键（或者也可以叫做“名字”或“标识符”），位于冒号 ":" 的前面，值在冒号的右边\n可以随时添加、删除和读取属性值\n\n# 点符号访问属性值\n\n// 读取文件的属性：\nalert( user.name ); // john\nalert( user.age ); // 30\n\n\n1\n2\n3\n\n\n# delete 操作符移除属性\n\ndelete user.age;\n\n\n1\n\n\n# 多词属性\n\n多字词语来作为属性名，但必须给它们加上引号\n\nlet user = {\n  name: "john",\n  age: 30,\n  "likes birds": true  // 多词属性名必须加引号\n};\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.1.3 []\n\n# 多词属性\n\n多词属性，点操作就不能用\n\n// 这将提示有语法错误\nuser.likes birds = true\n\n\n1\n2\n\n\n点符号要求 key 是有效的变量标识符。这意味着：不包含空格，不以数字开头，也不包含特殊字符（允许使用 $ 和 _）\n\nlet user = {};\n// 设置\nuser["likes birds"] = true;\n// 读取\nalert(user["likes birds"]); // true\n// 删除\ndelete user["likes birds"];\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n请注意方括号中的字符串要放在引号中，单引号或双引号都可以\n\n# 变量 key由表达式得到\n\nlet user = {\n  name: "john",\n  age: 30\n};\nlet key = prompt("what do you want to know about the user?", "name");\n// 访问变量\nalert( user[key] ); // john（如果输入 "name"）\nlet key = "name";\nalert( user.key ) // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4.1.4 计算属性\n\n当创建一个对象时，我们可以在对象字面量中使用方括号。这叫做 计算属性\n\n\n\n\n\n \n\n\n\nlet fruit = prompt("which fruit to buy?", "apple");\nlet bag = {\n  [fruit]: 5, // 属性名是从 fruit 变量中得到的\n};\nalert( bag.apple ); // 5 如果 fruit="apple"\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.1.5 属性值简写\n\n属性名跟变量名一样。这种通过变量生成属性的应用场景很常见，在这有一种特殊的 属性值缩写 方法，使属性名变得更短\n\n\n\n\n \n \n\n\n\n\n\nfunction makeuser(name, age) {\n  return {\n    name, // 与 name: name 相同\n    age,  // 与 age: age 相同\n    // ...\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4.1.6 属性名称限制\n\n变量名不能是编程语言的某个保留字，如 "for"、"let"、"return" 等，但对象的属性名并不受此限制\n属性名可以是任何字符串或者 symbol。\n其他类型会被自动地转换为字符串\n\n\n# 4.1.7 属性存在性测试，"in" 操作符\n\njavascript 的对象有一个需要注意的特性：能够被访问任何属性。即使属性不存在也不会报错！\n读取不存在的属性只会得到 undefined\n检查属性是否存在的操作符 "in"\n\n"key" in object\n\n\n1\n\n\n注意\n\n请注意，in 的左边必须是 属性名。通常是一个带引号的字符串\n如果我们省略引号，就意味着左边是一个变量，它应该包含要判断的实际属性名\n\n属性存在，但存储的值是 undefined 的时候，使用undefined判断属性存在与否会有问题：\n\nlet obj = {\n  test: undefined\n};\nalert( obj.test ); // 显示 undefined，所以属性不存在？\nalert( "test" in obj ); // true，属性存在！\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.1.8 for..in\n\n为了遍历一个对象的所有键（key），可以使用一个特殊形式的循环：for..in\n\nfor (key in object) {\n  // 对此对象属性中的每个键执行的代码\n}\n\n\n1\n2\n3\n\n\n\n# 4.2 对象引用和复制\n\n对象与原始类型的根本区别之一是，对象是“通过引用”存储和复制的，而原始类型：字符串、数字、布尔值等 —— 总是“作为一个整体”复制\n赋值了对象的变量存储的不是对象本身，而是该对象“在内存中的地址” —— 换句话说就是对该对象的“引用”。\n当一个对象变量被复制 —— 引用被复制，而该对象自身并没有被复制。\n\n\n# 4.2.1 对象通过引用比较\n\n仅当两个对象为同一对象时，两者才相等\n\nlet a = {};\nlet b = a; // 复制引用\nalert( a == b ); // true，都引用同一对象\nalert( a === b ); // true\n\nlet c = {};\nlet d = {}; // 两个独立的对象\nalert( c == d ); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 4.2.2 object.assign,克隆与合并\n\n拷贝一个对象变量会又创建一个对相同对象的引用\n要复制一个对象需要创建一个新对象，并通过遍历现有属性的结构，在原始类型值的层面，将其复制到新对象，以复制已有对象的结构\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n\n\nlet user = {\n  name: "john",\n  age: 30\n};\nlet clone = {}; // 新的空对象\n// 将 user 中所有的属性拷贝到其中\nfor (let key in user) {\n  clone[key] = user[key];\n}\n// 现在 clone 是带有相同内容的完全独立的对象\nclone.name = "pete"; // 改变了其中的数据\nalert( user.name ); // 原来的对象中的 name 属性依然是 john\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n我们也可以使用 object.assign 方法来达成同样的效果\n\nobject.assign(dest, [src1, src2, src3...])\n\n\n1\n\n * 第一个参数 dest 是指目标对象。\n * 更后面的参数 src1, ..., srcn（可按需传递多个参数）是源对象。\n * 该方法将所有源对象的属性拷贝到目标对象 dest 中。换句话说，从第二个开始的所有参数的属性都被拷贝到第一个参数的对象中。\n * 调用结果返回 dest。\n\n我们可以用它来合并多个对象：\n\n\n\n\n\n \n \n\n\n\nlet user = { name: "john" };\nlet permissions1 = { canview: true };\nlet permissions2 = { canedit: true };\n// 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中\nobject.assign(user, permissions1, permissions2);\n// 现在 user = { name: "john", canview: true, canedit: true }\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果被拷贝的属性的属性名已经存在，那么它会被覆盖：\n\nlet user = { name: "john" };\nobject.assign(user, { name: "pete" });\nalert(user.name); // 现在 user = { name: "pete" }\n\n\n1\n2\n3\n\n\n\n# 4.2.3 深层克隆\n\n如果对象中的属性存在对象，那么该属性会被以引用形式拷贝\n\nlet user = {\n  name: "john",\n  sizes: {\n    height: 182,\n    width: 50\n  }\n};\nlet clone = object.assign({}, user);\nalert( user.sizes === clone.sizes ); // true，同一个对象\n// user 和 clone 分享同一个 sizes\nuser.sizes.width++;       // 通过其中一个改变属性值\nalert(clone.sizes.width); // 51，能从另外一个看到变更的结果\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n为了解决这个问题，我们应该使用一个拷贝循环来检查 user[key] 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的深拷贝。\n\nconst 声明的对象是可以被修改的\n\n通过引用对对象进行存储的一个重要的副作用是声明为 const 的对象 可以 被修改。\n例如：\n\nconst user = {\n  name: "john"\n};\n*!*\nuser.name = "pete"; // (*)\n*/!*\nalert(user.name); // pete\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n看起来 (*) 行的代码会触发一个错误，但实际并没有。user 的值是一个常量，它必须始终引用同一个对象，但该对象的属性可以被自由修改\n\n\n# 4.3 垃圾回收\n\n对于开发者来说，javascript 的内存管理是自动的、无形的\n\n\n# 4.3.1 可达性（reachability）\n\njavascript 中主要的内存管理概念是 可达性 “可达”值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的\n\n 1. 这里列出固有的可达值的基本集合，这些值明显不能被释放。\n    \n    比方说：\n    \n    * 当前执行的函数，它的局部变量和参数。\n    * 当前嵌套调用链上的其他函数、它们的局部变量和参数。\n    * 全局变量。\n    * （还有一些内部的）\n    \n    这些值被称作 根（roots）。\n\n 2. 如果一个值可以通过引用链从根访问任何其他值，则认为该值是可达的\n\n\n# 4.3.2 简单的例子\n\n// user 具有对这个对象的引用\nlet user = {\n  name: "john"\n};\nuser = null;\n\n\n1\n2\n3\n4\n5\n\n\n全局变量 "user" 引用了对象 {name："john"}（为简洁起见，我们称它为 john）。john 的 "name" 属性存储一个原始值，所以它被写在对象内部。\n如果 user 的值被重写了，这个引用就没了。john 变成不可达的了。因为没有引用了，就不能访问到它了。垃圾回收器会认为它是垃圾数据并进行回收，然后释放内存。\n\n\n\n# 4.3.3 两个引用\n\n我们把 user 的引用复制给 admin：\n\n// user 具有对这个对象的引用\nlet user = {\n  name: "john"\n};\nlet admin = user;\nuser = null;\n\n\n1\n2\n3\n4\n5\n6\n\n\n对象仍然可以被通过 admin 这个全局变量访问到，所以对象还在内存中。如果我们又重写了 admin，对象就会被删除\n\n\n# 4.3.4 相互关联的对象\n\nfunction marry(man, woman) {\n  woman.husband = man;\n  man.wife = woman;\n  return {\n    father: man,\n    mother: woman\n  }\n}\nlet family = marry({\n  name: "john"\n}, {\n  name: "ann"\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nmarry 函数通过让两个对象相互引用使它们“结婚”了，并返回了一个包含这两个对象的新对象。\n由此产生的内存结构\n现在让我们移除两个引用：\n\ndelete family.father;\ndelete family.mother.husband;\n\n\n1\n2\n\n\n对外引用不重要，只有传入引用才可以使对象可达。所以，john 现在是不可达的，并且将被从内存中删除，同时 john 的所有数据也将变得不可达\n\n\n# 4.3.5 无法到达的岛屿\n\n几个对象相互引用，但外部没有对其任意对象的引用，这些对象也可能是不可达的，并被从内存中删除\n\nfamily = null;\n\n\n1\n\n\n\n\n\n# 4.3.6 垃圾回收内部算法\n\n垃圾回收的基本算法被称为 "mark-and-sweep"。\n\n定期执行以下“垃圾回收”步骤：\n\n * 垃圾收集器找到所有的根，并“标记”（记住）它们。\n * 然后它遍历并“标记”来自它们的所有引用。\n * 然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。\n * ……如此操作，直到所有可达的（从根部）引用都被访问到。\n * 没有被标记的对象都会被删除。\n\n这是垃圾收集工作的概念。javascript 引擎做了许多优化，使垃圾回收运行速度更快，并且不影响正常代码运行。\n\n一些优化建议：\n\n * 分代收集（generational collection）—— 对象被分成两组：“新的”和“旧的”。许多对象出现，完成它们的工作并很快死去，它们可以很快被清理。那些长期存活的对象会变得“老旧”，而且被检查的频次也会减少。\n * 增量收集（incremental collection）—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。所以引擎试图将垃圾收集工作分成几部分来做。然后将这几部分会逐一进行处理。这需要它们之间有额外的标记来追踪变化，但是这样会有许多微小的延迟而不是一个大的延迟。\n * 闲时收集（idle-time collection）—— 垃圾收集器只会在 cpu 空闲时尝试运行，以减少可能对代码执行的影响。\n\n\n# 4.4 对象方法，this\n\n在 javascript 中，行为（action）由属性中的函数来表示\n\n\n# 4.4.1 对象方法示例\n\n作为对象属性的函数被称为 方法\n\nlet user = {\n  name: "john",\n  age: 30\n};\nuser.sayhi = function() {\n  alert("hello!");\n};\nuser.sayhi(); // hello!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用函数表达式创建了一个函数，并将其指定给对象的 user.sayhi 属性 也可以使用预先声明的函数作为方法\n\nlet user = {\n  // ...\n};\n// 首先，声明函数\nfunction sayhi() {\n  alert("hello!");\n}\n// 然后将其作为一个方法添加\nuser.sayhi = sayhi;\nuser.sayhi(); // hello!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 方法简写\n\n在对象字面量中，有一种更短的（声明）方法的语法\n\nuser = {\n  sayhi: function() {\n    alert("hello");\n  }\n};\n// 方法简写看起来更好，对吧？\nlet user = {\n  sayhi() { // 与 "sayhi: function(){...}" 一样\n    alert("hello");\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 4.4.2 方法中的this\n\n为了访问该对象，方法中可以使用 this 关键字。 this 的值就是在点之前的这个对象，即调用该方法的对象\n\nlet user = {\n  name: "john",\n  age: 30,\n  sayhi() {\n    // "this" 指的是“当前的对象”\n    alert(this.name);\n  }\n};\nuser.sayhi(); // john\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n技术上讲，也可以在不使用 this 的情况下，通过外部变量名来引用它。但这样的代码是不可靠的\n\nlet user = {\n  name: "john",\n  age: 30,\n  sayhi() {\n    alert( user.name ); // 导致错误\n  }\n};\nlet admin = user;\nuser = null; // 重写让其更明显\nadmin.sayhi(); // typeerror: cannot read property \'name\' of null\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 4.4.3 "this" 不受限制\n\njavascript 中的 this 可以用于任何函数，即使它不是对象的方法 this 的值是在代码运行时计算出来的，它取决于代码上下文。\n\n例如，这里相同的函数被分配给两个不同的对象，在调用中有着不同的 "this" 值：\n\nlet user = { name: "john" };\nlet admin = { name: "admin" };\nfunction sayhi() {\n  alert( this.name );\n}\n// 在两个对象中使用相同的函数\nuser.f = sayhi;\nadmin.f = sayhi;\n// 这两个调用有不同的 this 值\n// 函数内部的 "this" 是“点符号前面”的那个对象\nuser.f(); // john（this == user）\nadmin.f(); // admin（this == admin）\nadmin[\'f\'](); // admin（使用点符号或方括号语法来访问这个方法，都没有关系。）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果 obj.f() 被调用了，则 this 在 f 函数调用期间是 obj。所以在上面的例子中 this 先是 user，之后是 admin\n\n在没有对象的情况下调用：`this == undefined`\n\nfunction sayhi() {\n  alert(this);\n}\nsayhi(); // undefined\n\n\n1\n2\n3\n4\n\n\n在这种情况下，严格模式下的 this 值为 undefined。如果我们尝试访问 this.name，将会报错。 在非严格模式的情况下，this 将会是 全局对象（浏览器中的 window）。这是一个历史行为，"use strict" 已经将其修复了\n\n\n# 4.4.4 箭头函数没有自己的 "this"\n\n箭头函数有些特别：它们没有自己的 this。如果我们在这样的函数中引用 this，this 值取决于外部“正常的”函数。\n\n举个例子，这里的 arrow() 使用的 this 来自于外部的 user.sayhi() 方法：\n\nlet user = {\n  firstname: "ilya",\n  sayhi() {\n    let arrow = () => alert(this.firstname);\n    arrow();\n  }\n};\nuser.sayhi(); // ilya\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这是箭头函数的一个特性，当我们并不想要一个独立的 this，反而想从外部上下文中获取时，它很有用\n\n\n# 4.5 构造器与new\n\n\n# 4.5.1 构造函数\n\n构造函数在技术上是常规函数。不过有两个约定：\n\n 1. 它们的命名以大写字母开头。\n 2. 它们只能由 "new" 操作符来执行\n\nfunction user(name) {\n  this.name = name;\n  this.isadmin = false;\n}\nlet user = new user("jack");\nalert(user.name); // jack\nalert(user.isadmin); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当一个函数被使用 new 操作符执行时，它按照以下步骤：\n\n 1. 一个新的空对象被创建并分配给 this。\n 2. 函数体执行。通常它会修改 this，为其添加新的属性。\n 3. 返回 this 的值\n\nfunction user(name) {\n  // this = {};（隐式创建）\n  // 添加属性到 this\n  this.name = name;\n  this.isadmin = false;\n  // return this;（隐式返回）\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4.5.2 构造器模式测试：new.target\n\n在一个函数内部，我们可以使用 new.target 属性来检查它是否被使用 new 进行调用了。\n\n对于常规调用，它为 undefined，对于使用 new 的调用，则等于该函数：\n\nfunction user() {\n  alert(new.target);\n}\n// 不带 "new"：\nuser(); // undefined\n// 带 "new"：\nnew user(); // function user { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n我们也可以让 new 调用和常规调用做相同的工作，像这样：\n\nfunction user(name) {\n  if (!new.target) { // 如果你没有通过 new 运行我\n    return new user(name); // ……我会给你添加 new\n  }\n  this.name = name;\n}\nlet john = user("john"); // 将调用重定向到新用户\nalert(john.name); // john\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 4.5.3 构造器的 return\n\n通常，构造器没有 return 语句。它们的任务是将所有必要的东西写入 this，并自动转换为结果。\n\n但是，如果这有一个 return 语句，那么规则就简单了：\n\n * 如果 return 返回的是一个对象，则返回这个对象，而不是 this。\n * 如果 return 返回的是一个原始类型，则忽略\n\nfunction biguser() {\n  this.name = "john";\n  return { name: "godzilla" };  // <-- 返回这个对象\n}\nalert( new biguser().name );  // godzilla，得到了那个对象\n\nfunction smalluser() {\n  this.name = "john";\n  return; // <-- 返回 this\n}\nalert( new smalluser().name );  // john\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n省略括号\n\n如果没有参数，我们可以省略 new 后的括号：\n\nlet user = new user; // <-- 没有参数\n// 等同于\nlet user = new user();\n\n\n1\n2\n3\n\n\n\n# 4.5.4 构造器中的方法\n\n我们不仅可以将属性添加到 this 中，还可以添加方法\n\nfunction user(name) {\n  this.name = name;\n  this.sayhi = function() {\n    alert( "my name is: " + this.name );\n  };\n}\nlet john = new user("john");\njohn.sayhi(); // my name is: john\n/*\njohn = {\n   name: "john",\n   sayhi: function() { ... }\n}\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 4.6 可选链 ?.\n\n可选链 ?. 是一种访问嵌套对象属性的安全的方式。即使中间的属性不存在，也不会出现错误\n\n\n# 4.6.1 可选链语法\n\n如果可选链 ?. 前面的值为 undefined 或者 null，它会停止运算并返回 undefined 例如 value?.prop：\n\n * 如果 value 存在，则结果与 value.prop 相同，\n * 否则（当 value 为 undefined/null 时）则返回 undefined\n\n请注意：?. 语法使其前面的值成为可选值，但不会对其后面的起作用\n\n`?.` 前的变量必须已声明\n\n如果未声明变量 user，那么 user?.anything 会触发一个错误：\n\n// referenceerror: user is not defined\nuser?.address;\n\n\n1\n2\n\n\n?. 前的变量必须已声明（例如 let/const/var user 或作为一个函数参数）。可选链仅适用于已声明的变量\n\n\n# 4.6.2 短路效应\n\n如果 ?. 左边部分不存在，就会立即停止运算（“短路效应”）。\n\n因此，如果在 ?. 的右侧有任何进一步的函数调用或操作，它们均不会执行。\n\nlet user = null;\nlet x = 0;\nuser?.sayhi(x++); // 没有 "user"，因此代码执行没有到达 sayhi 调用和 x++\nalert(x); // 0，值没有增加\n\n\n1\n2\n3\n4\n\n\n\n# 4.6.3 其它变体：?.()，?.[]\n\n可选链 ?. 不是一个运算符，而是一个特殊的语法结构。它还可以与函数和方括号一起使用\n\nlet useradmin = {\n  admin() {\n    alert("i am admin");\n  }\n};\nlet userguest = {};\nuseradmin.admin?.(); // i am admin\nuserguest.admin?.(); // 啥都没发生（没有这样的方法）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n此外，我们还可以将 ?. 跟 delete 一起使用：\n\ndelete user?.name; // 如果 user 存在，则删除 user.name\n\n\n1\n\n\n我们可以使用 `?.` 来安全地读取或删除，但不能写入\n\n可选链 ?. 不能用在赋值语句的左侧。\n\nlet user = null;\nuser?.name = "john"; // error，不起作用\n// 因为它在计算的是：undefined = "john"\n\n\n1\n2\n3\n\n\n\n# 4.7 symbol 类型\n\n根据规范，只有两种原始类型可以用作对象属性键：\n\n * 字符串类型\n * symbol 类型\n\n\n# 4.7.1 symbol\n\n"symbol" 值表示唯一的标识符。\n\n可以使用 symbol() 来创建这种类型的值：\n\nlet id = symbol();\n\n\n1\n\n\n创建时，我们可以给 symbol 一个描述（也称为 symbol 名），这在代码调试时非常有用：\n\n// id 是描述为 "id" 的 symbol\nlet id = symbol("id");\n\n\n1\n2\n\n\nsymbol 保证是唯一的。即使我们创建了许多具有相同描述的 symbol，它们的值也是不同。描述只是一个标签，不影响任何东西 两个描述相同的 symbol —— 它们不相等：\n\nlet id1 = symbol("id");\nlet id2 = symbol("id");\nalert(id1 == id2); // false\n\n\n1\n2\n3\n\n\nsymbol 不会被自动转换为字符串\n\njavascript 中的大多数值都支持字符串的隐式转换\n\nlet id = symbol("id");\nalert(id); // 类型错误：无法将 symbol 值转换为字符串。\n\n\n1\n2\n\n\n这是一种防止混乱的“语言保护”，因为字符串和 symbol 有本质上的不同，不应该意外地将它们转换成另一个 如果我们真的想显示一个 symbol，我们需要在它上面调用 .tostring()，如下所示：\n\nlet id = symbol("id");\nalert(id.tostring()); // symbol(id)，现在它有效了\n\n\n1\n2\n\n\n或者获取 symbol.description 属性，只显示描述（description）：\n\nlet id = symbol("id");\nalert(id.description); // id\n\n\n1\n2\n\n\n\n# 4.7.2 “隐藏”属性\n\nsymbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性\n\nlet user = { // 属于另一个代码\n  name: "john"\n};\nlet id = symbol("id");\nuser[id] = 1;\nalert( user[id] ); // 我们可以使用 symbol 作为键来访问数据\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 对象字面量中的 symbol\n\n如果我们要在对象字面量 {...} 中使用 symbol，则需要使用方括号把它括起来。\n\n就像这样：\n\nlet id = symbol("id");\nlet user = {\n  name: "john",\n  [id]: 123 // 而不是 "id"：123\n};\n\n\n1\n2\n3\n4\n5\n\n\n这是因为我们需要变量 id 的值作为键，而不是字符串 "id"\n\n# symbol 在 for..in 中会被跳过\n\nsymbol 属性不参与 for..in 循环\n\nlet id = symbol("id");\nlet user = {\n  name: "john",\n  age: 30,\n  [id]: 123\n};\nfor (let key in user) alert(key); // name, age（没有 symbol）\n// 使用 symbol 任务直接访问\nalert( "direct: " + user[id] );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nobject.keys(user) 也会忽略它们。这是一般“隐藏符号属性”原则的一部分 相反，object.assign 会同时复制字符串和 symbol 属性\n\n\n# 4.7.3 全局 symbol\n\n有一个 全局 symbol 注册表。我们可以在其中创建 symbol 并在稍后访问它们，它可以确保每次访问相同名字的 symbol 时，返回的都是相同的 symbol 要从注册表中读取（不存在则创建）symbol，请使用 symbol.for(key)。\n\n该调用会检查全局注册表，如果有一个描述为 key 的 symbol，则返回该 symbol，否则将创建一个新 symbol（symbol(key)），并通过给定的 key 将其存储在注册表中\n\n// 从全局注册表中读取\nlet id = symbol.for("id"); // 如果该 symbol 不存在，则创建它\n// 再次读取（可能是在代码中的另一个位置）\nlet idagain = symbol.for("id");\n// 相同的 symbol\nalert( id === idagain ); // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n# symbol.keyfor\n\n对于全局 symbol，不仅有 symbol.for(key) 按名字返回一个 symbol，还有一个反向调用：symbol.keyfor(sym)，它的作用完全反过来：通过全局 symbol 返回一个名字\n\n// 通过 name 获取 symbol\nlet sym = symbol.for("name");\nlet sym2 = symbol.for("id");\n// 通过 symbol 获取 name\nalert( symbol.keyfor(sym) ); // name\nalert( symbol.keyfor(sym2) ); // id\n\n\n1\n2\n3\n4\n5\n6\n\n\nsymbol.keyfor 内部使用全局 symbol 注册表来查找 symbol 的键。所以它不适用于非全局 symbol。如果 symbol 不是全局的，它将无法找到它并返回 undefined\n\n\n# 4.7.4 系统 symbol\n\njavascript 内部有很多“系统” symbol，我们可以使用它们来微调对象的各个方面 众所周知的 symbol 表的规范中：\n\n * symbol.hasinstance\n * symbol.isconcatspreadable\n * symbol.iterator\n * symbol.toprimitive\n\n\n# 4.8 对象 — 原始值转换\n\n当对象相加 obj1 + obj2，相减 obj1 - obj2，或者使用 alert(obj) 打印时会发生什么？ 在此类运算的情况下，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果（也是一个原始值）\n\n\n# 4.8.1 转换规则\n\n 1. 没有转换为布尔值。所有的对象在布尔上下文（context）中均为 true，就这么简单。只有字符串和数字转换。\n 2. 数字转换发生在对象相减或应用数学函数时。例如，date 对象（将在 info:date 一章中介绍）可以相减，date1 - date2 的结果是两个日期之间的差值。\n 3. 至于字符串转换 —— 通常发生在我们像 alert(obj) 这样输出一个对象和类似的上下文中。\n\n\n# 4.8.2 hint\n\n类型转换在各种情况下有三种变体。它们被称为 "hint"\n\n"string" : 对象到字符串的转换，当我们对期望一个字符串的对象执行操作时，如 "alert"：\n\n```js\n// 输出\nalert(obj);\n// 将对象作为属性键\nanotherobj[obj] = 123;\n```\n\n\n"number" : 对象到数字的转换，例如当我们进行数学运算时：\n\n```js\n// 显式转换\nlet num = number(obj);\n// 数学运算（除了二元加法）\nlet n = +obj; // 一元加法\nlet delta = date1 - date2;\n// 小于/大于的比较\nlet greater = user1 > user2;\n```\n\n大多数内建的数学函数也包括这种转换。\n\n\n"default" : 在少数情况下发生，当运算符“不确定”期望值的类型时。\n\n例如，二元加法 `+` 可用于字符串（连接），也可以用于数字（相加）。因此，当二元加法得到对象类型的参数时，它将依据 `"default"` hint 来对其进行转换。\n\n此外，如果对象被用于与字符串、数字或 symbol 进行 `==` 比较，这时到底应该进行哪种转换也不是很明确，因此使用 `"default"` hint。\n\n```js\n// 二元加法使用默认 hint\nlet total = obj1 + obj2;\n// obj == number 使用默认 hint\nif (user == 1) { ... };\n```\n\n像 `<` 和 `>` 这样的小于/大于比较运算符，也可以同时用于字符串和数字。不过，它们使用 "number" hint，而不是 "default"。这是历史原因。  \n\n\n为了进行转换，javascript 尝试查找并调用三个对象方法：\n\n 1. 调用 obj[symbol.toprimitive](hint) —— 带有 symbol 键 symbol.toprimitive（系统 symbol）的方法，如果这个方法存在的话，\n 2. 否则，如果 hint 是 "string" —— 尝试调用 obj.tostring() 或 obj.valueof()，无论哪个存在。\n 3. 否则，如果 hint 是 "number" 或 "default" —— 尝试调用 obj.valueof() 或 obj.tostring()，无论哪个存在。\n\n\n# 4.8.3 symbol.toprimitive\n\n如果 symbol.toprimitive 方法存在，则它会被用于所有 hint，无需更多其他方法。\n\n例如，这里 user 对象实现了它：\n\nlet user = {\n  name: "john",\n  money: 1000,\n  [symbol.toprimitive](hint) {\n    alert(`hint: ${hint}`);\n    return hint == "string" ? `{name: "${this.name}"}` : this.money;\n  }\n};\n// 转换演示：\nalert(user); // hint: string -> {name: "john"}\nalert(+user); // hint: number -> 1000\nalert(user + 500); // hint: default -> 1500\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 4.8.4 tostring/valueof\n\n如果没有 symbol.toprimitive，那么 javascript 将尝试寻找 tostring 和 valueof 方法：\n\n * 对于 "string" hint：调用 tostring 方法，如果它不存在，则调用 valueof 方法（因此，对于字符串转换，优先调用 tostring）。\n * 对于其他 hint：调用 valueof 方法，如果它不存在，则调用 tostring 方法（因此，对于数学运算，优先调用 valueof 方法）。\n\n默认情况下，普通对象具有 tostring 和 valueof 方法：\n\n * tostring 方法返回一个字符串 "[object object]"。\n * valueof 方法返回对象自身。\n\n# 转换可以返回任何原始类型\n\n关于所有原始转换方法，有一个重要的点需要知道，就是它们不一定会返回 "hint" 的原始值。\n\n没有限制 tostring() 是否返回字符串，或 symbol.toprimitive 方法是否为 "number" hint 返回数字。\n\n唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象',charsets:{cjk:!0}},{title:"简介",frontmatter:{title:"简介",date:"2020-01-05T10:15:07.000Z",permalink:"/pages/e05dce83e5129785",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","初识 TypeScript"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/01.%E5%88%9D%E8%AF%86%20TypeScript/01.%E7%AE%80%E4%BB%8B.html",relativePath:"《TypeScript 从零实现 axios》/01.初识 TypeScript/01.简介.md",key:"v-d7e58e4e",path:"/pages/e05dce83e5129785/",headers:[{level:2,title:"TypeScript 的特点",slug:"typescript-的特点",normalizedTitle:"typescript 的特点",charIndex:127},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:653}],headersStr:"TypeScript 的特点 总结",content:"# 简介\n\nTypeScript 作为 JavaScript 语言的超集，它为 JavaScript 添加了可选择的类型标注，大大增强了代码的可读性和可维护性。同时，它提供最新和不断发展的 JavaScript 特性，能让我们建立更健壮的组件。\n\n\n# TypeScript 的特点\n\nTypeScript 主要有 3 大特点：\n\n * 始于JavaScript，归于JavaScript\n\nTypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript 引擎中。\n\n * 强大的工具构建大型应用程序\n\n类型允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。\n\n类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 JavaScript 库的行为。\n\n * 先进的 JavaScript\n\nTypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。\n\n这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的JavaScript。\n\n\n# 总结\n\nTypeScript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。如果你还没有开始学习 TypeScript，那么你可能要落后了哟，所以还等什么，快来和我一起学习并使用 TypeScript 吧，来感受一下它为我们带来的奇妙体验。",normalizedContent:"# 简介\n\ntypescript 作为 javascript 语言的超集，它为 javascript 添加了可选择的类型标注，大大增强了代码的可读性和可维护性。同时，它提供最新和不断发展的 javascript 特性，能让我们建立更健壮的组件。\n\n\n# typescript 的特点\n\ntypescript 主要有 3 大特点：\n\n * 始于javascript，归于javascript\n\ntypescript 可以编译出纯净、 简洁的 javascript 代码，并且可以运行在任何浏览器上、node.js 环境中和任何支持 ecmascript 3（或更高版本）的javascript 引擎中。\n\n * 强大的工具构建大型应用程序\n\n类型允许 javascript 开发者在开发 javascript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。\n\n类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 javascript 库的行为。\n\n * 先进的 javascript\n\ntypescript 提供最新的和不断发展的 javascript 特性，包括那些来自 2015 年的 ecmascript 和未来的提案中的特性，比如异步功能和 decorators，以帮助建立健壮的组件。\n\n这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ecmascript3（或更新版本）的javascript。\n\n\n# 总结\n\ntypescript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。如果你还没有开始学习 typescript，那么你可能要落后了哟，所以还等什么，快来和我一起学习并使用 typescript 吧，来感受一下它为我们带来的奇妙体验。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"编写第一个 TypeScript 程序",frontmatter:{title:"编写第一个 TypeScript 程序",date:"2020-01-05T10:15:07.000Z",permalink:"/pages/c85249f40e7a3517",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","初识 TypeScript"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/01.%E5%88%9D%E8%AF%86%20TypeScript/03.%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA%20TypeScript%20%E7%A8%8B%E5%BA%8F.html",relativePath:"《TypeScript 从零实现 axios》/01.初识 TypeScript/03.编写第一个 TypeScript 程序.md",key:"v-1a72a707",path:"/pages/c85249f40e7a3517/",headers:[{level:2,title:"编译代码",slug:"编译代码",normalizedTitle:"编译代码",charIndex:180},{level:2,title:"类型注解",slug:"类型注解",normalizedTitle:"类型注解",charIndex:401},{level:2,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:1166},{level:2,title:"类",slug:"类",normalizedTitle:"类",charIndex:401},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2390}],headersStr:"编译代码 类型注解 接口 类 总结",content:"# 编写第一个 TypeScript 程序\n\n在编辑器，将下面的代码输入到 greeter.ts 文件里：\n\nfunction greeter (person) {\n  return 'Hello, ' + person\n}\n\nlet user = 'Yee'\n\nconsole.log(greeter(user))\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 编译代码\n\n我们使用了 .ts 扩展名，但是这段代码仅仅是 JavaScript 而已。\n\n在命令行上，运行 TypeScript 编译器：\n\ntsc greeter.ts\n\n\n1\n\n\n输出结果为一个 greeter.js 文件，它包含了和输入文件中相同的 JavsScript 代码。\n\n在命令行上，通过 Node.js 运行这段代码：\n\nnode greeter.js\n\n\n1\n\n\n控制台输出：\n\nHello, Yee\n\n\n1\n\n\n\n# 类型注解\n\n接下来让我们看看 TypeScript 工具带来的高级功能。 给 person 函数的参数添加 : string 类型注解，如下：\n\nfunction greeter (person: string) {\n  return 'Hello, ' + person\n}\n\nlet user = 'Yee'\n\nconsole.log(greeter(user))\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nTypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 greeter 函数接收一个字符串参数。 然后尝试把 greeter 的调用改成传入一个数组：\n\nfunction greeter (person: string) {\n  return 'Hello, ' + person\n}\n\nlet user = [0, 1, 2]\n\nconsole.log(greeter(user))\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n重新编译，你会看到产生了一个错误：\n\nerror TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.\n\n\n1\n\n\n类似地，尝试删除 greeter 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。\n\n要注意的是尽管有错误，greeter.js 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。\n\n\n# 接口\n\n让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 firstName 和 lastName 字段的对象。 在 TypeScript 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 implements 语句。\n\ninterface Person {\n  firstName: string\n  lastName: string\n}\n\nfunction greeter (person: Person) {\n  return 'Hello, ' + person.firstName + ' ' + person.lastName\n}\n\nlet user = {\n  firstName: 'Yee',\n  lastName: 'Huang'\n}\n\nconsole.log(greeter(user))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 类\n\n最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。\n\n让我们创建一个 User 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。\n\n还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。\n\nclass User {\n  fullName: string\n  firstName: string\n  lastName: string\n\n  constructor (firstName: string, lastName: string) {\n    this.firstName = firstName\n    this.lastName = lastName\n    this.fullName = firstName + ' ' + lastName\n  }\n}\n\ninterface Person {\n  firstName: string\n  lastName: string\n}\n\nfunction greeter (person: Person) {\n  return 'Hello, ' + person.firstName + ' ' + person.lastName\n}\n\nlet user = new User('Yee', 'Huang')\n\nconsole.log(greeter(user))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n重新运行 tsc greeter.ts，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 JavaScript 函数的实现。\n\n\n# 总结\n\n到这里，你已经对 TypeScript 有了一个大致的印象，那么下一章让我们来一起学习 TypeScript 的一些常用语法吧。",normalizedContent:"# 编写第一个 typescript 程序\n\n在编辑器，将下面的代码输入到 greeter.ts 文件里：\n\nfunction greeter (person) {\n  return 'hello, ' + person\n}\n\nlet user = 'yee'\n\nconsole.log(greeter(user))\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 编译代码\n\n我们使用了 .ts 扩展名，但是这段代码仅仅是 javascript 而已。\n\n在命令行上，运行 typescript 编译器：\n\ntsc greeter.ts\n\n\n1\n\n\n输出结果为一个 greeter.js 文件，它包含了和输入文件中相同的 javsscript 代码。\n\n在命令行上，通过 node.js 运行这段代码：\n\nnode greeter.js\n\n\n1\n\n\n控制台输出：\n\nhello, yee\n\n\n1\n\n\n\n# 类型注解\n\n接下来让我们看看 typescript 工具带来的高级功能。 给 person 函数的参数添加 : string 类型注解，如下：\n\nfunction greeter (person: string) {\n  return 'hello, ' + person\n}\n\nlet user = 'yee'\n\nconsole.log(greeter(user))\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ntypescript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 greeter 函数接收一个字符串参数。 然后尝试把 greeter 的调用改成传入一个数组：\n\nfunction greeter (person: string) {\n  return 'hello, ' + person\n}\n\nlet user = [0, 1, 2]\n\nconsole.log(greeter(user))\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n重新编译，你会看到产生了一个错误：\n\nerror ts2345: argument of type 'number[]' is not assignable to parameter of type 'string'.\n\n\n1\n\n\n类似地，尝试删除 greeter 调用的所有参数。 typescript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，typescript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。\n\n要注意的是尽管有错误，greeter.js 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 typescript。但在这种情况下，typescript 会警告你代码可能不会按预期执行。\n\n\n# 接口\n\n让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 firstname 和 lastname 字段的对象。 在 typescript 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 implements 语句。\n\ninterface person {\n  firstname: string\n  lastname: string\n}\n\nfunction greeter (person: person) {\n  return 'hello, ' + person.firstname + ' ' + person.lastname\n}\n\nlet user = {\n  firstname: 'yee',\n  lastname: 'huang'\n}\n\nconsole.log(greeter(user))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 类\n\n最后，让我们使用类来改写这个例子。 typescript 支持 javascript 的新特性，比如支持基于类的面向对象编程。\n\n让我们创建一个 user 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。\n\n还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。\n\nclass user {\n  fullname: string\n  firstname: string\n  lastname: string\n\n  constructor (firstname: string, lastname: string) {\n    this.firstname = firstname\n    this.lastname = lastname\n    this.fullname = firstname + ' ' + lastname\n  }\n}\n\ninterface person {\n  firstname: string\n  lastname: string\n}\n\nfunction greeter (person: person) {\n  return 'hello, ' + person.firstname + ' ' + person.lastname\n}\n\nlet user = new user('yee', 'huang')\n\nconsole.log(greeter(user))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n重新运行 tsc greeter.ts，你会看到 typescript 里的类只是一个语法糖，本质上还是 javascript 函数的实现。\n\n\n# 总结\n\n到这里，你已经对 typescript 有了一个大致的印象，那么下一章让我们来一起学习 typescript 的一些常用语法吧。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"基础类型",frontmatter:{title:"基础类型",date:"2020-01-05T10:17:47.000Z",permalink:"/pages/28672e2743bbc3a7",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","TypeScript 常用语法"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/02.TypeScript%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/01.%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B.html",relativePath:"《TypeScript 从零实现 axios》/02.TypeScript 常用语法/01.基础类型.md",key:"v-bbee7fd6",path:"/pages/28672e2743bbc3a7/",headers:[{level:2,title:"布尔值",slug:"布尔值",normalizedTitle:"布尔值",charIndex:69},{level:2,title:"数字",slug:"数字",normalizedTitle:"数字",charIndex:187},{level:2,title:"字符串",slug:"字符串",normalizedTitle:"字符串",charIndex:453},{level:2,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:1e3},{level:2,title:"元组 Tuple",slug:"元组-tuple",normalizedTitle:"元组 tuple",charIndex:1199},{level:2,title:"枚举",slug:"枚举",normalizedTitle:"枚举",charIndex:53},{level:2,title:"any",slug:"any",normalizedTitle:"any",charIndex:2347},{level:2,title:"void",slug:"void",normalizedTitle:"void",charIndex:2751},{level:2,title:"null 和 undefined",slug:"null-和-undefined",normalizedTitle:"null 和 undefined",charIndex:3007},{level:2,title:"never",slug:"never",normalizedTitle:"never",charIndex:3425},{level:2,title:"object",slug:"object",normalizedTitle:"object",charIndex:3965},{level:2,title:"类型断言",slug:"类型断言",normalizedTitle:"类型断言",charIndex:4311}],headersStr:"布尔值 数字 字符串 数组 元组 Tuple 枚举 any void null 和 undefined never object 类型断言",content:"# 基础类型\n\nTypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。\n\n\n# 布尔值\n\n最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 boolean（其它语言中也一样）。\n\nlet isDone: boolean = false\n\n\n1\n\n\n\n# 数字\n\n和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。\n\nlet decLiteral: number = 20\nlet hexLiteral: number = 0x14\nlet binaryLiteral: number = 0b10100\nlet octalLiteral: number = 0o24\n\n\n1\n2\n3\n4\n\n\n\n# 字符串\n\nJavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（\"）或单引号（'）表示字符串。\n\nlet name: string = 'bob'\nname = 'smith'\n\n\n1\n2\n\n\n你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ `），并且以 ${ expr } 这种形式嵌入表达式\n\nlet name: string = `Yee`\nlet age: number = 37\nlet sentence: string = `Hello, my name is ${ name }.\n\nI'll be ${ age + 1 } years old next month.`\n\n\n1\n2\n3\n4\n5\n\n\n这与下面定义 sentence 的方式效果相同：\n\nlet sentence: string = 'Hello, my name is ' + name + '.\\n\\n' +\n    'I\\'ll be ' + (age + 1) + ' years old next month.'\n\n\n1\n2\n\n\n\n# 数组\n\nTypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组：\n\nlet list: number[] = [1, 2, 3]\n\n\n1\n\n\n第二种方式是使用数组泛型，Array<元素类型>：\n\nlet list: Array<number> = [1, 2, 3]\n\n\n1\n\n\n\n# 元组 Tuple\n\n元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。\n\nlet x: [string, number]\nx = ['hello', 10] // OK\nx = [10, 'hello'] // Error\n\n\n1\n2\n3\n\n\n当访问一个已知索引的元素，会得到正确的类型：\n\nconsole.log(x[0].substr(1)) // OK\nconsole.log(x[1].substr(1)) // Error, 'number' 不存在 'substr' 方法\n\n\n1\n2\n\n\n当访问一个越界的元素，会使用联合类型替代：\n\nx[3] = 'world' // OK, 字符串可以赋值给(string | number)类型\n\nconsole.log(x[5].toString()) // OK, 'string' 和 'number' 都有 toString\n\nx[6] = true // Error, 布尔不是(string | number)类型\n\n\n1\n2\n3\n4\n5\n\n\n联合类型是高级主题，我们会在以后的章节里讨论它。\n\n注意：自从 TyeScript 3.1 版本之后，访问越界元素会报错，我们不应该再使用该特性。\n\n\n# 枚举\n\nenum 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\n\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green\n\n\n1\n2\n\n\n默认情况下，从 0 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1 开始编号：\n\nenum Color {Red = 1, Green, Blue}\nlet c: Color = Color.Green\n\n\n1\n2\n\n\n或者，全部都采用手动赋值：\n\nenum Color {Red = 1, Green = 2, Blue = 4}\nlet c: Color = Color.Green\n\n\n1\n2\n\n\n枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：\n\nenum Color {Red = 1, Green, Blue}\nlet colorName: string = Color[2]\n\nconsole.log(colorName)  // 显示'Green'因为上面代码里它的值是2\n\n\n1\n2\n3\n4\n\n\n\n# any\n\n有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any 类型来标记这些变量：\n\nlet notSure: any = 4\nnotSure = 'maybe a string instead'\nnotSure = false // 也可以是个 boolean\n\n\n1\n2\n3\n\n\n在对现有代码进行改写的时候，any 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，any 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：\n\nlet list: any[] = [1, true, 'free']\n\nlist[1] = 100\n\n\n1\n2\n3\n\n\n\n# void\n\n某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：\n\nfunction warnUser(): void {\n  console.log('This is my warning message')\n}\n\n\n\n1\n2\n3\n4\n\n\n声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null：\n\nlet unusable: void = undefined\n\n\n1\n\n\n\n# null 和 undefined\n\nTypeScript 里，undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 和 void 相似，它们的本身的类型用处不是很大：\n\nlet u: undefined = undefined\nlet n: null = null\n\n\n1\n2\n\n\n默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。\n\n然而，当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 string 或 null 或 undefined，你可以使用联合类型 string | null | undefined。 再次说明，稍后我们会介绍联合类型。\n\n\n# never\n\nnever 类型表示的是那些永不存在的值的类型。 例如， never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never 类型，当它们被永不为真的类型保护所约束时。\n\nnever 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。\n\n下面是一些返回 never 类型的函数：\n\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n  throw new Error(message)\n}\n\n// 推断的返回值类型为never\nfunction fail() {\n  return error(\"Something failed\")\n}\n\n// 返回never的函数必须存在无法达到的终点\nfunction infiniteLoop(): never {\n  while (true) {\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# object\n\nobject 表示非原始类型，也就是除 number，string，boolean，symbol，null或undefined 之外的类型。\n\n使用 object 类型，就可以更好的表示像 Object.create 这样的 API。例如：\n\ndeclare function create(o: object | null): void\n\ncreate({ prop: 0 }) // OK\ncreate(null) // OK\n\ncreate(42) // Error\ncreate('string') // Error\ncreate(false) // Error\ncreate(undefined) // Error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 类型断言\n\n有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n\n通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。\n\n类型断言有两种形式。 其一是“尖括号”语法：\n\nlet someValue: any = 'this is a string'\n\nlet strLength: number = (<string>someValue).length\n\n\n1\n2\n3\n\n\n另一个为 as 语法：\n\nlet someValue: any = 'this is a string'\n\nlet strLength: number = (someValue as string).length\n\n\n1\n2\n3\n\n\n两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 as 语法断言是被允许的。",normalizedContent:"# 基础类型\n\ntypescript 支持与 javascript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。\n\n\n# 布尔值\n\n最基本的数据类型就是简单的 true/false 值，在javascript 和 typescript 里叫做 boolean（其它语言中也一样）。\n\nlet isdone: boolean = false\n\n\n1\n\n\n\n# 数字\n\n和 javascript 一样，typescript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，typescript 还支持 ecmascript 2015中引入的二进制和八进制字面量。\n\nlet decliteral: number = 20\nlet hexliteral: number = 0x14\nlet binaryliteral: number = 0b10100\nlet octalliteral: number = 0o24\n\n\n1\n2\n3\n4\n\n\n\n# 字符串\n\njavascript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string 表示文本数据类型。 和 javascript 一样，可以使用双引号（\"）或单引号（'）表示字符串。\n\nlet name: string = 'bob'\nname = 'smith'\n\n\n1\n2\n\n\n你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ `），并且以 ${ expr } 这种形式嵌入表达式\n\nlet name: string = `yee`\nlet age: number = 37\nlet sentence: string = `hello, my name is ${ name }.\n\ni'll be ${ age + 1 } years old next month.`\n\n\n1\n2\n3\n4\n5\n\n\n这与下面定义 sentence 的方式效果相同：\n\nlet sentence: string = 'hello, my name is ' + name + '.\\n\\n' +\n    'i\\'ll be ' + (age + 1) + ' years old next month.'\n\n\n1\n2\n\n\n\n# 数组\n\ntypescript 像 javascript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组：\n\nlet list: number[] = [1, 2, 3]\n\n\n1\n\n\n第二种方式是使用数组泛型，array<元素类型>：\n\nlet list: array<number> = [1, 2, 3]\n\n\n1\n\n\n\n# 元组 tuple\n\n元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。\n\nlet x: [string, number]\nx = ['hello', 10] // ok\nx = [10, 'hello'] // error\n\n\n1\n2\n3\n\n\n当访问一个已知索引的元素，会得到正确的类型：\n\nconsole.log(x[0].substr(1)) // ok\nconsole.log(x[1].substr(1)) // error, 'number' 不存在 'substr' 方法\n\n\n1\n2\n\n\n当访问一个越界的元素，会使用联合类型替代：\n\nx[3] = 'world' // ok, 字符串可以赋值给(string | number)类型\n\nconsole.log(x[5].tostring()) // ok, 'string' 和 'number' 都有 tostring\n\nx[6] = true // error, 布尔不是(string | number)类型\n\n\n1\n2\n3\n4\n5\n\n\n联合类型是高级主题，我们会在以后的章节里讨论它。\n\n注意：自从 tyescript 3.1 版本之后，访问越界元素会报错，我们不应该再使用该特性。\n\n\n# 枚举\n\nenum 类型是对 javascript 标准数据类型的一个补充。 像 c# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\n\nenum color {red, green, blue}\nlet c: color = color.green\n\n\n1\n2\n\n\n默认情况下，从 0 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1 开始编号：\n\nenum color {red = 1, green, blue}\nlet c: color = color.green\n\n\n1\n2\n\n\n或者，全部都采用手动赋值：\n\nenum color {red = 1, green = 2, blue = 4}\nlet c: color = color.green\n\n\n1\n2\n\n\n枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 color 里的哪个名字，我们可以查找相应的名字：\n\nenum color {red = 1, green, blue}\nlet colorname: string = color[2]\n\nconsole.log(colorname)  // 显示'green'因为上面代码里它的值是2\n\n\n1\n2\n3\n4\n\n\n\n# any\n\n有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any 类型来标记这些变量：\n\nlet notsure: any = 4\nnotsure = 'maybe a string instead'\nnotsure = false // 也可以是个 boolean\n\n\n1\n2\n3\n\n\n在对现有代码进行改写的时候，any 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，any 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：\n\nlet list: any[] = [1, true, 'free']\n\nlist[1] = 100\n\n\n1\n2\n3\n\n\n\n# void\n\n某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：\n\nfunction warnuser(): void {\n  console.log('this is my warning message')\n}\n\n\n\n1\n2\n3\n4\n\n\n声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null：\n\nlet unusable: void = undefined\n\n\n1\n\n\n\n# null 和 undefined\n\ntypescript 里，undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 和 void 相似，它们的本身的类型用处不是很大：\n\nlet u: undefined = undefined\nlet n: null = null\n\n\n1\n2\n\n\n默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。\n\n然而，当你指定了 --strictnullchecks 标记，null 和 undefined 只能赋值给 void 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 string 或 null 或 undefined，你可以使用联合类型 string | null | undefined。 再次说明，稍后我们会介绍联合类型。\n\n\n# never\n\nnever 类型表示的是那些永不存在的值的类型。 例如， never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never 类型，当它们被永不为真的类型保护所约束时。\n\nnever 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。\n\n下面是一些返回 never 类型的函数：\n\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n  throw new error(message)\n}\n\n// 推断的返回值类型为never\nfunction fail() {\n  return error(\"something failed\")\n}\n\n// 返回never的函数必须存在无法达到的终点\nfunction infiniteloop(): never {\n  while (true) {\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# object\n\nobject 表示非原始类型，也就是除 number，string，boolean，symbol，null或undefined 之外的类型。\n\n使用 object 类型，就可以更好的表示像 object.create 这样的 api。例如：\n\ndeclare function create(o: object | null): void\n\ncreate({ prop: 0 }) // ok\ncreate(null) // ok\n\ncreate(42) // error\ncreate('string') // error\ncreate(false) // error\ncreate(undefined) // error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 类型断言\n\n有时候你会遇到这样的情况，你会比 typescript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n\n通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 typescript 会假设你，程序员，已经进行了必须的检查。\n\n类型断言有两种形式。 其一是“尖括号”语法：\n\nlet somevalue: any = 'this is a string'\n\nlet strlength: number = (<string>somevalue).length\n\n\n1\n2\n3\n\n\n另一个为 as 语法：\n\nlet somevalue: any = 'this is a string'\n\nlet strlength: number = (somevalue as string).length\n\n\n1\n2\n3\n\n\n两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 typescript 里使用 jsx 时，只有 as 语法断言是被允许的。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"安装 TypeScript",frontmatter:{title:"安装 TypeScript",date:"2020-01-05T10:15:07.000Z",permalink:"/pages/064e0f7b6b6142c8",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","初识 TypeScript"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/01.%E5%88%9D%E8%AF%86%20TypeScript/02.%E5%AE%89%E8%A3%85%20TypeScript.html",relativePath:"《TypeScript 从零实现 axios》/01.初识 TypeScript/02.安装 TypeScript.md",key:"v-23f81a77",path:"/pages/064e0f7b6b6142c8/",headersStr:null,content:"# 安装 TypeScript\n\n命令行运行如下命令，全局安装 TypeScript：\n\nnpm install -g typescript\n\n\n1\n\n\n安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：\n\ntsc -V\n\n\n1\n",normalizedContent:"# 安装 typescript\n\n命令行运行如下命令，全局安装 typescript：\n\nnpm install -g typescript\n\n\n1\n\n\n安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：\n\ntsc -v\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"变量声明",frontmatter:{title:"变量声明",date:"2020-01-05T10:17:47.000Z",permalink:"/pages/54add7f5cf78088e",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","TypeScript 常用语法"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/02.TypeScript%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/02.%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E.html",relativePath:"《TypeScript 从零实现 axios》/02.TypeScript 常用语法/02.变量声明.md",key:"v-501d21b4",path:"/pages/54add7f5cf78088e/",headers:[{level:2,title:"var 声明",slug:"var-声明",normalizedTitle:"var 声明",charIndex:230},{level:3,title:"作用域规则",slug:"作用域规则",normalizedTitle:"作用域规则",charIndex:732},{level:3,title:"捕获变量怪异之处",slug:"捕获变量怪异之处",normalizedTitle:"捕获变量怪异之处",charIndex:1414},{level:2,title:"let 声明",slug:"let-声明",normalizedTitle:"let 声明",charIndex:2174},{level:3,title:"块作用域",slug:"块作用域",normalizedTitle:"块作用域",charIndex:2312},{level:3,title:"重定义及屏蔽",slug:"重定义及屏蔽",normalizedTitle:"重定义及屏蔽",charIndex:3304},{level:3,title:"块级作用域变量的获取",slug:"块级作用域变量的获取",normalizedTitle:"块级作用域变量的获取",charIndex:4429},{level:2,title:"const 声明",slug:"const-声明",normalizedTitle:"const 声明",charIndex:4925},{level:2,title:"let vs. const",slug:"let-vs-const",normalizedTitle:"let vs. const",charIndex:5409},{level:2,title:"解构",slug:"解构",normalizedTitle:"解构",charIndex:5610},{level:3,title:"解构数组",slug:"解构数组",normalizedTitle:"解构数组",charIndex:5617},{level:3,title:"对象解构",slug:"对象解构",normalizedTitle:"对象解构",charIndex:6321},{level:3,title:"属性重命名",slug:"属性重命名",normalizedTitle:"属性重命名",charIndex:6586},{level:3,title:"默认值",slug:"默认值",normalizedTitle:"默认值",charIndex:6866},{level:3,title:"函数声明",slug:"函数声明",normalizedTitle:"函数声明",charIndex:7093},{level:2,title:"展开",slug:"展开",normalizedTitle:"展开",charIndex:7694}],headersStr:"var 声明 作用域规则 捕获变量怪异之处 let 声明 块作用域 重定义及屏蔽 块级作用域变量的获取 const 声明 let vs. const 解构 解构数组 对象解构 属性重命名 默认值 函数声明 展开",content:"# 变量声明\n\nlet 和 const 是 JavaScript 里相对较新的变量声明方式。let 在很多方面与 var 是相似的，但是可以帮助大家避免在 JavaScript 里常见一些问题。const 是对 let 的一个增强，它能阻止对一个变量再次赋值。\n\n因为 TypeScript 是 JavaScript 的超集，所以它本身就支持 let 和 const。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 var。\n\n如果你已经对 var 声明的怪异之处了如指掌，那么你可以轻松地略过这节。\n\n\n# var 声明\n\n在 ES5 的时代，我们都是通过 var 关键字定义JavaScript 变量：\n\nvar a = 10\n\n\n1\n\n\n大家都能理解，这里定义了一个名为 a 值为 10 的变量。\n\n我们也可以在函数内部定义变量：\n\nfunction f() {\n  var message = 'Hello World!'\n\n  return message\n}\n\n\n1\n2\n3\n4\n5\n\n\n并且我们也可以在其它函数内部访问相同的变量：\n\nfunction f() {\n  var a = 10\n  return function g() {\n    var b = a + 1\n    return b\n  }\n}\n\nvar g = f()\ng() // returns 11\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面的例子是一个典型的闭包场景，g 可以获取到 f 函数里定义的 a 变量。 每当 g 被调用时，它都可以访问到 f 里的 a 变量。 即使当 g 在 f 已经执行完后才被调用，它仍然可以访问 a。\n\n\n# 作用域规则\n\nvar 声明有些奇怪的作用域规则。 看下面的例子：\n\nfunction f(shouldInitialize) {\n  if (shouldInitialize) {\n    var x = 10\n  }\n\n  return x\n}\n\nf(true)  // returns '10'\nf(false) // returns 'undefined'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n有些同学可能要多看几遍这个例子。 变量 x 是定义在 if 语句里面，但是我们却可以在语句的外面访问它。 这是因为 var 声明的作用域是函数作用域，函数参数也使用函数作用域。\n\n这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：\n\nfunction sumMatrix(matrix) {\n  var sum = 0\n  for (var i = 0; i < matrix.length; i++) {\n    var currentRow = matrix[i]\n    for (var i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i]\n    }\n  }\n\n  return sum\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这里很容易看出一些问题，里层的 for 循环会覆盖变量 i，因为所有 i 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。\n\n\n# 捕获变量怪异之处\n\n猜一下下面的代码会返回什么：\n\nfor (var i = 0; i < 10; i++) {\n  setTimeout(function() {\n    console.log(i)\n  }, 100 * i)\n}\n\n\n1\n2\n3\n4\n5\n\n\n答案是，setTimeout 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）：\n\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n很多 JavaScript 程序员对这种行为已经很熟悉了，但如果你很不解也没有关系，因为你并不是一个人。 大多数人期望输出结果是这样：\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 我们传给 setTimeout 的每一个函数表达式实际上都引用了相同作用域里的同一个 i。\n\n让我们花点时间思考一下这是为什么。 setTimeout 在若干毫秒后执行一个函数，并且是在 for 循环结束后。for 循环结束后，i 的值为 10。 所以当函数被调用的时候，它会打印出 10。\n\n一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时 i 的值：\n\nfor (var i = 0; i < 10; i++) {\n  (function(i) {\n    setTimeout(function() {\n      console.log(i)\n    }, 100 * i)\n  })(i)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这种奇怪的形式我们已经司空见惯了。 参数 i 会覆盖 for 循环里的 i，但是因为我们起了同样的名字，所以我们不用怎么改 for 循环体里的代码。\n\n\n# let 声明\n\n现在你已经知道了 var 存在一些问题，这恰好说明了为什么用 let 语句来声明变量。 除了名字不同外， let 与 var 的写法一致：\n\nlet hello = 'Hello!'\n\n\n1\n\n\n主要的区别不在语法上，而是语义，我们接下来会深入研究。\n\n\n# 块作用域\n\n当用 let 声明一个变量，它使用的是块作用域。 不同于使用 var 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 for 循环之外是不能访问的。\n\nfunction f(input: boolean) {\n  let a = 100\n\n  if (input) {\n    // OK: 仍然能访问到 a\n    let b = a + 1\n    return b\n  }\n\n  // Error: 'b' 在这里不存在\n  return b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这里我们定义了 2 个变量 a 和 b。 a 的作用域是 f 函数体内，而 b 的作用域是 if 语句块里。\n\n在 catch 语句里声明的变量也具有同样的作用域规则。\n\ntry {\n  throw 'Oh no!';\n}\ncatch (e) {\n  console.log('Catch it.')\n}\n\n// Error: 'e' 在这里不存在\nconsole.log(e)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于暂时性死区。 它只是用来说明我们不能在 let 语句之前访问它们，幸运的是 TypeScript 可以告诉我们这些信息。\n\na++ // TS2448: Block-scoped variable 'a' used before its declaration.\nlet a\n\n\n1\n2\n\n\n注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 ES2015，现代的运行时会抛出一个错误；然而，现今 TypeScript 是不会报错的。\n\nfunction foo() {\n  // okay to capture 'a'\n  return a\n}\n\n// 不能在'a'被声明前调用'foo'\n// 运行时应该抛出错误\nfoo()\n\nlet a\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n关于暂时性死区的更多信息，查看这里 Mozilla Developer Network。\n\n\n# 重定义及屏蔽\n\n我们提过使用 var 声明时，它不在乎你声明多少次；你只会得到 1 个。\n\nfunction f(x) {\n  var x\n  var x\n\n  if (true) {\n    var x\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在上面的例子里，所有 x 的声明实际上都引用一个相同的x，并且这是完全有效的代码，但这经常会成为 bug 的来源。幸运的是 let 的声明就不会这么宽松了。\n\nlet x = 10\nlet x = 20 // 错误，不能在 1 个作用域里多次声明 x\n\n\n1\n2\n\n\n并不是要求两个均是块级作用域的声明 TypeScript 才会给出一个错误的警告。\n\nfunction f(x) {\n  let x = 100 // Error: 干扰参数声明\n}\n\nfunction g() {\n  let x = 100\n  var x = 100 // Error: 不能同时具有 x 的两个声明\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。\n\nfunction f(condition, x) {\n  if (condition) {\n    let x = 100\n    return x\n  }\n\n  return x\n}\n\nf(false, 0) // returns 0\nf(true, 0)  // returns 100\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 let 重写之前的 sumMatrix 函数。\n\nfunction sumMatrix(matrix: number[][]) {\n  let sum = 0\n  for (let i = 0; i < matrix.length; i++) {\n    let currentRow = matrix[i]\n    for (let i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i]\n    }\n  }\n\n  return sum\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这个版本的循环能得到正确的结果，因为内层循环的 i 可以屏蔽掉外层循环的 i。\n\n通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好权衡一下。\n\n\n# 块级作用域变量的获取\n\n每次进入一个作用域时，let 会创建一个变量的环境。就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。\n\n回想一下前面 setTimeout 的例子，我们最后需要使用立即执行的函数表达式来获取每次 for 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 TypeScript 里这样做了。\n\n当 let 声明出现在循环体里时拥有完全不同的行为。不仅是在循环里引入了一个新的变量环境，而且针对每次迭代都会创建这样一个新作用域，这就相当于我们在使用立即执行的函数表达式时做的事。所以在 setTimeout 例子里我们仅使用 let 声明就可以了。\n\nfor (let i = 0; i < 10 ; i++) {\n  setTimeout(function() {\n    console.log(i)\n  }, 100 * i)\n}\n\n\n1\n2\n3\n4\n5\n\n\n会输出与预料一致的结果：\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# const 声明\n\nconst 声明是声明变量的另一种方式。\n\nconst numLivesForCat = 9\n\n\n1\n\n\n它们与 let 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 let 相同的作用域规则，但是不能对它们重新赋值。\n\n这很好理解，它们引用的值是不可变的。\n\nconst numLivesForCat = 9\nconst kitty = {\n  name: 'Kitty',\n  numLives: numLivesForCat\n}\n\n// Error\nkitty = {\n  name: 'Tommy',\n  numLives: numLivesForCat\n};\n\n// OK\nkitty.name = 'Jerry'\nkitty.numLives--\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n除非你使用特殊的方法去避免，实际上 const 变量的内部状态是可修改的。 幸运的是，TypeScript 允许你将对象的成员设置成只读的。接口一章有详细说明。\n\n\n# let vs. const\n\n现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。与大多数泛泛的问题一样，答案是：依情况而定。\n\n使用最小特权原则，所有变量除了你计划去修改的都应该使用 const。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。使用 const 也可以让我们更容易的推测数据的流动。\n\n\n# 解构\n\n\n# 解构数组\n\n最简单的解构莫过于数组的解构赋值了：\n\nlet input = [1, 2]\nlet [first, second] = input\nconsole.log(first) // outputs 1\nconsole.log(second) // outputs 2\n\n\n1\n2\n3\n4\n\n\n这创建了 2 个命名变量 first 和 second。 相当于使用了索引，但更为方便：\n\nlet first = input[0]\nlet second = input[1]\n\n\n1\n2\n\n\n作用于函数参数：\n\nlet input: [number, number] = [1, 2]\n\nfunction f([first, second]: [number, number]) {\n  console.log(first)\n  console.log(second)\n}\n\nf(input)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n你可以在数组里使用 ... 语法创建剩余变量：\n\nlet [first, ...rest] = [1, 2, 3, 4]\nconsole.log(first) // outputs 1\nconsole.log(rest) // outputs [ 2, 3, 4 ]\n\n\n1\n2\n3\n\n\n你也可以忽略你不关心的尾随元素：\n\nlet [first] = [1, 2, 3, 4]\nconsole.log(first) // outputs 1\n\n\n1\n2\n\n\n或其它元素：\n\nlet [, second, , fourth] = [1, 2, 3, 4]\n\n\n1\n\n\n\n# 对象解构\n\n你也可以解构对象：\n\nlet o = {\n    a: 'foo',\n    b: 12,\n    c: 'bar'\n}\nlet { a, b } = o\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这通过 o.a 和 o.b 创建了 a 和 b 。 注意，如果你不需要 c 你可以忽略它。\n\n你可以在对象里使用 ... 语法创建剩余变量：\n\nlet { a, ...passthrough } = o\nlet total = passthrough.b + passthrough.c.length\n\n\n1\n2\n\n\n\n# 属性重命名\n\n你也可以给属性以不同的名字：\n\nlet { a: newName1, b: newName2 } = o\n\n\n1\n\n\n这里的语法开始变得混乱。 你可以将 a: newName1 读做 \"a 作为 newName1\"。 方向是从左到右，好像你写成了以下样子：\n\nlet newName1 = o.a\nlet newName2 = o.b\n\n\n1\n2\n\n\n令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型，仍然需要在其后写上完整的模式。\n\nlet {a, b}: {a: string, b: number} = o\n\n\n1\n\n\n\n# 默认值\n\n默认值可以让你在属性为 undefined 时使用缺省值：\n\nfunction keepWholeObject(wholeObject: { a: string, b?: number }) {\n  let { a, b = 1001 } = wholeObject\n}\n\n\n1\n2\n3\n\n\n现在，即使 b 为 undefined ， keepWholeObject 函数的变量 wholeObject 的属性 a 和 b 都会有值。\n\n\n# 函数声明\n\n解构也能用于函数声明。 看以下简单的情况：\n\ntype C = { a: string, b?: number }\nfunction f({ a, b }: C): void {\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\n但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。\n\nfunction f({ a = '', b = 0 } = {}): void {\n  // ...\n}\nf()\n\n\n1\n2\n3\n4\n\n\n> 上面的代码是一个类型推断的例子，将在后续章节介绍。\n\n其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：\n\nfunction f({ a, b = 0 } = { a: '' }): void {\n  // ...\n}\nf({ a: 'yes' }) // OK, 默认 b = 0\nf() // OK, 默认 a: '', b = 0\nf({}) // Error, 一旦传入参数则 a 是必须的\n\n\n1\n2\n3\n4\n5\n6\n\n\n要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。\n\n\n# 展开\n\nlet first = [1, 2]\nlet second = [3, 4]\nlet bothPlus = [0, ...first, ...second, 5]\n\n\n1\n2\n3\n\n\n这会令 bothPlus 的值为 [0, 1, 2, 3, 4, 5]。 展开操作创建了 first 和 second的 一份浅拷贝。 它们不会被展开操作所改变。\n\n你还可以展开对象：\n\nlet defaults = { food: 'spicy', price: '$10', ambiance: 'noisy' }\nlet search = { ...defaults, food: 'rich' }\n\n\n1\n2\n\n\nsearch的值为 { food: 'rich', price: '$10', ambiance: 'noisy' }。 对象的展开比数组的展开要复杂的多。像数组展开一样，它是从左至右进行处理，但结果仍为对象。这就意味着出现在展开对象后面的属性会覆盖前面的属性。因此，如果我们修改上面的例子，在结尾处进行展开的话：\n\nlet defaults = { food: 'spicy', price: '$10', ambiance: 'noisy' }\nlet search = { food: 'rich', ...defaults }\n\n\n1\n2\n\n\n那么，defaults 里的 food 属性会重写 food: 'rich'，在这里这并不是我们想要的结果。",normalizedContent:"# 变量声明\n\nlet 和 const 是 javascript 里相对较新的变量声明方式。let 在很多方面与 var 是相似的，但是可以帮助大家避免在 javascript 里常见一些问题。const 是对 let 的一个增强，它能阻止对一个变量再次赋值。\n\n因为 typescript 是 javascript 的超集，所以它本身就支持 let 和 const。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 var。\n\n如果你已经对 var 声明的怪异之处了如指掌，那么你可以轻松地略过这节。\n\n\n# var 声明\n\n在 es5 的时代，我们都是通过 var 关键字定义javascript 变量：\n\nvar a = 10\n\n\n1\n\n\n大家都能理解，这里定义了一个名为 a 值为 10 的变量。\n\n我们也可以在函数内部定义变量：\n\nfunction f() {\n  var message = 'hello world!'\n\n  return message\n}\n\n\n1\n2\n3\n4\n5\n\n\n并且我们也可以在其它函数内部访问相同的变量：\n\nfunction f() {\n  var a = 10\n  return function g() {\n    var b = a + 1\n    return b\n  }\n}\n\nvar g = f()\ng() // returns 11\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面的例子是一个典型的闭包场景，g 可以获取到 f 函数里定义的 a 变量。 每当 g 被调用时，它都可以访问到 f 里的 a 变量。 即使当 g 在 f 已经执行完后才被调用，它仍然可以访问 a。\n\n\n# 作用域规则\n\nvar 声明有些奇怪的作用域规则。 看下面的例子：\n\nfunction f(shouldinitialize) {\n  if (shouldinitialize) {\n    var x = 10\n  }\n\n  return x\n}\n\nf(true)  // returns '10'\nf(false) // returns 'undefined'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n有些同学可能要多看几遍这个例子。 变量 x 是定义在 if 语句里面，但是我们却可以在语句的外面访问它。 这是因为 var 声明的作用域是函数作用域，函数参数也使用函数作用域。\n\n这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：\n\nfunction summatrix(matrix) {\n  var sum = 0\n  for (var i = 0; i < matrix.length; i++) {\n    var currentrow = matrix[i]\n    for (var i = 0; i < currentrow.length; i++) {\n      sum += currentrow[i]\n    }\n  }\n\n  return sum\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这里很容易看出一些问题，里层的 for 循环会覆盖变量 i，因为所有 i 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。\n\n\n# 捕获变量怪异之处\n\n猜一下下面的代码会返回什么：\n\nfor (var i = 0; i < 10; i++) {\n  settimeout(function() {\n    console.log(i)\n  }, 100 * i)\n}\n\n\n1\n2\n3\n4\n5\n\n\n答案是，settimeout 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）：\n\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n很多 javascript 程序员对这种行为已经很熟悉了，但如果你很不解也没有关系，因为你并不是一个人。 大多数人期望输出结果是这样：\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 我们传给 settimeout 的每一个函数表达式实际上都引用了相同作用域里的同一个 i。\n\n让我们花点时间思考一下这是为什么。 settimeout 在若干毫秒后执行一个函数，并且是在 for 循环结束后。for 循环结束后，i 的值为 10。 所以当函数被调用的时候，它会打印出 10。\n\n一个通常的解决方法是使用立即执行的函数表达式（iife）来捕获每次迭代时 i 的值：\n\nfor (var i = 0; i < 10; i++) {\n  (function(i) {\n    settimeout(function() {\n      console.log(i)\n    }, 100 * i)\n  })(i)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这种奇怪的形式我们已经司空见惯了。 参数 i 会覆盖 for 循环里的 i，但是因为我们起了同样的名字，所以我们不用怎么改 for 循环体里的代码。\n\n\n# let 声明\n\n现在你已经知道了 var 存在一些问题，这恰好说明了为什么用 let 语句来声明变量。 除了名字不同外， let 与 var 的写法一致：\n\nlet hello = 'hello!'\n\n\n1\n\n\n主要的区别不在语法上，而是语义，我们接下来会深入研究。\n\n\n# 块作用域\n\n当用 let 声明一个变量，它使用的是块作用域。 不同于使用 var 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 for 循环之外是不能访问的。\n\nfunction f(input: boolean) {\n  let a = 100\n\n  if (input) {\n    // ok: 仍然能访问到 a\n    let b = a + 1\n    return b\n  }\n\n  // error: 'b' 在这里不存在\n  return b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这里我们定义了 2 个变量 a 和 b。 a 的作用域是 f 函数体内，而 b 的作用域是 if 语句块里。\n\n在 catch 语句里声明的变量也具有同样的作用域规则。\n\ntry {\n  throw 'oh no!';\n}\ncatch (e) {\n  console.log('catch it.')\n}\n\n// error: 'e' 在这里不存在\nconsole.log(e)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于暂时性死区。 它只是用来说明我们不能在 let 语句之前访问它们，幸运的是 typescript 可以告诉我们这些信息。\n\na++ // ts2448: block-scoped variable 'a' used before its declaration.\nlet a\n\n\n1\n2\n\n\n注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 es2015，现代的运行时会抛出一个错误；然而，现今 typescript 是不会报错的。\n\nfunction foo() {\n  // okay to capture 'a'\n  return a\n}\n\n// 不能在'a'被声明前调用'foo'\n// 运行时应该抛出错误\nfoo()\n\nlet a\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n关于暂时性死区的更多信息，查看这里 mozilla developer network。\n\n\n# 重定义及屏蔽\n\n我们提过使用 var 声明时，它不在乎你声明多少次；你只会得到 1 个。\n\nfunction f(x) {\n  var x\n  var x\n\n  if (true) {\n    var x\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在上面的例子里，所有 x 的声明实际上都引用一个相同的x，并且这是完全有效的代码，但这经常会成为 bug 的来源。幸运的是 let 的声明就不会这么宽松了。\n\nlet x = 10\nlet x = 20 // 错误，不能在 1 个作用域里多次声明 x\n\n\n1\n2\n\n\n并不是要求两个均是块级作用域的声明 typescript 才会给出一个错误的警告。\n\nfunction f(x) {\n  let x = 100 // error: 干扰参数声明\n}\n\nfunction g() {\n  let x = 100\n  var x = 100 // error: 不能同时具有 x 的两个声明\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。\n\nfunction f(condition, x) {\n  if (condition) {\n    let x = 100\n    return x\n  }\n\n  return x\n}\n\nf(false, 0) // returns 0\nf(true, 0)  // returns 100\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 let 重写之前的 summatrix 函数。\n\nfunction summatrix(matrix: number[][]) {\n  let sum = 0\n  for (let i = 0; i < matrix.length; i++) {\n    let currentrow = matrix[i]\n    for (let i = 0; i < currentrow.length; i++) {\n      sum += currentrow[i]\n    }\n  }\n\n  return sum\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这个版本的循环能得到正确的结果，因为内层循环的 i 可以屏蔽掉外层循环的 i。\n\n通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好权衡一下。\n\n\n# 块级作用域变量的获取\n\n每次进入一个作用域时，let 会创建一个变量的环境。就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。\n\n回想一下前面 settimeout 的例子，我们最后需要使用立即执行的函数表达式来获取每次 for 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 typescript 里这样做了。\n\n当 let 声明出现在循环体里时拥有完全不同的行为。不仅是在循环里引入了一个新的变量环境，而且针对每次迭代都会创建这样一个新作用域，这就相当于我们在使用立即执行的函数表达式时做的事。所以在 settimeout 例子里我们仅使用 let 声明就可以了。\n\nfor (let i = 0; i < 10 ; i++) {\n  settimeout(function() {\n    console.log(i)\n  }, 100 * i)\n}\n\n\n1\n2\n3\n4\n5\n\n\n会输出与预料一致的结果：\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# const 声明\n\nconst 声明是声明变量的另一种方式。\n\nconst numlivesforcat = 9\n\n\n1\n\n\n它们与 let 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 let 相同的作用域规则，但是不能对它们重新赋值。\n\n这很好理解，它们引用的值是不可变的。\n\nconst numlivesforcat = 9\nconst kitty = {\n  name: 'kitty',\n  numlives: numlivesforcat\n}\n\n// error\nkitty = {\n  name: 'tommy',\n  numlives: numlivesforcat\n};\n\n// ok\nkitty.name = 'jerry'\nkitty.numlives--\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n除非你使用特殊的方法去避免，实际上 const 变量的内部状态是可修改的。 幸运的是，typescript 允许你将对象的成员设置成只读的。接口一章有详细说明。\n\n\n# let vs. const\n\n现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。与大多数泛泛的问题一样，答案是：依情况而定。\n\n使用最小特权原则，所有变量除了你计划去修改的都应该使用 const。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。使用 const 也可以让我们更容易的推测数据的流动。\n\n\n# 解构\n\n\n# 解构数组\n\n最简单的解构莫过于数组的解构赋值了：\n\nlet input = [1, 2]\nlet [first, second] = input\nconsole.log(first) // outputs 1\nconsole.log(second) // outputs 2\n\n\n1\n2\n3\n4\n\n\n这创建了 2 个命名变量 first 和 second。 相当于使用了索引，但更为方便：\n\nlet first = input[0]\nlet second = input[1]\n\n\n1\n2\n\n\n作用于函数参数：\n\nlet input: [number, number] = [1, 2]\n\nfunction f([first, second]: [number, number]) {\n  console.log(first)\n  console.log(second)\n}\n\nf(input)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n你可以在数组里使用 ... 语法创建剩余变量：\n\nlet [first, ...rest] = [1, 2, 3, 4]\nconsole.log(first) // outputs 1\nconsole.log(rest) // outputs [ 2, 3, 4 ]\n\n\n1\n2\n3\n\n\n你也可以忽略你不关心的尾随元素：\n\nlet [first] = [1, 2, 3, 4]\nconsole.log(first) // outputs 1\n\n\n1\n2\n\n\n或其它元素：\n\nlet [, second, , fourth] = [1, 2, 3, 4]\n\n\n1\n\n\n\n# 对象解构\n\n你也可以解构对象：\n\nlet o = {\n    a: 'foo',\n    b: 12,\n    c: 'bar'\n}\nlet { a, b } = o\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这通过 o.a 和 o.b 创建了 a 和 b 。 注意，如果你不需要 c 你可以忽略它。\n\n你可以在对象里使用 ... 语法创建剩余变量：\n\nlet { a, ...passthrough } = o\nlet total = passthrough.b + passthrough.c.length\n\n\n1\n2\n\n\n\n# 属性重命名\n\n你也可以给属性以不同的名字：\n\nlet { a: newname1, b: newname2 } = o\n\n\n1\n\n\n这里的语法开始变得混乱。 你可以将 a: newname1 读做 \"a 作为 newname1\"。 方向是从左到右，好像你写成了以下样子：\n\nlet newname1 = o.a\nlet newname2 = o.b\n\n\n1\n2\n\n\n令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型，仍然需要在其后写上完整的模式。\n\nlet {a, b}: {a: string, b: number} = o\n\n\n1\n\n\n\n# 默认值\n\n默认值可以让你在属性为 undefined 时使用缺省值：\n\nfunction keepwholeobject(wholeobject: { a: string, b?: number }) {\n  let { a, b = 1001 } = wholeobject\n}\n\n\n1\n2\n3\n\n\n现在，即使 b 为 undefined ， keepwholeobject 函数的变量 wholeobject 的属性 a 和 b 都会有值。\n\n\n# 函数声明\n\n解构也能用于函数声明。 看以下简单的情况：\n\ntype c = { a: string, b?: number }\nfunction f({ a, b }: c): void {\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\n但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。\n\nfunction f({ a = '', b = 0 } = {}): void {\n  // ...\n}\nf()\n\n\n1\n2\n3\n4\n\n\n> 上面的代码是一个类型推断的例子，将在后续章节介绍。\n\n其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 c 的定义有一个 b 可选属性：\n\nfunction f({ a, b = 0 } = { a: '' }): void {\n  // ...\n}\nf({ a: 'yes' }) // ok, 默认 b = 0\nf() // ok, 默认 a: '', b = 0\nf({}) // error, 一旦传入参数则 a 是必须的\n\n\n1\n2\n3\n4\n5\n6\n\n\n要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。\n\n\n# 展开\n\nlet first = [1, 2]\nlet second = [3, 4]\nlet bothplus = [0, ...first, ...second, 5]\n\n\n1\n2\n3\n\n\n这会令 bothplus 的值为 [0, 1, 2, 3, 4, 5]。 展开操作创建了 first 和 second的 一份浅拷贝。 它们不会被展开操作所改变。\n\n你还可以展开对象：\n\nlet defaults = { food: 'spicy', price: '$10', ambiance: 'noisy' }\nlet search = { ...defaults, food: 'rich' }\n\n\n1\n2\n\n\nsearch的值为 { food: 'rich', price: '$10', ambiance: 'noisy' }。 对象的展开比数组的展开要复杂的多。像数组展开一样，它是从左至右进行处理，但结果仍为对象。这就意味着出现在展开对象后面的属性会覆盖前面的属性。因此，如果我们修改上面的例子，在结尾处进行展开的话：\n\nlet defaults = { food: 'spicy', price: '$10', ambiance: 'noisy' }\nlet search = { food: 'rich', ...defaults }\n\n\n1\n2\n\n\n那么，defaults 里的 food 属性会重写 food: 'rich'，在这里这并不是我们想要的结果。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"接口",frontmatter:{title:"接口",date:"2020-01-05T10:17:47.000Z",permalink:"/pages/54ea89b497ec3bb3",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","TypeScript 常用语法"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/02.TypeScript%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/03.%E6%8E%A5%E5%8F%A3.html",relativePath:"《TypeScript 从零实现 axios》/02.TypeScript 常用语法/03.接口.md",key:"v-7fa1e8d0",path:"/pages/54ea89b497ec3bb3/",headers:[{level:2,title:"接口初探",slug:"接口初探",normalizedTitle:"接口初探",charIndex:116},{level:2,title:"可选属性",slug:"可选属性",normalizedTitle:"可选属性",charIndex:986},{level:2,title:"只读属性",slug:"只读属性",normalizedTitle:"只读属性",charIndex:2229},{level:3,title:"readonly vs const",slug:"readonly-vs-const",normalizedTitle:"readonly vs const",charIndex:2813},{level:2,title:"额外的属性检查",slug:"额外的属性检查",normalizedTitle:"额外的属性检查",charIndex:2921},{level:2,title:"函数类型",slug:"函数类型",normalizedTitle:"函数类型",charIndex:4748},{level:2,title:"可索引的类型",slug:"可索引的类型",normalizedTitle:"可索引的类型",charIndex:5743},{level:2,title:"类类型",slug:"类类型",normalizedTitle:"类类型",charIndex:7034},{level:3,title:"实现接口",slug:"实现接口",normalizedTitle:"实现接口",charIndex:7042},{level:3,title:"类静态部分与实例部分的区别",slug:"类静态部分与实例部分的区别",normalizedTitle:"类静态部分与实例部分的区别",charIndex:7622},{level:2,title:"继承接口",slug:"继承接口",normalizedTitle:"继承接口",charIndex:8898},{level:2,title:"混合类型",slug:"混合类型",normalizedTitle:"混合类型",charIndex:9475},{level:2,title:"接口继承类",slug:"接口继承类",normalizedTitle:"接口继承类",charIndex:10027}],headersStr:"接口初探 可选属性 只读属性 readonly vs const 额外的属性检查 函数类型 可索引的类型 类类型 实现接口 类静态部分与实例部分的区别 继承接口 混合类型 接口继承类",content:"# 接口\n\nTypeScript 的核心原则之一是对值所具有的结构进行类型检查。它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。\n\n\n# 接口初探\n\n下面通过一个简单示例来观察接口是如何工作的：\n\nfunction printLabel(labelledObj: { label: string }) {\n  console.log(labelledObj.label)\n}\n\nlet myObj = { size: 10, label: 'Size 10 Object' }\nprintLabel(myObj)\n\n\n1\n2\n3\n4\n5\n6\n\n\n类型检查器会查看 printLabel 的调用。printLabel 有一个参数，并要求这个对象参数有一个名为 label 类型为 string 的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，以及其类型是否匹配。 然而，有些时候 TypeScript 却并不会这么宽松，我们下面会稍做讲解。\n\n下面我们重写上面的例子，这次使用接口来描述：必须包含一个label 属性且类型为 string：\n\ninterface LabelledValue {\n  label: string\n}\n\nfunction printLabel(labelledObj: LabelledValue) {\n  console.log(labelledObj.label)\n}\n\nlet myObj = {size: 10, label: 'Size 10 Object'}\nprintLabel(myObj)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nLabelledValue 接口就好比一个名字，用来描述上面例子里的结构。 它代表了有一个 label 属性且类型为string 的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 printLabel 的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。\n\n还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。\n\n\n# 可选属性\n\n接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。例如给函数传入的参数对象中只有部分属性赋值了。\n\ninterface Square {\n  color: string,\n  area: number\n}\n\ninterface SquareConfig {\n  color?: string\n  width?: number\n}\n\nfunction createSquare (config: SquareConfig): Square {\n  let newSquare = {color: 'white', area: 100}\n  if (config.color) {\n    newSquare.color = config.color\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width\n  }\n  return newSquare\n}\n\nlet mySquare = createSquare({color: 'black'})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 ? 符号。\n\n可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare 里的 color 属性名拼错，就会得到一个错误提示：\n\ninterface Square {\n  color: string,\n  area: number\n}\n\ninterface SquareConfig {\n   color?: string;\n   width?: number;\n}\n\nfunction createSquare(config: SquareConfig): Square {\n   let newSquare = {color: 'white', area: 100}\n   if (config.clor) {\n     // Error: 属性 'clor' 不存在于类型 'SquareConfig' 中\n     newSquare.color = config.clor\n   }\n   if (config.width) {\n     newSquare.area = config.width * config.width\n   }\n   return newSquare\n }\n\n let mySquare = createSquare({color: 'black'})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 只读属性\n\n一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly 来指定只读属性:\n\ninterface Point {\n  readonly x: number\n  readonly y: number\n}\n\n\n1\n2\n3\n4\n\n\n你可以通过赋值一个对象字面量来构造一个 Point。 赋值后，x 和 y 再也不能被改变了。\n\nlet p1: Point = { x: 10, y: 20 }\np1.x = 5 // error!\n\n\n1\n2\n\n\nTypeScript 具有 ReadonlyArray<T> 类型，它与 Array<T> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：\n\nlet a: number[] = [1, 2, 3, 4]\nlet ro: ReadonlyArray<number> = a\nro[0] = 12 // error!\nro.push(5) // error!\nro.length = 100 // error!\na = ro // error!\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码的最后一行，可以看到就算把整个 ReadonlyArray 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：\n\na = ro as number[]\n\n\n1\n\n\n\n# readonly vs const\n\n最简单判断该用 readonly 还是 const 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用 readonly。\n\n\n# 额外的属性检查\n\n我们在第一个例子里使用了接口，TypeScript 让我们传入 { size: number; label: string; } 到仅期望得到 { label: string; } 的函数里, 并且我们已经学过了可选属性。\n\n然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。 比如，拿 createSquare 例子来说：\n\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n}\n\nfunction createSquare (config: SquareConfig): { color: string; area: number } {\n  let newSquare = {color: 'white', area: 100}\n  if (config.color) {\n    newSquare.color = config.color\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width\n  }\n  return newSquare\n}\n\n\nlet mySquare = createSquare({ colour: 'red', width: 100 })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n注意传入 createSquare 的参数拼写为 colour 而不是 color。 在 JavaScript 里，这会默默地失败。\n\n你可能会争辩这个程序已经正确地类型化了，因为 width 属性是兼容的，不存在 color 属性，而且额外的 colour 属性是无意义的。\n\n然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。\n\n// error: 'colour' 不存在于类型 'SquareConfig' 中\nlet mySquare = createSquare({ colour: 'red', width: 100 })\n\n\n1\n2\n\n\n绕开这些检查非常简单。 最简便的方法是使用类型断言：\n\nlet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig)\n\n\n1\n\n\n然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig 带有上面定义的类型的 color 和 width 属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：\n\ninterface SquareConfig {\n  color?: string\n  width?: number\n  [propName: string]: any\n}\n\n\n1\n2\n3\n4\n5\n\n\n我们稍后会讲到索引签名，但在这我们要表示的是SquareConfig 可以有任意数量的属性，并且只要它们不是 color 和 width，那么就无所谓它们的类型是什么。\n\n还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 squareOptions 不会经过额外属性检查，所以编译器不会报错。\n\nlet squareOptions = { colour: 'red', width: 100 }\nlet mySquare = createSquare(squareOptions)\n\n\n1\n2\n\n\n要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大多数额外属性检查错误是真正的bug。也就是说你遇到了额外类型检查出的错误，你应该去审查一下你的类型声明。 在这里，如果支持传入 color 或 colour 属性到 createSquare，你应该修改 SquareConfig 定义来体现出这一点。\n\n\n# 函数类型\n\n接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。\n\n为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。\n\ninterface SearchFunc {\n  (source: string, subString: string): boolean\n}\n\n\n1\n2\n3\n\n\n这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。\n\nlet mySearch: SearchFunc\nmySearch = function(source: string, subString: string): boolean {\n  let result = source.search(subString);\n  return result > -1\n}\n\n\n1\n2\n3\n4\n5\n\n\n对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：\n\nlet mySearch: SearchFunc\nmySearch = function(src: string, sub: string): boolean {\n  let result = src.search(sub);\n  return result > -1\n}\n\n\n1\n2\n3\n4\n5\n\n\n函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc 类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false 和 true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc 接口中的定义不匹配。\n\nlet mySearch: SearchFunc\nmySearch = function(src, sub) {\n  let result = src.search(sub)\n  return result > -1\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 可索引的类型\n\n与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 a[10] 或 ageMap['daniel']。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：\n\ninterface StringArray {\n  [index: number]: string\n}\n\nlet myArray: StringArray\nmyArray = ['Bob', 'Fred']\n\nlet myStr: string = myArray[0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面例子里，我们定义了 StringArray 接口，它具有索引签名。 这个索引签名表示了当用 number 去索引 StringArray 时会得到 string 类型的返回值。\n\nTypeScript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number 来索引时，JavaScript 会将它转换成string 然后再去索引对象。 也就是说用 100（一个 number）去索引等同于使用'100'（一个 string ）去索引，因此两者需要保持一致。\n\nclass Animal {\n  name: string\n}\nclass Dog extends Animal {\n  breed: string\n}\n\n// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!\ninterface NotOkay {\n  [x: number]: Animal\n  [x: string]: Dog\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n字符串索引签名能够很好的描述 dictionary 模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property 和 obj['property'] 两种形式都可以。 下面的例子里， name 的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：\n\ninterface NumberDictionary {\n  [index: string]: number;\n  length: number;    // 可以，length是number类型\n  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配\n}\n\n\n1\n2\n3\n4\n5\n\n\n最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：\n\ninterface ReadonlyStringArray {\n  readonly [index: number]: string;\n}\nlet myArray: ReadonlyStringArray = ['Alice', 'Bob'];\nmyArray[2] = 'Mallory'; // error!\n\n\n1\n2\n3\n4\n5\n\n\n\n# 类类型\n\n\n# 实现接口\n\n与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。\n\ninterface ClockInterface {\n  currentTime: Date\n}\n\nclass Clock implements ClockInterface {\n  currentTime: Date\n  constructor(h: number, m: number) { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n你也可以在接口中描述一个方法，在类里实现它，如同下面的 setTime 方法一样：\n\ninterface ClockInterface {\n  currentTime: Date\n  setTime(d: Date)\n}\n\nclass Clock implements ClockInterface {\n  currentTime: Date\n  setTime(d: Date) {\n    this.currentTime = d\n  }\n  constructor(h: number, m: number) { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。\n\n\n# 类静态部分与实例部分的区别\n\n当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：\n\ninterface ClockConstructor {\n  new (hour: number, minute: number)\n}\n\n// error\nclass Clock implements ClockConstructor {\n  currentTime: Date\n  constructor(h: number, m: number) { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。constructor 存在于类的静态部分，所以不在检查的范围内。\n\n看下面的例子，我们定义了两个接口， ClockConstructor 为构造函数所用和 ClockInterface 为实例方法所用。 为了方便我们定义一个构造函数 createClock，它用传入的类型创建实例。\n\ninterface ClockConstructor {\n  new (hour: number, minute: number): ClockInterface\n}\ninterface ClockInterface {\n  tick()\n}\n\nfunction createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {\n  return new ctor(hour, minute)\n}\n\nclass DigitalClock implements ClockInterface {\n  constructor(h: number, m: number) { }\n  tick() {\n    console.log('beep beep')\n  }\n}\nclass AnalogClock implements ClockInterface {\n  constructor(h: number, m: number) { }\n  tick() {\n    console.log('tick tock')\n  }\n}\n\nlet digital = createClock(DigitalClock, 12, 17)\nlet analog = createClock(AnalogClock, 7, 32)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n因为 createClock 的第一个参数是 ClockConstructor 类型，在 createClock(AnalogClock, 7, 32) 里，会检查 AnalogClock 是否符合构造函数签名。\n\n\n# 继承接口\n\n和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。\n\ninterface Shape {\n  color: string\n}\n\ninterface Square extends Shape {\n  sideLength: number\n}\n\nlet square = {} as Square\nsquare.color = 'blue'\nsquare.sideLength = 10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n一个接口可以继承多个接口，创建出多个接口的合成接口。\n\ninterface Shape {\n  color: string\n}\n\ninterface PenStroke {\n  penWidth: number\n}\n\ninterface Square extends Shape, PenStroke {\n  sideLength: number\n}\n\nlet square = {} as Square\nsquare.color = 'blue'\nsquare.sideLength = 10\nsquare.penWidth = 5.0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 混合类型\n\n先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。\n\n一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。\n\ninterface Counter {\n  (start: number): string\n  interval: number\n  reset(): void\n}\n\nfunction getCounter(): Counter {\n  let counter = (function (start: number) { }) as Counter\n  counter.interval = 123\n  counter.reset = function () { }\n  return counter\n}\n\nlet c = getCounter()\nc(10)\nc.reset()\nc.interval = 5.0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。这门课要重构的 axios 库就是一个很好的例子。\n\n\n# 接口继承类\n\n当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 private 和 protected 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。\n\n当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。例：\n\nclass Control {\n  private state: any\n}\n\ninterface SelectableControl extends Control {\n  select(): void\n}\n\nclass Button extends Control implements SelectableControl {\n  select() { }\n}\n\nclass TextBox extends Control {\n  select() { }\n}\n\n// Error：“ImageC”类型缺少“state”属性。\nclass ImageC implements SelectableControl {\n  select() { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n在上面的例子里，SelectableControl 包含了 Control 的所有成员，包括私有成员 state。 因为 state 是私有成员，所以只能够是 Control 的子类们才能实现 SelectableControl 接口。 因为只有 Control 的子类才能够拥有一个声明于Control 的私有成员 state，这对私有成员的兼容性是必需的。\n\n在 Control 类内部，是允许通过 SelectableControl 的实例来访问私有成员 state 的。 实际上，SelectableControl 接口和拥有 select 方法的 Control 类是一样的。Button和 TextBox 类是 SelectableControl 的子类（因为它们都继承自Control 并有 select 方法），但 ImageC 类并不是这样的。",normalizedContent:"# 接口\n\ntypescript 的核心原则之一是对值所具有的结构进行类型检查。它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 typescript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。\n\n\n# 接口初探\n\n下面通过一个简单示例来观察接口是如何工作的：\n\nfunction printlabel(labelledobj: { label: string }) {\n  console.log(labelledobj.label)\n}\n\nlet myobj = { size: 10, label: 'size 10 object' }\nprintlabel(myobj)\n\n\n1\n2\n3\n4\n5\n6\n\n\n类型检查器会查看 printlabel 的调用。printlabel 有一个参数，并要求这个对象参数有一个名为 label 类型为 string 的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，以及其类型是否匹配。 然而，有些时候 typescript 却并不会这么宽松，我们下面会稍做讲解。\n\n下面我们重写上面的例子，这次使用接口来描述：必须包含一个label 属性且类型为 string：\n\ninterface labelledvalue {\n  label: string\n}\n\nfunction printlabel(labelledobj: labelledvalue) {\n  console.log(labelledobj.label)\n}\n\nlet myobj = {size: 10, label: 'size 10 object'}\nprintlabel(myobj)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nlabelledvalue 接口就好比一个名字，用来描述上面例子里的结构。 它代表了有一个 label 属性且类型为string 的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 printlabel 的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。\n\n还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。\n\n\n# 可选属性\n\n接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。例如给函数传入的参数对象中只有部分属性赋值了。\n\ninterface square {\n  color: string,\n  area: number\n}\n\ninterface squareconfig {\n  color?: string\n  width?: number\n}\n\nfunction createsquare (config: squareconfig): square {\n  let newsquare = {color: 'white', area: 100}\n  if (config.color) {\n    newsquare.color = config.color\n  }\n  if (config.width) {\n    newsquare.area = config.width * config.width\n  }\n  return newsquare\n}\n\nlet mysquare = createsquare({color: 'black'})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 ? 符号。\n\n可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createsquare 里的 color 属性名拼错，就会得到一个错误提示：\n\ninterface square {\n  color: string,\n  area: number\n}\n\ninterface squareconfig {\n   color?: string;\n   width?: number;\n}\n\nfunction createsquare(config: squareconfig): square {\n   let newsquare = {color: 'white', area: 100}\n   if (config.clor) {\n     // error: 属性 'clor' 不存在于类型 'squareconfig' 中\n     newsquare.color = config.clor\n   }\n   if (config.width) {\n     newsquare.area = config.width * config.width\n   }\n   return newsquare\n }\n\n let mysquare = createsquare({color: 'black'})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 只读属性\n\n一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly 来指定只读属性:\n\ninterface point {\n  readonly x: number\n  readonly y: number\n}\n\n\n1\n2\n3\n4\n\n\n你可以通过赋值一个对象字面量来构造一个 point。 赋值后，x 和 y 再也不能被改变了。\n\nlet p1: point = { x: 10, y: 20 }\np1.x = 5 // error!\n\n\n1\n2\n\n\ntypescript 具有 readonlyarray<t> 类型，它与 array<t> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：\n\nlet a: number[] = [1, 2, 3, 4]\nlet ro: readonlyarray<number> = a\nro[0] = 12 // error!\nro.push(5) // error!\nro.length = 100 // error!\na = ro // error!\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码的最后一行，可以看到就算把整个 readonlyarray 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：\n\na = ro as number[]\n\n\n1\n\n\n\n# readonly vs const\n\n最简单判断该用 readonly 还是 const 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用 readonly。\n\n\n# 额外的属性检查\n\n我们在第一个例子里使用了接口，typescript 让我们传入 { size: number; label: string; } 到仅期望得到 { label: string; } 的函数里, 并且我们已经学过了可选属性。\n\n然而，天真地将这两者结合的话就会像在 javascript 里那样搬起石头砸自己的脚。 比如，拿 createsquare 例子来说：\n\ninterface squareconfig {\n    color?: string;\n    width?: number;\n}\n\nfunction createsquare (config: squareconfig): { color: string; area: number } {\n  let newsquare = {color: 'white', area: 100}\n  if (config.color) {\n    newsquare.color = config.color\n  }\n  if (config.width) {\n    newsquare.area = config.width * config.width\n  }\n  return newsquare\n}\n\n\nlet mysquare = createsquare({ colour: 'red', width: 100 })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n注意传入 createsquare 的参数拼写为 colour 而不是 color。 在 javascript 里，这会默默地失败。\n\n你可能会争辩这个程序已经正确地类型化了，因为 width 属性是兼容的，不存在 color 属性，而且额外的 colour 属性是无意义的。\n\n然而，typescript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。\n\n// error: 'colour' 不存在于类型 'squareconfig' 中\nlet mysquare = createsquare({ colour: 'red', width: 100 })\n\n\n1\n2\n\n\n绕开这些检查非常简单。 最简便的方法是使用类型断言：\n\nlet mysquare = createsquare({ width: 100, opacity: 0.5 } as squareconfig)\n\n\n1\n\n\n然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 squareconfig 带有上面定义的类型的 color 和 width 属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：\n\ninterface squareconfig {\n  color?: string\n  width?: number\n  [propname: string]: any\n}\n\n\n1\n2\n3\n4\n5\n\n\n我们稍后会讲到索引签名，但在这我们要表示的是squareconfig 可以有任意数量的属性，并且只要它们不是 color 和 width，那么就无所谓它们的类型是什么。\n\n还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 squareoptions 不会经过额外属性检查，所以编译器不会报错。\n\nlet squareoptions = { colour: 'red', width: 100 }\nlet mysquare = createsquare(squareoptions)\n\n\n1\n2\n\n\n要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大多数额外属性检查错误是真正的bug。也就是说你遇到了额外类型检查出的错误，你应该去审查一下你的类型声明。 在这里，如果支持传入 color 或 colour 属性到 createsquare，你应该修改 squareconfig 定义来体现出这一点。\n\n\n# 函数类型\n\n接口能够描述 javascript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。\n\n为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。\n\ninterface searchfunc {\n  (source: string, substring: string): boolean\n}\n\n\n1\n2\n3\n\n\n这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。\n\nlet mysearch: searchfunc\nmysearch = function(source: string, substring: string): boolean {\n  let result = source.search(substring);\n  return result > -1\n}\n\n\n1\n2\n3\n4\n5\n\n\n对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：\n\nlet mysearch: searchfunc\nmysearch = function(src: string, sub: string): boolean {\n  let result = src.search(sub);\n  return result > -1\n}\n\n\n1\n2\n3\n4\n5\n\n\n函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，typescript 的类型系统会推断出参数类型，因为函数直接赋值给了 searchfunc 类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false 和 true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 searchfunc 接口中的定义不匹配。\n\nlet mysearch: searchfunc\nmysearch = function(src, sub) {\n  let result = src.search(sub)\n  return result > -1\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 可索引的类型\n\n与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 a[10] 或 agemap['daniel']。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：\n\ninterface stringarray {\n  [index: number]: string\n}\n\nlet myarray: stringarray\nmyarray = ['bob', 'fred']\n\nlet mystr: string = myarray[0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面例子里，我们定义了 stringarray 接口，它具有索引签名。 这个索引签名表示了当用 number 去索引 stringarray 时会得到 string 类型的返回值。\n\ntypescript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number 来索引时，javascript 会将它转换成string 然后再去索引对象。 也就是说用 100（一个 number）去索引等同于使用'100'（一个 string ）去索引，因此两者需要保持一致。\n\nclass animal {\n  name: string\n}\nclass dog extends animal {\n  breed: string\n}\n\n// 错误：使用数值型的字符串索引，有时会得到完全不同的animal!\ninterface notokay {\n  [x: number]: animal\n  [x: string]: dog\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n字符串索引签名能够很好的描述 dictionary 模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property 和 obj['property'] 两种形式都可以。 下面的例子里， name 的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：\n\ninterface numberdictionary {\n  [index: string]: number;\n  length: number;    // 可以，length是number类型\n  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配\n}\n\n\n1\n2\n3\n4\n5\n\n\n最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：\n\ninterface readonlystringarray {\n  readonly [index: number]: string;\n}\nlet myarray: readonlystringarray = ['alice', 'bob'];\nmyarray[2] = 'mallory'; // error!\n\n\n1\n2\n3\n4\n5\n\n\n\n# 类类型\n\n\n# 实现接口\n\n与 c# 或 java 里接口的基本作用一样，typescript 也能够用它来明确的强制一个类去符合某种契约。\n\ninterface clockinterface {\n  currenttime: date\n}\n\nclass clock implements clockinterface {\n  currenttime: date\n  constructor(h: number, m: number) { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n你也可以在接口中描述一个方法，在类里实现它，如同下面的 settime 方法一样：\n\ninterface clockinterface {\n  currenttime: date\n  settime(d: date)\n}\n\nclass clock implements clockinterface {\n  currenttime: date\n  settime(d: date) {\n    this.currenttime = d\n  }\n  constructor(h: number, m: number) { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。\n\n\n# 类静态部分与实例部分的区别\n\n当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：\n\ninterface clockconstructor {\n  new (hour: number, minute: number)\n}\n\n// error\nclass clock implements clockconstructor {\n  currenttime: date\n  constructor(h: number, m: number) { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。constructor 存在于类的静态部分，所以不在检查的范围内。\n\n看下面的例子，我们定义了两个接口， clockconstructor 为构造函数所用和 clockinterface 为实例方法所用。 为了方便我们定义一个构造函数 createclock，它用传入的类型创建实例。\n\ninterface clockconstructor {\n  new (hour: number, minute: number): clockinterface\n}\ninterface clockinterface {\n  tick()\n}\n\nfunction createclock(ctor: clockconstructor, hour: number, minute: number): clockinterface {\n  return new ctor(hour, minute)\n}\n\nclass digitalclock implements clockinterface {\n  constructor(h: number, m: number) { }\n  tick() {\n    console.log('beep beep')\n  }\n}\nclass analogclock implements clockinterface {\n  constructor(h: number, m: number) { }\n  tick() {\n    console.log('tick tock')\n  }\n}\n\nlet digital = createclock(digitalclock, 12, 17)\nlet analog = createclock(analogclock, 7, 32)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n因为 createclock 的第一个参数是 clockconstructor 类型，在 createclock(analogclock, 7, 32) 里，会检查 analogclock 是否符合构造函数签名。\n\n\n# 继承接口\n\n和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。\n\ninterface shape {\n  color: string\n}\n\ninterface square extends shape {\n  sidelength: number\n}\n\nlet square = {} as square\nsquare.color = 'blue'\nsquare.sidelength = 10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n一个接口可以继承多个接口，创建出多个接口的合成接口。\n\ninterface shape {\n  color: string\n}\n\ninterface penstroke {\n  penwidth: number\n}\n\ninterface square extends shape, penstroke {\n  sidelength: number\n}\n\nlet square = {} as square\nsquare.color = 'blue'\nsquare.sidelength = 10\nsquare.penwidth = 5.0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 混合类型\n\n先前我们提过，接口能够描述 javascript 里丰富的类型。 因为 javascript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。\n\n一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。\n\ninterface counter {\n  (start: number): string\n  interval: number\n  reset(): void\n}\n\nfunction getcounter(): counter {\n  let counter = (function (start: number) { }) as counter\n  counter.interval = 123\n  counter.reset = function () { }\n  return counter\n}\n\nlet c = getcounter()\nc(10)\nc.reset()\nc.interval = 5.0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n在使用 javascript 第三方库的时候，你可能需要像上面那样去完整地定义类型。这门课要重构的 axios 库就是一个很好的例子。\n\n\n# 接口继承类\n\n当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 private 和 protected 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。\n\n当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。例：\n\nclass control {\n  private state: any\n}\n\ninterface selectablecontrol extends control {\n  select(): void\n}\n\nclass button extends control implements selectablecontrol {\n  select() { }\n}\n\nclass textbox extends control {\n  select() { }\n}\n\n// error：“imagec”类型缺少“state”属性。\nclass imagec implements selectablecontrol {\n  select() { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n在上面的例子里，selectablecontrol 包含了 control 的所有成员，包括私有成员 state。 因为 state 是私有成员，所以只能够是 control 的子类们才能实现 selectablecontrol 接口。 因为只有 control 的子类才能够拥有一个声明于control 的私有成员 state，这对私有成员的兼容性是必需的。\n\n在 control 类内部，是允许通过 selectablecontrol 的实例来访问私有成员 state 的。 实际上，selectablecontrol 接口和拥有 select 方法的 control 类是一样的。button和 textbox 类是 selectablecontrol 的子类（因为它们都继承自control 并有 select 方法），但 imagec 类并不是这样的。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"类",frontmatter:{title:"类",date:"2020-01-05T10:17:47.000Z",permalink:"/pages/fad060bd9a8bfac6",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","TypeScript 常用语法"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/02.TypeScript%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/04.%E7%B1%BB.html",relativePath:"《TypeScript 从零实现 axios》/02.TypeScript 常用语法/04.类.md",key:"v-32676bf1",path:"/pages/fad060bd9a8bfac6/",headers:[{level:2,title:"基本示例",slug:"基本示例",normalizedTitle:"基本示例",charIndex:261},{level:2,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:37},{level:2,title:"公共，私有与受保护的修饰符",slug:"公共-私有与受保护的修饰符",normalizedTitle:"公共，私有与受保护的修饰符",charIndex:2412},{level:3,title:"默认为 public",slug:"默认为-public",normalizedTitle:"默认为 public",charIndex:2430},{level:3,title:"理解 private",slug:"理解-private",normalizedTitle:"理解 private",charIndex:2849},{level:3,title:"理解 protected",slug:"理解-protected",normalizedTitle:"理解 protected",charIndex:4117},{level:2,title:"readonly 修饰符",slug:"readonly-修饰符",normalizedTitle:"readonly 修饰符",charIndex:5477},{level:3,title:"参数属性",slug:"参数属性",normalizedTitle:"参数属性",charIndex:5715},{level:2,title:"存取器",slug:"存取器",normalizedTitle:"存取器",charIndex:6127},{level:2,title:"静态属性",slug:"静态属性",normalizedTitle:"静态属性",charIndex:7353},{level:2,title:"抽象类",slug:"抽象类",normalizedTitle:"抽象类",charIndex:8171},{level:2,title:"高级技巧",slug:"高级技巧",normalizedTitle:"高级技巧",charIndex:9400},{level:3,title:"构造函数",slug:"构造函数",normalizedTitle:"构造函数",charIndex:578},{level:3,title:"把类当做接口使用",slug:"把类当做接口使用",normalizedTitle:"把类当做接口使用",charIndex:11355}],headersStr:"基本示例 继承 公共，私有与受保护的修饰符 默认为 public 理解 private 理解 protected readonly 修饰符 参数属性 存取器 静态属性 抽象类 高级技巧 构造函数 把类当做接口使用",content:"# 类\n\n对于传统的 JavaScript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。\n\n\n# 基本示例\n\n下面看一个使用类的例子：\n\nclass Greeter {\n  greeting: string\n  constructor(message: string) {\n    this.greeting = message\n  }\n  greet() {\n    return 'Hello, ' + this.greeting\n  }\n}\n\nlet greeter = new Greeter('world')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果你使用过 C# 或 Java，你会对这种语法非常熟悉。 我们声明一个 Greeter 类。这个类有 3 个成员：一个叫做 greeting 的属性，一个构造函数和一个 greet 方法。\n\n你会注意到，我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。\n\n最后一行，我们使用 new 构造了 Greeter 类的一个实例。它会调用之前定义的构造函数，创建一个 Greeter 类型的新对象，并执行构造函数初始化它。\n\n\n# 继承\n\n在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。\n\n看下面的例子：\n\nclass Animal {\n  move(distance: number = 0) {\n    console.log(`Animal moved ${distance}m.`)\n  }\n}\n\nclass Dog extends Animal {\n  bark() {\n    console.log('Woof! Woof!')\n  }\n}\n\nconst dog = new Dog()\ndog.bark()\ndog.move(10)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，Dog 是一个 派生类，它派生自 Animal 基类，通过 extends 关键字。 派生类通常被称作子类，基类通常被称作超类。\n\n因为 Dog 继承了 Animal 的功能，因此我们可以创建一个 Dog 的实例，它能够 bark() 和 move()。\n\n下面我们来看个更加复杂的例子。\n\nclass Animal {\n  name: string\n  constructor(name: string) {\n    this.name = name\n  }\n  move(distance: number = 0) {\n    console.log(`${this.name} moved ${distance}m.`)\n  }\n}\n\nclass Snake extends Animal {\n  constructor(name: string) {\n    super(name)\n  }\n  move(distance: number = 5) {\n    console.log('Slithering...')\n    super.move(distance)\n  }\n}\n\nclass Horse extends Animal {\n  constructor(name: string) {\n    super(name)\n  }\n  move(distance: number = 45) {\n    console.log('Galloping...')\n    super.move(distance)\n  }\n}\n\nlet sam = new Snake('Sammy')\nlet tom: Animal = new Horse('Tommy')\n\nsam.move()\ntom.move(34)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n这个例子展示了一些上面没有提到的特性。 这一次，我们使用 extends 关键字创建了 Animal的两个子类：Horse 和 Snake。\n\n与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this 的属性之前，我们 一定要调用 super()。 这个是 TypeScript 强制执行的一条重要规则。\n\n这个例子演示了如何在子类里可以重写父类的方法。Snake类和 Horse 类都创建了 move 方法，它们重写了从 Animal 继承来的 move 方法，使得 move 方法根据不同的类而具有不同的功能。注意，即使 tom 被声明为 Animal 类型，但因为它的值是 Horse，调用 tom.move(34) 时，它会调用 Horse 里重写的方法。\n\nSlithering...\nSammy moved 5m.\nGalloping...\nTommy moved 34m.\n\n\n1\n2\n3\n4\n\n\n\n# 公共，私有与受保护的修饰符\n\n\n# 默认为 public\n\n在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 public 来做修饰；例如，C# 要求必须明确地使用 public 指定成员是可见的。 在 TypeScript 里，成员都默认为 public。\n\n你也可以明确的将一个成员标记成 public。 我们可以用下面的方式来重写上面的 Animal 类：\n\nclass Animal {\n  public name: string\n  public constructor(name: string) {\n    this.name = name\n  }\n  public move(distance: number) {\n    console.log(`${this.name} moved ${distance}m.`)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 理解 private\n\n当成员被标记成 private 时，它就不能在声明它的类的外部访问。比如：\n\nclass Animal {\n  private name: string\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nnew Animal('Cat').name // 错误: 'name' 是私有的.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nTypeScript 使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。\n\n然而，当我们比较带有 private 或 protected 成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private 成员，那么只有当另外一个类型中也存在这样一个 private 成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected 成员也使用这个规则。\n\n下面来看一个例子，更好地说明了这一点：\n\nclass Animal {\n  private name: string\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nclass Rhino extends Animal {\n  constructor() {\n    super('Rhino')\n  }\n}\n\nclass Employee {\n  private name: string\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nlet animal = new Animal('Goat')\nlet rhino = new Rhino()\nlet employee = new Employee('Bob')\n\nanimal = rhino\nanimal = employee // 错误: Animal 与 Employee 不兼容.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n这个例子中有 Animal 和 Rhino 两个类， Rhino 是 Animal 类的子类。 还有一个 Employee 类，其类型看上去与 Animal 是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 Animal 和 Rhino 共享了来自 Animal 里的私有成员定义 private name: string，因此它们是兼容的。然而 Employee 却不是这样。当把 Employee 赋值给 Animal 的时候，得到一个错误，说它们的类型不兼容。尽管 Employee 里也有一个私有成员 name，但它明显不是 Animal 里面定义的那个。\n\n\n# 理解 protected\n\nprotected 修饰符与 private 修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问。例如：\n\nclass Person {\n  protected name: string\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nclass Employee extends Person {\n  private department: string\n\n  constructor(name: string, department: string) {\n    super(name)\n    this.department = department\n  }\n\n  getElevatorPitch() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`\n  }\n}\n\nlet howard = new Employee('Howard', 'Sales')\nconsole.log(howard.getElevatorPitch())\nconsole.log(howard.name) // error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n注意，我们不能在 Person 类外使用 name，但是我们仍然可以通过 Employee 类的实例方法访问，因为 Employee 是由 Person 派生而来的。\n\n构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如：\n\nclass Person {\n  protected name: string\n  protected constructor(name: string) {\n    this.name = name\n  }\n}\n\n// Employee 能够继承 Person\nclass Employee extends Person {\n  private department: string\n\n  constructor(name: string, department: string) {\n    super(name)\n    this.department = department\n  }\n\n  public getElevatorPitch() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`\n  }\n}\n\nlet howard = new Employee('Howard', 'Sales')\nlet john = new Person('John') // 错误: 'Person' 的构造函数是被保护的.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# readonly 修饰符\n\n你可以使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。\n\nclass Person {\n  readonly name: string\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nlet john = new Person('John')\njohn.name = 'peter'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 参数属性\n\n在上面的例子中，我们必须在 Person 类里定义一个只读成员 name 和一个参数为 name 的构造函数，并且立刻将 name 的值赋给 this.name，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 Person 类的修改版，使用了参数属性：\n\nclass Person {\n  constructor(readonly name: string) {\n  }\n}\n\n\n1\n2\n3\n4\n\n\n注意看我们是如何舍弃参数 name，仅在构造函数里使用 readonly name: string 参数来创建和初始化 name 成员。 我们把声明和赋值合并至一处。\n\n参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 private 限定一个参数属性会声明并初始化一个私有成员；对于 public 和 protected 来说也是一样。\n\n\n# 存取器\n\nTypeScript 支持通过 getters/setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。\n\n下面来看如何把一个简单的类改写成使用 get 和 set。 首先，我们从一个没有使用存取器的例子开始。\n\nclass Employee {\n  fullName: string\n}\n\nlet employee = new Employee()\nemployee.fullName = 'Bob Smith'\nif (employee.fullName) {\n  console.log(employee.fullName)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n我们可以设置 fullName，因为它是 public 的，有时候当我们去修改它的时候触发一些额外逻辑，存取器就派上用场了。\n\n下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。我们把对 fullName 的直接访问改成了可以检查密码的 set 方法。 我们也加了一个 get 方法，让上面的例子仍然可以工作。\n\nlet passcode = 'secret passcode'\n\nclass Employee {\n  private _fullName: string\n\n  get fullName(): string {\n    return this._fullName\n  }\n\n  set fullName(newName: string) {\n    if (passcode && passcode == 'secret passcode') {\n      this._fullName = newName\n    }\n    else {\n      console.log('Error: Unauthorized update of employee!')\n    }\n  }\n}\n\nlet employee = new Employee()\nemployee.fullName = 'Bob Smith'\nif (employee.fullName) {\n  console.log(employee.fullName)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。\n\n对于存取器有下面几点需要注意的：\n\n首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。其次，只带有 get 不带有 set 的存取器自动被推断为 readonly。这在从代码生成 .d.ts 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。\n\n\n# 静态属性\n\n到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 static 定义 origin，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 origin 前面加上类名。 如同在实例属性上使用 this.xxx 来访问属性一样，这里我们使用 Grid.xxx 来访问静态属性。\n\nclass Grid {\n  static origin = {x: 0, y: 0}\n\n  scale: number\n\n  constructor (scale: number) {\n    this.scale = scale\n  }\n\n  calculateDistanceFromOrigin(point: {x: number; y: number}) {\n    let xDist = point.x - Grid.origin.x\n    let yDist = point.y - Grid.origin.y\n    return Math.sqrt(xDist * xDist + yDist * yDist) * this.scale\n  }\n}\n\nlet grid1 = new Grid(1.0)  // 1x scale\nlet grid2 = new Grid(5.0)  // 5x scale\n\nconsole.log(grid1.calculateDistanceFromOrigin({x: 3, y: 4}))\nconsole.log(grid2.calculateDistanceFromOrigin({x: 3, y: 4}))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 抽象类\n\n抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。 abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。\n\nabstract class Animal {\n  abstract makeSound(): void\n  move(): void {\n    console.log('roaming the earth...')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 abstract 关键字并且可以包含访问修饰符。\n\nabstract class Department {\n  name: string\n\n  constructor(name: string) {\n     this.name = name\n  }\n\n  printName(): void {\n    console.log('Department name: ' + this.name)\n  }\n\n  abstract printMeeting(): void // 必须在派生类中实现\n}\n\nclass AccountingDepartment extends Department {\n  constructor() {\n    super('Accounting and Auditing') // 在派生类的构造函数中必须调用 super()\n  }\n\n  printMeeting(): void {\n    console.log('The Accounting Department meets each Monday at 10am.')\n  }\n\n  generateReports(): void {\n    console.log('Generating accounting reports...')\n  }\n}\n\nlet department: Department // 允许创建一个对抽象类型的引用\ndepartment = new Department() // 错误: 不能创建一个抽象类的实例\ndepartment = new AccountingDepartment() // 允许对一个抽象子类进行实例化和赋值\ndepartment.printName()\ndepartment.printMeeting()\ndepartment.generateReports() // 错误: 方法在声明的抽象类中不存在\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 高级技巧\n\n\n# 构造函数\n\n当你在 TypeScript 里声明了一个类的时候，实际上同时声明了很多东西。首先就是类的实例的类型。\n\nclass Greeter {\n  static standardGreeting = 'Hello, there'\n  greeting: string\n  constructor(message: string) {\n    this.greeting = message\n  }\n  greet() {\n    return 'Hello, ' + this.greeting\n  }\n}\n\nlet greeter: Greeter\ngreeter = new Greeter('world')\nconsole.log(greeter.greet())\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这里，我们写了 let greeter: Greeter，意思是 Greeter 类的实例的类型是 Greeter。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。\n\n我们也创建了一个叫做构造函数的值。 这个函数会在我们使用 new 创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：\n\nvar Greeter = /** @class */ (function () {\n  function Greeter(message) {\n    this.greeting = message;\n  }\n  Greeter.prototype.greet = function () {\n    return 'Hello, ' + this.greeting;\n  };\n  Greeter.standardGreeting = 'Hello, there';\n  return Greeter;\n}());\nvar greeter;\ngreeter = new Greeter('world');\nconsole.log(greeter.greet());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面的代码里，var Greeter 将被构造函数赋值。 当我们调用 new 并执行了这个函数后，便会得到一个类的实例。这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有实例部分与静态部分这两个部分。\n\n让我们稍微改写一下这个例子，看看它们之间的区别：\n\nclass Greeter {\n  static standardGreeting = 'Hello, there'\n\n  greeting: string\n\n  constructor(message?: string) {\n    this.greeting = message\n  }\n\n  greet() {\n    if (this.greeting) {\n      return 'Hello, ' + this.greeting\n    } else {\n      return Greeter.standardGreeting\n    }\n  }\n}\n\nlet greeter: Greeter\ngreeter = new Greeter()\nconsole.log(greeter.greet())\n\nlet greeterMaker: typeof Greeter = Greeter\ngreeterMaker.standardGreeting = 'Hey there'\n\nlet greeter2: Greeter = new greeterMaker()\nconsole.log(greeter2.greet())\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n这个例子里， greeter1 与之前看到的一样。 我们实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。\n\n再之后，我们直接使用类。 我们创建了一个叫做 greeterMaker 的变量。这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 typeof Greeter，意思是取 Greeter 类的类型，而不是实例的类型。或者更确切的说，\"告诉我 Greeter 标识符的类型\"，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 greeterMaker 上使用 new，创建 Greeter 的实例。\n\n\n# 把类当做接口使用\n\n如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。\n\nclass Point {\n  x: number\n  y: number\n}\n\ninterface Point3d extends Point {\n  z: number\n}\n\nlet point3d: Point3d = {x: 1, y: 2, z: 3}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",normalizedContent:"# 类\n\n对于传统的 javascript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ecmascript 2015，也就是 es6 开始， javascript 程序员将能够使用基于类的面向对象的方式。 使用 typescript，我们允许开发者现在就使用这些特性，并且编译后的 javascript 可以在所有主流浏览器和平台上运行，而不需要等到下个 javascript 版本。\n\n\n# 基本示例\n\n下面看一个使用类的例子：\n\nclass greeter {\n  greeting: string\n  constructor(message: string) {\n    this.greeting = message\n  }\n  greet() {\n    return 'hello, ' + this.greeting\n  }\n}\n\nlet greeter = new greeter('world')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果你使用过 c# 或 java，你会对这种语法非常熟悉。 我们声明一个 greeter 类。这个类有 3 个成员：一个叫做 greeting 的属性，一个构造函数和一个 greet 方法。\n\n你会注意到，我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。\n\n最后一行，我们使用 new 构造了 greeter 类的一个实例。它会调用之前定义的构造函数，创建一个 greeter 类型的新对象，并执行构造函数初始化它。\n\n\n# 继承\n\n在 typescript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。\n\n看下面的例子：\n\nclass animal {\n  move(distance: number = 0) {\n    console.log(`animal moved ${distance}m.`)\n  }\n}\n\nclass dog extends animal {\n  bark() {\n    console.log('woof! woof!')\n  }\n}\n\nconst dog = new dog()\ndog.bark()\ndog.move(10)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，dog 是一个 派生类，它派生自 animal 基类，通过 extends 关键字。 派生类通常被称作子类，基类通常被称作超类。\n\n因为 dog 继承了 animal 的功能，因此我们可以创建一个 dog 的实例，它能够 bark() 和 move()。\n\n下面我们来看个更加复杂的例子。\n\nclass animal {\n  name: string\n  constructor(name: string) {\n    this.name = name\n  }\n  move(distance: number = 0) {\n    console.log(`${this.name} moved ${distance}m.`)\n  }\n}\n\nclass snake extends animal {\n  constructor(name: string) {\n    super(name)\n  }\n  move(distance: number = 5) {\n    console.log('slithering...')\n    super.move(distance)\n  }\n}\n\nclass horse extends animal {\n  constructor(name: string) {\n    super(name)\n  }\n  move(distance: number = 45) {\n    console.log('galloping...')\n    super.move(distance)\n  }\n}\n\nlet sam = new snake('sammy')\nlet tom: animal = new horse('tommy')\n\nsam.move()\ntom.move(34)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n这个例子展示了一些上面没有提到的特性。 这一次，我们使用 extends 关键字创建了 animal的两个子类：horse 和 snake。\n\n与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this 的属性之前，我们 一定要调用 super()。 这个是 typescript 强制执行的一条重要规则。\n\n这个例子演示了如何在子类里可以重写父类的方法。snake类和 horse 类都创建了 move 方法，它们重写了从 animal 继承来的 move 方法，使得 move 方法根据不同的类而具有不同的功能。注意，即使 tom 被声明为 animal 类型，但因为它的值是 horse，调用 tom.move(34) 时，它会调用 horse 里重写的方法。\n\nslithering...\nsammy moved 5m.\ngalloping...\ntommy moved 34m.\n\n\n1\n2\n3\n4\n\n\n\n# 公共，私有与受保护的修饰符\n\n\n# 默认为 public\n\n在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 public 来做修饰；例如，c# 要求必须明确地使用 public 指定成员是可见的。 在 typescript 里，成员都默认为 public。\n\n你也可以明确的将一个成员标记成 public。 我们可以用下面的方式来重写上面的 animal 类：\n\nclass animal {\n  public name: string\n  public constructor(name: string) {\n    this.name = name\n  }\n  public move(distance: number) {\n    console.log(`${this.name} moved ${distance}m.`)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 理解 private\n\n当成员被标记成 private 时，它就不能在声明它的类的外部访问。比如：\n\nclass animal {\n  private name: string\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nnew animal('cat').name // 错误: 'name' 是私有的.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ntypescript 使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。\n\n然而，当我们比较带有 private 或 protected 成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private 成员，那么只有当另外一个类型中也存在这样一个 private 成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected 成员也使用这个规则。\n\n下面来看一个例子，更好地说明了这一点：\n\nclass animal {\n  private name: string\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nclass rhino extends animal {\n  constructor() {\n    super('rhino')\n  }\n}\n\nclass employee {\n  private name: string\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nlet animal = new animal('goat')\nlet rhino = new rhino()\nlet employee = new employee('bob')\n\nanimal = rhino\nanimal = employee // 错误: animal 与 employee 不兼容.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n这个例子中有 animal 和 rhino 两个类， rhino 是 animal 类的子类。 还有一个 employee 类，其类型看上去与 animal 是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 animal 和 rhino 共享了来自 animal 里的私有成员定义 private name: string，因此它们是兼容的。然而 employee 却不是这样。当把 employee 赋值给 animal 的时候，得到一个错误，说它们的类型不兼容。尽管 employee 里也有一个私有成员 name，但它明显不是 animal 里面定义的那个。\n\n\n# 理解 protected\n\nprotected 修饰符与 private 修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问。例如：\n\nclass person {\n  protected name: string\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nclass employee extends person {\n  private department: string\n\n  constructor(name: string, department: string) {\n    super(name)\n    this.department = department\n  }\n\n  getelevatorpitch() {\n    return `hello, my name is ${this.name} and i work in ${this.department}.`\n  }\n}\n\nlet howard = new employee('howard', 'sales')\nconsole.log(howard.getelevatorpitch())\nconsole.log(howard.name) // error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n注意，我们不能在 person 类外使用 name，但是我们仍然可以通过 employee 类的实例方法访问，因为 employee 是由 person 派生而来的。\n\n构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如：\n\nclass person {\n  protected name: string\n  protected constructor(name: string) {\n    this.name = name\n  }\n}\n\n// employee 能够继承 person\nclass employee extends person {\n  private department: string\n\n  constructor(name: string, department: string) {\n    super(name)\n    this.department = department\n  }\n\n  public getelevatorpitch() {\n    return `hello, my name is ${this.name} and i work in ${this.department}.`\n  }\n}\n\nlet howard = new employee('howard', 'sales')\nlet john = new person('john') // 错误: 'person' 的构造函数是被保护的.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# readonly 修饰符\n\n你可以使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。\n\nclass person {\n  readonly name: string\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nlet john = new person('john')\njohn.name = 'peter'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 参数属性\n\n在上面的例子中，我们必须在 person 类里定义一个只读成员 name 和一个参数为 name 的构造函数，并且立刻将 name 的值赋给 this.name，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 person 类的修改版，使用了参数属性：\n\nclass person {\n  constructor(readonly name: string) {\n  }\n}\n\n\n1\n2\n3\n4\n\n\n注意看我们是如何舍弃参数 name，仅在构造函数里使用 readonly name: string 参数来创建和初始化 name 成员。 我们把声明和赋值合并至一处。\n\n参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 private 限定一个参数属性会声明并初始化一个私有成员；对于 public 和 protected 来说也是一样。\n\n\n# 存取器\n\ntypescript 支持通过 getters/setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。\n\n下面来看如何把一个简单的类改写成使用 get 和 set。 首先，我们从一个没有使用存取器的例子开始。\n\nclass employee {\n  fullname: string\n}\n\nlet employee = new employee()\nemployee.fullname = 'bob smith'\nif (employee.fullname) {\n  console.log(employee.fullname)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n我们可以设置 fullname，因为它是 public 的，有时候当我们去修改它的时候触发一些额外逻辑，存取器就派上用场了。\n\n下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。我们把对 fullname 的直接访问改成了可以检查密码的 set 方法。 我们也加了一个 get 方法，让上面的例子仍然可以工作。\n\nlet passcode = 'secret passcode'\n\nclass employee {\n  private _fullname: string\n\n  get fullname(): string {\n    return this._fullname\n  }\n\n  set fullname(newname: string) {\n    if (passcode && passcode == 'secret passcode') {\n      this._fullname = newname\n    }\n    else {\n      console.log('error: unauthorized update of employee!')\n    }\n  }\n}\n\nlet employee = new employee()\nemployee.fullname = 'bob smith'\nif (employee.fullname) {\n  console.log(employee.fullname)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。\n\n对于存取器有下面几点需要注意的：\n\n首先，存取器要求你将编译器设置为输出 ecmascript 5 或更高。 不支持降级到 ecmascript 3。其次，只带有 get 不带有 set 的存取器自动被推断为 readonly。这在从代码生成 .d.ts 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。\n\n\n# 静态属性\n\n到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 static 定义 origin，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 origin 前面加上类名。 如同在实例属性上使用 this.xxx 来访问属性一样，这里我们使用 grid.xxx 来访问静态属性。\n\nclass grid {\n  static origin = {x: 0, y: 0}\n\n  scale: number\n\n  constructor (scale: number) {\n    this.scale = scale\n  }\n\n  calculatedistancefromorigin(point: {x: number; y: number}) {\n    let xdist = point.x - grid.origin.x\n    let ydist = point.y - grid.origin.y\n    return math.sqrt(xdist * xdist + ydist * ydist) * this.scale\n  }\n}\n\nlet grid1 = new grid(1.0)  // 1x scale\nlet grid2 = new grid(5.0)  // 5x scale\n\nconsole.log(grid1.calculatedistancefromorigin({x: 3, y: 4}))\nconsole.log(grid2.calculatedistancefromorigin({x: 3, y: 4}))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 抽象类\n\n抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。 abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。\n\nabstract class animal {\n  abstract makesound(): void\n  move(): void {\n    console.log('roaming the earth...')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 abstract 关键字并且可以包含访问修饰符。\n\nabstract class department {\n  name: string\n\n  constructor(name: string) {\n     this.name = name\n  }\n\n  printname(): void {\n    console.log('department name: ' + this.name)\n  }\n\n  abstract printmeeting(): void // 必须在派生类中实现\n}\n\nclass accountingdepartment extends department {\n  constructor() {\n    super('accounting and auditing') // 在派生类的构造函数中必须调用 super()\n  }\n\n  printmeeting(): void {\n    console.log('the accounting department meets each monday at 10am.')\n  }\n\n  generatereports(): void {\n    console.log('generating accounting reports...')\n  }\n}\n\nlet department: department // 允许创建一个对抽象类型的引用\ndepartment = new department() // 错误: 不能创建一个抽象类的实例\ndepartment = new accountingdepartment() // 允许对一个抽象子类进行实例化和赋值\ndepartment.printname()\ndepartment.printmeeting()\ndepartment.generatereports() // 错误: 方法在声明的抽象类中不存在\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 高级技巧\n\n\n# 构造函数\n\n当你在 typescript 里声明了一个类的时候，实际上同时声明了很多东西。首先就是类的实例的类型。\n\nclass greeter {\n  static standardgreeting = 'hello, there'\n  greeting: string\n  constructor(message: string) {\n    this.greeting = message\n  }\n  greet() {\n    return 'hello, ' + this.greeting\n  }\n}\n\nlet greeter: greeter\ngreeter = new greeter('world')\nconsole.log(greeter.greet())\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这里，我们写了 let greeter: greeter，意思是 greeter 类的实例的类型是 greeter。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。\n\n我们也创建了一个叫做构造函数的值。 这个函数会在我们使用 new 创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成javascript后是什么样子的：\n\nvar greeter = /** @class */ (function () {\n  function greeter(message) {\n    this.greeting = message;\n  }\n  greeter.prototype.greet = function () {\n    return 'hello, ' + this.greeting;\n  };\n  greeter.standardgreeting = 'hello, there';\n  return greeter;\n}());\nvar greeter;\ngreeter = new greeter('world');\nconsole.log(greeter.greet());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面的代码里，var greeter 将被构造函数赋值。 当我们调用 new 并执行了这个函数后，便会得到一个类的实例。这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有实例部分与静态部分这两个部分。\n\n让我们稍微改写一下这个例子，看看它们之间的区别：\n\nclass greeter {\n  static standardgreeting = 'hello, there'\n\n  greeting: string\n\n  constructor(message?: string) {\n    this.greeting = message\n  }\n\n  greet() {\n    if (this.greeting) {\n      return 'hello, ' + this.greeting\n    } else {\n      return greeter.standardgreeting\n    }\n  }\n}\n\nlet greeter: greeter\ngreeter = new greeter()\nconsole.log(greeter.greet())\n\nlet greetermaker: typeof greeter = greeter\ngreetermaker.standardgreeting = 'hey there'\n\nlet greeter2: greeter = new greetermaker()\nconsole.log(greeter2.greet())\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n这个例子里， greeter1 与之前看到的一样。 我们实例化 greeter类，并使用这个对象。 与我们之前看到的一样。\n\n再之后，我们直接使用类。 我们创建了一个叫做 greetermaker 的变量。这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 typeof greeter，意思是取 greeter 类的类型，而不是实例的类型。或者更确切的说，\"告诉我 greeter 标识符的类型\"，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 greetermaker 上使用 new，创建 greeter 的实例。\n\n\n# 把类当做接口使用\n\n如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。\n\nclass point {\n  x: number\n  y: number\n}\n\ninterface point3d extends point {\n  z: number\n}\n\nlet point3d: point3d = {x: 1, y: 2, z: 3}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"函数",frontmatter:{title:"函数",date:"2020-01-05T10:17:47.000Z",permalink:"/pages/870a51ba2a9edfad",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","TypeScript 常用语法"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/02.TypeScript%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/05.%E5%87%BD%E6%95%B0.html",relativePath:"《TypeScript 从零实现 axios》/02.TypeScript 常用语法/05.函数.md",key:"v-8507e4da",path:"/pages/870a51ba2a9edfad/",headers:[{level:2,title:"基本示例",slug:"基本示例",normalizedTitle:"基本示例",charIndex:151},{level:2,title:"函数类型",slug:"函数类型",normalizedTitle:"函数类型",charIndex:608},{level:3,title:"为函数定义类型",slug:"为函数定义类型",normalizedTitle:"为函数定义类型",charIndex:617},{level:3,title:"书写完整函数类型",slug:"书写完整函数类型",normalizedTitle:"书写完整函数类型",charIndex:858},{level:3,title:"推断类型",slug:"推断类型",normalizedTitle:"推断类型",charIndex:1481},{level:2,title:"可选参数和默认参数",slug:"可选参数和默认参数",normalizedTitle:"可选参数和默认参数",charIndex:1783},{level:3,title:"剩余参数",slug:"剩余参数",normalizedTitle:"剩余参数",charIndex:3749},{level:2,title:"this",slug:"this",normalizedTitle:"this",charIndex:4437},{level:3,title:"this 和箭头函数",slug:"this-和箭头函数",normalizedTitle:"this 和箭头函数",charIndex:4758},{level:3,title:"this 参数",slug:"this-参数",normalizedTitle:"this 参数",charIndex:6252},{level:3,title:"this 参数在回调函数里",slug:"this-参数在回调函数里",normalizedTitle:"this 参数在回调函数里",charIndex:7319},{level:2,title:"重载",slug:"重载",normalizedTitle:"重载",charIndex:8695}],headersStr:"基本示例 函数类型 为函数定义类型 书写完整函数类型 推断类型 可选参数和默认参数 剩余参数 this this 和箭头函数 this 参数 this 参数在回调函数里 重载",content:"# 函数\n\n函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。\n\n\n# 基本示例\n\n和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。你可以随意选择适合应用程序的方式，不论是定义一系列 API 函数还是只使用一次的函数。\n\n通过下面的例子可以迅速回想起这两种 JavaScript 中的函数：\n\n// 命名函数\nfunction add(x, y) {\n  return x + y\n}\n\n// 匿名函数\nlet myAdd = function(x, y) {\n  return x + y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n在 JavaScript 里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习 JavaScript 和 TypeScript 会很有帮助。\n\nlet z = 100\n\nfunction addToZ(x, y) {\n  return x + y + z\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 函数类型\n\n\n# 为函数定义类型\n\n让我们为上面那个函数添加类型：\n\nfunction add(x: number, y: number): number {\n  return x + y\n}\n\nlet myAdd = function(x: number, y: number): number {\n  return x + y\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n我们可以给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript 能够根据返回语句自动推断出返回值类型。\n\n\n# 书写完整函数类型\n\n现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。\n\nlet myAdd: (x: number, y: number) => number =\nfunction(x: number, y: number): number {\n  return x + y\n}\n\n\n\n1\n2\n3\n4\n5\n\n\n函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。这个名字只是为了增加可读性。 我们也可以这么写：\n\nlet myAdd: (baseValue: number, increment: number) => number =\nfunction(x: number, y: number): number {\n  return x + y\n}\n\n\n1\n2\n3\n4\n\n\n只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。\n\n第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用(=>)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 void 而不能留空。\n\n函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成 API 的一部分。\n\n\n# 推断类型\n\n尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型：\n\nlet myAdd = function(x: number, y: number): number {\n  return x + y\n}\n\nlet myAdd: (baseValue: number, increment: number) => number =\nfunction(x, y) {\n  return x + y\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这叫做“按上下文归类”，是类型推论的一种。它帮助我们更好地为程序指定类型。\n\n\n# 可选参数和默认参数\n\nTypeScript 里的每个函数参数都是必须的。 这不是指不能传递 null 或 undefined 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。\n\nfunction buildName(firstName: string, lastName: string) {\n    return firstName + ' ' + lastName;\n}\n\nlet result1 = buildName('Bob')                  // Error, 参数过少\nlet result2 = buildName('Bob', 'Adams', 'Sr.');  // Error, 参数过多\nlet result3 = buildName('Bob', 'Adams');         // OK\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nJavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined。 在TypeScript 里我们可以在参数名旁使用 ? 实现可选参数的功能。 比如，我们想让 lastName 是可选的：\n\nfunction buildName(firstName: string, lastName?: string): string {\n  if (lastName)\n    return firstName + ' ' + lastName\n  else\n    return firstName\n}\n\nlet result1 = buildName('Bob');  // 现在正常了\nlet result2 = buildName('Bob', 'Adams', 'Sr.')  // Error, 参数过多\nlet result3 = buildName('Bob', 'Adams')  // OK\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n可选参数必须跟在必须参数后面。 如果上例我们想让 firstName 是可选的，那么就必须调整它们的位置，把 firstName 放在后面。\n\n在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 undefined 时。 它们叫做有默认初始化值的参数。 让我们修改上例，把lastName 的默认值设置为 \"Smith\"。\n\nfunction buildName(firstName: string, lastName = 'Smith'): string {\n  return firstName + ' ' + lastName\n}\n\nlet result1 = buildName('Bob')                  // 返回 \"Bob Smith\"\nlet result2 = buildName('Bob', undefined)     // 正常, 同样 \"Bob Smith\"\nlet result3 = buildName('Bob', 'Adams', 'Sr.')  // 错误, 参数过多\nlet result4 = buildName('Bob', 'Adams')        // OK\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 undefined 值来获得默认值。 例如，我们重写最后一个例子，让 firstName 是带默认值的参数：\n\nfunction buildName(firstName = 'Will', lastName: string): string {\n  return firstName + ' ' + lastName\n}\n\nlet result1 = buildName('Bob')                  // Error, 参数过少\nlet result2 = buildName('Bob', 'Adams', \"Sr.\")  // Error, 参数过多\nlet result3 = buildName('Bob', 'Adams')         // OK， 返回 \"Bob Adams\"\nlet result4 = buildName(undefined, 'Adams')     // OK，  返回 \"Will Adams\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 剩余参数\n\n必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 arguments 来访问所有传入的参数。\n\n在 TypeScript 里，你可以把所有参数收集到一个变量里：\n\nfunction buildName(firstName: string, ...restOfName: string[]): string {\n  return firstName + ' ' + restOfName.join(' ')\n}\n\nlet employeeName = buildName('Joseph', 'Samuel', 'Lucas', 'MacKinzie')\n\n\n1\n2\n3\n4\n5\n\n\n剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ ...）后面给定的名字，你可以在函数体内使用这个数组。\n\n这个省略号也会在带有剩余参数的函数类型定义上使用到：\n\nfunction buildName(firstName: string, ...restOfName: string[]): string {\n  return firstName + ' ' + restOfName.join(' ')\n}\n\nlet buildNameFun: (fname: string, ...rest: string[]) => string = buildName\n\n\n1\n2\n3\n4\n5\n\n\n\n# this\n\n学习如何在 JavaScript 里正确使用 this 就好比一场成年礼。由于 TypeScript 是 JavaScript 的超集，TypeScript 程序员也需要弄清 this 工作机制并且当有 bug 的时候能够找出错误所在。 幸运的是，TypeScript 能通知你错误地使用了 this 的地方。 如果你想了解 JavaScript 里的 this是如何工作的，那么首先阅读 Yehuda Katz 写的 Understanding JavaScript Function Invocation and \"this\"。 Yehuda 的文章详细的阐述了 this 的内部工作原理，因此我们这里只做简单介绍。\n\n\n# this 和箭头函数\n\nJavaScript里，this 的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。\n\n下面看一个例子：\n\nlet deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: Array(52),\n  createCardPicker: function() {\n    return function() {\n      let pickedCard = Math.floor(Math.random() * 52)\n      let pickedSuit = Math.floor(pickedCard / 13)\n\n      return {suit: this.suits[pickedSuit], card: pickedCard % 13}\n    }\n  }\n}\n\nlet cardPicker = deck.createCardPicker()\nlet pickedCard = cardPicker()\n\nconsole.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n可以看到 createCardPicker 是个函数，并且它又返回了一个函数。如果我们尝试运行这个程序，会发现它并没有输出而是报错了。 因为 createCardPicker 返回的函数里的 this 被设置成了 global 而不是 deck 对象。 因为我们只是独立的调用了 cardPicker()。 顶级的非方法式调用会将 this 视为 global。\n\n为了解决这个问题，我们可以在函数被返回时就绑好正确的this。 这样的话，无论之后怎么使用它，都会引用绑定的deck 对象。 我们需要改变函数表达式来使用 ECMAScript 6 箭头语法。 箭头函数能保存函数创建时的 this 值，而不是调用时的值：\n\nlet deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: Array(52),\n  createCardPicker: function() {\n    // 注意：这里使用箭头函数\n    return () => {\n      let pickedCard = Math.floor(Math.random() * 52)\n      let pickedSuit = Math.floor(pickedCard / 13)\n\n      return {suit: this.suits[pickedSuit], card: pickedCard % 13}\n    }\n  }\n}\n\nlet cardPicker = deck.createCardPicker()\nlet pickedCard = cardPicker()\n\nconsole.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# this 参数\n\n在上述的例子中 this.suits[pickedSuit] 的类型为 any，这是因为 this 来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 this 参数。 this 参数是个假的参数，它出现在参数列表的最前面：\n\nfunction f(this: void) {\n  // 确保“this”在此独立函数中不可用\n}\n\n\n1\n2\n3\n\n\n让我们往例子里添加一些接口，Card 和 Deck，让类型重用能够变得清晰简单些：\n\ninterface Card {\n  suit: string\n  card: number\n}\n\ninterface Deck {\n  suits: string[]\n  cards: number[]\n\n  createCardPicker (this: Deck): () => Card\n}\n\nlet deck: Deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: Array(52),\n  // NOTE: 函数现在显式指定其被调用方必须是 deck 类型\n  createCardPicker: function (this: Deck) {\n    return () => {\n      let pickedCard = Math.floor(Math.random() * 52)\n      let pickedSuit = Math.floor(pickedCard / 13)\n\n      return {suit: this.suits[pickedSuit], card: pickedCard % 13}\n    }\n  }\n}\n\nlet cardPicker = deck.createCardPicker()\nlet pickedCard = cardPicker()\n\nconsole.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n现在 TypeScrip t知道 createCardPicker 期望在某个 Deck 对象上调用。也就是说 this 是 Deck 类型的，而非 any。\n\n\n# this 参数在回调函数里\n\n你可以也看到过在回调函数里的 this 报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用，this 将为 undefined。 稍做改动，你就可以通过 this 参数来避免错误。 首先，库函数的作者要指定 this 的类型：\n\ninterface UIElement {\n  addClickListener(onclick: (this: void, e: Event) => void): void\n}\n\n\n1\n2\n3\n\n\nthis: void 意味着 addClickListener 期望传入的 onclick 方法不需要 this\n\ninterface UIElement {\n  addClickListener (onclick: (this: void, e: Event) => void): void\n}\n\nclass Handler {\n  type: string\n\n  onClickBad (this: Handler, e: Event) {\n    this.type = e.type\n  }\n}\n\nlet h = new Handler()\n\nlet uiElement: UIElement = {\n  addClickListener () {\n  }\n}\n\nuiElement.addClickListener(h.onClickBad) // error!\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n指定了 this 类型后，你显式声明 onClickBad 必须在 Handler 的实例上调用。 然后 TypeScript 会检测到 addClickListener 要求函数带有 this: void。 改变 this 类型来修复这个错误：\n\nclass Handler {\n  type: string;\n\n  onClickBad (this: void, e: Event) {\n    console.log('clicked!')\n  }\n}\n\nlet h = new Handler()\n\nlet uiElement: UIElement = {\n  addClickListener () {\n  }\n}\n\nuiElement.addClickListener(h.onClickBad)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n因为 onClickGood 指定了 this 类型为 void，因此传递 addClickListener 是合法的。 当然了，这也意味着不能使用 this.info。 如果你两者都想要，你不得不使用箭头函数了：\n\nclass Handler {\n  type: string\n  onClickGood = (e: Event) => {\n    this.type = e.type\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这是可行的因为箭头函数不会捕获 this，所以你总是可以把它们传给期望 this: void 的函数。\n\n\n# 重载\n\nJavaScript 本身是个动态语言。JavaScript 里函数根据传入不同的参数而返回不同类型的数据的场景是很常见的。\n\nlet suits = ['hearts', 'spades', 'clubs', 'diamonds']\n\nfunction pickCard(x): any {\n  if (Array.isArray(x)) {\n    let pickedCard = Math.floor(Math.random() * x.length)\n    return pickedCard\n  } else if (typeof x === 'number') {\n    let pickedSuit = Math.floor(x / 13)\n    return { suit: suits[pickedSuit], card: x % 13 }\n  }\n}\n\nlet myDeck = [\n  { suit: 'diamonds', card: 2 },\n  { suit: 'spades', card: 10 },\n  { suit: 'hearts', card: 4 }\n]\nlet pickedCard1 = myDeck[pickCard(myDeck)];\nconsole.log('card: ' + pickedCard1.card + ' of ' + pickedCard1.suit)\n\nlet pickedCard2 = pickCard(15)\nconsole.log('card: ' + pickedCard2.card + ' of ' + pickedCard2.suit)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\npickCard 方法根据传入参数的不同会返回两种不同的类型。如果传入的是代表纸牌的对象数组，函数作用是从中抓一张牌。如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。\n\n方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 pickCard 函数。\n\nlet suits = ['hearts', 'spades', 'clubs', 'diamonds']\n\nfunction pickCard(x: {suit: string; card: number }[]): number\nfunction pickCard(x: number): {suit: string; card: number }\n\nfunction pickCard(x): any {\n  if (Array.isArray(x)) {\n    let pickedCard = Math.floor(Math.random() * x.length)\n    return pickedCard\n  } else if (typeof x === 'number') {\n    let pickedSuit = Math.floor(x / 13)\n    return { suit: suits[pickedSuit], card: x % 13 }\n  }\n}\n\nlet myDeck = [\n  { suit: 'diamonds', card: 2 },\n  { suit: 'spades', card: 10 },\n  { suit: 'hearts', card: 4 }\n]\nlet pickedCard1 = myDeck[pickCard(myDeck)];\nconsole.log('card: ' + pickedCard1.card + ' of ' + pickedCard1.suit)\n\nlet pickedCard2 = pickCard(15)\nconsole.log('card: ' + pickedCard2.card + ' of ' + pickedCard2.suit)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n这样改变后，重载的 pickCard 函数在调用的时候会进行正确的类型检查。\n\n为了让编译器能够选择正确的检查类型，它与 JavaScript 里的处理流程相似。它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。因此，在定义重载的时候，一定要把最精确的定义放在最前面。\n\n注意，function pickCard(x): any 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象数组，另一个接收数字。 以其它参数调用 pickCard 会产生错误。",normalizedContent:"# 函数\n\n函数是 javascript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 typescript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。typescript 为 javascript 函数添加了额外的功能，让我们可以更容易地使用。\n\n\n# 基本示例\n\n和 javascript 一样，typescript 函数可以创建有名字的函数和匿名函数。你可以随意选择适合应用程序的方式，不论是定义一系列 api 函数还是只使用一次的函数。\n\n通过下面的例子可以迅速回想起这两种 javascript 中的函数：\n\n// 命名函数\nfunction add(x, y) {\n  return x + y\n}\n\n// 匿名函数\nlet myadd = function(x, y) {\n  return x + y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n在 javascript 里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习 javascript 和 typescript 会很有帮助。\n\nlet z = 100\n\nfunction addtoz(x, y) {\n  return x + y + z\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 函数类型\n\n\n# 为函数定义类型\n\n让我们为上面那个函数添加类型：\n\nfunction add(x: number, y: number): number {\n  return x + y\n}\n\nlet myadd = function(x: number, y: number): number {\n  return x + y\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n我们可以给每个参数添加类型之后再为函数本身添加返回值类型。typescript 能够根据返回语句自动推断出返回值类型。\n\n\n# 书写完整函数类型\n\n现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。\n\nlet myadd: (x: number, y: number) => number =\nfunction(x: number, y: number): number {\n  return x + y\n}\n\n\n\n1\n2\n3\n4\n5\n\n\n函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。这个名字只是为了增加可读性。 我们也可以这么写：\n\nlet myadd: (basevalue: number, increment: number) => number =\nfunction(x: number, y: number): number {\n  return x + y\n}\n\n\n1\n2\n3\n4\n\n\n只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。\n\n第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用(=>)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 void 而不能留空。\n\n函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成 api 的一部分。\n\n\n# 推断类型\n\n尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，typescript 编译器会自动识别出类型：\n\nlet myadd = function(x: number, y: number): number {\n  return x + y\n}\n\nlet myadd: (basevalue: number, increment: number) => number =\nfunction(x, y) {\n  return x + y\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这叫做“按上下文归类”，是类型推论的一种。它帮助我们更好地为程序指定类型。\n\n\n# 可选参数和默认参数\n\ntypescript 里的每个函数参数都是必须的。 这不是指不能传递 null 或 undefined 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。\n\nfunction buildname(firstname: string, lastname: string) {\n    return firstname + ' ' + lastname;\n}\n\nlet result1 = buildname('bob')                  // error, 参数过少\nlet result2 = buildname('bob', 'adams', 'sr.');  // error, 参数过多\nlet result3 = buildname('bob', 'adams');         // ok\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\njavascript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined。 在typescript 里我们可以在参数名旁使用 ? 实现可选参数的功能。 比如，我们想让 lastname 是可选的：\n\nfunction buildname(firstname: string, lastname?: string): string {\n  if (lastname)\n    return firstname + ' ' + lastname\n  else\n    return firstname\n}\n\nlet result1 = buildname('bob');  // 现在正常了\nlet result2 = buildname('bob', 'adams', 'sr.')  // error, 参数过多\nlet result3 = buildname('bob', 'adams')  // ok\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n可选参数必须跟在必须参数后面。 如果上例我们想让 firstname 是可选的，那么就必须调整它们的位置，把 firstname 放在后面。\n\n在 typescript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 undefined 时。 它们叫做有默认初始化值的参数。 让我们修改上例，把lastname 的默认值设置为 \"smith\"。\n\nfunction buildname(firstname: string, lastname = 'smith'): string {\n  return firstname + ' ' + lastname\n}\n\nlet result1 = buildname('bob')                  // 返回 \"bob smith\"\nlet result2 = buildname('bob', undefined)     // 正常, 同样 \"bob smith\"\nlet result3 = buildname('bob', 'adams', 'sr.')  // 错误, 参数过多\nlet result4 = buildname('bob', 'adams')        // ok\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 undefined 值来获得默认值。 例如，我们重写最后一个例子，让 firstname 是带默认值的参数：\n\nfunction buildname(firstname = 'will', lastname: string): string {\n  return firstname + ' ' + lastname\n}\n\nlet result1 = buildname('bob')                  // error, 参数过少\nlet result2 = buildname('bob', 'adams', \"sr.\")  // error, 参数过多\nlet result3 = buildname('bob', 'adams')         // ok， 返回 \"bob adams\"\nlet result4 = buildname(undefined, 'adams')     // ok，  返回 \"will adams\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 剩余参数\n\n必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 javascript 里，你可以使用 arguments 来访问所有传入的参数。\n\n在 typescript 里，你可以把所有参数收集到一个变量里：\n\nfunction buildname(firstname: string, ...restofname: string[]): string {\n  return firstname + ' ' + restofname.join(' ')\n}\n\nlet employeename = buildname('joseph', 'samuel', 'lucas', 'mackinzie')\n\n\n1\n2\n3\n4\n5\n\n\n剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ ...）后面给定的名字，你可以在函数体内使用这个数组。\n\n这个省略号也会在带有剩余参数的函数类型定义上使用到：\n\nfunction buildname(firstname: string, ...restofname: string[]): string {\n  return firstname + ' ' + restofname.join(' ')\n}\n\nlet buildnamefun: (fname: string, ...rest: string[]) => string = buildname\n\n\n1\n2\n3\n4\n5\n\n\n\n# this\n\n学习如何在 javascript 里正确使用 this 就好比一场成年礼。由于 typescript 是 javascript 的超集，typescript 程序员也需要弄清 this 工作机制并且当有 bug 的时候能够找出错误所在。 幸运的是，typescript 能通知你错误地使用了 this 的地方。 如果你想了解 javascript 里的 this是如何工作的，那么首先阅读 yehuda katz 写的 understanding javascript function invocation and \"this\"。 yehuda 的文章详细的阐述了 this 的内部工作原理，因此我们这里只做简单介绍。\n\n\n# this 和箭头函数\n\njavascript里，this 的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。\n\n下面看一个例子：\n\nlet deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: array(52),\n  createcardpicker: function() {\n    return function() {\n      let pickedcard = math.floor(math.random() * 52)\n      let pickedsuit = math.floor(pickedcard / 13)\n\n      return {suit: this.suits[pickedsuit], card: pickedcard % 13}\n    }\n  }\n}\n\nlet cardpicker = deck.createcardpicker()\nlet pickedcard = cardpicker()\n\nconsole.log('card: ' + pickedcard.card + ' of ' + pickedcard.suit)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n可以看到 createcardpicker 是个函数，并且它又返回了一个函数。如果我们尝试运行这个程序，会发现它并没有输出而是报错了。 因为 createcardpicker 返回的函数里的 this 被设置成了 global 而不是 deck 对象。 因为我们只是独立的调用了 cardpicker()。 顶级的非方法式调用会将 this 视为 global。\n\n为了解决这个问题，我们可以在函数被返回时就绑好正确的this。 这样的话，无论之后怎么使用它，都会引用绑定的deck 对象。 我们需要改变函数表达式来使用 ecmascript 6 箭头语法。 箭头函数能保存函数创建时的 this 值，而不是调用时的值：\n\nlet deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: array(52),\n  createcardpicker: function() {\n    // 注意：这里使用箭头函数\n    return () => {\n      let pickedcard = math.floor(math.random() * 52)\n      let pickedsuit = math.floor(pickedcard / 13)\n\n      return {suit: this.suits[pickedsuit], card: pickedcard % 13}\n    }\n  }\n}\n\nlet cardpicker = deck.createcardpicker()\nlet pickedcard = cardpicker()\n\nconsole.log('card: ' + pickedcard.card + ' of ' + pickedcard.suit)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# this 参数\n\n在上述的例子中 this.suits[pickedsuit] 的类型为 any，这是因为 this 来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 this 参数。 this 参数是个假的参数，它出现在参数列表的最前面：\n\nfunction f(this: void) {\n  // 确保“this”在此独立函数中不可用\n}\n\n\n1\n2\n3\n\n\n让我们往例子里添加一些接口，card 和 deck，让类型重用能够变得清晰简单些：\n\ninterface card {\n  suit: string\n  card: number\n}\n\ninterface deck {\n  suits: string[]\n  cards: number[]\n\n  createcardpicker (this: deck): () => card\n}\n\nlet deck: deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: array(52),\n  // note: 函数现在显式指定其被调用方必须是 deck 类型\n  createcardpicker: function (this: deck) {\n    return () => {\n      let pickedcard = math.floor(math.random() * 52)\n      let pickedsuit = math.floor(pickedcard / 13)\n\n      return {suit: this.suits[pickedsuit], card: pickedcard % 13}\n    }\n  }\n}\n\nlet cardpicker = deck.createcardpicker()\nlet pickedcard = cardpicker()\n\nconsole.log('card: ' + pickedcard.card + ' of ' + pickedcard.suit)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n现在 typescrip t知道 createcardpicker 期望在某个 deck 对象上调用。也就是说 this 是 deck 类型的，而非 any。\n\n\n# this 参数在回调函数里\n\n你可以也看到过在回调函数里的 this 报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用，this 将为 undefined。 稍做改动，你就可以通过 this 参数来避免错误。 首先，库函数的作者要指定 this 的类型：\n\ninterface uielement {\n  addclicklistener(onclick: (this: void, e: event) => void): void\n}\n\n\n1\n2\n3\n\n\nthis: void 意味着 addclicklistener 期望传入的 onclick 方法不需要 this\n\ninterface uielement {\n  addclicklistener (onclick: (this: void, e: event) => void): void\n}\n\nclass handler {\n  type: string\n\n  onclickbad (this: handler, e: event) {\n    this.type = e.type\n  }\n}\n\nlet h = new handler()\n\nlet uielement: uielement = {\n  addclicklistener () {\n  }\n}\n\nuielement.addclicklistener(h.onclickbad) // error!\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n指定了 this 类型后，你显式声明 onclickbad 必须在 handler 的实例上调用。 然后 typescript 会检测到 addclicklistener 要求函数带有 this: void。 改变 this 类型来修复这个错误：\n\nclass handler {\n  type: string;\n\n  onclickbad (this: void, e: event) {\n    console.log('clicked!')\n  }\n}\n\nlet h = new handler()\n\nlet uielement: uielement = {\n  addclicklistener () {\n  }\n}\n\nuielement.addclicklistener(h.onclickbad)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n因为 onclickgood 指定了 this 类型为 void，因此传递 addclicklistener 是合法的。 当然了，这也意味着不能使用 this.info。 如果你两者都想要，你不得不使用箭头函数了：\n\nclass handler {\n  type: string\n  onclickgood = (e: event) => {\n    this.type = e.type\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这是可行的因为箭头函数不会捕获 this，所以你总是可以把它们传给期望 this: void 的函数。\n\n\n# 重载\n\njavascript 本身是个动态语言。javascript 里函数根据传入不同的参数而返回不同类型的数据的场景是很常见的。\n\nlet suits = ['hearts', 'spades', 'clubs', 'diamonds']\n\nfunction pickcard(x): any {\n  if (array.isarray(x)) {\n    let pickedcard = math.floor(math.random() * x.length)\n    return pickedcard\n  } else if (typeof x === 'number') {\n    let pickedsuit = math.floor(x / 13)\n    return { suit: suits[pickedsuit], card: x % 13 }\n  }\n}\n\nlet mydeck = [\n  { suit: 'diamonds', card: 2 },\n  { suit: 'spades', card: 10 },\n  { suit: 'hearts', card: 4 }\n]\nlet pickedcard1 = mydeck[pickcard(mydeck)];\nconsole.log('card: ' + pickedcard1.card + ' of ' + pickedcard1.suit)\n\nlet pickedcard2 = pickcard(15)\nconsole.log('card: ' + pickedcard2.card + ' of ' + pickedcard2.suit)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\npickcard 方法根据传入参数的不同会返回两种不同的类型。如果传入的是代表纸牌的对象数组，函数作用是从中抓一张牌。如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。\n\n方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 pickcard 函数。\n\nlet suits = ['hearts', 'spades', 'clubs', 'diamonds']\n\nfunction pickcard(x: {suit: string; card: number }[]): number\nfunction pickcard(x: number): {suit: string; card: number }\n\nfunction pickcard(x): any {\n  if (array.isarray(x)) {\n    let pickedcard = math.floor(math.random() * x.length)\n    return pickedcard\n  } else if (typeof x === 'number') {\n    let pickedsuit = math.floor(x / 13)\n    return { suit: suits[pickedsuit], card: x % 13 }\n  }\n}\n\nlet mydeck = [\n  { suit: 'diamonds', card: 2 },\n  { suit: 'spades', card: 10 },\n  { suit: 'hearts', card: 4 }\n]\nlet pickedcard1 = mydeck[pickcard(mydeck)];\nconsole.log('card: ' + pickedcard1.card + ' of ' + pickedcard1.suit)\n\nlet pickedcard2 = pickcard(15)\nconsole.log('card: ' + pickedcard2.card + ' of ' + pickedcard2.suit)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n这样改变后，重载的 pickcard 函数在调用的时候会进行正确的类型检查。\n\n为了让编译器能够选择正确的检查类型，它与 javascript 里的处理流程相似。它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。因此，在定义重载的时候，一定要把最精确的定义放在最前面。\n\n注意，function pickcard(x): any 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象数组，另一个接收数字。 以其它参数调用 pickcard 会产生错误。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"数据类型",frontmatter:{title:"数据类型",date:"2022-09-21T15:39:52.000Z",permalink:"/pages/74296a/",categories:["《JavaScript》","《现代JavaScript教程》","JavaScript编程语言"],tags:[null]},regularPath:"/%E3%80%8AJavaScript%E3%80%8B/02.%E3%80%8A%E7%8E%B0%E4%BB%A3JavaScript%E6%95%99%E7%A8%8B%E3%80%8B/00.%20JavaScript%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/04.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"《JavaScript》/02.《现代JavaScript教程》/00. JavaScript编程语言/04.数据类型.md",key:"v-30ff3e14",path:"/pages/74296a/",headers:[{level:2,title:"5 数据类型",slug:"_5-数据类型",normalizedTitle:"5 数据类型",charIndex:2},{level:3,title:"5.1 原始数据类型方法",slug:"_5-1-原始数据类型方法",normalizedTitle:"5.1 原始数据类型方法",charIndex:13},{level:4,title:"5.1.1 原始类型与对象",slug:"_5-1-1-原始类型与对象",normalizedTitle:"5.1.1 原始类型与对象",charIndex:91},{level:4,title:"5.1.2 当作对象的原始类型",slug:"_5-1-2-当作对象的原始类型",normalizedTitle:"5.1.2 当作对象的原始类型",charIndex:338},{level:3,title:"5.2 数字类型",slug:"_5-2-数字类型",normalizedTitle:"5.2 数字类型",charIndex:1588},{level:4,title:"5.2.1 编写数字的更多方法",slug:"_5-2-1-编写数字的更多方法",normalizedTitle:"5.2.1 编写数字的更多方法",charIndex:1826},{level:5,title:"下划线 _",slug:"下划线",normalizedTitle:"下划线 _",charIndex:1845},{level:5,title:"字母 e",slug:"字母-e",normalizedTitle:"字母 e",charIndex:1989},{level:4,title:"5.2.2 十六进制，二进制和八进制数字",slug:"_5-2-2-十六进制-二进制和八进制数字",normalizedTitle:"5.2.2 十六进制，二进制和八进制数字",charIndex:2240},{level:4,title:"5.2.3 toString(base)",slug:"_5-2-3-tostring-base",normalizedTitle:"5.2.3 tostring(base)",charIndex:2550},{level:4,title:"5.2.4 舍入",slug:"_5-2-4-舍入",normalizedTitle:"5.2.4 舍入",charIndex:3243},{level:5,title:"数字舍入到小数点后 n 位",slug:"数字舍入到小数点后-n-位",normalizedTitle:"数字舍入到小数点后 n 位",charIndex:3747},{level:4,title:"5.2.5 不精确的计算",slug:"_5-2-5-不精确的计算",normalizedTitle:"5.2.5 不精确的计算",charIndex:4465},{level:4,title:"5.2.6 isFinite 和 isNaN",slug:"_5-2-6-isfinite-和-isnan",normalizedTitle:"5.2.6 isfinite 和 isnan",charIndex:5516},{level:5,title:"isNaN(value)",slug:"isnan-value",normalizedTitle:"isnan(value)",charIndex:5651},{level:5,title:"isFinite(value)",slug:"isfinite-value",normalizedTitle:"isfinite(value)",charIndex:5853},{level:4,title:"5.2.7 parseInt 和 parseFloat",slug:"_5-2-7-parseint-和-parsefloat",normalizedTitle:"5.2.7 parseint 和 parsefloat",charIndex:6601},{level:4,title:"5.2.8 Math对象",slug:"_5-2-8-math对象",normalizedTitle:"5.2.8 math对象",charIndex:7372},{level:3,title:"5.3 字符串",slug:"_5-3-字符串",normalizedTitle:"5.3 字符串",charIndex:7860},{level:4,title:"5.3.1 引号（Quotes）",slug:"_5-3-1-引号-quotes",normalizedTitle:"5.3.1 引号（quotes）",charIndex:7944},{level:4,title:"5.3.2 特殊字符",slug:"_5-3-2-特殊字符",normalizedTitle:"5.3.2 特殊字符",charIndex:8350},{level:4,title:"5.3.3 字符串长度",slug:"_5-3-3-字符串长度",normalizedTitle:"5.3.3 字符串长度",charIndex:9695},{level:4,title:"5.3.4 访问字符",slug:"_5-3-4-访问字符",normalizedTitle:"5.3.4 访问字符",charIndex:9907},{level:4,title:"5.3.5 字符串是不可变的",slug:"_5-3-5-字符串是不可变的",normalizedTitle:"5.3.5 字符串是不可变的",charIndex:10407},{level:4,title:"5.3.6 改变大小写",slug:"_5-3-6-改变大小写",normalizedTitle:"5.3.6 改变大小写",charIndex:10671},{level:4,title:"5.3.7 查找子字符串",slug:"_5-3-7-查找子字符串",normalizedTitle:"5.3.7 查找子字符串",charIndex:10904},{level:5,title:"str.indexOf",slug:"str-indexof",normalizedTitle:"str.indexof",charIndex:10920},{level:5,title:"includes，startsWith，endsWith",slug:"includes-startswith-endswith",normalizedTitle:"includes，startswith，endswith",charIndex:12254},{level:4,title:"5.3.8 获取子字符串",slug:"_5-3-8-获取子字符串",normalizedTitle:"5.3.8 获取子字符串",charIndex:12827},{level:5,title:"str.slice(start [, end])",slug:"str-slice-start-end",normalizedTitle:"str.slice(start [, end])",charIndex:12893},{level:5,title:"str.substring(start [, end])",slug:"str-substring-start-end",normalizedTitle:"str.substring(start [, end])",charIndex:13336},{level:5,title:"str.substr(start [, length])",slug:"str-substr-start-length",normalizedTitle:"str.substr(start [, length])",charIndex:13702},{level:4,title:"5.3.8 比较字符串",slug:"_5-3-8-比较字符串",normalizedTitle:"5.3.8 比较字符串",charIndex:14473},{level:5,title:"正确的比较",slug:"正确的比较",normalizedTitle:"正确的比较",charIndex:15015},{level:4,title:"5.3.9 Unicode",slug:"_5-3-9-unicode",normalizedTitle:"5.3.9 unicode",charIndex:15268},{level:5,title:"代理对",slug:"代理对",normalizedTitle:"代理对",charIndex:15285},{level:5,title:"变音符号与规范化",slug:"变音符号与规范化",normalizedTitle:"变音符号与规范化",charIndex:16294},{level:3,title:"5.4 数组",slug:"_5-4-数组",normalizedTitle:"5.4 数组",charIndex:17156},{level:4,title:"5.4.1 声明数组",slug:"_5-4-1-声明数组",normalizedTitle:"5.4.1 声明数组",charIndex:17206},{level:4,title:"5.4.2 简单使用数组",slug:"_5-4-2-简单使用数组",normalizedTitle:"5.4.2 简单使用数组",charIndex:17280},{level:4,title:'5.4.3 使用 "at" 获取最后一个元素',slug:"_5-4-3-使用-at-获取最后一个元素",normalizedTitle:"5.4.3 使用 &quot;at&quot; 获取最后一个元素",charIndex:null},{level:4,title:"5.4.4 pop/push, shift/unshift 方法",slug:"_5-4-4-pop-push-shift-unshift-方法",normalizedTitle:"5.4.4 pop/push, shift/unshift 方法",charIndex:18564},{level:4,title:"5.4.5 数组原理",slug:"_5-4-5-数组原理",normalizedTitle:"5.4.5 数组原理",charIndex:19875},{level:4,title:"5.4.6 数组性能",slug:"_5-4-6-数组性能",normalizedTitle:"5.4.6 数组性能",charIndex:20702},{level:4,title:"5.4.7 数组循环",slug:"_5-4-7-数组循环",normalizedTitle:"5.4.7 数组循环",charIndex:21070},{level:4,title:'5.4.8 数组 "length"',slug:"_5-4-8-数组-length",normalizedTitle:"5.4.8 数组 &quot;length&quot;",charIndex:null},{level:4,title:"5.4.9 new Array()",slug:"_5-4-9-new-array",normalizedTitle:"5.4.9 new array()",charIndex:22410},{level:4,title:"5.4.10 多维数组",slug:"_5-4-10-多维数组",normalizedTitle:"5.4.10 多维数组",charIndex:22671},{level:4,title:"5.4.11 toString",slug:"_5-4-11-tostring",normalizedTitle:"5.4.11 tostring",charIndex:22826},{level:4,title:"5.4.12 不要使用 == 比较数组",slug:"_5-4-12-不要使用-比较数组",normalizedTitle:"5.4.12 不要使用 == 比较数组",charIndex:23196},{level:3,title:"5.5 数组方法",slug:"_5-5-数组方法",normalizedTitle:"5.5 数组方法",charIndex:23838},{level:4,title:"5.5.1 添加/移除数组元素",slug:"_5-5-1-添加-移除数组元素",normalizedTitle:"5.5.1 添加/移除数组元素",charIndex:23850},{level:5,title:"splice",slug:"splice",normalizedTitle:"splice",charIndex:23993},{level:5,title:"slice",slug:"slice",normalizedTitle:"slice",charIndex:12884},{level:5,title:"concat",slug:"concat",normalizedTitle:"concat",charIndex:25084},{level:4,title:"5.5.2 遍历：forEach",slug:"_5-5-2-遍历-foreach",normalizedTitle:"5.5.2 遍历：foreach",charIndex:26082},{level:4,title:"5.5.3 搜索数组",slug:"_5-5-3-搜索数组",normalizedTitle:"5.5.3 搜索数组",charIndex:26385},{level:5,title:"indexOf/lastIndexOf 和 includes",slug:"indexof-lastindexof-和-includes",normalizedTitle:"indexof/lastindexof 和 includes",charIndex:26399},{level:5,title:"find 和 findIndex/findLastIndex",slug:"find-和-findindex-findlastindex",normalizedTitle:"find 和 findindex/findlastindex",charIndex:27236},{level:5,title:"filter",slug:"filter",normalizedTitle:"filter",charIndex:28128},{level:4,title:"5.5.4 转换数组",slug:"_5-5-4-转换数组",normalizedTitle:"5.5.4 转换数组",charIndex:28518},{level:5,title:"map",slug:"map",normalizedTitle:"map",charIndex:28532},{level:5,title:"sort(fn)",slug:"sort-fn",normalizedTitle:"sort(fn)",charIndex:28757},{level:5,title:"reverse",slug:"reverse",normalizedTitle:"reverse",charIndex:30252},{level:5,title:"split 和 join",slug:"split-和-join",normalizedTitle:"split 和 join",charIndex:30391},{level:5,title:"reduce/reduceRight",slug:"reduce-reduceright",normalizedTitle:"reduce/reduceright",charIndex:30811},{level:4,title:"5.5.5 Array.isArray",slug:"_5-5-5-array-isarray",normalizedTitle:"5.5.5 array.isarray",charIndex:32279},{level:4,title:'5.5.6 大多数方法都支持 "thisArg"',slug:"_5-5-6-大多数方法都支持-thisarg",normalizedTitle:"5.5.6 大多数方法都支持 &quot;thisarg&quot;",charIndex:null},{level:3,title:"5.6 可迭代对象",slug:"_5-6-可迭代对象",normalizedTitle:"5.6 可迭代对象",charIndex:33452},{level:4,title:"5.6.1 Symbol.iterator",slug:"_5-6-1-symbol-iterator",normalizedTitle:"5.6.1 symbol.iterator",charIndex:33527},{level:4,title:"5.6.2 字符串迭代",slug:"_5-6-2-字符串迭代",normalizedTitle:"5.6.2 字符串迭代",charIndex:35402},{level:4,title:"5.6.3 显示调用迭代器",slug:"_5-6-3-显示调用迭代器",normalizedTitle:"5.6.3 显示调用迭代器",charIndex:35723},{level:4,title:"5.6.4 可迭代（iterable）和类数组（array-like）",slug:"_5-6-4-可迭代-iterable-和类数组-array-like",normalizedTitle:"5.6.4 可迭代（iterable）和类数组（array-like）",charIndex:36090},{level:4,title:"5.6.5 Array.from",slug:"_5-6-5-array-from",normalizedTitle:"5.6.5 array.from",charIndex:36309},{level:3,title:"5.7 映射和集合",slug:"_5-7-映射和集合",normalizedTitle:"5.7 映射和集合",charIndex:36842},{level:4,title:"5.7.1 Map",slug:"_5-7-1-map",normalizedTitle:"5.7.1 map",charIndex:36855},{level:5,title:"Map 比较键",slug:"map-比较键",normalizedTitle:"map 比较键",charIndex:38285},{level:5,title:"链式调用",slug:"链式调用",normalizedTitle:"链式调用",charIndex:38396},{level:4,title:"5.7.2 Map 迭代",slug:"_5-7-2-map-迭代",normalizedTitle:"5.7.2 map 迭代",charIndex:38519},{level:4,title:"5.7.3 Object.entries：从对象创建 Map",slug:"_5-7-3-object-entries-从对象创建-map",normalizedTitle:"5.7.3 object.entries：从对象创建 map",charIndex:39243},{level:4,title:"5.7.4 Object.fromEntries：从 Map 创建对象",slug:"_5-7-4-object-fromentries-从-map-创建对象",normalizedTitle:"5.7.4 object.fromentries：从 map 创建对象",charIndex:39833},{level:4,title:"5.7.5 Set",slug:"_5-7-5-set",normalizedTitle:"5.7.5 set",charIndex:40807},{level:4,title:"5.7.6 Set 迭代（iteration）",slug:"_5-7-6-set-迭代-iteration",normalizedTitle:"5.7.6 set 迭代（iteration）",charIndex:41692},{level:3,title:"5.8 WeakMap and WeakSet（弱映射和弱集合）",slug:"_5-8-weakmap-and-weakset-弱映射和弱集合",normalizedTitle:"5.8 weakmap and weakset（弱映射和弱集合）",charIndex:42295},{level:4,title:"5.8.1 WeakMap",slug:"_5-8-1-weakmap",normalizedTitle:"5.8.1 weakmap",charIndex:42659},{level:4,title:"5.8.2 WeakMap使用案例",slug:"_5-8-2-weakmap使用案例",normalizedTitle:"5.8.2 weakmap使用案例",charIndex:43474},{level:5,title:"额外的数据",slug:"额外的数据",normalizedTitle:"额外的数据",charIndex:43495},{level:5,title:"缓存",slug:"缓存",normalizedTitle:"缓存",charIndex:44761},{level:4,title:"5.8.3 WeakSet",slug:"_5-8-3-weakset",normalizedTitle:"5.8.3 weakset",charIndex:45993},{level:3,title:"5.9 对象迭代",slug:"_5-9-对象迭代",normalizedTitle:"5.9 对象迭代",charIndex:46867},{level:4,title:"5.9.1  Object.keys，values，entries",slug:"_5-9-1-object-keys-values-entries",normalizedTitle:"5.9.1  object.keys，values，entries",charIndex:null},{level:4,title:"5.9.2 转换对象",slug:"_5-9-2-转换对象",normalizedTitle:"5.9.2 转换对象",charIndex:48246},{level:3,title:"5.10 解构赋值",slug:"_5-10-解构赋值",normalizedTitle:"5.10 解构赋值",charIndex:48795},{level:4,title:"5.10.1 数组解构",slug:"_5-10-1-数组解构",normalizedTitle:"5.10.1 数组解构",charIndex:48982},{level:5,title:"其余的 '...'",slug:"其余的",normalizedTitle:"其余的 '...'",charIndex:51048},{level:5,title:"默认值",slug:"默认值",normalizedTitle:"默认值",charIndex:51785},{level:4,title:"5.10.2 对象解构",slug:"_5-10-2-对象解构",normalizedTitle:"5.10.2 对象解构",charIndex:52400},{level:5,title:'剩余模式（pattern）"..."',slug:"剩余模式-pattern",normalizedTitle:"剩余模式（pattern）&quot;...&quot;",charIndex:null},{level:4,title:"5.10.3 嵌套解构",slug:"_5-10-3-嵌套解构",normalizedTitle:"5.10.3 嵌套解构",charIndex:55441},{level:4,title:"5.10.4 智能函数参数",slug:"_5-10-4-智能函数参数",normalizedTitle:"5.10.4 智能函数参数",charIndex:56202},{level:3,title:"5.11 日期和时间",slug:"_5-11-日期和时间",normalizedTitle:"5.11 日期和时间",charIndex:58104},{level:4,title:"5.11.1 创建",slug:"_5-11-1-创建",normalizedTitle:"5.11.1 创建",charIndex:58187},{level:4,title:"5.11.2 访问日期组件",slug:"_5-11-2-访问日期组件",normalizedTitle:"5.11.2 访问日期组件",charIndex:59813},{level:4,title:"5.11.3 设置日期组件",slug:"_5-11-3-设置日期组件",normalizedTitle:"5.11.3 设置日期组件",charIndex:60827},{level:4,title:"5.11.4 自动校准（Autocorrection）",slug:"_5-11-4-自动校准-autocorrection",normalizedTitle:"5.11.4 自动校准（autocorrection）",charIndex:61396},{level:4,title:"5.11.5 日期转化为数字，日期差值",slug:"_5-11-5-日期转化为数字-日期差值",normalizedTitle:"5.11.5 日期转化为数字，日期差值",charIndex:62186},{level:4,title:"5.11.6 Date.now()",slug:"_5-11-6-date-now",normalizedTitle:"5.11.6 date.now()",charIndex:62607},{level:4,title:"5.11.7 基准测试（Benchmarking）",slug:"_5-11-7-基准测试-benchmarking",normalizedTitle:"5.11.7 基准测试（benchmarking）",charIndex:63072},{level:4,title:"5.11.8 对字符串调用 Date.parse",slug:"_5-11-8-对字符串调用-date-parse",normalizedTitle:"5.11.8 对字符串调用 date.parse",charIndex:65573},{level:3,title:"5.12 JSON",slug:"_5-12-json",normalizedTitle:"5.12 json",charIndex:66168},{level:4,title:"5.12.1 JSON.stringify",slug:"_5-12-1-json-stringify",normalizedTitle:"5.12.1 json.stringify",charIndex:66444},{level:4,title:"5.12.2 排除和转换：replacer",slug:"_5-12-2-排除和转换-replacer",normalizedTitle:"5.12.2 排除和转换：replacer",charIndex:68637},{level:4,title:"5.12.3 格式化：space",slug:"_5-12-3-格式化-space",normalizedTitle:"5.12.3 格式化：space",charIndex:71043},{level:4,title:'5.12.4 自定义 "toJSON"',slug:"_5-12-4-自定义-tojson",normalizedTitle:"5.12.4 自定义 &quot;tojson&quot;",charIndex:null},{level:4,title:"5.12.5  JSON.parse",slug:"_5-12-5-json-parse",normalizedTitle:"5.12.5  json.parse",charIndex:null},{level:4,title:"5.12.6 使用 reviver",slug:"_5-12-6-使用-reviver",normalizedTitle:"5.12.6 使用 reviver",charIndex:73726}],headersStr:'5 数据类型 5.1 原始数据类型方法 5.1.1 原始类型与对象 5.1.2 当作对象的原始类型 5.2 数字类型 5.2.1 编写数字的更多方法 下划线 _ 字母 e 5.2.2 十六进制，二进制和八进制数字 5.2.3 toString(base) 5.2.4 舍入 数字舍入到小数点后 n 位 5.2.5 不精确的计算 5.2.6 isFinite 和 isNaN isNaN(value) isFinite(value) 5.2.7 parseInt 和 parseFloat 5.2.8 Math对象 5.3 字符串 5.3.1 引号（Quotes） 5.3.2 特殊字符 5.3.3 字符串长度 5.3.4 访问字符 5.3.5 字符串是不可变的 5.3.6 改变大小写 5.3.7 查找子字符串 str.indexOf includes，startsWith，endsWith 5.3.8 获取子字符串 str.slice(start [, end]) str.substring(start [, end]) str.substr(start [, length]) 5.3.8 比较字符串 正确的比较 5.3.9 Unicode 代理对 变音符号与规范化 5.4 数组 5.4.1 声明数组 5.4.2 简单使用数组 5.4.3 使用 "at" 获取最后一个元素 5.4.4 pop/push, shift/unshift 方法 5.4.5 数组原理 5.4.6 数组性能 5.4.7 数组循环 5.4.8 数组 "length" 5.4.9 new Array() 5.4.10 多维数组 5.4.11 toString 5.4.12 不要使用 == 比较数组 5.5 数组方法 5.5.1 添加/移除数组元素 splice slice concat 5.5.2 遍历：forEach 5.5.3 搜索数组 indexOf/lastIndexOf 和 includes find 和 findIndex/findLastIndex filter 5.5.4 转换数组 map sort(fn) reverse split 和 join reduce/reduceRight 5.5.5 Array.isArray 5.5.6 大多数方法都支持 "thisArg" 5.6 可迭代对象 5.6.1 Symbol.iterator 5.6.2 字符串迭代 5.6.3 显示调用迭代器 5.6.4 可迭代（iterable）和类数组（array-like） 5.6.5 Array.from 5.7 映射和集合 5.7.1 Map Map 比较键 链式调用 5.7.2 Map 迭代 5.7.3 Object.entries：从对象创建 Map 5.7.4 Object.fromEntries：从 Map 创建对象 5.7.5 Set 5.7.6 Set 迭代（iteration） 5.8 WeakMap and WeakSet（弱映射和弱集合） 5.8.1 WeakMap 5.8.2 WeakMap使用案例 额外的数据 缓存 5.8.3 WeakSet 5.9 对象迭代 5.9.1  Object.keys，values，entries 5.9.2 转换对象 5.10 解构赋值 5.10.1 数组解构 其余的 \'...\' 默认值 5.10.2 对象解构 剩余模式（pattern）"..." 5.10.3 嵌套解构 5.10.4 智能函数参数 5.11 日期和时间 5.11.1 创建 5.11.2 访问日期组件 5.11.3 设置日期组件 5.11.4 自动校准（Autocorrection） 5.11.5 日期转化为数字，日期差值 5.11.6 Date.now() 5.11.7 基准测试（Benchmarking） 5.11.8 对字符串调用 Date.parse 5.12 JSON 5.12.1 JSON.stringify 5.12.2 排除和转换：replacer 5.12.3 格式化：space 5.12.4 自定义 "toJSON" 5.12.5  JSON.parse 5.12.6 使用 reviver',content:'# 5 数据类型\n\n\n# 5.1 原始数据类型方法\n\nJavaScript 允许我们像使用对象一样使用原始类型（字符串，数字等）。JavaScript 还提供了这样的调用方法\n\n# 5.1.1 原始类型与对象\n\n原始值：\n\n * 是原始类型中的一种值。\n * 在 JavaScript 中有 7 种原始类型：string，number，bigint，boolean，symbol，null 和 undefined。\n\n对象：\n\n * 能够存储多个值作为属性。\n * 可以使用大括号 {} 创建对象，例如：{name: "John", age: 30}。JavaScript 中还有其他种类的对象，例如函数就是对象\n\n对象比原始类型“更重”。它们需要额外的资源来支持运作\n\n# 5.1.2 当作对象的原始类型\n\n在保持原始类型轻量的前提下提供可以用方法访问的操作，所以提出了对象包装器，实现下面的解决方案\n\n 1. 原始类型仍然是原始的。与预期相同，提供单个值\n 2. JavaScript 允许访问字符串，数字，布尔值和 symbol 的方法和属性\n 3. 为了使它们起作用，创建了提供额外功能的特殊“对象包装器”，使用后即被销毁\n\n“对象包装器”对于每种原始类型都是不同的，它们被称为 String、Number、Boolean、Symbol 和 BigInt。因此，它们提供了不同的方法\n\n用法演示如下：\n\nlet str = "Hello";\nalert( str.toUpperCase() ); // HELLO\n\n\n1\n2\n\n\n以下是 str.toUpperCase() 中实际发生的情况：\n\n 1. 字符串 str 是一个原始值。因此，在访问其属性时，会创建一个包含字符串字面值的特殊对象，并且具有有用的方法，例如 toUpperCase()。\n 2. 该方法运行并返回一个新的字符串（由 alert 显示）。\n 3. 特殊对象被销毁，只留下原始值 str。\n\nJavaScript 引擎高度优化了这个过程。它甚至可能跳过创建额外的对象。但是它仍然必须遵守规范，并且表现得好像它创建了一样\n\n构造器 `String/Number/Boolean` 仅供内部使用\n\n像 Java 这样的一些语言允许我们使用 new Number(1) 或 new Boolean(false) 等语法，明确地为原始类型创建“对象包装器”。 在 JavaScript 中，由于历史原因，这也是可以的，但极其 不推荐。因为这样会出问题。 例如：\n\nalert( typeof 0 ); // "number"\nalert( typeof new Number(0) ); // "object"!\n\n\n1\n2\n\n\n对象在 if 中始终为真，因此此处的 alert 将显示：\n\nlet zero = new Number(0);\nif (zero) { // zero 为 true，因为它是一个对象\n  alert( "zero is truthy?!?" );\n}\n\n\n1\n2\n3\n4\n\n\n另一方面，调用不带 new（关键字）的 String/Number/Boolean 函数是完全理智和有用的。它们将一个值转换为相应的类型：转成字符串、数字或布尔值（原始类型）。 例如，下面完全是有效的：\n\nlet num = Number("123"); // 将字符串转成数字\n\n\n1\n\n\nnull/undefined 没有任何方法\n\n特殊的原始类型 null 和 undefined 是例外。它们没有对应的“对象包装器”，也没有提供任何方法。从某种意义上说，它们是“最原始的”。 尝试访问这种值的属性会导致错误：\n\nalert(null.test); // error\n\n\n1\n\n\n\n# 5.2 数字类型\n\n在现代 JavaScript 中，数字（number）有两种类型：\n\n 1. JavaScript 中的常规数字以 64 位的格式 IEEE-754 存储，也被称为“双精度浮点数”。这是我们大多数时候所使用的数字，我们将在本章中学习它们。\n\n 2. BigInt 数字，用于表示任意长度的整数。有时会需要它们，因为常规数字不能安全地超过 253 或小于 -253。由于仅在少数特殊领域才会用到 BigInt\n\n所以，此章节我们讨论的都是常规数字类型\n\n# 5.2.1 编写数字的更多方法\n\n# 下划线 _\n\n可以使用下划线 _ 作为数字的分隔符，下划线 _ 扮演了“语法糖”的角色，使得数字具有更强的可读性。JavaScript 引擎会直接忽略\n\nlet billion1 = 1000000000;\nlet billion2 = 1_000_000_000;\n\n\n1\n2\n\n\n# 字母 e\n\ne 把数字乘以 1 后面跟着给定数量的 0 的数字\n\n1e3 === 1 * 1000; // e3 表示 *1000\n1.23e6 === 1.23 * 1000000; // e6 表示 *1000000\n// -3 除以 1 后面跟着 3 个 0 的数字\n1e-3 === 1 / 1000; // 0.001\n// -6 除以 1 后面跟着 6 个 0 的数字\n1.23e-6 === 1.23 / 1000000; // 0.00000123\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 5.2.2 十六进制，二进制和八进制数字\n\n十六进制有一种较短的写方法：0x，然后是数字\n\n// 十六进制\nalert( 0xff ); // 255\nalert( 0xFF ); // 255（一样，大小写没影响）\n\n\n1\n2\n3\n\n\n二进制和八进制数字系统很少使用，但也支持使用 0b 和 0o 前缀\n\nlet a = 0b11111111; // 二进制形式的 255\nlet b = 0o377; // 八进制形式的 255\nalert( a == b ); // true，两边是相同的数字，都是 255\n\n\n1\n2\n3\n\n\n只有这三种进制支持这种写法。对于其他进制，我们应该使用函数 parseInt\n\n# 5.2.3 toString(base)\n\n方法 num.toString(base) 返回在给定 base 进制数字系统中 num 的字符串表示形式\n\nlet num = 255;\nalert( num.toString(16) );  // ff\nalert( num.toString(2) );   // 11111111\n\n\n1\n2\n3\n\n\nbase 的范围可以从 2 到 36。默认情况下是 10 常见的用例如下：\n\n * base=16 用于十六进制颜色，字符编码等，数字可以是 0..9 或 A..F。\n * base=2 主要用于调试按位操作，数字可以是 0 或 1。\n * base=36 是最大进制，数字可以是 0..9 或 A..Z。所有拉丁字母都被用于了表示数字。对于 36 进制来说，一个有趣且有用的例子是，当我们需要将一个较长的数字标识符转换成较短的时候，例如做一个短的 URL。可以简单地使用基数为 36 的数字系统表示：\n\n使用两个点来调用一个方法\n\n请注意 123456..toString(36) 中的两个点不是打错了。如果我们想直接在一个数字上调用一个方法，比如上面例子中的 toString，那么我们需要在它后面放置两个点 ..。\n\n如果我们放置一个点：123456.toString(36)，那么就会出现一个 error，因为 JavaScript 语法隐含了第一个点之后的部分为小数部分。如果我们再放一个点，那么 JavaScript 就知道小数部分为空，现在使用该方法。\n\n也可以写成 (123456).toString(36)。\n\n# 5.2.4 舍入\n\n舍入（rounding）是使用数字时最常用的操作之一 Math.floor : 向下舍入：3.1 变成 3，-1.1 变成 -2。\n\nMath.ceil : 向上舍入：3.1 变成 4，-1.1 变成 -1。\n\nMath.round : 向最近的整数舍入：3.1 变成 3，3.6 变成 4，中间值 3.5 变成 4。\n\nMath.trunc（IE 浏览器不支持这个方法） : 移除小数点后的所有内容而没有舍入：3.1 变成 3，-1.1 变成 -1。\n\n这个是总结它们之间差异的表格：\n\n       MATH.FLOOR   MATH.CEIL   MATH.ROUND   MATH.TRUNC\n3.1    3            4           3            3\n3.6    3            4           4            3\n-1.1   -2           -1          -1           -1\n-1.6   -2           -1          -2           -1\n\n# 数字舍入到小数点后 n 位\n\n 1. 乘除法\n    \n    例如，要将数字舍入到小数点后两位，我们可以将数字乘以 100，调用舍入函数，然后再将其除回。\n    \n    let num = 1.23456;\n    alert( Math.round(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23\n    \n    \n    1\n    2\n    \n\n 2. 函数 toFixed(n) 将数字舍入到小数点后 n 位，并以字符串形式返回结果。\n    \n    let num = 12.34;\n    alert( num.toFixed(1) ); // "12.3"\n    \n    \n    1\n    2\n    \n    \n    这会向上或向下舍入到最接近的值，类似于 Math.round：\n    \n    let num = 12.36;\n    alert( num.toFixed(1) ); // "12.4"\n    \n    \n    1\n    2\n    \n    \n    请注意 toFixed 的结果是一个字符串。如果小数部分比所需要的短，则在结尾添加零：\n    \n    let num = 12.34;\n    alert( num.toFixed(5) ); // "12.34000"，在结尾添加了 0，以达到小数点后五位\n    \n    \n    1\n    2\n    \n    \n    我们可以使用一元加号或 Number() 调用，将其转换为数字，例如 + num.toFixed(5)。\n\n# 5.2.5 不精确的计算\n\n在内部，数字是以 64 位格式 IEEE-754 表示的，所以正好有 64 位可以存储一个数字：其中 52 位被用于存储这些数字，其中 11 位用于存储小数点的位置（对于整数，它们为零），而 1 位用于符号。\n\n如果一个数字真的很大，则可能会溢出 64 位存储，变成一个特殊的数值 Infinity：\n\nalert( 1e500 ); // Infinity\n\n\n1\n\n\n这可能不那么明显，但经常会发生的是，精度的损失\n\nalert( 0.1 + 0.2 == 0.3 ); // false\n\n\n1\n\n\n一个数字以其二进制的形式存储在内存中，一个 1 和 0 的序列。但是在十进制数字系统中看起来很简单的 0.1，0.2 这样的小数，实际上在二进制形式中是无限循环小数。\n\n什么是 0.1？0.1 就是 1 除以 10，1/10，即十分之一。在十进制数字系统中，这样的数字表示起来很容易。将其与三分之一进行比较：1/3。三分之一变成了无限循环小数 0.33333(3)。\n\n在十进制数字系统中，可以保证以 10 的整数次幂作为除数能够正常工作，但是以 3 作为除数则不能。也是同样的原因，在二进制数字系统中，可以保证以 2 的整数次幂作为除数时能够正常工作，但 1/10 就变成了一个无限循环的二进制小数。\n\n使用二进制数字系统无法 精确 存储 0.1 或 0.2，就像没有办法将三分之一存储为十进制小数一样。\n\n解决方法中最可靠的是借助toFixed(n)对结果进行舍入\n\nlet sum = 0.1 + 0.2;\nalert( sum.toFixed(2) ); // 0.30\n\n\n1\n2\n\n\n提示\n\n// Hello！我是一个会自我增加的数字！\nalert( 9999999999999999 ); // 显示 10000000000000000\n\n\n1\n2\n\n\n出现了同样的问题：精度损失。有 64 位来表示该数字，其中 52 位可用于存储数字，但这还不够。所以最不重要的数字就消失了。\n\nJavaScript 不会在此类事件中触发 error。它会尽最大努力使数字符合所需的格式，但不幸的是，这种格式不够大到满足需求。\n\n两个零\n\n数字内部表示的另一个有趣结果是存在两个零：0 和 -0。\n\n这是因为在存储时，使用一位来存储符号，因此对于包括零在内的任何数字，可以设置这一位或者不设置。\n\n在大多数情况下，这种区别并不明显，因为运算符将它们视为相同的值\n\n# 5.2.6 isFinite 和 isNaN\n\n * Infinity（和 -Infinity）是一个特殊的数值，比任何数值都大（小）。\n * NaN 代表一个 error。\n\n它们属于 number 类型，但不是“普通”数字，因此，这里有用于检查它们的特殊函数\n\n# isNaN(value)\n\n将其参数转换为数字，然后测试它是否为 NaN\n\nalert( isNaN(NaN) ); // true\nalert( isNaN("str") ); // true\n\n\n1\n2\n\n\nNaN独一无二\n\n我们不能使用 === NaN 比较。"NaN" 是独一无二的，它不等于任何东西，包括它自身：\n\nalert( NaN === NaN ); // false\n\n\n1\n\n\n# isFinite(value)\n\n将其参数转换为数字，如果是常规数字而不是 NaN/Infinity/-Infinity，则返回 true\n\nalert( isFinite("15") ); // true\nalert( isFinite("str") ); // false，因为是一个特殊的值：NaN\nalert( isFinite(Infinity) ); // false，因为是一个特殊的值：Infinity\n\n\n1\n2\n3\n\n\n有时 isFinite 被用于验证字符串值是否为常规数字：\n\nlet num = +prompt("Enter a number", \'\');\n// 结果会是 true，除非你输入的是 Infinity、-Infinity 或不是数字\nalert( isFinite(num) );\n\n\n1\n2\n3\n\n\n注意\n\n请注意，在所有数字函数中，包括 isFinite，空字符串或仅有空格的字符串均被视为 0\n\n与 `Object.is` 进行比较\n\n有一个特殊的内建方法 Object.is，它类似于 === 一样对值进行比较，但它对于两种边缘情况更可靠：\n\n 1. 它适用于 NaN：Object.is(NaN，NaN) === true，这是件好事。\n 2. 值 0 和 -0 是不同的：Object.is(0，-0) === false，从技术上讲这是对的，因为在内部，数字的符号位可能会不同，即使其他所有位均为零。\n\n在所有其他情况下，Object.is(a，b) 与 a === b 相同。\n\n这种比较方式经常被用在 JavaScript 规范中。当内部算法需要比较两个值是否完全相同时，它使用 Object.is（内部称为SameValue）\n\n# 5.2.7 parseInt 和 parseFloat\n\n使用加号 + 或 Number() 的数字转换是严格的。如果一个值不完全是一个数字，就会失败：\n\nalert( +"100px" ); // NaN\n\n\n1\n\n\n唯一的例外是字符串开头或结尾的空格，因为它们会被忽略。\n\nparseInt 和 parseFloat 可以从字符串中“读取”数字，直到无法读取为止。如果发生 error，则返回收集到的数字。函数 parseInt 返回一个整数，而 parseFloat 返回一个浮点数：\n\nalert( parseInt(\'100px\') ); // 100\nalert( parseFloat(\'12.5em\') ); // 12.5\nalert( parseInt(\'12.3\') ); // 12，只有整数部分被返回了\nalert( parseFloat(\'12.3.4\') ); // 12.3，在第二个点出停止了读取\n\n\n1\n2\n3\n4\n\n\n某些情况下，parseInt/parseFloat 会返回 NaN。当没有数字可读时会发生这种情况：\n\nalert( parseInt(\'a123\') ); // NaN，第一个符号停止了读取\n\n\n1\n\n\nparseInt(str, radix) 的第二个参数\n\nparseInt() 函数具有可选的第二个参数。它指定了数字系统的基数，因此 parseInt 还可以解析十六进制数字、二进制数字等的字符串：\n\nalert( parseInt(\'0xff\', 16) ); // 255\nalert( parseInt(\'ff\', 16) ); // 255，没有 0x 仍然有效\nalert( parseInt(\'2n9c\', 36) ); // 123456\n\n\n1\n2\n3\n\n\n# 5.2.8 Math对象\n\nJavaScript 有一个内建的 Math 对象，它包含了一个小型的数学函数和常量库 Math.random() : 返回一个从 0 到 1 的随机数（不包括 1）。\n\n```js\nalert( Math.random() ); // 0.1234567894322\nalert( Math.random() ); // 0.5435252343232\nalert( Math.random() ); // ... (任何随机数)\n```\n\n\nMath.max(a, b, c...) / Math.min(a, b, c...) : 从任意数量的参数中返回最大/最小值。\n\n```js\nalert( Math.max(3, 5, -10, 0, 1) ); // 5\nalert( Math.min(1, 2) ); // 1\n```\n\n\nMath.pow(n, power) : 返回 n 的给定（power）次幂。\n\n```js\nalert( Math.pow(2, 10) ); // 2 的 10 次幂 = 1024\n```\n\n\n\n# 5.3 字符串\n\n在 JavaScript 中，文本数据被以字符串形式存储，单个字符没有单独的类型。\n\n字符串的内部格式始终是 UTF-16，它不依赖于页面编码\n\n# 5.3.1 引号（Quotes）\n\n字符串可以包含在单引号、双引号或反引号中：\n\nlet single = \'single-quoted\';\nlet double = "double-quoted";\nlet backticks = `backticks`;\n\n\n1\n2\n3\n\n\n单引号和双引号基本相同。但是，反引号允许我们通过 ${…} 将任何表达式嵌入到字符串中：\n\nfunction sum(a, b) {\n  return a + b;\n}\nalert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.\n\n\n1\n2\n3\n4\n\n\n使用反引号的另一个优点是它们允许字符串跨行：\n\nlet guestList = `Guests:\n * John\n * Pete\n * Mary\n`;\nalert(guestList); // 客人清单，多行\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 5.3.2 特殊字符\n\n我们可以通过使用“换行符（newline character）”，以支持使用单引号和双引号来创建跨行字符串。换行符写作 \\n，用来表示换行：\n\nlet guestList = "Guests:\\n * John\\n * Pete\\n * Mary";\nalert(guestList); // 一个多行的客人列表\n\n\n1\n2\n\n\n例如，这两行描述的是一样的，只是书写方式不同：\n\nlet str1 = "Hello\\nWorld"; // 使用“换行符”创建的两行字符串\n// 使用反引号和普通的换行创建的两行字符串\nlet str2 = `Hello\nWorld`;\nalert(str1 == str2); // true\n\n\n1\n2\n3\n4\n5\n\n\n还有其他不常见的“特殊”字符。\n\n这是完整列表：\n\n字符                            描述\n\\n                            换行\n\\r                            在 Windows 文本文件中，两个字符 \\r\\n 的组合代表一个换行。而在非 Windows 操作系统上，它就是\n                              \\n。这是历史原因造成的，大多数的 Windows 软件也理解 \\n。\n\\\', \\"                        引号\n\\\\                            反斜线\n\\t                            制表符\n\\b, \\f, \\v                    退格，换页，垂直标签 —— 为了兼容性，现在已经不使用了。\n\\xXX                          具有给定十六进制 Unicode XX 的 Unicode 字符，例如：\'\\x7A\' 和 \'z\' 相同。\n\\uXXXX                        以 UTF-16 编码的十六进制代码 XXXX 的 Unicode 字符，例如 \\u00A9 —— 是版权符号 © 的\n                              Unicode。它必须正好是 4 个十六进制数字。\n\\u{X…XXXXXX}（1 到 6 个十六进制字符）   具有给定 UTF-32 编码的 Unicode 符号。一些罕见的字符用两个 Unicode 符号编码，占用 4\n                              个字节。这样我们就可以插入长代码了。\n\nUnicode 示例：\n\nalert( "\\u00A9" ); // ©\nalert( "\\u{20331}" ); // 佫，罕见的中国象形文字（长 Unicode）\nalert( "\\u{1F60D}" ); // 😍，笑脸符号（另一个长 Unicode）\n\n\n1\n2\n3\n\n\n所有的特殊字符都以反斜杠字符 \\ 开始。它也被称为“转义字符”。\n\n注意\n\n注意反斜杠 \\ 在 JavaScript 中用于正确读取字符串，然后消失。内存中的字符串没有 \\。\n\n# 5.3.3 字符串长度\n\nlength 属性表示字符串长度：\n\nalert( `My\\n`.length ); // 3\n\n\n1\n\n\n注意 \\n 是一个单独的“特殊”字符，所以长度确实是 3\n\n`length` 是一个属性\n\n掌握其他编程语言的人，有时会错误地调用 str.length() 而不是 str.length。这是行不通的。\n\n请注意 str.length 是一个数字属性，而不是函数。后面不需要添加括号\n\n# 5.3.4 访问字符\n\n要获取在 pos 位置的一个字符，可以使用方括号 [pos] 或者调用 str.charAt(pos) 方法。第一个字符从零位置开始\n\nlet str = `Hello`;\n// 第一个字符\nalert( str[0] ); // H\nalert( str.charAt(0) ); // H\n// 最后一个字符\nalert( str[str.length - 1] ); // o\n\n\n1\n2\n3\n4\n5\n6\n\n\n方括号是获取字符的一种现代化方法，而 charAt 是历史原因才存在的。\n\n它们之间的唯一区别是，如果没有找到字符，[] 返回 undefined，而 charAt 返回一个空字符串：\n\nlet str = `Hello`;\nalert( str[1000] ); // undefined\nalert( str.charAt(1000) ); // \'\'（空字符串）\n\n\n1\n2\n3\n\n\n可以使用for.. of遍历字符\n\nfor(let char of "Hello"){\n  alert(char); //H,e,l,l,o\n}\n\n\n1\n2\n3\n\n\n# 5.3.5 字符串是不可变的\n\n在 JavaScript 中，字符串不可更改。改变字符是不可能的。\n\n我们证明一下为什么不可能：\n\nlet str = \'Hi\';\nstr[0] = \'h\'; // error\nalert( str[0] ); // 无法运行\n\n\n1\n2\n3\n\n\n通常的解决方法是创建一个新的字符串，并将其分配给 str 而不是以前的字符串。\n\n例如：\n\nlet str = \'Hi\';\nstr = \'h\' + str[1];  // 替换字符串\nalert( str ); // hi\n\n\n1\n2\n3\n\n\n# 5.3.6 改变大小写\n\ntoLowerCase() 和 toUpperCase() 方法可以改变大小写：\n\nalert( \'Interface\'.toUpperCase() ); // INTERFACE\nalert( \'Interface\'.toLowerCase() ); // interface\n\n\n1\n2\n\n\n或者我们想要使一个字符变成小写：\n\nalert( \'Interface\'[0].toLowerCase() ); // \'i\'\n\n\n1\n\n\n# 5.3.7 查找子字符串\n\n# str.indexOf\n\nstr.indexOf(substr, pos)从给定位置 pos 开始，在 str 中查找 substr，如果没有找到，则返回 -1，否则返回匹配成功的位置。\n\n例如：\n\nlet str = \'Widget with id\';\nalert( str.indexOf(\'Widget\') ); // 0，因为 \'Widget\' 一开始就被找到\nalert( str.indexOf(\'widget\') ); // -1，没有找到，检索是大小写敏感的\nalert( str.indexOf("id") ); // 1，"id" 在位置 1 处（……idget 和 id）\n\n\n1\n2\n3\n4\n\n\n可选的第二个参数允许我们从一个给定的位置开始检索。\n\n例如，"id" 第一次出现的位置是 1。查询下一个存在位置时，我们从 2 开始检索：\n\nlet str = \'Widget with id\';\nalert( str.indexOf(\'id\', 2) ) // 12\n\n\n1\n2\n\n\n`str.lastIndexOf(substr, pos)`\n\n还有一个类似的方法 str.lastIndexOf(substr, position)，它从字符串的末尾开始搜索到开头。\n\n它会以相反的顺序列出这些事件\n\n在 if 测试中 indexOf 有一点不方便。我们不能像这样把它放在 if 中：\n\nlet str = "Widget with id";\nif (str.indexOf("Widget")) {\n    alert("We found it"); // 不工作！\n}\n\n\n1\n2\n3\n4\n\n\n上述示例中的 alert 不会显示，因为 str.indexOf("Widget") 返回 0（意思是它在起始位置就查找到了匹配项）。是的，但是 if 认为 0 表示 false。\n\n因此我们应该检查 -1，像这样：\n\n\n\n \n\n\n\n\nlet str = "Widget with id";\nif (str.indexOf("Widget") != -1) {\n    alert("We found it"); // 现在工作了！\n}\n\n\n1\n2\n3\n4\n\n\n按位（bitwise）NOT 技巧\n\n这里使用的一个老技巧是 bitwise NOT ~ 运算符。它将数字转换为 32-bit 整数（如果存在小数部分，则删除小数部分），然后对其二进制表示形式中的所有位均取反\n\n只有当 n == -1 时，~n 才为零（适用于任何 32-bit 带符号的整数 n）\n\nlet str = "Widget";\nif (~str.indexOf("Widget")) {\n  alert( \'Found it!\' ); // 正常运行\n}\n\n\n1\n2\n3\n4\n\n\n由于 ~ 运算符将大数字截断为 32 位，因此存在给出 0 的其他数字，最小的数字是 ~4294967295=0。这使得这种检查只有在字符串没有那么长的情况下才是正确的 现在我们只会在旧的代码中看到这个技巧，因为现代 JavaScript 提供了 .includes 方法（见下文）\n\n# includes，startsWith，endsWith\n\n更现代的方法 str.includes(substr, pos) 根据 str 中是否包含 substr 来返回 true/false。\n\n如果我们需要检测匹配，但不需要它的位置，那么这是正确的选择：\n\nalert( "Widget with id".includes("Widget") ); // true\nalert( "Hello".includes("Bye") ); // false\n\n\n1\n2\n\n\nstr.includes 的第二个可选参数是开始搜索的起始位置：\n\nalert( "Widget".includes("id") ); // true\nalert( "Widget".includes("id", 3) ); // false, 从位置 3 开始没有 "id"\n\n\n1\n2\n\n\n方法 str.startsWith 和 str.endsWith 的功能与其名称所表示的意思相同：\n\nalert( "Widget".startsWith("Wid") ); // true，"Widget" 以 "Wid" 开始\nalert( "Widget".endsWith("get") ); // true，"Widget" 以 "get" 结束\n\n\n1\n2\n\n\n# 5.3.8 获取子字符串\n\nJavaScript 中有三种获取字符串的方法：substring、substr 和 slice\n\n# str.slice(start [, end])\n\n返回字符串从 start 到（但不包括）end 的部分\n\nlet str = "stringify";\nalert( str.slice(0, 5) ); // \'strin\'，从 0 到 5 的子字符串（不包括 5）\nalert( str.slice(0, 1) ); // \'s\'，从 0 到 1，但不包括 1，所以只有在 0 处的字符\n\n\n1\n2\n3\n\n\n如果没有第二个参数，slice 会一直运行到字符串末尾：\n\nlet str = "stringify";\nalert( str.slice(2) ); // 从第二个位置直到结束\n\n\n1\n2\n\n\nstart/end 也有可能是负值。它们的意思是起始位置从字符串结尾计算：\n\nlet str = "stringify";\n// 从右边的第四个位置开始，在右边的第一个位置结束\nalert( str.slice(-4, -1) ); // \'gif\'\n\n\n1\n2\n3\n\n\n# str.substring(start [, end])\n\n返回字符串在 start 和 end 之间 的部分 这与 slice 几乎相同，但它允许 start 大于 end。\n\n例如：\n\nlet str = "stringify";\n// 这些对于 substring 是相同的\nalert( str.substring(2, 6) ); // "ring"\nalert( str.substring(6, 2) ); // "ring"\n// ……但对 slice 是不同的：\nalert( str.slice(2, 6) ); // "ring"（一样）\nalert( str.slice(6, 2) ); // ""（空字符串）\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n不支持负参数（不像 slice），它们被视为 0。\n\n# str.substr(start [, length])\n\n返回字符串从 start 开始的给定 length 的部分 与以前的方法相比，这个允许我们指定 length 而不是结束位置：\n\nlet str = "stringify";\nalert( str.substr(2, 4) ); // \'ring\'，从位置 2 开始，获取 4 个字符\n\n\n1\n2\n\n\n第一个参数可能是负数，从结尾算起：\n\nlet str = "stringify";\nalert( str.substr(-4, 2) ); // \'gi\'，从第 4 位获取 2 个字符\n\n\n1\n2\n\n\n方法                      选择方式……                              负值参数\nslice(start, end)       从 start 到 end（不含 end）               允许\nsubstring(start, end)   start 与 end 之间（包括 start，但不包括 end）   负值代表 0\nsubstr(start, length)   从 start 开始获取长为 length 的字符串          允许 start 为负数\n\n使用哪一个？\n\n它们都可用于获取子字符串。正式一点来讲，substr 有一个小缺点：它不是在 JavaScript 核心规范中描述的，而是在附录 B 中。附录 B 的内容主要是描述因历史原因而遗留下来的仅浏览器特性。因此，理论上非浏览器环境可能无法支持 substr，但实际上它在别的地方也都能用。\n\n相较于其他两个变体，slice 稍微灵活一些，它允许以负值作为参数并且写法更简短。因此仅仅记住这三种方法中的 slice 就足够了\n\n# 5.3.8 比较字符串\n\n所有的字符串都使用 UTF-16 编码。即：每个字符都有对应的数字代码。有特殊的方法可以获取代码表示的字符，以及字符对应的代码。\n\nstr.codePointAt(pos) : 返回在 pos 位置的字符代码 :\n\n```js\n// 不同的字母有不同的代码\nalert( "z".codePointAt(0) ); // 122\nalert( "Z".codePointAt(0) ); // 90\n```\n\n\nString.fromCodePoint(code) : 通过数字 code 创建字符\n\n```js\nalert( String.fromCodePoint(90) ); // Z\n```\n\n我们还可以用 `\\u` 后跟十六进制代码，通过这些代码添加 Unicode 字符：\n\n```js\n// 在十六进制系统中 90 为 5a\nalert( \'\\u005a\' ); // Z\n```\n\n\n字符通过数字代码进行比较。越大的代码意味着字符越大。a（97）的代码大于 Z（90）的代码。\n\n * 所有小写字母追随在大写字母之后，因为它们的代码更大。\n * 一些像 Ö 的字母与主要字母表不同。这里，它的代码比任何从 a 到 z 的代码都要大。\n\n# 正确的比较\n\n现代浏览器（IE10- 需要额外的库 Intl.JS) 都支持国际化标准 ECMA-402。\n\n它提供了一种特殊的方法来比较不同语言的字符串，遵循它们的规则。\n\n调用 str.localeCompare(str2) 会根据语言规则返回一个整数，这个整数能指示字符串 str 在排序顺序中排在字符串 str2 前面、后面、还是相同：\n\n * 如果 str 排在 str2 前面，则返回负数。\n * 如果 str 排在 str2 后面，则返回正数。\n * 如果它们在相同位置，则返回 0。\n\n# 5.3.9 Unicode\n\n# 代理对\n\n所有常用的字符都是一个 2 字节的代码。大多数欧洲语言，数字甚至大多数象形文字中的字母都有 2 字节的表示形式。\n\n但 2 字节只允许 65536 个组合，这对于表示每个可能的符号是不够的。所以稀有的符号被称为“代理对”的一对 2 字节的符号编码。\n\n这些符号的长度是 2：\n\nalert( \'𝒳\'.length ); // 2，大写数学符号 X\nalert( \'😂\'.length ); // 2，笑哭表情\nalert( \'𩷶\'.length ); // 2，罕见的中国象形文字\n\n\n1\n2\n3\n\n\n注意，代理对在 JavaScript 被创建时并不存在，因此无法被编程语言正确处理！\n\n我们实际上在上面的每个字符串中都有一个符号，但 length 显示长度为 2。\n\nString.fromCodePoint 和 str.codePointAt 是几种处理代理对的少数方法。它们最近才出现在编程语言中。在它们之前，只有 String.fromCharCode 和 str.charCodeAt。这些方法实际上与 fromCodePoint/codePointAt 相同，但是不适用于代理对。\n\n获取符号可能会非常麻烦，因为代理对被认为是两个字符：\n\nalert( \'𝒳\'[0] ); // 奇怪的符号……\nalert( \'𝒳\'[1] ); // ……代理对的一块\n\n\n1\n2\n\n\n请注意，代理对的各部分没有任何意义。因此，上述示例中的 alert 显示的实际上是垃圾信息。\n\n技术角度来说，代理对也是可以通过它们的代码检测到的：如果一个字符的代码在 0xd800..0xdbff 范围内，那么它是代理对的第一部分。下一个字符（第二部分）必须在 0xdc00..0xdfff 范围中。这些范围是按照标准专门为代理对保留的。\n\n在上述示例中：\n\n// charCodeAt 不理解代理对，所以它给出了代理对的代码\nalert( \'𝒳\'.charCodeAt(0).toString(16) ); // d835，在 0xd800 和 0xdbff 之间\nalert( \'𝒳\'.charCodeAt(1).toString(16) ); // dcb3, 在 0xdc00 和 0xdfff 之间\n\n\n1\n2\n3\n\n\n本章节后面的 iterable 章节中，你可以找到更多处理代理对的方法\n\n# 变音符号与规范化\n\n在许多语言中，都有一些由基本字符组成的符号，在其上方/下方有一个标记。\n\n最常见的“复合”字符在 UTF-16 表中都有自己的代码。但不是全部，因为可能的组合太多。\n\n为了支持任意组合，UTF-16 允许我们使用多个 Unicode 字符：基本字符紧跟“装饰”它的一个或多个“标记”字符。\n\n例如，如果我们 S 后跟有特殊的 "dot above" 字符（代码 \\u0307），则显示 Ṡ。\n\nalert( \'S\\u0307\' ); // Ṡ\n\n\n1\n\n\n两个视觉上看起来相同的字符，可以用不同的 Unicode 组合表示。\n\n例如：\n\nlet s1 = \'S\\u0307\\u0323\'; // Ṩ，S + 上点 + 下点\nlet s2 = \'S\\u0323\\u0307\'; // Ṩ，S + 下点 + 上点\nalert( `s1: ${s1}, s2: ${s2}` );\nalert( s1 == s2 ); // false，尽管字符看起来相同（?!）\n\n\n1\n2\n3\n4\n\n\n为了解决这个问题，有一个 “Unicode 规范化”算法，它将每个字符串都转化成单个“通用”格式。\n\n它由 str.normalize() 实现。\n\nalert( "S\\u0307\\u0323".normalize() == "S\\u0323\\u0307".normalize() ); // true\n\n\n1\n\n\n有趣的是，在实际情况下，normalize() 实际上将一个由 3 个字符组成的序列合并为一个：\\u1e68（S 有两个点）。\n\nalert( "S\\u0307\\u0323".normalize().length ); // 1\nalert( "S\\u0307\\u0323".normalize() == "\\u1e68" ); // true\n\n\n1\n2\n\n\n事实上，情况并非总是如此，因为符号 Ṩ 是“常用”的，所以 UTF-16 创建者把它包含在主表中并给它了对应的代码。\n\n\n# 5.4 数组\n\n特殊的数据结构数组（Array）是一种 有序集合，里面的元素都是按顺序排列的\n\n# 5.4.1 声明数组\n\n创建一个空数组有两种语法：\n\nlet arr = new Array();\nlet arr = [];\n\n\n1\n2\n\n\n# 5.4.2 简单使用数组\n\n数组元素从 0 开始编号。\n\n我们可以通过方括号中的数字获取元素：\n\nlet fruits = ["Apple", "Orange", "Plum"];\nalert( fruits[0] ); // Apple\nalert( fruits[1] ); // Orange\nalert( fruits[2] ); // Plum\n\n\n1\n2\n3\n4\n\n\n可以替换元素：\n\nfruits[2] = \'Pear\'; // 现在变成了 ["Apple", "Orange", "Pear"]\n\n\n1\n\n\n……或者向数组新加一个元素：\n\nfruits[3] = \'Lemon\'; // 现在变成 ["Apple", "Orange", "Pear", "Lemon"]\n\n\n1\n\n\nlength 属性的值是数组中元素的总个数：\n\nlet fruits = ["Apple", "Orange", "Plum"];\nalert( fruits.length ); // 3\n\n\n1\n2\n\n\n也可以用 alert 来显示整个数组。\n\nlet fruits = ["Apple", "Orange", "Plum"];\nalert( fruits ); // Apple,Orange,Plum\n\n\n1\n2\n\n\n数组可以存储任何类型的元素。\n\n例如:\n\n// 混合值\nlet arr = [ \'Apple\', { name: \'John\' }, true, function() { alert(\'hello\'); } ];\n// 获取索引为 1 的对象然后显示它的 name\nalert( arr[1].name ); // John\n// 获取索引为 3 的函数并执行\narr[3](); // hello\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 5.4.3 使用 "at" 获取最后一个元素\n\n假设我们想要数组的最后一个元素。\n\n一些编程语言允许我们使用负数索引来实现这一点，例如 fruits[-1]。\n\n但在 JavaScript 中这行不通。结果将是 undefined，因为方括号中的索引是被按照其字面意思处理的。\n\n我们可以显式地计算最后一个元素的索引，然后访问它：fruits[fruits.length - 1]。\n\nlet fruits = ["Apple", "Orange", "Plum"];\nalert( fruits[fruits.length-1] ); // Plum\n\n\n1\n2\n\n\n有一个更简短的语法 fruits.at(-1)：\n\nlet fruits = ["Apple", "Orange", "Plum"];\n// 与 fruits[fruits.length-1] 相同\nalert( fruits.at(-1) ); // Plum\n\n\n1\n2\n3\n\n\n换句话说，arr.at(i)：\n\n * 如果 i >= 0，则与 arr[i] 完全相同。\n * 对于 i 为负数的情况，它则从数组的尾部向前数。\n\n# 5.4.4 pop/push, shift/unshift 方法\n\n队列（queue）是最常见的使用数组的方法之一。在计算机科学中，这表示支持两个操作的一个有序元素的集合：\n\n * push 在末端添加一个元素.\n * shift 取出队列首端的一个元素，整个队列往前移，这样原先排第二的元素现在排在了第一\n\n数组还有另一个用例，就是数据结构 栈。\n\n它支持两种操作：\n\n * push 在末端添加一个元素.\n * pop 从末端取出一个元素.\n\n所以新元素的添加和取出都是从“末端”开始的。\n\nJavaScript 中的数组既可以用作队列，也可以用作栈。它们允许你从首端/末端来添加/删除元素。\n\n这在计算机科学中，允许这样的操作的数据结构被称为 双端队列（deque）。\n\n作用于数组末端的方法：\n\npop : 取出并返回数组的最后一个元素：\n\n```js\nlet fruits = ["Apple", "Orange", "Pear"];\nalert( fruits.pop() ); // 移除 "Pear" 然后 alert 显示出来\nalert( fruits ); // Apple, Orange\n```\n\n`fruits.pop()` 和 `fruits.at(-1)` 都返回数组的最后一个元素，但 `fruits.pop()` 同时也删除了数组的最后一个元素，进而修改了原数组。\n\n\npush : 在数组末端添加元素：\n\n```js\nlet fruits = ["Apple", "Orange"];\nfruits.push("Pear");\nalert( fruits ); // Apple, Orange, Pear\n```\n\n调用 `fruits.push(...)` 与 `fruits[fruits.length] = ...` 是一样的。\n\n\n作用于数组首端的方法：\n\nshift : 取出数组的第一个元素并返回它：\n\n```js\nlet fruits = ["Apple", "Orange", "Pear"];\nalert( fruits.shift() ); // 移除 Apple 然后 alert 显示出来\nalert( fruits ); // Orange, Pear\n```\n\n\nunshift : 在数组的首端添加元素：\n\n```js\nlet fruits = ["Orange", "Pear"];\nfruits.unshift(\'Apple\');\nalert( fruits ); // Apple, Orange, Pear\n```\n\n\npush 和 unshift 方法都可以一次添加多个元素：\n\nlet fruits = ["Apple"];\nfruits.push("Orange", "Peach");\nfruits.unshift("Pineapple", "Lemon");\n// ["Pineapple", "Lemon", "Apple", "Orange", "Peach"]\nalert( fruits );\n\n\n1\n2\n3\n4\n5\n\n\n# 5.4.5 数组原理\n\n数组是一种特殊的对象。使用方括号来访问属性 arr[0] 实际上是来自于对象的语法。它其实与 obj[key] 相同，其中 arr 是对象，而数字用作键（key）。\n\n它们扩展了对象，提供了特殊的方法来处理有序的数据集合以及 length 属性。但从本质上讲，它仍然是一个对象。\n\n记住，在 JavaScript 中只有 8 种基本的数据类型。数组是一个对象，因此其行为也像一个对象。\n\n数组真正特殊的是它们的内部实现。JavaScript 引擎尝试把这些元素一个接一个地存储在连续的内存区域，就像本章的插图显示的一样，而且还有一些其它的优化，以使数组运行得非常快。\n\n但是，如果我们不像“有序集合”那样使用数组，而是像常规对象那样使用数组，这些就都不生效了。\n\nlet fruits = []; // 创建一个数组\nfruits[99999] = 5; // 分配索引远大于数组长度的属性\nfruits.age = 25; // 创建一个具有任意名称的属性\n\n\n1\n2\n3\n\n\n这是可以的，因为数组是基于对象的。我们可以给它们添加任何属性。\n\n但是 Javascript 引擎会发现，我们在像使用常规对象一样使用数组，那么针对数组的优化就不再适用了，然后对应的优化就会被关闭，这些优化所带来的优势也就荡然无存了。\n\n数组误用的几种方式:\n\n * 添加一个非数字的属性，比如 arr.test = 5。\n * 制造空洞，比如：添加 arr[0]，然后添加 arr[1000] (它们中间什么都没有)。\n * 以倒序填充数组，比如 arr[1000]，arr[999] 等等。\n\n请将数组视为作用于 有序数据 的特殊结构。它们为此提供了特殊的方法。数组在 JavaScript 引擎内部是经过特殊调整的，使得更好地作用于连续的有序数据，所以请以正确的方式使用数组。如果你需要任意键值，那很有可能实际上你需要的是常规对象 {}\n\n# 5.4.6 数组性能\n\npush/pop 方法运行的比较快，而 shift/unshift 比较慢\n\nshift 操作必须做三件事:\n\n 1. 移除索引为 0 的元素。\n 2. 把所有的元素向左移动，把索引 1 改成 0，2 改成 1 以此类推，对其重新编号。\n 3. 更新 length 属性。\n\n\n\n数组里的元素越多，移动它们就要花越多的时间，也就意味着越多的内存操作。\n\nunshift 也是一样：为了在数组的首端添加元素，我们首先需要将现有的元素向右移动，增加它们的索引值。\n\npush/pop 不需要移动任何东西。如果从末端移除一个元素，pop 方法只需要清理索引值并缩短 length 就可以了\n\npop 和push方法不需要移动任何东西，因为其它元素都保留了各自的索引。这就是为什么 pop 和push 会特别快。\n\n# 5.4.7 数组循环\n\n遍历数组最古老的方式就是 for 循环：\n\nlet arr = ["Apple", "Orange", "Pear"];\n*!*\nfor (let i = 0; i < arr.length; i++) {\n*/!*\n  alert( arr[i] );\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n但对于数组来说还有另一种循环方式，for..of：\n\nlet fruits = ["Apple", "Orange", "Plum"];\n// 遍历数组元素\nfor (let fruit of fruits) {\n  alert( fruit ); \n}\n\n\n1\n2\n3\n4\n5\n\n\nfor..of 不能获取当前元素的索引，只是获取元素值\n\n技术上来讲，因为数组也是对象，所以使用 for..in 也是可以的：\n\nlet arr = ["Apple", "Orange", "Pear"];\n*!*\nfor (let key in arr) {\n*/!*\n  alert( arr[key] ); // Apple, Orange, Pear\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n但这其实是一个很不好的想法。会有一些潜在问题存在：\n\n 1. for..in 循环会遍历 所有属性，不仅仅是这些数字属性。\n    \n    在浏览器和其它环境中有一种称为“类数组”的对象，它们 看似是数组。也就是说，它们有 length 和索引属性，但是也可能有其它的非数字的属性和方法，这通常是我们不需要的。for..in 循环会把它们都列出来。所以如果我们需要处理类数组对象，这些“额外”的属性就会存在问题。\n\n 2. for..in 循环适用于普通对象，并且做了对应的优化。但是不适用于数组，因此速度要慢 10-100 倍。当然即使是这样也依然非常快。只有在遇到瓶颈时可能会有问题。但是我们仍然应该了解这其中的不同。\n\n通常来说，我们不应该用 for..in 来处理数组。\n\n# 5.4.8 数组 "length"\n\n当我们修改数组的时候，length 属性会自动更新。它实际上不是数组里元素的个数，而是最大的数字索引值加一。\n\n例如，一个数组只有一个元素，但是这个元素的索引值很大，那么这个数组的 length 也会很大：\n\nlet fruits = [];\nfruits[123] = "Apple";\nalert( fruits.length ); // 124\n\n\n1\n2\n3\n\n\nlength 属性的另一个有意思的点是它是可写的。\n\n如果我们手动增加它，则不会发生任何有趣的事儿。但是如果我们减少它，数组就会被截断。该过程是不可逆的，下面是例子：\n\nlet arr = [1, 2, 3, 4, 5];\narr.length = 2; // 截断到只剩 2 个元素\nalert( arr ); // [1, 2]\narr.length = 5; // 又把 length 加回来\nalert( arr[3] ); // undefined：被截断的那些数值并没有回来\n\n\n1\n2\n3\n4\n5\n\n\n所以，清空数组最简单的方法就是：arr.length = 0;\n\n# 5.4.9 new Array()\n\n创建数组的另一种语法：\n\nlet arr = new Array("Apple", "Pear", "etc");\n\n\n1\n\n\n如果使用单个参数（即数字）调用 new Array，那么它会创建一个 指定了长度，却没有任何项 的数组。\n\nlet arr = new Array(2); // 会创建一个 [2] 的数组吗？\nalert( arr[0] ); // undefined！没有元素。\nalert( arr.length ); // length 2\n\n\n1\n2\n3\n\n\n# 5.4.10 多维数组\n\n数组里的项也可以是数组。我们可以将其用于多维数组，例如存储矩阵：\n\nlet matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\nalert( matrix[1][1] ); // 最中间的那个数\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 5.4.11 toString\n\n数组有自己的 toString 方法的实现，会返回以逗号隔开的元素列表。\n\n例如：\n\nlet arr = [1, 2, 3];\nalert( arr ); // 1,2,3\nalert( String(arr) === \'1,2,3\' ); // true\n\n\n1\n2\n3\n\n\n此外，我们试试运行一下这个：\n\nalert( [] + 1 ); // "1"\nalert( [1] + 1 ); // "11"\nalert( [1,2] + 1 ); // "1,21"\n\n\n1\n2\n3\n\n\n数组没有 Symbol.toPrimitive，也没有 valueOf，它们只能执行 toString 进行转换，所以这里 [] 就变成了一个空字符串，[1] 变成了 "1"，[1,2] 变成了 "1,2"。\n\n# 5.4.12 不要使用 == 比较数组\n\n该运算符不会对数组进行特殊处理，它会像处理任意对象那样处理数组。\n\n * 仅当两个对象引用的是同一个对象时，它们才相等 ==。\n * 如果 == 左右两个参数之中有一个参数是对象，另一个参数是原始类型，那么该对象将会被转换为原始类型\n * ……null 和 undefined 相等 ==，且各自不等于任何其他的值。\n\n严格比较 === 更简单，因为它不会进行类型转换。\n\n所以，如果我们使用 == 来比较数组，除非我们比较的是两个引用同一数组的变量，否则它们永远不相等。\n\n例如：\n\nalert( [] == [] ); // false\nalert( [0] == [0] ); // false\n\n\n1\n2\n\n\n从技术上讲，这些数组是不同的对象。所以它们不相等。== 运算符不会进行逐项比较。\n\n与原始类型的比较也可能会产生看似很奇怪的结果：\n\nalert( 0 == [] ); // true\nalert(\'0\' == [] ); // false\n// 在 [] 被转换为 \'\' 后\nalert( 0 == \'\' ); // true，因为 \'\' 被转换成了数字 0\nalert(\'0\' == \'\' ); // false，没有进一步的类型转换，是不同的字符串\n\n\n1\n2\n3\n4\n5\n\n\n在这里的两个例子中，我们将原始类型和数组对象进行比较。因此，数组 [] 被转换为原始类型以进行比较，被转换成了一个空字符串 \'\'。\n\n\n# 5.5 数组方法\n\n# 5.5.1 添加/移除数组元素\n\n * arr.push(...items) —— 从尾端添加元素，\n * arr.pop() —— 从尾端提取元素，\n * arr.shift() —— 从首端提取元素，\n * arr.unshift(...items) —— 从首端添加元素。\n\n# splice\n\n因为 delete方法是通过 key 来移除对应的值。对于对象来说是可以的。但是对于数组来说，我们希望剩下的元素能够移动并占据被释放的位置，否则length属性是不会自动变化的\n\narr.splice 方法可以说是处理数组的瑞士军刀。它可以做所有事情：添加，删除和插入元素。\n\narr.splice(start[, deleteCount, elem1, ..., elemN])\n\n\n1\n\n\n它从索引 start 开始修改 arr：删除 deleteCount 个元素并在当前位置插入 elem1, ..., elemN。最后返回已被删除元素的数组。\n\nlet arr = ["I", "study", "JavaScript","right", "now"];\n// 删除数组的前三项，并使用其他内容代替它们\nlet removed = arr.splice(0, 3, "Let\'s", "dance");\nalert( arr ) // 现在 ["Let\'s", "dance", "right", "now"]\nalert( removed ) //"I", "study", "JavaScript"\n\n\n1\n2\n3\n4\n5\n\n\n允许负向索引\n\n在这里和其他数组方法中，负向索引都是被允许的。它们从数组末尾计算位置，如下所示：\n\nlet arr = [1, 2, 5];\n// 从索引 -1（尾端前一位）\n// 删除 0 个元素，\n// 然后插入 3 和 4\narr.splice(-1, 0, 3, 4);\nalert( arr ); // 1,2,3,4,5\n\n\n1\n2\n3\n4\n5\n6\n\n\n# slice\n\narr.slice([start], [end])\n\n\n1\n\n\n它会返回一个新数组，将所有从索引 start 到 end（不包括 end）的数组项复制到一个新的数组。start 和 end 都可以是负数，在这种情况下，从末尾计算索引。\n\n它和字符串的 str.slice 方法有点像，就是把子字符串替换成子数组\n\nlet arr = ["t", "e", "s", "t"];\nalert( arr.slice(1, 3) ); // e,s（复制从位置 1 到位置 3 的元素）\nalert( arr.slice(-2) ); // s,t（复制从位置 -2 到尾端的元素）\n\n\n1\n2\n3\n\n\n我们也可以不带参数地调用它：arr.slice() 会创建一个 arr 的副本。其通常用于获取副本，以进行不影响原始数组的进一步转换。\n\n# concat\n\narr.concat 创建一个新数组，其中包含来自于其他数组和其他项的值。\n\narr.concat(arg1, arg2...)\n\n\n1\n\n\n它接受任意数量的参数 —— 数组或值都可以。结果是一个包含来自于 arr，然后是 arg1，arg2 的元素的新数组。\n\n如果参数 argN 是一个数组，那么其中的所有元素都会被复制。否则，将复制参数本身。\n\n例如：\n\nlet arr = [1, 2];\n// create an array from: arr and [3,4]\nalert( arr.concat([3, 4]) ); // 1,2,3,4\n// create an array from: arr and [3,4] and [5,6]\nalert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6\n// create an array from: arr and [3,4], then add values 5 and 6\nalert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通常，它只复制数组中的元素。其他对象，即使它们看起来像数组一样，但仍然会被作为一个整体添加：\n\nlet arr = [1, 2];\nlet arrayLike = {\n  0: "something",\n  length: 1\n};\nalert( arr.concat(arrayLike) ); // 1,2,[object Object]\n\n\n1\n2\n3\n4\n5\n6\n\n\n……但是，如果类似数组的对象具有 Symbol.isConcatSpreadable 属性，那么它就会被 concat 当作一个数组来处理：此对象中的元素将被添加：\n\n\n\n\n\n\n \n\n\n\n\n\nlet arr = [1, 2];\nlet arrayLike = {\n  0: "something",\n  1: "else",\n  [Symbol.isConcatSpreadable]: true,\n  length: 2\n};\nalert( arr.concat(arrayLike) ); // 1,2,something,else\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 5.5.2 遍历：forEach\n\narr.forEach 方法允许为数组的每个元素都运行一个函数。\n\n语法：\n\narr.forEach(function(item, index, array) {\n  // ... do something with item\n});\n\n\n1\n2\n3\n\n\n["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {\n  alert(`${item} is at index ${index} in ${array}`);\n});\n\n\n1\n2\n3\n\n\n该函数的结果（如果它有返回）会被抛弃和忽略\n\n# 5.5.3 搜索数组\n\n# indexOf/lastIndexOf 和 includes\n\narr.indexOf 和 arr.includes 方法语法相似，并且作用基本上也与字符串的方法相同，只不过这里是对数组元素而不是字符进行操作：\n\n * arr.indexOf(item, from) 从索引 from 开始搜索 item，如果找到则返回索引，否则返回 -1。\n * arr.includes(item, from) —— 从索引 from 开始搜索 item，如果找到则返回 true（译注：如果没找到，则返回 false）。\n\n注意\n\n请注意，indexOf 使用严格相等 === 进行比较。所以，如果我们搜索 false，它会准确找到 false 而不是数字 0。\n\n如果我们想检查数组中是否包含元素 item，并且不需要知道其确切的索引，那么 arr.includes 是首选。\n\n方法 arr.lastIndexOf 与 indexOf 相同，但从右向左查找。\n\nlet fruits = [\'Apple\', \'Orange\', \'Apple\'];\nalert( arr.indexOf(\'Apple\') ); // 0（第一个 Apple）\nalert( arr.lastIndexOf(\'Apple\') ); // 2（最后一个 Apple）\n\n\n1\n2\n3\n\n\n方法 `includes` 可以正确的处理 `NaN`\n\n方法 includes 的一个次要但值得注意的特性是，它可以正确处理 NaN，这与 indexOf 不同：\n\nconst arr = [NaN];\nalert( arr.indexOf(NaN) ); // -1（错，应该为 0）\nalert( arr.includes(NaN) );// true（正确）\n\n\n1\n2\n3\n\n\n这是因为 includes 是在比较晚的时候才被添加到 JavaScript 中的，并且在内部使用了更新了的比较算法。\n\n# find 和 findIndex/findLastIndex\n\nlet result = arr.find(function(item, index, array) {\n  // 如果返回 true，则返回 item 并停止迭代\n  // 对于假值（false）的情况，则返回 undefined\n});\n\n\n1\n2\n3\n4\n\n\n依次对数组中的每个元素调用该函数：\n\n * item 是元素。\n * index 是它的索引。\n * array 是数组本身。\n\n如果它返回 true，则搜索停止，并返回 item。如果没有搜索到，则返回 undefined。\n\nlet users = [\n  {id: 1, name: "John"},\n  {id: 2, name: "Pete"},\n  {id: 3, name: "Mary"}\n];\nlet user = users.find(item => item.id == 1);\nalert(user.name); // John\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\narr.findIndex 方法（与 arr.find）具有相同的语法，但它返回找到的元素的索引，而不是元素本身。如果没找到，则返回 -1。\n\narr.findLastIndex 方法类似于 findIndex，但从右向左搜索，类似于 lastIndexOf。\n\nlet users = [\n  {id: 1, name: "John"},\n  {id: 2, name: "Pete"},\n  {id: 3, name: "Mary"},\n  {id: 4, name: "John"}\n];\n// 寻找第一个 John 的索引\nalert(users.findIndex(user => user.name == \'John\')); // 0\n// 寻找最后一个 John 的索引\nalert(users.findLastIndex(user => user.name == \'John\')); // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# filter\n\nfilter 语法与 find 大致相同，但是返回的是所有匹配元素组成的数组：\n\nlet results = arr.filter(function(item, index, array) {\n  // 如果 true item 被 push 到 results，迭代继续\n  // 如果什么都没找到，则返回空数组\n});\n\n\n1\n2\n3\n4\n\n\nlet users = [\n  {id: 1, name: "John"},\n  {id: 2, name: "Pete"},\n  {id: 3, name: "Mary"}\n];\n// 返回前两个用户的数组\nlet someUsers = users.filter(item => item.id < 3);\nalert(someUsers.length); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 5.5.4 转换数组\n\n# map\n\narr.map 对数组的每个元素都调用函数，并返回结果数组。\n\nlet result = arr.map(function(item, index, array) {\n  // 返回新值而不是当前元素\n})\n\n\n1\n2\n3\n\n\nlet lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);\nalert(lengths); // 5,7,6\n\n\n1\n2\n\n\n# sort(fn)\n\narr.sort 方法对数组进行 原位（in-place） 排序，更改元素的顺序。(译注：原位是指在此数组内，而非生成一个新数组。)\n\n它还返回排序后的数组，但是返回值通常会被忽略，因为修改了 arr 本身。\n\n语法：\n\nlet arr = [ 1, 2, 15 ];\n// 该方法重新排列 arr 的内容\narr.sort();\nalert( arr );  // 1, 15, 2\n\n\n1\n2\n3\n4\n\n\n这些元素默认情况下被按字符串进行排序。\n\n从字面上看，所有元素都被转换为字符串，然后进行比较。对于字符串，按照词典顺序进行排序，实际上应该是 "2" > "15"。\n\n要使用我们自己的排序顺序，我们需要提供一个函数作为 arr.sort() 的参数。\n\n该函数应该比较两个任意值并返回：\n\nfunction compare(a, b) {\n  if (a > b) return 1; // 如果第一个值比第二个值大\n  if (a == b) return 0; // 如果两个值相等\n  if (a < b) return -1; // 如果第一个值比第二个值小\n}\n\n\n1\n2\n3\n4\n5\n\n\n例如，按数字进行排序：\n\nfunction compareNumeric(a, b) {\n  if (a > b) return 1;\n  if (a == b) return 0;\n  if (a < b) return -1;\n}\nlet arr = [ 1, 2, 15 ];\narr.sort(compareNumeric);\nalert(arr);  // 1, 2, 15\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n现在结果符合预期了。\n\narr 可以是由任何内容组成的数组，它可能包含数字、字符串、对象或其他任何内容。我们有一组 一些元素。要对其进行排序，我们需要一个 排序函数 来确认如何比较这些元素。默认是按字符串进行排序的。\n\narr.sort(fn) 方法实现了通用的排序算法。我们不需要关心它的内部工作原理（大多数情况下都是经过 快速排序 或 Timsort 算法优化的）。它将遍历数组，使用提供的函数比较其元素并对其重新排序，我们所需要的就是提供执行比较的函数 fn。\n\n比较函数可以返回任何数字\n\n实际上，比较函数只需要返回一个正数表示“大于”，一个负数表示“小于”。 通过这个原理我们可以编写更短的函数：\n\nlet arr = [ 1, 2, 15 ];\narr.sort(function(a, b) { return a - b; });\nalert(arr);  // *!*1, 2, 15*/!*\n\n\n1\n2\n3\n\n\n用 `localeCompare` for strings\n\n字符串比较默认情况下，它通过字母的代码比较字母。 对于许多字母，最好使用 str.localeCompare 方法正确地对字母进行排序，例如 Ö。\n\nlet countries = [\'Österreich\', \'Andorra\', \'Vietnam\'];\nalert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich（错的）\nalert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam（对的！）\n\n\n1\n2\n3\n\n\n# reverse\n\narr.reverse 方法用于颠倒 arr 中元素的顺序。\n\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();\nalert( arr ); // 5,4,3,2,1\n\n\n1\n2\n3\n\n\n它也会返回颠倒后的数组 arr\n\n# split 和 join\n\nstr.split(delim) 通过给定的分隔符 delim 将字符串分割成一个数组。\n\nsplit 方法有一个可选的第二个数字参数 —— 对数组长度的限制。如果提供了，那么额外的元素会被忽略。但实际上它很少使用：\n\nlet arr = \'Bilbo, Gandalf, Nazgul, Saruman\'.split(\', \', 2);\nalert(arr); // Bilbo, Gandalf\n\n\n1\n2\n\n\narr.join(glue) 与 split 相反。它会在它们之间创建一串由 glue 粘合的 arr 项。\n\n例如：\n\nlet arr = [\'Bilbo\', \'Gandalf\', \'Nazgul\'];\nlet str = arr.join(\';\'); // 使用分号 ; 将数组粘合成字符串\nalert( str ); // Bilbo;Gandalf;Nazgul\n\n\n1\n2\n3\n\n\n# reduce/reduceRight\n\narr.reduce 方法和 arr.reduceRight 用于根据数组计算单个值。\n\n语法是：\n\nlet value = arr.reduce(function(accumulator, item, index, array) {\n  // ...\n}, [initial]);\n\n\n1\n2\n3\n\n\n该函数一个接一个地应用于所有数组元素，并将其结果“搬运（carry on）”到下一个调用。\n\n参数：\n\n * accumulator —— 是上一个函数调用的结果，第一次等于 initial（如果提供了 initial 的话）。\n * item —— 当前的数组元素。\n * index —— 当前索引。\n * arr —— 数组本身。\n\n应用函数时，上一个函数调用的结果将作为第一个参数传递给下一个函数。因此，第一个参数本质上是累加器，用于存储所有先前执行的组合结果。最后，它成为 reduce 的结果。\n\n在这里，我们通过一行代码得到一个数组的总和：\n\nlet arr = [1, 2, 3, 4, 5];\nlet result = arr.reduce((sum, current) => sum + current, 0);\nalert(result); // 15\n\n\n1\n2\n3\n\n\n让我们看看细节，到底发生了什么。\n\n 1. 在第一次运行时，sum 的值为初始值 initial（reduce 的最后一个参数），等于 0，current 是第一个数组元素，等于 1。所以函数运行的结果是 1。\n 2. 在第二次运行时，sum = 1，我们将第二个数组元素（2）与其相加并返回。\n 3. 在第三次运行中，sum = 3，我们继续把下一个元素与其相加，以此类推……\n\n计算流程： 每一行代表的是对下一个数组元素的函数调用：\n\n          SUM   CURRENT   RESULT\n第 1 次调用   0     1         1\n第 2 次调用   1     2         3\n第 3 次调用   3     3         6\n第 4 次调用   6     4         10\n第 5 次调用   10    5         15\n\n我们也可以省略初始值：\n\nlet arr = [1, 2, 3, 4, 5];\n// 删除 reduce 的初始值（没有 0）\nlet result = arr.reduce((sum, current) => sum + current);\nalert( result ); // 15\n\n\n1\n2\n3\n4\n\n\n结果是一样的。这是因为如果没有初始值，那么 reduce 会将数组的第一个元素作为初始值，并从第二个元素开始迭代。\n\n但是这种使用需要非常小心。如果数组为空，那么在没有初始值的情况下调用 reduce 会导致错误。\n\n例如：\n\nlet arr = [];\n// Error: Reduce of empty array with no initial value\n// 如果初始值存在，则 reduce 将为空 arr 返回它（即这个初始值）。\narr.reduce((sum, current) => sum + current);\n\n\n1\n2\n3\n4\n\n\n所以建议始终指定初始值。\n\narr.reduceRight 和 arr.reduce 方法的功能一样，只是遍历为从右到左。\n\n# 5.5.5 Array.isArray\n\n数组是基于对象的，不构成单独的语言类型。\n\n所以 typeof 不能帮助从数组中区分出普通对象：\n\nalert(typeof {}); // object\nalert(typeof []); // object（相同）\n\n\n1\n2\n\n\n……但是数组经常被使用，因此有一种特殊的方法用于判断：Array.isArray(value)。如果 value 是一个数组，则返回 true；否则返回 false。\n\nalert(Array.isArray({})); // false\nalert(Array.isArray([])); // true\n\n\n1\n2\n\n\n# 5.5.6 大多数方法都支持 "thisArg"\n\n几乎所有调用函数的数组方法 —— 比如 find，filter，map，除了 sort 是一个特例，都接受一个可选的附加参数 thisArg。\n\n以下是这些方法的完整语法：\n\narr.find(func, thisArg);\narr.filter(func, thisArg);\narr.map(func, thisArg);\n// ...\n// thisArg 是可选的最后一个参数\n\n\n1\n2\n3\n4\n5\n\n\nthisArg 参数的值在 func 中变为 this。\n\n例如，在这里我们使用 army 对象方法作为过滤器，thisArg 用于传递上下文（passes the context）：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\nlet army = {\n  minAge: 18,\n  maxAge: 27,\n  canJoin(user) {\n    return user.age >= this.minAge && user.age < this.maxAge;\n  }\n};\nlet users = [\n  {age: 16},\n  {age: 20},\n  {age: 23},\n  {age: 30}\n];\n// 找到 army.canJoin 返回 true 的 user\nlet soldiers = users.filter(army.canJoin, army);\nalert(soldiers.length); // 2\nalert(soldiers[0].age); // 20\nalert(soldiers[1].age); // 23\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n如果在上面的示例中我们使用了 users.filter(army.canJoin)，那么 army.canJoin 将被作为独立函数调用，并且这时 this=undefined，从而会导致即时错误。\n\n\n# 5.6 可迭代对象\n\n可迭代（Iterable） 对象是数组的泛化。这个概念是说任何对象都可以被定制为可在 for..of 循环中使用的对象。\n\n# 5.6.1 Symbol.iterator\n\n为了让一个自己创建的对象可迭代（也就让 for..of 可以运行）我们需要为对象添加一个名为 Symbol.iterator 的方法（一个专门用于使对象可迭代的内建 symbol）。\n\n 1. 当 for..of 循环启动时，它会调用这个方法（如果没找到，就会报错）。这个方法必须返回一个 迭代器（iterator） —— 一个有 next 方法的对象。\n 2. 从此开始，for..of 仅适用于这个被返回的对象。\n 3. 当 for..of 循环希望取得下一个数值，它就调用这个对象的 next() 方法。\n 4. next() 方法返回的结果的格式必须是 {done: Boolean, value: any}，当 done=true 时，表示循环结束，否则 value 是下一个值。\n\nlet range = {\n  from: 1,\n  to: 5\n};\n// 1. for..of 调用首先会调用这个：\nrange[Symbol.iterator] = function() {\n  // ……它返回迭代器对象（iterator object）：\n  // 2. 接下来，for..of 仅与下面的迭代器对象一起工作，要求它提供下一个值\n  return {\n    current: this.from,\n    last: this.to,\n    // 3. next() 在 for..of 的每一轮循环迭代中被调用\n    next() {\n      // 4. 它将会返回 {done:.., value :...} 格式的对象\n      if (this.current <= this.last) {\n        return { done: false, value: this.current++ };\n      } else {\n        return { done: true };\n      }\n    }\n  };\n};\n// 现在它可以运行了！\nfor (let num of range) {\n  alert(num); // 1, 然后是 2, 3, 4, 5\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n关注点分离\n\n关注点分离是可迭代对象的核心功能\n\n * range 自身没有 next() 方法。\n * 相反，是通过调用 range[Symbol.iterator]() 创建了另一个对象，即所谓的“迭代器”对象，并且它的 next 会为迭代生成值。\n\n因此，迭代器对象和与其进行迭代的对象是分开的。\n\n从技术上说，我们可以将它们合并，并使用 range 自身作为迭代器来简化代码\n\nlet range = {\n  from: 1,\n  to: 5,\n  [Symbol.iterator]() {\n    this.current = this.from;\n    return this;\n  },\n  next() {\n    if (this.current <= this.to) {\n      return { done: false, value: this.current++ };\n    } else {\n      return { done: true };\n    }\n  }\n};\nfor (let num of range) {\n  alert(num); // 1, 然后是 2, 3, 4, 5\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n但缺点是，现在不可能同时在对象上运行两个 for..of 循环了：它们将共享迭代状态，因为只有一个迭代器，即对象本身。但是两个并行的 for..of 是很罕见的，即使在异步情况下\n\n无穷迭代器（iterator）\n\n无穷迭代器也是可能的。例如，将 range 设置为 range.to = Infinity，这时 range 则成为了无穷迭代器。或者我们可以创建一个可迭代对象，它生成一个无穷伪随机数序列。也是可能的。\n\nnext 没有什么限制，它可以返回越来越多的值，这是正常的。\n\n当然，迭代这种对象的 for..of 循环将不会停止。但是我们可以通过使用 break 来停止它。\n\n# 5.6.2 字符串迭代\n\n数组和字符串是使用最广泛的内建可迭代对象。\n\n对于一个字符串，for..of 遍历它的每个字符：\n\nfor (let char of "test") {\n  // 触发 4 次，每个字符一次\n  alert( char ); // t, then e, then s, then t\n}\n\n\n1\n2\n3\n4\n\n\n对于代理对（surrogate pairs），它也能正常工作！（译注：这里的代理对也就指的是 UTF-16 的扩展字符）\n\nlet str = \'𝒳😂\';\nfor (let char of str) {\n    alert( char ); // 𝒳，然后是 😂\n}\n\n\n1\n2\n3\n4\n\n\n# 5.6.3 显示调用迭代器\n\n不使用for..of，直接通过迭代器遍历字符串\n\nlet str = "Hello";\n// 和 for..of 做相同的事\n// for (let char of str) alert(char);\nlet iterator = str[Symbol.iterator]();\nwhile (true) {\n  let result = iterator.next();\n  if (result.done) break;\n  alert(result.value); // 一个接一个地输出字符\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n很少需要我们这样做，但是比 for..of 给了我们更多的控制权。例如，我们可以拆分迭代过程：迭代一部分，然后停止，做一些其他处理，然后再恢复迭代。\n\n# 5.6.4 可迭代（iterable）和类数组（array-like）\n\n这两个官方术语看起来差不多，但其实大不相同。请确保你能够充分理解它们的含义，以免造成混淆。\n\n * Iterable 如上所述，是实现了 Symbol.iterator 方法的对象。\n * Array-like 是有索引和 length 属性的对象，所以它们看起来很像数组。\n\n可迭代对象和类数组对象通常都 不是数组，它们没有 push 和 pop 等方法\n\n# 5.6.5 Array.from\n\n有一个全局方法 Array.from 可以接受一个可迭代或类数组的值，并从中获取一个“真正的”数组。然后我们就可以对其调用数组方法了。\n\nlet arrayLike = {\n  0: "Hello",\n  1: "World",\n  length: 2\n};\nlet arr = Array.from(arrayLike); // (*)\nalert(arr.pop()); // World（pop 方法有效）\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nArray.from 的完整语法允许我们提供一个可选的“映射（mapping）”函数：\n\nArray.from(obj[, mapFn, thisArg])\n\n\n1\n\n\n可选的第二个参数 mapFn 可以是一个函数，该函数会在对象中的元素被添加到数组前，被应用于每个元素，此外 thisArg 允许我们为该函数设置 this。\n\n例如：\n\n// 假设 range 来自上文例子中\n// 求每个数的平方\nlet arr = Array.from(range, num => num * num);\nalert(arr); // 1,4,9,16,25\n\n\n1\n2\n3\n4\n\n\n\n# 5.7 映射和集合\n\n# 5.7.1 Map\n\nMap 是一个带键的数据项的集合，就像一个 Object 一样。 但是它们最大的差别是 Map 允许任何类型的键（key）。\n\n它的方法和属性如下：\n\n * new Map() —— 创建 map。\n * map.set(key, value) —— 根据键存储值。\n * map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。\n * map.has(key) —— 如果 key 存在则返回 true，否则返回 false。\n * map.delete(key) —— 删除指定键的值。\n * map.clear() —— 清空 map。\n * map.size —— 返回当前元素个数\n\nlet map = new Map();\nmap.set(\'1\', \'str1\');   // 字符串键\nmap.set(1, \'num1\');     // 数字键\nmap.set(true, \'bool1\'); // 布尔值键\n// 还记得普通的 Object 吗? 它会将键转化为字符串\n// Map 则会保留键的类型，所以下面这两个结果不同：\nalert( map.get(1)   ); // \'num1\'\nalert( map.get(\'1\') ); // \'str1\'\nalert( map.size ); // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如我们所见，与对象不同，键不会被转换成字符串。键可以是任何类型\n\n`map[key]` 不是使用 `Map` 的正确方式\n\n虽然 map[key] 也有效，例如我们可以设置 map[key] = 2，这样会将 map 视为 JavaScript 的 plain object，因此它暗含了所有相应的限制（仅支持 string/symbol 键等）。\n所以我们应该使用 map 方法：set 和 get 等。\n\nMap 还可以使用对象作为键。 使用对象作为键是 Map 最值得注意和重要的功能之一。在 Object 中，我们则无法使用对象作为键。在 Object 中使用字符串作为键是可以的，但我们无法使用另一个 Object 作为 Object 中的键\n\nlet john = { name: "John" };\n// 存储每个用户的来访次数\nlet visitsCountMap = new Map();\n// john 是 Map 中的键\nvisitsCountMap.set(john, 123);\nalert( visitsCountMap.get(john) ); // 123\n\nlet john = { name: "John" };\nlet ben = { name: "Ben" };\nlet visitsCountObj = {}; // 尝试使用对象\nvisitsCountObj[ben] = 234; // 尝试将对象 ben 用作键\nvisitsCountObj[john] = 123; // 尝试将对象 john 用作键，但我们会发现使用对象 ben 作为键存下的值会被替换掉\n// 变成这样了！\nalert( visitsCountObj["[object Object]"] ); // 123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# Map 比较键\n\nMap 使用 SameValueZero 算法来比较键是否相等。它和严格等于 === 差不多，但区别是 NaN 被看成是等于 NaN。所以 NaN 也可以被用作键。\n这个算法不能被改变或者自定义。\n\n# 链式调用\n\n每一次 map.set 调用都会返回 map 本身，所以我们可以进行“链式”调用：\n\nmap.set(\'1\', \'str1\')\n  .set(1, \'num1\')\n  .set(true, \'bool1\');\n\n\n1\n2\n3\n\n\n# 5.7.2 Map 迭代\n\n如果要在 map 里使用循环，可以使用以下三个方法：\n\n * map.keys() —— 遍历并返回一个包含所有键的可迭代对象，\n * map.values() —— 遍历并返回一个包含所有值的可迭代对象，\n * map.entries() —— 遍历并返回一个包含所有实体 [key, value] 的可迭代对象，for..of 在默认情况下使用的就是这个。\n\nlet recipeMap = new Map([\n  [\'cucumber\', 500],\n  [\'tomatoes\', 350],\n  [\'onion\',    50]\n]);\n// 遍历所有的键（vegetables）\nfor (let vegetable of recipeMap.keys()) {\n  alert(vegetable); // cucumber, tomatoes, onion\n}\n// 遍历所有的值（amounts）\nfor (let amount of recipeMap.values()) {\n  alert(amount); // 500, 350, 50\n}\n// 遍历所有的实体 [key, value]\nfor (let entry of recipeMap) { // 与 recipeMap.entries() 相同\n  alert(entry); // cucumber,500 (and so on)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n使用插入顺序\n\n迭代的顺序与插入值的顺序相同。与普通的 Object 不同，Map 保留了此顺序\n\n# 5.7.3 Object.entries：从对象创建 Map\n\n当创建一个 Map 后，我们可以传入一个带有键值对的数组（或其它可迭代对象）来进行初始化，如下所示：\n\n// 键值对 [key, value] 数组\nlet map = new Map([\n  [\'1\',  \'str1\'],\n  [1,    \'num1\'],\n  [true, \'bool1\']\n]);\nalert( map.get(\'1\') ); // str1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果我们想从一个已有的普通对象（plain object）来创建一个 Map，那么我们可以使用内建方法 Object.entries(obj)，该方法返回对象的键/值对数组，该数组格式完全按照 Map 所需的格式。\n\n所以可以像下面这样从一个对象创建一个 Map：\n\nlet obj = {\n  name: "John",\n  age: 30\n};\n*!*\nlet map = new Map(Object.entries(obj));\n*/!*\nalert( map.get(\'name\') ); // John\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这里，Object.entries 返回键/值对数组：[ ["name","John"], ["age", 30] ]。这就是 Map 所需要的格式\n\n# 5.7.4 Object.fromEntries：从 Map 创建对象\n\nObject.fromEntries 方法的作用是相反的：给定一个具有 [key, value] 键值对的数组，它会根据给定数组创建一个对象：\n\nlet prices = Object.fromEntries([\n  [\'banana\', 1],\n  [\'orange\', 2],\n  [\'meat\', 4]\n]);\n// 现在 prices = { banana: 1, orange: 2, meat: 4 }\nalert(prices.orange); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n我们可以使用 Object.fromEntries 从 Map 得到一个普通对象（plain object）。\n\n例如，我们在 Map 中存储了一些数据，但是我们需要把这些数据传给需要普通对象（plain object）的第三方代码。\n\n我们来开始：\n\nlet map = new Map();\nmap.set(\'banana\', 1);\nmap.set(\'orange\', 2);\nmap.set(\'meat\', 4);\n*!*\nlet obj = Object.fromEntries(map.entries()); // 创建一个普通对象（plain object）(*)\n*/!*\n// 完成了！\n// obj = { banana: 1, orange: 2, meat: 4 }\nalert(obj.orange); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n调用 map.entries() 将返回一个可迭代的键/值对，这刚好是 Object.fromEntries 所需要的格式。\n\n我们可以把带 (*) 这一行写得更短：\n\nlet obj = Object.fromEntries(map); // 省掉 .entries()\n\n\n1\n\n\n上面的代码作用也是一样的，因为 Object.fromEntries 期望得到一个可迭代对象作为参数，而不一定是数组。并且 map 的标准迭代会返回跟 map.entries() 一样的键/值对。因此，我们可以获得一个普通对象（plain object），其键/值对与 map 相同。\n\n# 5.7.5 Set\n\nSet 是一个特殊的类型集合 —— “值的集合”（没有键），它的每一个值只能出现一次。\n\n它的主要方法如下：\n\n * new Set(iterable) —— 创建一个 set，如果提供了一个 iterable 对象（通常是数组），将会从数组里面复制值到 set 中。\n * set.add(value) —— 添加一个值，返回 set 本身\n * set.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。\n * set.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。\n * set.clear() —— 清空 set。\n * set.size —— 返回元素个数。\n\n它的主要特点是，重复使用同一个值调用 set.add(value) 并不会发生什么改变。这就是 Set 里面的每一个值只出现一次的原因。\n\nlet set = new Set();\nlet john = { name: "John" };\nlet pete = { name: "Pete" };\nlet mary = { name: "Mary" };\n// visits，一些访客来访好几次\nset.add(john);\nset.add(pete);\nset.add(mary);\nset.add(john);\nset.add(mary);\n// set 只保留不重复的值\nalert( set.size ); // 3\nfor (let user of set) {\n  alert(user.name); // John（然后 Pete 和 Mary）\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nSet 的替代方法可以是一个用户数组，用 arr.find 在每次插入值时检查是否重复。但是这样性能会很差，因为这个方法会遍历整个数组来检查每个元素。Set 内部对唯一性检查进行了更好的优化。\n\n# 5.7.6 Set 迭代（iteration）\n\n我们可以使用 for..of 或 forEach 来遍历 Set：\n\nlet set = new Set(["oranges", "apples", "bananas"]);\nfor (let value of set) alert(value);\n// 与 forEach 相同：\nset.forEach((value, valueAgain, set) => {\n  alert(value);\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意一件有趣的事儿。forEach 的回调函数有三个参数：一个 value，然后是 同一个值 valueAgain，最后是目标对象。没错，同一个值在参数里出现了两次。\n\nforEach 的回调函数有三个参数，是为了与 Map 兼容。当然，这看起来确实有些奇怪。但是这对在特定情况下轻松地用 Set 代替 Map 很有帮助，反之亦然。\n\nMap 中用于迭代的方法在 Set 中也同样支持：\n\n * set.keys() —— 遍历并返回一个包含所有值的可迭代对象，\n * set.values() —— 与 set.keys() 作用相同，这是为了兼容 Map，\n * set.entries() —— 遍历并返回一个包含所有的实体 [value, value] 的可迭代对象，它的存在也是为了兼容 Map。\n\n\n# 5.8 WeakMap and WeakSet（弱映射和弱集合）\n\n通常，当对象、数组之类的数据结构在内存中时，它们的子元素，如对象的属性、数组的元素都被认为是可达的\n如果我们使用对象作为常规 Map 的键，那么当 Map 存在时，该对象也将存在。它会占用内存，并且不会被（垃圾回收机制）回收。\n\nlet john = { name: "John" };\nlet map = new Map();\nmap.set(john, "...");\njohn = null; // 覆盖引用\n// john 被存储在了 map 中，\n// 我们可以使用 map.keys() 来获取它\n\n\n1\n2\n3\n4\n5\n6\n\n\nWeakMap 在这方面有着根本上的不同。它不会阻止垃圾回收机制对作为键的对象（key object）的回收。\n\n# 5.8.1 WeakMap\n\nWeakMap 和 Map 的第一个不同点就是，WeakMap 的键必须是对象，不能是原始值 如果我们在 weakMap 中使用一个对象作为键，并且没有其他对这个对象的引用 —— 该对象将会被从内存（和map）中自动清除。\n\nlet john = { name: "John" };\nlet weakMap = new WeakMap();\nweakMap.set(john, "...");\njohn = null; // 覆盖引用\n// john 被从内存中删除了！\n\n\n1\n2\n3\n4\n5\n\n\n与上面常规的 Map 的例子相比，现在如果 john 仅仅是作为 WeakMap 的键而存在 —— 它将会被从 map（和内存）中自动删除。\n\nWeakMap 不支持迭代以及 keys()，values() 和 entries() 方法。所以没有办法获取 WeakMap 的所有键或值。\n\nWeakMap 只有以下的方法：\n\n * weakMap.get(key)\n * weakMap.set(key, value)\n * weakMap.delete(key)\n * weakMap.has(key)\n\n为什么会有这种限制呢？这是技术的原因。如果一个对象丢失了其它所有引用（就像上面示例中的 john），那么它就会被垃圾回收机制自动回收。但是在从技术的角度并不能准确知道 何时会被回收。\n\n这些都是由 JavaScript 引擎决定的。JavaScript 引擎可能会选择立即执行内存清理，如果现在正在发生很多删除操作，那么 JavaScript 引擎可能就会选择等一等，稍后再进行内存清理。因此，从技术上讲，WeakMap 的当前元素的数量是未知的。JavaScript 引擎可能清理了其中的垃圾，可能没清理，也可能清理了一部分。因此，暂不支持访问 WeakMap 的所有键/值的方法。\n\n# 5.8.2 WeakMap使用案例\n\n# 额外的数据\n\nWeakMap 的主要应用场景是 额外数据的存储。\n\n假如我们正在处理一个“属于”另一个代码的一个对象，也可能是第三方库，并想存储一些与之相关的数据，那么这些数据就应该与这个对象共存亡 —— 这时候 WeakMap 正是我们所需要的利器。\n\n我们将这些数据放到 WeakMap 中，并使用该对象作为这些数据的键，那么当该对象被垃圾回收机制回收后，这些数据也会被自动清除。\n\nweakMap.set(john, "secret documents");\n// 如果 john 消失，secret documents 将会被自动清除\n\n\n1\n2\n\n\n例如，我们有用于处理用户访问计数的代码。收集到的信息被存储在 map 中：一个用户对象作为键，其访问次数为值。当一个用户离开时（该用户对象将被垃圾回收机制回收），这时我们就不再需要他的访问次数了。\n\n下面是一个使用 Map 的计数函数的例子：\n\n// 📁 visitsCount.js\nlet visitsCountMap = new Map(); // map: user => visits count\n// 递增用户来访次数\nfunction countUser(user) {\n  let count = visitsCountMap.get(user) || 0;\n  visitsCountMap.set(user, count + 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n下面是其他部分的代码，可能是使用它的其它代码：\n\n// 📁 main.js\nlet john = { name: "John" };\ncountUser(john); // count his visits\n// 不久之后，john 离开了\njohn = null;\n\n\n1\n2\n3\n4\n5\n\n\n现在，john 这个对象应该被垃圾回收，但它仍在内存中，因为它是 visitsCountMap 中的一个键。\n\n当我们移除用户时，我们需要清理 visitsCountMap，否则它将在内存中无限增大。在复杂的架构中，这种清理会成为一项繁重的任务。\n\n我们可以通过使用 WeakMap 来避免这样的问题：\n\n// 📁 visitsCount.js\nlet visitsCountMap = new WeakMap(); // weakmap: user => visits count\n// 递增用户来访次数\nfunction countUser(user) {\n  let count = visitsCountMap.get(user) || 0;\n  visitsCountMap.set(user, count + 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n现在我们不需要去清理 visitsCountMap 了。当 john 对象变成不可达时，即便它是 WeakMap 里的一个键，它也会连同它作为 WeakMap 里的键所对应的信息一同被从内存中删除。\n\n# 缓存\n\n另外一个常见的例子是缓存。我们可以存储（“缓存”）函数的结果，以便将来对同一个对象的调用可以重用这个结果。\n\n为了实现这一点，我们可以使用 Map（非最佳方案）：\n\n// 📁 cache.js\nlet cache = new Map();\n// 计算并记住结果\nfunction process(obj) {\n  if (!cache.has(obj)) {\n    let result = /* calculations of the result for */ obj;\n    cache.set(obj, result);\n  }\n  return cache.get(obj);\n}\n// 现在我们在其它文件中使用 process()\n// 📁 main.js\nlet obj = {/* 假设我们有个对象 */};\nlet result1 = process(obj); // 计算完成\n// ……稍后，来自代码的另外一个地方……\nlet result2 = process(obj); // 取自缓存的被记忆的结果\n// ……稍后，我们不再需要这个对象时：\nobj = null;\nalert(cache.size); // 1（啊！该对象依然在 cache 中，并占据着内存！）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n对于多次调用同一个对象，它只需在第一次调用时计算出结果，之后的调用可以直接从 cache 中获取。这样做的缺点是，当我们不再需要这个对象的时候需要清理 cache。\n\n如果我们用 WeakMap 替代 Map，便不会存在这个问题。当对象被垃圾回收时，对应缓存的结果也会被自动从内存中清除。\n\n// 📁 cache.js\nlet cache = new WeakMap();\n// 计算并记结果\nfunction process(obj) {\n  if (!cache.has(obj)) {\n    let result = /* calculate the result for */ obj;\n    cache.set(obj, result);\n  }\n  return cache.get(obj);\n}\n// 📁 main.js\nlet obj = {/* some object */};\nlet result1 = process(obj);\nlet result2 = process(obj);\n// ……稍后，我们不再需要这个对象时：\nobj = null;\n// 无法获取 cache.size，因为它是一个 WeakMap，\n// 要么是 0，或即将变为 0\n// 当 obj 被垃圾回收，缓存的数据也会被清除\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 5.8.3 WeakSet\n\nWeakSet 的表现类似：\n\n * 与 Set 类似，但是我们只能向 WeakSet 添加对象（而不能是原始值）。\n * 对象只有在其它某个（些）地方能被访问的时候，才能留在 WeakSet 中。\n * 跟 Set 一样，WeakSet 支持 add，has 和 delete 方法，但不支持 size 和 keys()，并且不可迭代。\n\n变“弱（weak）”的同时，它也可以作为额外的存储空间。但并非针对任意数据，而是针对“是/否”的事实。WeakSet 的元素可能代表着有关该对象的某些信息。\n\n例如，我们可以将用户添加到 WeakSet 中，以追踪访问过我们网站的用户：\n\nlet visitedSet = new WeakSet();\nlet john = { name: "John" };\nlet pete = { name: "Pete" };\nlet mary = { name: "Mary" };\nvisitedSet.add(john); // John 访问了我们\nvisitedSet.add(pete); // 然后是 Pete\nvisitedSet.add(john); // John 再次访问\n// visitedSet 现在有两个用户了\n// 检查 John 是否来访过？\nalert(visitedSet.has(john)); // true\n// 检查 Mary 是否来访过？\nalert(visitedSet.has(mary)); // false\njohn = null;\n// visitedSet 将被自动清理(即自动清除其中已失效的值 john)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nWeakMap 和 WeakSet 最明显的局限性就是不能迭代，并且无法获取所有当前内容。那样可能会造成不便，但是并不会阻止 WeakMap/WeakSet 完成其主要工作 —— 为在其它地方存储/管理的对象数据提供“额外”存储。\n\n\n# 5.9 对象迭代\n\n在前面的章节中，我们认识了 map.keys()，map.values() 和 map.entries() 方法。\n\n这些方法是通用的，有一个共同的约定来将它们用于各种数据结构。如果我们创建一个我们自己的数据结构，我们也应该实现这些方法。\n\n它们支持：\n\n * Map\n * Set\n * Array\n\n普通对象也支持类似的方法，但是语法上有一些不同\n\n# 5.9.1 Object.keys，values，entries\n\n对于普通对象，下列这些方法是可用的：\n\n * Object.keys(obj) —— 返回一个包含该对象所有的键的数组。\n * Object.values(obj) —— 返回一个包含该对象所有的值的数组。\n * Object.entries(obj) —— 返回一个包含该对象所有 [key, value] 键值对的数组。\n\n……但是请注意区别（比如说跟 map 的区别）：\n\n       MAP          OBJECT\n调用语法   map.keys()   Object.keys(obj)，而不是 obj.keys()\n返回值    可迭代对象        “真正的”数组\n\n第一个区别是，对于对象我们使用的调用语法是 Object.keys(obj)，而不是 obj.keys()。\n\n为什么会这样？主要原因是灵活性。请记住，在 JavaScript 中，对象是所有复杂结构的基础。因此，我们可能有一个自己创建的对象，比如 data，并实现了它自己的 data.values() 方法。同时，我们依然可以对它调用 Object.values(data) 方法。\n\n第二个区别是 Object.* 方法返回的是“真正的”数组对象，而不只是一个可迭代对象。这主要是历史原因。\n\n举个例子：\n\nlet user = {\n  name: "John",\n  age: 30\n};\n\n\n1\n2\n3\n4\n\n * Object.keys(user) = ["name", "age"]\n * Object.values(user) = ["John", 30]\n * Object.entries(user) = [ ["name","John"], ["age",30] ]\n\n这里有一个使用 Object.values 来遍历属性值的例子：\n\nlet user = {\n  name: "John",\n  age: 30\n};\n// 遍历所有的值\nfor (let value of Object.values(user)) {\n  alert(value); // John, then 30\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nObject.keys/values/entries 会忽略 symbol 属性\n\n就像 for..in 循环一样，这些方法会忽略使用 Symbol(...) 作为键的属性。 通常这很方便。但是，如果我们也想要 Symbol 类型的键，那么这儿有一个单独的方法 Object.getOwnPropertySymbols，它会返回一个只包含 Symbol 类型的键的数组。另外，还有一种方法 Reflect.ownKeys(obj)，它会返回 所有 键。\n\n# 5.9.2 转换对象\n\n对象缺少数组存在的许多方法，例如 map 和 filter 等。\n\n如果我们想应用它们，那么我们可以使用 Object.entries，然后使用 Object.fromEntries：\n\n 1. 使用 Object.entries(obj) 从 obj 获取由键/值对组成的数组。\n 2. 对该数组使用数组方法，例如 map，对这些键/值对进行转换。\n 3. 对结果数组使用 Object.fromEntries(array) 方法，将结果转回成对象。\n\n例如，我们有一个带有价格的对象，并想将它们加倍：\n\nlet prices = {\n  banana: 1,\n  orange: 2,\n  meat: 4,\n};\nlet doublePrices = Object.fromEntries(\n  // 将价格转换为数组，将每个键/值对映射为另一对\n  // 然后通过 fromEntries 再将结果转换为对象\n  Object.entries(prices).map(entry => [entry[0], entry[1] * 2])\n);\nalert(doublePrices.meat); // 8\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 5.10 解构赋值\n\nJavaScript 中最常用的两种数据结构是 Object 和 Array。\n\n * 对象是一种根据键存储数据的实体。\n * 数组是一种直接存储数据的有序列表。\n\n但是，当我们把它们传递给函数时，函数可能不需要整个对象/数组，而只需要其中一部分。\n\n解构赋值 是一种特殊的语法，它使我们可以将数组或对象“拆包”至一系列变量中。有时这样做更方便\n\n# 5.10.1 数组解构\n\n// 我们有一个存放了名字和姓氏的数组\nlet arr = ["John", "Smith"]\n*!*\n// 解构赋值\n// 设置 firstName = arr[0]\n// 以及 surname = arr[1]\nlet [firstName, surname] = arr;\n*/!*\nalert(firstName); // John\nalert(surname);  // Smith\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们可以使用这些变量而非原来的数组项了。\n\n当与 split 函数（或其他返回值为数组的函数）结合使用时，看起来更优雅：\n\nlet [firstName, surname] = "John Smith".split(\' \');\nalert(firstName); // John\nalert(surname);  // Smith\n\n\n1\n2\n3\n\n\n“解构”并不意味着“破坏”\n\n这种语法被叫做“解构赋值”，是因为它“拆开”了数组或对象，将其中的各元素复制给一些变量。原来的数组或对象自身没有被修改。\n换句话说，解构赋值只是写起来简洁一点。以下两种写法是等价的：\n\n// let [firstName, surname] = arr;\nlet firstName = arr[0];\nlet surname = arr[1];\n\n\n1\n2\n3\n\n\n忽略使用逗号的元素\n\n可以通过添加额外的逗号来丢弃数组中不想要的元素：\n\n// 不需要第二个元素\nlet [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];\nalert( title ); // Consul\n\n\n1\n2\n3\n\n\n在上面的代码中，数组的第二个元素被跳过了，第三个元素被赋值给了 title 变量。数组中剩下的元素也都被跳过了（因为在这没有对应给它们的变量）\n\n等号右侧可以是任何可迭代对\n\n实际上，我们可以将其与任何可迭代对象一起使用，而不仅限于数组：\n\nlet [a, b, c] = "abc"; // ["a", "b", "c"]\nlet [one, two, three] = new Set([1, 2, 3]);\n\n\n1\n2\n\n\n这种情况下解构赋值是通过迭代右侧的值来完成工作的。这是一种用于对在 = 右侧的值上调用 for..of 并进行赋值的操作的语法糖\n\n赋值给等号左侧的任何内容\n\n我们可以在等号左侧使用任何“可以被赋值的”东西。 例如，一个对象的属性：\n\nlet user = {};\n[user.name, user.surname] = "John Smith".split(\' \');\nalert(user.name); // John\nalert(user.surname); // Smith\n\n\n1\n2\n3\n4\n\n\n与 .entries() 方法进行循环操作\n\n在前面的章节中我们已经见过了 Object.entries(obj) 方法。 我们可以将 .entries() 方法与解构语法一同使用，来遍历一个对象的“键—值”对：\n\nlet user = {\n  name: "John",\n  age: 30\n};\n// 使用循环遍历键—值对\nfor (let [key, value] of Object.entries(user)) {\n  alert(`${key}:${value}`); // name:John, then age:30\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n用于 Map 的类似代码更简单，因为 Map 是可迭代的：\n\nlet user = new Map();\nuser.set("name", "John");\nuser.set("age", "30");\n// Map 是以 [key, value] 对的形式进行迭代的，非常便于解构\nfor (let [key, value] of user) {\n  alert(`${key}:${value}`); // name:John, then age:30\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n交换变量值的技巧\n\n使用解构赋值来交换两个变量的值是一个著名的技巧：\n\nlet guest = "Jane";\nlet admin = "Pete";\n// 让我们来交换变量的值：使得 guest = Pete，admin = Jane\n[guest, admin] = [admin, guest];\nalert(`${guest} ${admin}`); // Pete Jane（成功交换！）\n\n\n1\n2\n3\n4\n5\n\n\n这里我们创建了一个由两个变量组成的临时数组，并且立即以颠倒的顺序对其进行了解构赋值。\n我们也可以用这种方式交换两个以上的变量\n\n# 其余的 \'...\'\n\n通常，如果数组比左边的列表长，那么“其余”的数组项会被省略。\n\n例如，这里只取了两项，其余的就被忽略了：\n\nlet [name1, name2] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];\nalert(name1); // Julius\nalert(name2); // Caesar\n// 其余数组项未被分配到任何地方\n\n\n1\n2\n3\n4\n\n\n如果我们还想收集其余的数组项 —— 我们可以使用三个点 "..." 来再加一个参数以获取其余数组项：\n\nlet [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];\n// rest 是包含从第三项开始的其余数组项的数组\nalert(rest[0]); // Consul\nalert(rest[1]); // of the Roman Republic\nalert(rest.length); // 2\n\n\n\n1\n2\n3\n4\n5\n6\n\n\nrest 的值就是数组中剩下的元素组成的数组。\n\n不一定要使用变量名 rest，我们也可以使用任何其他的变量名。只要确保它前面有三个点，并且在解构赋值的最后一个参数位置上就行了：\n\nlet [name1, name2, ...titles] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];\n// 现在 titles = ["Consul", "of the Roman Republic"]\n\n\n1\n2\n\n\n# 默认值\n\n如果数组比左边的变量列表短，这里不会出现报错。缺少对应值的变量都会被赋 undefined：\n\nlet [firstName, surname] = [];\nalert(firstName); // undefined\nalert(surname); // undefined\n\n\n1\n2\n3\n\n\n如果我们想要一个“默认”值给未赋值的变量，我们可以使用 = 来提供：\n\n// 默认值\nlet [name = "Guest", surname = "Anonymous"] = ["Julius"];\nalert(name);    // Julius（来自数组的值）\nalert(surname); // Anonymous（默认值被使用了）\n\n\n1\n2\n3\n4\n\n\n默认值可以是更加复杂的表达式，甚至可以是函数调用。不过，这些表达式或函数只会在这个变量未被赋值的时候才会被计算。\n\n举个例子，我们使用了 prompt 函数来提供两个默认值：\n\n// 只会提示输入姓氏\nlet [name = prompt(\'name?\'), surname = prompt(\'surname?\')] = ["Julius"];\nalert(name);    // Julius（来自数组）\nalert(surname); // 你输入的值\n\n\n1\n2\n3\n4\n\n\n请注意：prompt 将仅针对缺失值（surname）运行\n\n# 5.10.2 对象解构\n\n解构赋值同样适用于对象。基本语法是：\n\nlet {var1, var2} = {var1:…, var2:…}\n\n\n1\n\n\n在等号右侧是一个已经存在的对象，我们想把它拆分到变量中。等号左侧包含了对象相应属性的一个类对象“模式（pattern）”。在最简单的情况下，等号左侧的就是 {...} 中的变量名列表。\n\n如下所示：\n\nlet options = {\n  title: "Menu",\n  width: 100,\n  height: 200\n};\n*!*\nlet {title, width, height} = options;\n*/!*\nalert(title);  // Menu\nalert(width);  // 100\nalert(height); // 200\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n属性 options.title、options.width 和 options.height 值被赋给了对应的变量。\n\n变量的顺序并不重要，下面这个代码也是等价的：\n\n// 改变 let {...} 中元素的顺序\nlet {height, width, title} = { title: "Menu", height: 200, width: 100 }\n\n\n1\n2\n\n\n等号左侧的模式（pattern）可以更加复杂，指定属性和变量之间的映射关系。\n\n如果我们想把一个属性赋值给另一个名字的变量，比如把 options.width 属性赋值给名为 w 的变量，那么我们可以使用冒号来设置变量名称：\n\nlet options = {\n  title: "Menu",\n  width: 100,\n  height: 200\n};\n// { sourceProperty: targetVariable }\nlet {width: w, height: h, title} = options;\n// width -> w\n// height -> h\n// title -> title\nalert(title);  // Menu\nalert(w);      // 100\nalert(h);      // 200\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n冒号的语法是“从对象中什么属性的值：赋值给哪个变量”。上面的例子中，属性 width 被赋值给了 w，属性 height 被赋值给了 h，属性 title 被赋值给了同名变量。\n\n对于可能缺失的属性，我们可以使用 "=" 设置默认值，如下所示：\n\nlet options = {\n  title: "Menu"\n};\n*!*\nlet {width = 100, height = 200, title} = options;\n*/!*\nalert(title);  // Menu\nalert(width);  // 100\nalert(height); // 200\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n就像数组或函数参数一样，默认值可以是任意表达式甚至可以是函数调用。它们只会在未提供对应的值时才会被计算/调用。\n\n在下面的代码中，prompt 提示输入 width 值，但不会提示输入 title 值：\n\nlet options = {\n  title: "Menu"\n};\n*!*\nlet {width = prompt("width?"), title = prompt("title?")} = options;\n*/!*\nalert(title);  // Menu\nalert(width);  // (prompt 的返回值)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们还可以将冒号和等号结合起来：\n\nlet options = {\n  title: "Menu"\n};\n*!*\nlet {width: w = 100, height: h = 200, title} = options;\n*/!*\nalert(title);  // Menu\nalert(w);      // 100\nalert(h);      // 200\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果我们有一个具有很多属性的复杂对象，那么我们可以只提取所需的内容：\n\nlet options = {\n  title: "Menu",\n  width: 100,\n  height: 200\n};\n// 仅提取 title 作为变量\nlet { title } = options;\nalert(title); // Menu\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 剩余模式（pattern）"..."\n\n如果对象拥有的属性数量比我们提供的变量数量还多，该怎么办？我们可以只取其中的某一些属性，然后把“剩余的”赋值到其他地方吗？\n\n我们可以使用剩余模式（pattern），与数组类似。一些较旧的浏览器不支持此功能（例如 IE，可以使用 Babel 对其进行 polyfill），但可以在现代浏览器中使用。\n\n看起来就像这样：\n\nlet options = {\n  title: "Menu",\n  height: 200,\n  width: 100\n};\n// title = 名为 title 的属性\n// rest = 存有剩余属性的对象\nlet {title, ...rest} = options;\n// 现在 title="Menu", rest={height: 200, width: 100}\nalert(rest.height);  // 200\nalert(rest.width);   // 100\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n不使用 `let` 时的陷阱\n\n在上面的示例中，变量都是在赋值中通过正确方式声明的：let {…} = {…}。当然，我们也可以使用已有的变量，而不用 let，但这里有一个陷阱。 以下代码无法正常运行：\n\nlet title, width, height;\n// 这一行发生了错误\n{title, width, height} = {title: "Menu", width: 200, height: 100};\n\n\n1\n2\n3\n\n\n问题在于 JavaScript 把主代码流（即不在其他表达式中）的 {...} 当做一个代码块。这样的代码块可以用于对语句分组，如下所示：\n\n{\n  // 一个代码块\n  let message = "Hello";\n  // ...\n  alert( message );\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n因此，这里 JavaScript 假定我们有一个代码块，这就是报错的原因。我们需要解构它。 为了告诉 JavaScript 这不是一个代码块，我们可以把整个赋值表达式用括号 (...) 包起来：\n\nlet title, width, height;\n// 现在就可以了\n({title, width, height} = {title: "Menu", width: 200, height: 100});\nalert( title ); // Menu\n\n\n1\n2\n3\n4\n\n\n# 5.10.3 嵌套解构\n\n如果一个对象或数组嵌套了其他的对象和数组，我们可以在等号左侧使用更复杂的模式（pattern）来提取更深层的数据。\n\n在下面的代码中，options 的属性 size 是另一个对象，属性 items 是另一个数组。赋值语句中等号左侧的模式（pattern）具有相同的结构以从中提取值：\n\nlet options = {\n  size: {\n    width: 100,\n    height: 200\n  },\n  items: ["Cake", "Donut"],\n  extra: true\n};\n// 为了清晰起见，解构赋值语句被写成多行的形式\nlet {\n  size: { // 把 size 赋值到这里\n    width,\n    height\n  },\n  items: [item1, item2], // 把 items 赋值到这里\n  title = "Menu" // 在对象中不存在（使用默认值）\n} = options;\nalert(title);  // Menu\nalert(width);  // 100\nalert(height); // 200\nalert(item1);  // Cake\nalert(item2);  // Donut\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n对象 options 的所有属性，除了 extra 属性在等号左侧不存在，都被赋值给了对应的变量：\n\n\n\n最终，我们得到了 width、height、item1、item2 和具有默认值的 title 变量。\n\n注意，size 和 items 没有对应的变量，因为我们取的是它们的内容。\n\n# 5.10.4 智能函数参数\n\n有时，一个函数有很多参数，其中大部分的参数都是可选的。对用户界面来说更是如此。想象一个创建菜单的函数。它可能具有宽度参数，高度参数，标题参数和项目列表等。\n\n下面是实现这种函数的一个很不好的写法：\n\nfunction showMenu(title = "Untitled", width = 200, height = 100, items = []) {\n  // ...\n}\n\n\n1\n2\n3\n\n\n在实际开发中，记忆如此多的参数的位置是一个很大的负担。通常集成开发环境（IDE）会尽力帮助我们，特别是当代码有良好的文档注释的时候，但是…… 另一个问题就是，在大部分的参数只需采用默认值的情况下，调用这个函数时会需要写大量的 undefined。\n\n像这样：\n\n// 在采用默认值就可以的位置设置 undefined\nshowMenu("My Menu", undefined, undefined, ["Item1", "Item2"])\n\n\n1\n2\n\n\n这太难看了。而且，当我们处理更多参数的时候可读性会变得很差。\n\n解构赋值可以解决这些问题。\n\n我们可以用一个对象来传递所有参数，而函数负责把这个对象解构成各个参数：\n\n// 我们传递一个对象给函数\nlet options = {\n  title: "My menu",\n  items: ["Item1", "Item2"]\n};\n// ……然后函数马上把对象解构成变量\nfunction showMenu({title = "Untitled", width = 200, height = 100, items = []}) {\n  // title, items – 提取于 options，\n  // width, height – 使用默认值\n  alert( `${title} ${width} ${height}` ); // My Menu 200 100\n  alert( items ); // Item1, Item2\n}\nshowMenu(options);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们也可以使用带有嵌套对象和冒号映射的更加复杂的解构：\n\nlet options = {\n  title: "My menu",\n  items: ["Item1", "Item2"]\n};\nfunction showMenu({\n  title = "Untitled",\n  width: w = 100,  // width goes to w\n  height: h = 200, // height goes to h\n  items: [item1, item2] // items first element goes to item1, second to item2\n}) {\n  alert( `${title} ${w} ${h}` ); // My Menu 100 200\n  alert( item1 ); // Item1\n  alert( item2 ); // Item2\n}\nshowMenu(options);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n完整语法和解构赋值是一样的：\n\nfunction({\n  incomingProperty: varName = defaultValue\n  ...\n})\n\n\n1\n2\n3\n4\n\n\n对于参数对象，属性 incomingProperty 对应的变量是 varName，默认值是 defaultValue。 请注意，这种解构假定了 showMenu() 函数确实存在参数。如果我们想让所有的参数都使用默认值，那我们应该传递一个空对象：\n\nshowMenu({}); // 不错，所有值都取默认值\nshowMenu(); // 这样会导致错误\n\n\n1\n2\n\n\n我们可以通过指定空对象 {} 为整个参数对象的默认值来解决这个问题：\n\nfunction showMenu({ title = "Menu", width = 100, height = 200 }*!* = {}*/!*) {\n  alert( `${title} ${width} ${height}` );\n}\nshowMenu(); // Menu 100 200\n\n\n1\n2\n3\n4\n\n\n在上面的代码中，整个参数对象的默认是 {}，因此总会有内容可以用来解构\n\n\n# 5.11 日期和时间\n\n日期（Date）存储日期和时间，并提供了日期/时间的管理方法。\n\n我们可以使用它来存储创建/修改时间，测量时间，或者仅用来打印当前时间\n\n# 5.11.1 创建\n\n调用 new Date() 来创建一个新的 Date 对象。在调用时可以带有一些参数，如下所示：\n\nnew Date() : 不带参数 —— 创建一个表示当前日期和时间的 Date 对象：\n\n```js\nlet now = new Date();\nalert( now ); // 显示当前的日期/时间\n```\n\n\nnew Date(milliseconds) : 创建一个 Date 对象，其时间等于 1970 年 1 月 1 日 UTC+0 之后经过的毫秒数（1/1000 秒）。\n\n```js\n// 0 表示 01.01.1970 UTC+0\nlet Jan01_1970 = new Date(0);\nalert( Jan01_1970 );\n// 现在增加 24 小时，得到 02.01.1970 UTC+0\nlet Jan02_1970 = new Date(24 * 3600 * 1000);\nalert( Jan02_1970 );\n```\n\n传入的整数参数代表的是自 1970-01-01 00:00:00 以来经过的毫秒数，该整数被称为 **时间戳**。\n\n这是一种日期的轻量级数字表示形式。我们通常使用 `new Date(timestamp)` 通过时间戳来创建日期，并可以使用 `date.getTime()` 将现有的 `Date` 对象转化为时间戳（下文会讲到）。\n\n在 01.01.1970 之前的日期带有负的时间戳，例如：\n```js\n// 31 Dec 1969\nlet Dec31_1969 = new Date(-24 * 3600 * 1000);\nalert( Dec31_1969 );\n```\n\n\nnew Date(datestring) : 如果只有一个参数，并且是字符串，那么它会被自动解析。该算法与 Date.parse 所使用的算法相同，将在下文中进行介绍。\n\n```js\nlet date = new Date("2017-01-26");\nalert(date);\n// 未指定具体时间，所以假定时间为格林尼治标准时间（GMT）的午夜零点\n// 并根据运行代码时的用户的时区进行调整\n// 因此，结果可能是\n// Thu Jan 26 2017 11:00:00 GMT+1100 (Australian Eastern Daylight Time)\n// 或\n// Wed Jan 25 2017 16:00:00 GMT-0800 (Pacific Standard Time)\n```\n\n\nnew Date(year, month, date, hours, minutes, seconds, ms) : 使用当前时区中的给定组件创建日期。只有前两个参数是必须的。\n\n- `year` 应该是四位数。为了兼容性，也接受 2 位数，并将其视为 `19xx`，例如 `98` 与 `1998` 相同，但强烈建议始终使用 4 位数。\n- `month` 计数从 `0`（一月）开始，到 `11`（十二月）结束。\n- `date` 是当月的具体某一天，如果缺失，则为默认值 `1`。\n- 如果 `hours/minutes/seconds/ms` 缺失，则均为默认值 `0`。\n\n例如：\n\n```js\nnew Date(2011, 0, 1, 0, 0, 0, 0); // 1 Jan 2011, 00:00:00\nnew Date(2011, 0, 1); // 同样，时分秒等均为默认值 0\n```\n\n时间度量最大精确到 1 毫秒（1/1000 秒）：\n\n```js\nlet date = new Date(2011, 0, 1, 2, 3, 4, 567);\nalert( date ); // 1.01.2011, 02:03:04.567\n```\n\n\n# 5.11.2 访问日期组件\n\n从 Date 对象中访问年、月等信息有多种方式：\n\ngetFullYear() : 获取年份（4 位数）\n\ngetMonth() : 获取月份，从 0 到 11。\n\ngetDate() : 获取当月的具体日期，从 1 到 31，这个方法名称可能看起来有些令人疑惑。\n\ngetHours()，getMinutes()，getSeconds()，getMilliseconds() : 获取相应的时间组件。\n\n不是 `getYear()`，而是 `getFullYear()`\n\n很多 JavaScript 引擎都实现了一个非标准化的方法 getYear()。不推荐使用这个方法。它有时候可能会返回 2 位的年份信息。永远不要使用它。要获取年份就使用 getFullYear()。\n\n另外，我们还可以获取一周中的第几天：\n\ngetDay() : 获取一周中的第几天，从 0（星期日）到 6（星期六）。第一天始终是星期日，在某些国家可能不是这样的习惯，但是这不能被改变。\n\n以上的所有方法返回的组件都是基于当地时区的。\n\n当然，也有与当地时区的 UTC 对应项，它们会返回基于 UTC+0 时区的日、月、年等：getUTCFullYear()，getUTCMonth()，getUTCDay()。只需要在 "get" 之后插入 "UTC" 即可。\n\n如果你当地时区相对于 UTC 有偏移，那么下面代码会显示不同的小时数：\n\n//  当前日期\nlet date = new Date();\n// 当地时区的小时数\nalert( date.getHours() );\n// 在 UTC+0 时区的小时数（非夏令时的伦敦时间）\nalert( date.getUTCHours() );\n\n\n1\n2\n3\n4\n5\n6\n\n\n除了上述给定的方法，还有两个没有 UTC 变体的特殊方法：\n\ngetTime() : 返回日期的时间戳 —— 从 1970-1-1 00:00:00 UTC+0 开始到现在所经过的毫秒数。\n\ngetTimezoneOffset() : 返回 UTC 与本地时区之间的时差，以分钟为单位：\n\n```js\n// 如果你在时区 UTC-1，输出 60\n// 如果你在时区 UTC+3，输出 -180\nalert( new Date().getTimezoneOffset() );\n```\n\n\n# 5.11.3 设置日期组件\n\n下列方法可以设置日期/时间组件：\n\n * setFullYear(year, [month], [date])\n * setMonth(month, [date])\n * setDate(date)\n * setHours(hour, [min], [sec], [ms])\n * setMinutes(min, [sec], [ms])\n * setSeconds(sec, [ms])\n * setMilliseconds(ms)\n * setTime(milliseconds)（使用自 1970-01-01 00:00:00 UTC+0 以来的毫秒数来设置整个日期）\n\n以上方法除了 setTime() 都有 UTC 变体，例如：setUTCHours()。\n\n我们可以看到，有些方法可以一次性设置多个组件，比如 setHours。未提及的组件不会被修改。\n\n举个例子：\n\nlet today = new Date();\ntoday.setHours(0);\nalert(today); // 日期依然是今天，但是小时数被改为了 0\ntoday.setHours(0, 0, 0, 0);\nalert(today); // 日期依然是今天，时间为 00:00:00。\n\n\n1\n2\n3\n4\n5\n\n\n# 5.11.4 自动校准（Autocorrection）\n\n自动校准 是 Date 对象的一个非常方便的特性。我们可以设置超范围的数值，它会自动校准。\n\n举个例子：\n\nlet date = new Date(2013, 0, *!*32*/!*); // 32 Jan 2013 ?!?\nalert(date); // ……是 1st Feb 2013!\n\n\n1\n2\n\n\n超出范围的日期组件将会被自动分配。\n\n假设我们要在日期 "28 Feb 2016" 上加 2 天。结果可能是 "2 Mar" 或 "1 Mar"，因为存在闰年。但是我们不需要考虑这些，只需要直接加 2 天，剩下的 Date 对象会帮我们处理：\n\nlet date = new Date(2016, 1, 28);\n*!*\ndate.setDate(date.getDate() + 2);\n*/!*\nalert( date ); // 1 Mar 2016\n\n\n1\n2\n3\n4\n5\n\n\n这个特性经常被用来获取给定时间段后的日期。例如，我们想获取“现在 70 秒后”的日期：\n\nlet date = new Date();\ndate.setSeconds(date.getSeconds() + 70);\nalert( date ); // 显示正确的日期信息\n\n\n1\n2\n3\n\n\n我们还可以设置 0 甚至可以设置负值。例如：\n\nlet date = new Date(2016, 0, 2); // 2016 年 1 月 2 日\ndate.setDate(1); // 设置为当月的第一天\nalert( date );\ndate.setDate(0); // 天数最小可以设置为 1，所以这里设置的是上一月的最后一天\nalert( date ); // 31 Dec 2015\n\n\n1\n2\n3\n4\n5\n\n\n# 5.11.5 日期转化为数字，日期差值\n\n当 Date 对象被转化为数字时，得到的是对应的时间戳，与使用 date.getTime() 的结果相同：\n\nlet date = new Date();\nalert(+date); // 以毫秒为单位的数值，与使用 date.getTime() 的结果相同\n\n\n1\n2\n\n\n有一个重要的副作用：日期可以相减，相减的结果是以毫秒为单位时间差。\n\n这个作用可以用于时间测量：\n\nlet start = new Date(); // 开始测量时间\n// do the job\nfor (let i = 0; i < 100000; i++) {\n  let doSomething = i * i * i;\n}\nlet end = new Date(); // 结束测量时间\nalert( `The loop took ${end - start} ms` );\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 5.11.6 Date.now()\n\n如果我们仅仅想要测量时间间隔，我们不需要 Date 对象。\n\n有一个特殊的方法 Date.now()，它会返回当前的时间戳。\n\n它相当于 new Date().getTime()，但它不会创建中间的 Date 对象。因此它更快，而且不会对垃圾回收造成额外的压力。\n\n这种方法很多时候因为方便，又或是因性能方面的考虑而被采用，例如使用 JavaScript 编写游戏或其他的特殊应用场景。\n\n因此这样做可能会更好：\n\nlet start = Date.now(); // 从 1 Jan 1970 至今的时间戳\n// do the job\nfor (let i = 0; i < 100000; i++) {\n  let doSomething = i * i * i;\n}\nlet end = Date.now(); // 完成\nalert( `The loop took ${end - start} ms` ); // 相减的是时间戳，而不是日期\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 5.11.7 基准测试（Benchmarking）\n\n在对一个很耗 CPU 性能的函数进行可靠的基准测试（Benchmarking）时，我们需要谨慎一点。\n\n例如，我们想判断以下两个计算日期差值的函数：哪个更快？\n\n这种性能测量通常称为“基准测试（benchmark）”。\n\n// 我们有 date1 和 date2，哪个函数会更快地返回两者的时间差？\nfunction diffSubtract(date1, date2) {\n  return date2 - date1;\n}\n// or\nfunction diffGetTime(date1, date2) {\n  return date2.getTime() - date1.getTime();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这两个函数做的事情完全相同，但是其中一个函数使用显式的 date.getTime() 来获取毫秒形式的日期，另一个则依赖于“日期 — 数字”的转换。它们的结果是一样的。\n\n那么，哪个更快呢？\n\n首先想到的方法可能是连续运行两者很多次，并计算所消耗的时间之差。就这个例子而言，函数过于简单，所以我们必须执行至少 100000 次。\n\n让我们开始测量：\n\nfunction diffSubtract(date1, date2) {\n  return date2 - date1;\n}\nfunction diffGetTime(date1, date2) {\n  return date2.getTime() - date1.getTime();\n}\nfunction bench(f) {\n  let date1 = new Date(0);\n  let date2 = new Date();\n  let start = Date.now();\n  for (let i = 0; i < 100000; i++) f(date1, date2);\n  return Date.now() - start;\n}\nalert( \'Time of diffSubtract: \' + bench(diffSubtract) + \'ms\' );\nalert( \'Time of diffGetTime: \' + bench(diffGetTime) + \'ms\' );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n看起来使用 getTime() 这种方式快得多，这是因为它没有进行类型转换，对引擎优化来说更加简单。\n\n我们得到了结论，但是这并不是一个很好的度量的例子。\n\n想象一下当运行 bench(diffSubtract) 的同时，CPU 还在并行处理其他事务，并且这也会占用资源。然而，运行 bench(diffGetTime) 的时候，并行处理的事务完成了。\n\n对于现代多进程操作系统来说，这是一个非常常见的场景。\n\n比起第二个函数，第一个函数所能使用的 CPU 资源更少。这可能导致错误的结论。\n\n为了得到更加可靠的度量，整个度量测试包应该重新运行多次。\n\n例如，像下面的代码这样：\n\nfunction diffSubtract(date1, date2) {\n  return date2 - date1;\n}\nfunction diffGetTime(date1, date2) {\n  return date2.getTime() - date1.getTime();\n}\nfunction bench(f) {\n  let date1 = new Date(0);\n  let date2 = new Date();\n  let start = Date.now();\n  for (let i = 0; i < 100000; i++) f(date1, date2);\n  return Date.now() - start;\n}\nlet time1 = 0;\nlet time2 = 0;\n*!*\n// 交替运行 bench(diffSubtract) 和 bench(diffGetTime) 各 10 次\nfor (let i = 0; i < 10; i++) {\n  time1 += bench(diffSubtract);\n  time2 += bench(diffGetTime);\n}\n*/!*\nalert( \'Total time for diffSubtract: \' + time1 );\nalert( \'Total time for diffGetTime: \' + time2 );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n现代的 JavaScript 引擎的先进优化策略只对执行很多次的 "hot code" 有效（对于执行很少次数的代码没有必要优化）。因此，在上面的例子中，第一次执行的优化程度不高。我们可能需要增加一个预热步骤：\n\n// 在主循环中增加预热环节\nbench(diffSubtract);\nbench(diffGetTime);\n// 开始度量\nfor (let i = 0; i < 10; i++) {\n  time1 += bench(diffSubtract);\n  time2 += bench(diffGetTime);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n进行微型基准测试时要小心\n\n现代的 JavaScript 引擎执行了很多优化。与正常编写的代码相比，它们可能会改变“人为编写的专用于测试的代码”的执行流程，特别是在我们对很小的代码片段进行基准测试时，例如某个运算符或内建函数的工作方式。因此，为了深入理解性能问题，请学习 JavaScript 引擎的工作原理。在那之后，你或许再也不需要进行微型基准测试了。 http://mrale.ph 提供了很多 V8 引擎相关的文章。\n\n# 5.11.8 对字符串调用 Date.parse\n\nDate.parse(str) 方法可以从一个字符串中读取日期。\n\n字符串的格式应该为：YYYY-MM-DDTHH:mm:ss.sssZ，其中：\n\n * YYYY-MM-DD —— 日期：年-月-日。\n * 字符 "T" 是一个分隔符。\n * HH:mm:ss.sss —— 时间：小时，分钟，秒，毫秒。\n * 可选字符 \'Z\' 为 +-hh:mm 格式的时区。单个字符 Z 代表 UTC+0 时区。\n\n简短形式也是可以的，比如 YYYY-MM-DD 或 YYYY-MM，甚至可以是 YYYY。\n\nDate.parse(str) 调用会解析给定格式的字符串，并返回时间戳（自 1970-01-01 00:00:00 起所经过的毫秒数）。如果给定字符串的格式不正确，则返回 NaN。\n\n举个例子：\n\nlet ms = Date.parse(\'2012-01-26T13:51:50.417-07:00\');\nalert(ms); // 1327611110417  (时间戳)\n\n\n1\n2\n\n\n我们可以通过时间戳来立即创建一个 new Date 对象：\n\nlet date = new Date( Date.parse(\'2012-01-26T13:51:50.417-07:00\') );\nalert(date);\n\n\n1\n2\n\n\n\n# 5.12 JSON\n\nJSON（JavaScript Object Notation）是表示值和对象的通用格式。在 RFC 4627 标准中有对其的描述。最初它是为 JavaScript 而创建的，但许多其他编程语言也有用于处理它的库。因此，当客户端使用 JavaScript 而服务器端是使用 Ruby/PHP/Java 等语言编写的时，使用 JSON 可以很容易地进行数据交换。\n\nJavaScript 提供了如下方法：\n\n * JSON.stringify 将对象转换为 JSON。\n * JSON.parse 将 JSON 转换回对象。\n\n# 5.12.1 JSON.stringify\n\n例如，在这里我们 JSON.stringify 一个 student 对象：\n\nlet student = {\n  name: \'John\',\n  age: 30,\n  isAdmin: false,\n  courses: [\'html\', \'css\', \'js\'],\n  spouse: null\n};\nlet json = JSON.stringify(student);\nalert(typeof json); // we\'ve got a string!\nalert(json);\n/* JSON 编码的对象：\n{\n  "name": "John",\n  "age": 30,\n  "isAdmin": false,\n  "courses": ["html", "css", "js"],\n  "spouse": null\n}\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n方法 JSON.stringify(student) 接收对象并将其转换为字符串。\n\n得到的 json 字符串是一个被称为 JSON 编码（JSON-encoded） 或 序列化（serialized） 或 字符串化（stringified） 或 编组化（marshalled） 的对象。我们现在已经准备好通过有线发送它或将其放入普通数据存储。\n\n请注意，JSON 编码的对象与对象字面量有几个重要的区别：\n\n * 字符串使用双引号。JSON 中没有单引号或反引号。所以 \'John\' 被转换为 "John"。\n * 对象属性名称也是双引号的。这是强制性的。所以 age:30 被转换成 "age":30。\n\nJSON.stringify 也可以应用于原始（primitive）数据类型。\n\nJSON 支持以下数据类型：\n\n * Objects { ... }\n * Arrays [ ... ]\n * Primitives：\n   * strings，\n   * numbers，\n   * boolean values true/false，\n   * null。\n\n例如：\n\n// 数字在 JSON 还是数字\nalert( JSON.stringify(1) ) // 1\n// 字符串在 JSON 中还是字符串，只是被双引号扩起来\nalert( JSON.stringify(\'test\') ) // "test"\nalert( JSON.stringify(true) ); // true\nalert( JSON.stringify([1, 2, 3]) ); // [1,2,3]\n\n\n1\n2\n3\n4\n5\n6\n\n\nJSON 是语言无关的纯数据规范，因此一些特定于 JavaScript 的对象属性会被 JSON.stringify 跳过。\n\n即：\n\n * 函数属性（方法）。\n * Symbol 类型的键和值。\n * 存储 undefined 的属性。\n\nlet user = {\n  sayHi() { // 被忽略\n    alert("Hello");\n  },\n  [Symbol("id")]: 123, // 被忽略\n  something: undefined // 被忽略\n};\nalert( JSON.stringify(user) ); // {}（空对象）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n通常这很好。如果这不是我们想要的方式，那么我们很快就会看到如何自定义转换方式。\n\n最棒的是支持嵌套对象转换，并且可以自动对其进行转换。\n\n例如：\n\nlet meetup = {\n  title: "Conference",\n  room: {\n    number: 23,\n    participants: ["john", "ann"]\n  }\n};\nalert( JSON.stringify(meetup) );\n/* 整个结构都被字符串化了\n{\n  "title":"Conference",\n  "room":{"number":23,"participants":["john","ann"]},\n}\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n重要的限制：不得有循环引用。\n\n例如：\n\nlet room = {\n  number: 23\n};\nlet meetup = {\n  title: "Conference",\n  participants: ["john", "ann"]\n};\nmeetup.place = room;       // meetup 引用了 room\nroom.occupiedBy = meetup; // room 引用了 meetup\nJSON.stringify(meetup); // Error: Converting circular structure to JSON\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在这里，转换失败了，因为循环引用：room.occupiedBy 引用了 meetup，meetup.place 引用了 room：\n\n# 5.12.2 排除和转换：replacer\n\nJSON.stringify 的完整语法是：\n\nlet json = JSON.stringify(value[, replacer, space])\n\n\n1\n\n\nvalue : 要编码的值。\n\nreplacer : 要编码的属性数组或映射函数 function(key, value)。\n\nspace : 用于格式化的空格数量\n\n大部分情况，JSON.stringify 仅与第一个参数一起使用。但是，如果我们需要微调替换过程，比如过滤掉循环引用，我们可以使用 JSON.stringify 的第二个参数。\n\n如果我们传递一个属性数组给它，那么只有这些属性会被编码。\n\n例如：\n\nlet room = {\n  number: 23\n};\nlet meetup = {\n  title: "Conference",\n  participants: [{name: "John"}, {name: "Alice"}],\n  place: room // meetup 引用了 room\n};\nroom.occupiedBy = meetup; // room 引用了 meetup\nalert( JSON.stringify(meetup, [\'title\', \'participants\']) );\n// {"title":"Conference","participants":[{},{}]}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这里我们可能过于严格了。属性列表应用于了整个对象结构。所以 participants 是空的，因为 name 不在列表中。\n\n让我们包含除了会导致循环引用的 room.occupiedBy 之外的所有属性：\n\nlet room = {\n  number: 23\n};\nlet meetup = {\n  title: "Conference",\n  participants: [{name: "John"}, {name: "Alice"}],\n  place: room // meetup 引用了 room\n};\nroom.occupiedBy = meetup; // room 引用了 meetup\nalert( JSON.stringify(meetup, [\'title\', \'participants\', \'place\', \'name\', \'number\']) );\n/*\n{\n  "title":"Conference",\n  "participants":[{"name":"John"},{"name":"Alice"}],\n  "place":{"number":23}\n}\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n现在，除 occupiedBy 以外的所有内容都被序列化了。但是属性的列表太长了。\n\n幸运的是，我们可以使用一个函数代替数组作为 replacer。\n\n该函数会为每个 (key,value) 对调用并返回“已替换”的值，该值将替换原有的值。如果值被跳过了，则为 undefined。\n\n在我们的例子中，我们可以为 occupiedBy 以外的所有内容按原样返回 value。为了 occupiedBy，下面的代码返回 undefined：\n\nlet room = {\n  number: 23\n};\nlet meetup = {\n  title: "Conference",\n  participants: [{name: "John"}, {name: "Alice"}],\n  place: room // meetup 引用了 room\n};\nroom.occupiedBy = meetup; // room 引用了 meetup\nalert( JSON.stringify(meetup, function replacer(key, value) {\n  alert(`${key}: ${value}`);\n  return (key == \'occupiedBy\') ? undefined : value;\n}));\n/* key:value pairs that come to replacer:\n:             [object Object]\ntitle:        Conference\nparticipants: [object Object],[object Object]\n0:            [object Object]\nname:         John\n1:            [object Object]\nname:         Alice\nplace:        [object Object]\nnumber:       23\noccupiedBy: [object Object]\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n请注意 replacer 函数会获取每个键/值对，包括嵌套对象和数组项。它被递归地应用。replacer 中的 this 的值是包含当前属性的对象。\n\n第一个调用很特别。它是使用特殊的“包装对象”制作的：{"": meetup}。换句话说，第一个 (key, value) 对的键是空的，并且该值是整个目标对象。这就是上面的示例中第一行是 ":[object Object]" 的原因。\n\n这个理念是为了给 replacer 提供尽可能多的功能：如果有必要，它有机会分析并替换/跳过整个对象。\n\n# 5.12.3 格式化：space\n\nJSON.stringify(value, replacer, spaces) 的第三个参数是用于优化格式的空格数量。\n\n以前，所有字符串化的对象都没有缩进和额外的空格。如果我们想通过网络发送一个对象，那就没什么问题。space 参数专门用于调整出更美观的输出。\n\n这里的 space = 2 告诉 JavaScript 在多行中显示嵌套的对象，对象内部缩进 2 个空格：\n\nlet user = {\n  name: "John",\n  age: 25,\n  roles: {\n    isAdmin: false,\n    isEditor: true\n  }\n};\nalert(JSON.stringify(user, null, 2));\n/* 两个空格的缩进：\n{\n  "name": "John",\n  "age": 25,\n  "roles": {\n    "isAdmin": false,\n    "isEditor": true\n  }\n}\n*/\n/* 对于 JSON.stringify(user, null, 4) 的结果会有更多缩进：\n{\n    "name": "John",\n    "age": 25,\n    "roles": {\n        "isAdmin": false,\n        "isEditor": true\n    }\n}\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n第三个参数也可以是字符串。在这种情况下，字符串用于缩进，而不是空格的数量。\n\nspaces 参数仅用于日志记录和美化输出。\n\n# 5.12.4 自定义 "toJSON"\n\n像 toString 进行字符串转换，对象也可以提供 toJSON 方法来进行 JSON 转换。如果可用，JSON.stringify 会自动调用它。\n\n例如：\n\nlet room = {\n  number: 23\n};\nlet meetup = {\n  title: "Conference",\n  date: new Date(Date.UTC(2017, 0, 1)),\n  room\n};\nalert( JSON.stringify(meetup) );\n/*\n  {\n    "title":"Conference",\n    "date":"2017-01-01T00:00:00.000Z",  // (1)\n    "room": {"number":23}               // (2)\n  }\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n在这儿我们可以看到 date (1) 变成了一个字符串。这是因为所有日期都有一个内建的 toJSON 方法来返回这种类型的字符串。\n\n现在让我们为对象 room 添加一个自定义的 toJSON：\n\nlet room = {\n  number: 23,\n  toJSON() {\n    return this.number;\n  }\n};\nlet meetup = {\n  title: "Conference",\n  room\n};\nalert( JSON.stringify(room) ); // 23\nalert( JSON.stringify(meetup) );\n/*\n  {\n    "title":"Conference",\n    "room": 23\n  }\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n正如我们所看到的，toJSON 既可以用于直接调用 JSON.stringify(room) 也可以用于当 room 嵌套在另一个编码对象中时。\n\n# 5.12.5 JSON.parse\n\n要解码 JSON 字符串，我们需要另一个方法 JSON.parse。\n\n语法：\n\nlet value = JSON.parse(str, [reviver]);\n\n\n1\n\n\nstr : 要解析的 JSON 字符串。\n\nreviver : 可选的函数 function(key,value)，该函数将为每个 (key, value) 对调用，并可以对值进行转换。\n\n例如：\n\n// 字符串化数组\nlet numbers = "[0, 1, 2, 3]";\nnumbers = JSON.parse(numbers);\nalert( numbers[1] ); // 1\n\n\n1\n2\n3\n4\n\n\n对于嵌套对象：\n\nlet userData = \'{ "name": "John", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }\';\nlet user = JSON.parse(userData);\nalert( user.friends[1] ); // 1\n\n\n1\n2\n3\n\n\nJSON 可能会非常复杂，对象和数组可以包含其他对象和数组。但是它们必须遵循相同的 JSON 格式。\n\n以下是手写 JSON 时的典型错误（有时我们必须出于调试目的编写它）：\n\nlet json = `{\n  name: "John",                     // 错误：属性名没有双引号\n  "surname": \'Smith\',               // 错误：值使用的是单引号（必须使用双引号）\n  \'isAdmin\': false                  // 错误：键使用的是单引号（必须使用双引号）\n  "birthday": new Date(2000, 2, 3), // 错误：不允许使用 "new"，只能是裸值\n  "friends": [0,1,2,3]              // 这个没问题\n}`;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n此外，JSON 不支持注释。向 JSON 添加注释无效。\n\n还有另一种名为 JSON5 的格式，它允许未加引号的键，也允许注释等。但这是一个独立的库，不在语言的规范中。\n\n常规的 JSON 格式严格，并不是因为它的开发者很懒，而是为了实现简单，可靠且快速地实现解析算法。\n\n# 5.12.6 使用 reviver\n\n想象一下，我们从服务器上获得了一个字符串化的 meetup 对象。\n\n它看起来像这样：\n\n// title: (meetup title), date: (meetup date)\nlet str = \'{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}\';\n\n\n1\n2\n\n\n……现在我们需要对它进行 反序列（deserialize），把它转换回 JavaScript 对象。\n\n让我们通过调用 JSON.parse 来完成：\n\nlet str = \'{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}\';\nlet meetup = JSON.parse(str);\nalert( meetup.date.getDate() ); // Error!\n\n\n1\n2\n3\n\n\n啊！报错了！\n\nmeetup.date 的值是一个字符串，而不是 Date 对象。JSON.parse 怎么知道应该将字符串转换为 Date 呢？\n\n让我们将 reviver 函数传递给 JSON.parse 作为第二个参数，该函数按照“原样”返回所有值，但是 date 会变成 Date：\n\nlet str = \'{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}\';\nlet meetup = JSON.parse(str, function(key, value) {\n  if (key == \'date\') return new Date(value);\n  return value;\n});\nalert( meetup.date.getDate() ); // 现在正常运行了！\n\n\n1\n2\n3\n4\n5\n6\n\n\n顺便说一下，这也适用于嵌套对象：\n\nlet schedule = `{\n  "meetups": [\n    {"title":"Conference","date":"2017-11-30T12:00:00.000Z"},\n    {"title":"Birthday","date":"2017-04-18T12:00:00.000Z"}\n  ]\n}`;\nschedule = JSON.parse(schedule, function(key, value) {\n  if (key == \'date\') return new Date(value);\n  return value;\n});\nalert( schedule.meetups[1].date.getDate() ); // 正常运行了！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n',normalizedContent:'# 5 数据类型\n\n\n# 5.1 原始数据类型方法\n\njavascript 允许我们像使用对象一样使用原始类型（字符串，数字等）。javascript 还提供了这样的调用方法\n\n# 5.1.1 原始类型与对象\n\n原始值：\n\n * 是原始类型中的一种值。\n * 在 javascript 中有 7 种原始类型：string，number，bigint，boolean，symbol，null 和 undefined。\n\n对象：\n\n * 能够存储多个值作为属性。\n * 可以使用大括号 {} 创建对象，例如：{name: "john", age: 30}。javascript 中还有其他种类的对象，例如函数就是对象\n\n对象比原始类型“更重”。它们需要额外的资源来支持运作\n\n# 5.1.2 当作对象的原始类型\n\n在保持原始类型轻量的前提下提供可以用方法访问的操作，所以提出了对象包装器，实现下面的解决方案\n\n 1. 原始类型仍然是原始的。与预期相同，提供单个值\n 2. javascript 允许访问字符串，数字，布尔值和 symbol 的方法和属性\n 3. 为了使它们起作用，创建了提供额外功能的特殊“对象包装器”，使用后即被销毁\n\n“对象包装器”对于每种原始类型都是不同的，它们被称为 string、number、boolean、symbol 和 bigint。因此，它们提供了不同的方法\n\n用法演示如下：\n\nlet str = "hello";\nalert( str.touppercase() ); // hello\n\n\n1\n2\n\n\n以下是 str.touppercase() 中实际发生的情况：\n\n 1. 字符串 str 是一个原始值。因此，在访问其属性时，会创建一个包含字符串字面值的特殊对象，并且具有有用的方法，例如 touppercase()。\n 2. 该方法运行并返回一个新的字符串（由 alert 显示）。\n 3. 特殊对象被销毁，只留下原始值 str。\n\njavascript 引擎高度优化了这个过程。它甚至可能跳过创建额外的对象。但是它仍然必须遵守规范，并且表现得好像它创建了一样\n\n构造器 `string/number/boolean` 仅供内部使用\n\n像 java 这样的一些语言允许我们使用 new number(1) 或 new boolean(false) 等语法，明确地为原始类型创建“对象包装器”。 在 javascript 中，由于历史原因，这也是可以的，但极其 不推荐。因为这样会出问题。 例如：\n\nalert( typeof 0 ); // "number"\nalert( typeof new number(0) ); // "object"!\n\n\n1\n2\n\n\n对象在 if 中始终为真，因此此处的 alert 将显示：\n\nlet zero = new number(0);\nif (zero) { // zero 为 true，因为它是一个对象\n  alert( "zero is truthy?!?" );\n}\n\n\n1\n2\n3\n4\n\n\n另一方面，调用不带 new（关键字）的 string/number/boolean 函数是完全理智和有用的。它们将一个值转换为相应的类型：转成字符串、数字或布尔值（原始类型）。 例如，下面完全是有效的：\n\nlet num = number("123"); // 将字符串转成数字\n\n\n1\n\n\nnull/undefined 没有任何方法\n\n特殊的原始类型 null 和 undefined 是例外。它们没有对应的“对象包装器”，也没有提供任何方法。从某种意义上说，它们是“最原始的”。 尝试访问这种值的属性会导致错误：\n\nalert(null.test); // error\n\n\n1\n\n\n\n# 5.2 数字类型\n\n在现代 javascript 中，数字（number）有两种类型：\n\n 1. javascript 中的常规数字以 64 位的格式 ieee-754 存储，也被称为“双精度浮点数”。这是我们大多数时候所使用的数字，我们将在本章中学习它们。\n\n 2. bigint 数字，用于表示任意长度的整数。有时会需要它们，因为常规数字不能安全地超过 253 或小于 -253。由于仅在少数特殊领域才会用到 bigint\n\n所以，此章节我们讨论的都是常规数字类型\n\n# 5.2.1 编写数字的更多方法\n\n# 下划线 _\n\n可以使用下划线 _ 作为数字的分隔符，下划线 _ 扮演了“语法糖”的角色，使得数字具有更强的可读性。javascript 引擎会直接忽略\n\nlet billion1 = 1000000000;\nlet billion2 = 1_000_000_000;\n\n\n1\n2\n\n\n# 字母 e\n\ne 把数字乘以 1 后面跟着给定数量的 0 的数字\n\n1e3 === 1 * 1000; // e3 表示 *1000\n1.23e6 === 1.23 * 1000000; // e6 表示 *1000000\n// -3 除以 1 后面跟着 3 个 0 的数字\n1e-3 === 1 / 1000; // 0.001\n// -6 除以 1 后面跟着 6 个 0 的数字\n1.23e-6 === 1.23 / 1000000; // 0.00000123\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 5.2.2 十六进制，二进制和八进制数字\n\n十六进制有一种较短的写方法：0x，然后是数字\n\n// 十六进制\nalert( 0xff ); // 255\nalert( 0xff ); // 255（一样，大小写没影响）\n\n\n1\n2\n3\n\n\n二进制和八进制数字系统很少使用，但也支持使用 0b 和 0o 前缀\n\nlet a = 0b11111111; // 二进制形式的 255\nlet b = 0o377; // 八进制形式的 255\nalert( a == b ); // true，两边是相同的数字，都是 255\n\n\n1\n2\n3\n\n\n只有这三种进制支持这种写法。对于其他进制，我们应该使用函数 parseint\n\n# 5.2.3 tostring(base)\n\n方法 num.tostring(base) 返回在给定 base 进制数字系统中 num 的字符串表示形式\n\nlet num = 255;\nalert( num.tostring(16) );  // ff\nalert( num.tostring(2) );   // 11111111\n\n\n1\n2\n3\n\n\nbase 的范围可以从 2 到 36。默认情况下是 10 常见的用例如下：\n\n * base=16 用于十六进制颜色，字符编码等，数字可以是 0..9 或 a..f。\n * base=2 主要用于调试按位操作，数字可以是 0 或 1。\n * base=36 是最大进制，数字可以是 0..9 或 a..z。所有拉丁字母都被用于了表示数字。对于 36 进制来说，一个有趣且有用的例子是，当我们需要将一个较长的数字标识符转换成较短的时候，例如做一个短的 url。可以简单地使用基数为 36 的数字系统表示：\n\n使用两个点来调用一个方法\n\n请注意 123456..tostring(36) 中的两个点不是打错了。如果我们想直接在一个数字上调用一个方法，比如上面例子中的 tostring，那么我们需要在它后面放置两个点 ..。\n\n如果我们放置一个点：123456.tostring(36)，那么就会出现一个 error，因为 javascript 语法隐含了第一个点之后的部分为小数部分。如果我们再放一个点，那么 javascript 就知道小数部分为空，现在使用该方法。\n\n也可以写成 (123456).tostring(36)。\n\n# 5.2.4 舍入\n\n舍入（rounding）是使用数字时最常用的操作之一 math.floor : 向下舍入：3.1 变成 3，-1.1 变成 -2。\n\nmath.ceil : 向上舍入：3.1 变成 4，-1.1 变成 -1。\n\nmath.round : 向最近的整数舍入：3.1 变成 3，3.6 变成 4，中间值 3.5 变成 4。\n\nmath.trunc（ie 浏览器不支持这个方法） : 移除小数点后的所有内容而没有舍入：3.1 变成 3，-1.1 变成 -1。\n\n这个是总结它们之间差异的表格：\n\n       math.floor   math.ceil   math.round   math.trunc\n3.1    3            4           3            3\n3.6    3            4           4            3\n-1.1   -2           -1          -1           -1\n-1.6   -2           -1          -2           -1\n\n# 数字舍入到小数点后 n 位\n\n 1. 乘除法\n    \n    例如，要将数字舍入到小数点后两位，我们可以将数字乘以 100，调用舍入函数，然后再将其除回。\n    \n    let num = 1.23456;\n    alert( math.round(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23\n    \n    \n    1\n    2\n    \n\n 2. 函数 tofixed(n) 将数字舍入到小数点后 n 位，并以字符串形式返回结果。\n    \n    let num = 12.34;\n    alert( num.tofixed(1) ); // "12.3"\n    \n    \n    1\n    2\n    \n    \n    这会向上或向下舍入到最接近的值，类似于 math.round：\n    \n    let num = 12.36;\n    alert( num.tofixed(1) ); // "12.4"\n    \n    \n    1\n    2\n    \n    \n    请注意 tofixed 的结果是一个字符串。如果小数部分比所需要的短，则在结尾添加零：\n    \n    let num = 12.34;\n    alert( num.tofixed(5) ); // "12.34000"，在结尾添加了 0，以达到小数点后五位\n    \n    \n    1\n    2\n    \n    \n    我们可以使用一元加号或 number() 调用，将其转换为数字，例如 + num.tofixed(5)。\n\n# 5.2.5 不精确的计算\n\n在内部，数字是以 64 位格式 ieee-754 表示的，所以正好有 64 位可以存储一个数字：其中 52 位被用于存储这些数字，其中 11 位用于存储小数点的位置（对于整数，它们为零），而 1 位用于符号。\n\n如果一个数字真的很大，则可能会溢出 64 位存储，变成一个特殊的数值 infinity：\n\nalert( 1e500 ); // infinity\n\n\n1\n\n\n这可能不那么明显，但经常会发生的是，精度的损失\n\nalert( 0.1 + 0.2 == 0.3 ); // false\n\n\n1\n\n\n一个数字以其二进制的形式存储在内存中，一个 1 和 0 的序列。但是在十进制数字系统中看起来很简单的 0.1，0.2 这样的小数，实际上在二进制形式中是无限循环小数。\n\n什么是 0.1？0.1 就是 1 除以 10，1/10，即十分之一。在十进制数字系统中，这样的数字表示起来很容易。将其与三分之一进行比较：1/3。三分之一变成了无限循环小数 0.33333(3)。\n\n在十进制数字系统中，可以保证以 10 的整数次幂作为除数能够正常工作，但是以 3 作为除数则不能。也是同样的原因，在二进制数字系统中，可以保证以 2 的整数次幂作为除数时能够正常工作，但 1/10 就变成了一个无限循环的二进制小数。\n\n使用二进制数字系统无法 精确 存储 0.1 或 0.2，就像没有办法将三分之一存储为十进制小数一样。\n\n解决方法中最可靠的是借助tofixed(n)对结果进行舍入\n\nlet sum = 0.1 + 0.2;\nalert( sum.tofixed(2) ); // 0.30\n\n\n1\n2\n\n\n提示\n\n// hello！我是一个会自我增加的数字！\nalert( 9999999999999999 ); // 显示 10000000000000000\n\n\n1\n2\n\n\n出现了同样的问题：精度损失。有 64 位来表示该数字，其中 52 位可用于存储数字，但这还不够。所以最不重要的数字就消失了。\n\njavascript 不会在此类事件中触发 error。它会尽最大努力使数字符合所需的格式，但不幸的是，这种格式不够大到满足需求。\n\n两个零\n\n数字内部表示的另一个有趣结果是存在两个零：0 和 -0。\n\n这是因为在存储时，使用一位来存储符号，因此对于包括零在内的任何数字，可以设置这一位或者不设置。\n\n在大多数情况下，这种区别并不明显，因为运算符将它们视为相同的值\n\n# 5.2.6 isfinite 和 isnan\n\n * infinity（和 -infinity）是一个特殊的数值，比任何数值都大（小）。\n * nan 代表一个 error。\n\n它们属于 number 类型，但不是“普通”数字，因此，这里有用于检查它们的特殊函数\n\n# isnan(value)\n\n将其参数转换为数字，然后测试它是否为 nan\n\nalert( isnan(nan) ); // true\nalert( isnan("str") ); // true\n\n\n1\n2\n\n\nnan独一无二\n\n我们不能使用 === nan 比较。"nan" 是独一无二的，它不等于任何东西，包括它自身：\n\nalert( nan === nan ); // false\n\n\n1\n\n\n# isfinite(value)\n\n将其参数转换为数字，如果是常规数字而不是 nan/infinity/-infinity，则返回 true\n\nalert( isfinite("15") ); // true\nalert( isfinite("str") ); // false，因为是一个特殊的值：nan\nalert( isfinite(infinity) ); // false，因为是一个特殊的值：infinity\n\n\n1\n2\n3\n\n\n有时 isfinite 被用于验证字符串值是否为常规数字：\n\nlet num = +prompt("enter a number", \'\');\n// 结果会是 true，除非你输入的是 infinity、-infinity 或不是数字\nalert( isfinite(num) );\n\n\n1\n2\n3\n\n\n注意\n\n请注意，在所有数字函数中，包括 isfinite，空字符串或仅有空格的字符串均被视为 0\n\n与 `object.is` 进行比较\n\n有一个特殊的内建方法 object.is，它类似于 === 一样对值进行比较，但它对于两种边缘情况更可靠：\n\n 1. 它适用于 nan：object.is(nan，nan) === true，这是件好事。\n 2. 值 0 和 -0 是不同的：object.is(0，-0) === false，从技术上讲这是对的，因为在内部，数字的符号位可能会不同，即使其他所有位均为零。\n\n在所有其他情况下，object.is(a，b) 与 a === b 相同。\n\n这种比较方式经常被用在 javascript 规范中。当内部算法需要比较两个值是否完全相同时，它使用 object.is（内部称为samevalue）\n\n# 5.2.7 parseint 和 parsefloat\n\n使用加号 + 或 number() 的数字转换是严格的。如果一个值不完全是一个数字，就会失败：\n\nalert( +"100px" ); // nan\n\n\n1\n\n\n唯一的例外是字符串开头或结尾的空格，因为它们会被忽略。\n\nparseint 和 parsefloat 可以从字符串中“读取”数字，直到无法读取为止。如果发生 error，则返回收集到的数字。函数 parseint 返回一个整数，而 parsefloat 返回一个浮点数：\n\nalert( parseint(\'100px\') ); // 100\nalert( parsefloat(\'12.5em\') ); // 12.5\nalert( parseint(\'12.3\') ); // 12，只有整数部分被返回了\nalert( parsefloat(\'12.3.4\') ); // 12.3，在第二个点出停止了读取\n\n\n1\n2\n3\n4\n\n\n某些情况下，parseint/parsefloat 会返回 nan。当没有数字可读时会发生这种情况：\n\nalert( parseint(\'a123\') ); // nan，第一个符号停止了读取\n\n\n1\n\n\nparseint(str, radix) 的第二个参数\n\nparseint() 函数具有可选的第二个参数。它指定了数字系统的基数，因此 parseint 还可以解析十六进制数字、二进制数字等的字符串：\n\nalert( parseint(\'0xff\', 16) ); // 255\nalert( parseint(\'ff\', 16) ); // 255，没有 0x 仍然有效\nalert( parseint(\'2n9c\', 36) ); // 123456\n\n\n1\n2\n3\n\n\n# 5.2.8 math对象\n\njavascript 有一个内建的 math 对象，它包含了一个小型的数学函数和常量库 math.random() : 返回一个从 0 到 1 的随机数（不包括 1）。\n\n```js\nalert( math.random() ); // 0.1234567894322\nalert( math.random() ); // 0.5435252343232\nalert( math.random() ); // ... (任何随机数)\n```\n\n\nmath.max(a, b, c...) / math.min(a, b, c...) : 从任意数量的参数中返回最大/最小值。\n\n```js\nalert( math.max(3, 5, -10, 0, 1) ); // 5\nalert( math.min(1, 2) ); // 1\n```\n\n\nmath.pow(n, power) : 返回 n 的给定（power）次幂。\n\n```js\nalert( math.pow(2, 10) ); // 2 的 10 次幂 = 1024\n```\n\n\n\n# 5.3 字符串\n\n在 javascript 中，文本数据被以字符串形式存储，单个字符没有单独的类型。\n\n字符串的内部格式始终是 utf-16，它不依赖于页面编码\n\n# 5.3.1 引号（quotes）\n\n字符串可以包含在单引号、双引号或反引号中：\n\nlet single = \'single-quoted\';\nlet double = "double-quoted";\nlet backticks = `backticks`;\n\n\n1\n2\n3\n\n\n单引号和双引号基本相同。但是，反引号允许我们通过 ${…} 将任何表达式嵌入到字符串中：\n\nfunction sum(a, b) {\n  return a + b;\n}\nalert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.\n\n\n1\n2\n3\n4\n\n\n使用反引号的另一个优点是它们允许字符串跨行：\n\nlet guestlist = `guests:\n * john\n * pete\n * mary\n`;\nalert(guestlist); // 客人清单，多行\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 5.3.2 特殊字符\n\n我们可以通过使用“换行符（newline character）”，以支持使用单引号和双引号来创建跨行字符串。换行符写作 \\n，用来表示换行：\n\nlet guestlist = "guests:\\n * john\\n * pete\\n * mary";\nalert(guestlist); // 一个多行的客人列表\n\n\n1\n2\n\n\n例如，这两行描述的是一样的，只是书写方式不同：\n\nlet str1 = "hello\\nworld"; // 使用“换行符”创建的两行字符串\n// 使用反引号和普通的换行创建的两行字符串\nlet str2 = `hello\nworld`;\nalert(str1 == str2); // true\n\n\n1\n2\n3\n4\n5\n\n\n还有其他不常见的“特殊”字符。\n\n这是完整列表：\n\n字符                            描述\n\\n                            换行\n\\r                            在 windows 文本文件中，两个字符 \\r\\n 的组合代表一个换行。而在非 windows 操作系统上，它就是\n                              \\n。这是历史原因造成的，大多数的 windows 软件也理解 \\n。\n\\\', \\"                        引号\n\\\\                            反斜线\n\\t                            制表符\n\\b, \\f, \\v                    退格，换页，垂直标签 —— 为了兼容性，现在已经不使用了。\n\\xxx                          具有给定十六进制 unicode xx 的 unicode 字符，例如：\'\\x7a\' 和 \'z\' 相同。\n\\uxxxx                        以 utf-16 编码的十六进制代码 xxxx 的 unicode 字符，例如 \\u00a9 —— 是版权符号 © 的\n                              unicode。它必须正好是 4 个十六进制数字。\n\\u{x…xxxxxx}（1 到 6 个十六进制字符）   具有给定 utf-32 编码的 unicode 符号。一些罕见的字符用两个 unicode 符号编码，占用 4\n                              个字节。这样我们就可以插入长代码了。\n\nunicode 示例：\n\nalert( "\\u00a9" ); // ©\nalert( "\\u{20331}" ); // 佫，罕见的中国象形文字（长 unicode）\nalert( "\\u{1f60d}" ); // 😍，笑脸符号（另一个长 unicode）\n\n\n1\n2\n3\n\n\n所有的特殊字符都以反斜杠字符 \\ 开始。它也被称为“转义字符”。\n\n注意\n\n注意反斜杠 \\ 在 javascript 中用于正确读取字符串，然后消失。内存中的字符串没有 \\。\n\n# 5.3.3 字符串长度\n\nlength 属性表示字符串长度：\n\nalert( `my\\n`.length ); // 3\n\n\n1\n\n\n注意 \\n 是一个单独的“特殊”字符，所以长度确实是 3\n\n`length` 是一个属性\n\n掌握其他编程语言的人，有时会错误地调用 str.length() 而不是 str.length。这是行不通的。\n\n请注意 str.length 是一个数字属性，而不是函数。后面不需要添加括号\n\n# 5.3.4 访问字符\n\n要获取在 pos 位置的一个字符，可以使用方括号 [pos] 或者调用 str.charat(pos) 方法。第一个字符从零位置开始\n\nlet str = `hello`;\n// 第一个字符\nalert( str[0] ); // h\nalert( str.charat(0) ); // h\n// 最后一个字符\nalert( str[str.length - 1] ); // o\n\n\n1\n2\n3\n4\n5\n6\n\n\n方括号是获取字符的一种现代化方法，而 charat 是历史原因才存在的。\n\n它们之间的唯一区别是，如果没有找到字符，[] 返回 undefined，而 charat 返回一个空字符串：\n\nlet str = `hello`;\nalert( str[1000] ); // undefined\nalert( str.charat(1000) ); // \'\'（空字符串）\n\n\n1\n2\n3\n\n\n可以使用for.. of遍历字符\n\nfor(let char of "hello"){\n  alert(char); //h,e,l,l,o\n}\n\n\n1\n2\n3\n\n\n# 5.3.5 字符串是不可变的\n\n在 javascript 中，字符串不可更改。改变字符是不可能的。\n\n我们证明一下为什么不可能：\n\nlet str = \'hi\';\nstr[0] = \'h\'; // error\nalert( str[0] ); // 无法运行\n\n\n1\n2\n3\n\n\n通常的解决方法是创建一个新的字符串，并将其分配给 str 而不是以前的字符串。\n\n例如：\n\nlet str = \'hi\';\nstr = \'h\' + str[1];  // 替换字符串\nalert( str ); // hi\n\n\n1\n2\n3\n\n\n# 5.3.6 改变大小写\n\ntolowercase() 和 touppercase() 方法可以改变大小写：\n\nalert( \'interface\'.touppercase() ); // interface\nalert( \'interface\'.tolowercase() ); // interface\n\n\n1\n2\n\n\n或者我们想要使一个字符变成小写：\n\nalert( \'interface\'[0].tolowercase() ); // \'i\'\n\n\n1\n\n\n# 5.3.7 查找子字符串\n\n# str.indexof\n\nstr.indexof(substr, pos)从给定位置 pos 开始，在 str 中查找 substr，如果没有找到，则返回 -1，否则返回匹配成功的位置。\n\n例如：\n\nlet str = \'widget with id\';\nalert( str.indexof(\'widget\') ); // 0，因为 \'widget\' 一开始就被找到\nalert( str.indexof(\'widget\') ); // -1，没有找到，检索是大小写敏感的\nalert( str.indexof("id") ); // 1，"id" 在位置 1 处（……idget 和 id）\n\n\n1\n2\n3\n4\n\n\n可选的第二个参数允许我们从一个给定的位置开始检索。\n\n例如，"id" 第一次出现的位置是 1。查询下一个存在位置时，我们从 2 开始检索：\n\nlet str = \'widget with id\';\nalert( str.indexof(\'id\', 2) ) // 12\n\n\n1\n2\n\n\n`str.lastindexof(substr, pos)`\n\n还有一个类似的方法 str.lastindexof(substr, position)，它从字符串的末尾开始搜索到开头。\n\n它会以相反的顺序列出这些事件\n\n在 if 测试中 indexof 有一点不方便。我们不能像这样把它放在 if 中：\n\nlet str = "widget with id";\nif (str.indexof("widget")) {\n    alert("we found it"); // 不工作！\n}\n\n\n1\n2\n3\n4\n\n\n上述示例中的 alert 不会显示，因为 str.indexof("widget") 返回 0（意思是它在起始位置就查找到了匹配项）。是的，但是 if 认为 0 表示 false。\n\n因此我们应该检查 -1，像这样：\n\n\n\n \n\n\n\n\nlet str = "widget with id";\nif (str.indexof("widget") != -1) {\n    alert("we found it"); // 现在工作了！\n}\n\n\n1\n2\n3\n4\n\n\n按位（bitwise）not 技巧\n\n这里使用的一个老技巧是 bitwise not ~ 运算符。它将数字转换为 32-bit 整数（如果存在小数部分，则删除小数部分），然后对其二进制表示形式中的所有位均取反\n\n只有当 n == -1 时，~n 才为零（适用于任何 32-bit 带符号的整数 n）\n\nlet str = "widget";\nif (~str.indexof("widget")) {\n  alert( \'found it!\' ); // 正常运行\n}\n\n\n1\n2\n3\n4\n\n\n由于 ~ 运算符将大数字截断为 32 位，因此存在给出 0 的其他数字，最小的数字是 ~4294967295=0。这使得这种检查只有在字符串没有那么长的情况下才是正确的 现在我们只会在旧的代码中看到这个技巧，因为现代 javascript 提供了 .includes 方法（见下文）\n\n# includes，startswith，endswith\n\n更现代的方法 str.includes(substr, pos) 根据 str 中是否包含 substr 来返回 true/false。\n\n如果我们需要检测匹配，但不需要它的位置，那么这是正确的选择：\n\nalert( "widget with id".includes("widget") ); // true\nalert( "hello".includes("bye") ); // false\n\n\n1\n2\n\n\nstr.includes 的第二个可选参数是开始搜索的起始位置：\n\nalert( "widget".includes("id") ); // true\nalert( "widget".includes("id", 3) ); // false, 从位置 3 开始没有 "id"\n\n\n1\n2\n\n\n方法 str.startswith 和 str.endswith 的功能与其名称所表示的意思相同：\n\nalert( "widget".startswith("wid") ); // true，"widget" 以 "wid" 开始\nalert( "widget".endswith("get") ); // true，"widget" 以 "get" 结束\n\n\n1\n2\n\n\n# 5.3.8 获取子字符串\n\njavascript 中有三种获取字符串的方法：substring、substr 和 slice\n\n# str.slice(start [, end])\n\n返回字符串从 start 到（但不包括）end 的部分\n\nlet str = "stringify";\nalert( str.slice(0, 5) ); // \'strin\'，从 0 到 5 的子字符串（不包括 5）\nalert( str.slice(0, 1) ); // \'s\'，从 0 到 1，但不包括 1，所以只有在 0 处的字符\n\n\n1\n2\n3\n\n\n如果没有第二个参数，slice 会一直运行到字符串末尾：\n\nlet str = "stringify";\nalert( str.slice(2) ); // 从第二个位置直到结束\n\n\n1\n2\n\n\nstart/end 也有可能是负值。它们的意思是起始位置从字符串结尾计算：\n\nlet str = "stringify";\n// 从右边的第四个位置开始，在右边的第一个位置结束\nalert( str.slice(-4, -1) ); // \'gif\'\n\n\n1\n2\n3\n\n\n# str.substring(start [, end])\n\n返回字符串在 start 和 end 之间 的部分 这与 slice 几乎相同，但它允许 start 大于 end。\n\n例如：\n\nlet str = "stringify";\n// 这些对于 substring 是相同的\nalert( str.substring(2, 6) ); // "ring"\nalert( str.substring(6, 2) ); // "ring"\n// ……但对 slice 是不同的：\nalert( str.slice(2, 6) ); // "ring"（一样）\nalert( str.slice(6, 2) ); // ""（空字符串）\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n不支持负参数（不像 slice），它们被视为 0。\n\n# str.substr(start [, length])\n\n返回字符串从 start 开始的给定 length 的部分 与以前的方法相比，这个允许我们指定 length 而不是结束位置：\n\nlet str = "stringify";\nalert( str.substr(2, 4) ); // \'ring\'，从位置 2 开始，获取 4 个字符\n\n\n1\n2\n\n\n第一个参数可能是负数，从结尾算起：\n\nlet str = "stringify";\nalert( str.substr(-4, 2) ); // \'gi\'，从第 4 位获取 2 个字符\n\n\n1\n2\n\n\n方法                      选择方式……                              负值参数\nslice(start, end)       从 start 到 end（不含 end）               允许\nsubstring(start, end)   start 与 end 之间（包括 start，但不包括 end）   负值代表 0\nsubstr(start, length)   从 start 开始获取长为 length 的字符串          允许 start 为负数\n\n使用哪一个？\n\n它们都可用于获取子字符串。正式一点来讲，substr 有一个小缺点：它不是在 javascript 核心规范中描述的，而是在附录 b 中。附录 b 的内容主要是描述因历史原因而遗留下来的仅浏览器特性。因此，理论上非浏览器环境可能无法支持 substr，但实际上它在别的地方也都能用。\n\n相较于其他两个变体，slice 稍微灵活一些，它允许以负值作为参数并且写法更简短。因此仅仅记住这三种方法中的 slice 就足够了\n\n# 5.3.8 比较字符串\n\n所有的字符串都使用 utf-16 编码。即：每个字符都有对应的数字代码。有特殊的方法可以获取代码表示的字符，以及字符对应的代码。\n\nstr.codepointat(pos) : 返回在 pos 位置的字符代码 :\n\n```js\n// 不同的字母有不同的代码\nalert( "z".codepointat(0) ); // 122\nalert( "z".codepointat(0) ); // 90\n```\n\n\nstring.fromcodepoint(code) : 通过数字 code 创建字符\n\n```js\nalert( string.fromcodepoint(90) ); // z\n```\n\n我们还可以用 `\\u` 后跟十六进制代码，通过这些代码添加 unicode 字符：\n\n```js\n// 在十六进制系统中 90 为 5a\nalert( \'\\u005a\' ); // z\n```\n\n\n字符通过数字代码进行比较。越大的代码意味着字符越大。a（97）的代码大于 z（90）的代码。\n\n * 所有小写字母追随在大写字母之后，因为它们的代码更大。\n * 一些像 o 的字母与主要字母表不同。这里，它的代码比任何从 a 到 z 的代码都要大。\n\n# 正确的比较\n\n现代浏览器（ie10- 需要额外的库 intl.js) 都支持国际化标准 ecma-402。\n\n它提供了一种特殊的方法来比较不同语言的字符串，遵循它们的规则。\n\n调用 str.localecompare(str2) 会根据语言规则返回一个整数，这个整数能指示字符串 str 在排序顺序中排在字符串 str2 前面、后面、还是相同：\n\n * 如果 str 排在 str2 前面，则返回负数。\n * 如果 str 排在 str2 后面，则返回正数。\n * 如果它们在相同位置，则返回 0。\n\n# 5.3.9 unicode\n\n# 代理对\n\n所有常用的字符都是一个 2 字节的代码。大多数欧洲语言，数字甚至大多数象形文字中的字母都有 2 字节的表示形式。\n\n但 2 字节只允许 65536 个组合，这对于表示每个可能的符号是不够的。所以稀有的符号被称为“代理对”的一对 2 字节的符号编码。\n\n这些符号的长度是 2：\n\nalert( \'𝒳\'.length ); // 2，大写数学符号 x\nalert( \'😂\'.length ); // 2，笑哭表情\nalert( \'𩷶\'.length ); // 2，罕见的中国象形文字\n\n\n1\n2\n3\n\n\n注意，代理对在 javascript 被创建时并不存在，因此无法被编程语言正确处理！\n\n我们实际上在上面的每个字符串中都有一个符号，但 length 显示长度为 2。\n\nstring.fromcodepoint 和 str.codepointat 是几种处理代理对的少数方法。它们最近才出现在编程语言中。在它们之前，只有 string.fromcharcode 和 str.charcodeat。这些方法实际上与 fromcodepoint/codepointat 相同，但是不适用于代理对。\n\n获取符号可能会非常麻烦，因为代理对被认为是两个字符：\n\nalert( \'𝒳\'[0] ); // 奇怪的符号……\nalert( \'𝒳\'[1] ); // ……代理对的一块\n\n\n1\n2\n\n\n请注意，代理对的各部分没有任何意义。因此，上述示例中的 alert 显示的实际上是垃圾信息。\n\n技术角度来说，代理对也是可以通过它们的代码检测到的：如果一个字符的代码在 0xd800..0xdbff 范围内，那么它是代理对的第一部分。下一个字符（第二部分）必须在 0xdc00..0xdfff 范围中。这些范围是按照标准专门为代理对保留的。\n\n在上述示例中：\n\n// charcodeat 不理解代理对，所以它给出了代理对的代码\nalert( \'𝒳\'.charcodeat(0).tostring(16) ); // d835，在 0xd800 和 0xdbff 之间\nalert( \'𝒳\'.charcodeat(1).tostring(16) ); // dcb3, 在 0xdc00 和 0xdfff 之间\n\n\n1\n2\n3\n\n\n本章节后面的 iterable 章节中，你可以找到更多处理代理对的方法\n\n# 变音符号与规范化\n\n在许多语言中，都有一些由基本字符组成的符号，在其上方/下方有一个标记。\n\n最常见的“复合”字符在 utf-16 表中都有自己的代码。但不是全部，因为可能的组合太多。\n\n为了支持任意组合，utf-16 允许我们使用多个 unicode 字符：基本字符紧跟“装饰”它的一个或多个“标记”字符。\n\n例如，如果我们 s 后跟有特殊的 "dot above" 字符（代码 \\u0307），则显示 s。\n\nalert( \'s\\u0307\' ); // s\n\n\n1\n\n\n两个视觉上看起来相同的字符，可以用不同的 unicode 组合表示。\n\n例如：\n\nlet s1 = \'s\\u0307\\u0323\'; // s，s + 上点 + 下点\nlet s2 = \'s\\u0323\\u0307\'; // s，s + 下点 + 上点\nalert( `s1: ${s1}, s2: ${s2}` );\nalert( s1 == s2 ); // false，尽管字符看起来相同（?!）\n\n\n1\n2\n3\n4\n\n\n为了解决这个问题，有一个 “unicode 规范化”算法，它将每个字符串都转化成单个“通用”格式。\n\n它由 str.normalize() 实现。\n\nalert( "s\\u0307\\u0323".normalize() == "s\\u0323\\u0307".normalize() ); // true\n\n\n1\n\n\n有趣的是，在实际情况下，normalize() 实际上将一个由 3 个字符组成的序列合并为一个：\\u1e68（s 有两个点）。\n\nalert( "s\\u0307\\u0323".normalize().length ); // 1\nalert( "s\\u0307\\u0323".normalize() == "\\u1e68" ); // true\n\n\n1\n2\n\n\n事实上，情况并非总是如此，因为符号 s 是“常用”的，所以 utf-16 创建者把它包含在主表中并给它了对应的代码。\n\n\n# 5.4 数组\n\n特殊的数据结构数组（array）是一种 有序集合，里面的元素都是按顺序排列的\n\n# 5.4.1 声明数组\n\n创建一个空数组有两种语法：\n\nlet arr = new array();\nlet arr = [];\n\n\n1\n2\n\n\n# 5.4.2 简单使用数组\n\n数组元素从 0 开始编号。\n\n我们可以通过方括号中的数字获取元素：\n\nlet fruits = ["apple", "orange", "plum"];\nalert( fruits[0] ); // apple\nalert( fruits[1] ); // orange\nalert( fruits[2] ); // plum\n\n\n1\n2\n3\n4\n\n\n可以替换元素：\n\nfruits[2] = \'pear\'; // 现在变成了 ["apple", "orange", "pear"]\n\n\n1\n\n\n……或者向数组新加一个元素：\n\nfruits[3] = \'lemon\'; // 现在变成 ["apple", "orange", "pear", "lemon"]\n\n\n1\n\n\nlength 属性的值是数组中元素的总个数：\n\nlet fruits = ["apple", "orange", "plum"];\nalert( fruits.length ); // 3\n\n\n1\n2\n\n\n也可以用 alert 来显示整个数组。\n\nlet fruits = ["apple", "orange", "plum"];\nalert( fruits ); // apple,orange,plum\n\n\n1\n2\n\n\n数组可以存储任何类型的元素。\n\n例如:\n\n// 混合值\nlet arr = [ \'apple\', { name: \'john\' }, true, function() { alert(\'hello\'); } ];\n// 获取索引为 1 的对象然后显示它的 name\nalert( arr[1].name ); // john\n// 获取索引为 3 的函数并执行\narr[3](); // hello\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 5.4.3 使用 "at" 获取最后一个元素\n\n假设我们想要数组的最后一个元素。\n\n一些编程语言允许我们使用负数索引来实现这一点，例如 fruits[-1]。\n\n但在 javascript 中这行不通。结果将是 undefined，因为方括号中的索引是被按照其字面意思处理的。\n\n我们可以显式地计算最后一个元素的索引，然后访问它：fruits[fruits.length - 1]。\n\nlet fruits = ["apple", "orange", "plum"];\nalert( fruits[fruits.length-1] ); // plum\n\n\n1\n2\n\n\n有一个更简短的语法 fruits.at(-1)：\n\nlet fruits = ["apple", "orange", "plum"];\n// 与 fruits[fruits.length-1] 相同\nalert( fruits.at(-1) ); // plum\n\n\n1\n2\n3\n\n\n换句话说，arr.at(i)：\n\n * 如果 i >= 0，则与 arr[i] 完全相同。\n * 对于 i 为负数的情况，它则从数组的尾部向前数。\n\n# 5.4.4 pop/push, shift/unshift 方法\n\n队列（queue）是最常见的使用数组的方法之一。在计算机科学中，这表示支持两个操作的一个有序元素的集合：\n\n * push 在末端添加一个元素.\n * shift 取出队列首端的一个元素，整个队列往前移，这样原先排第二的元素现在排在了第一\n\n数组还有另一个用例，就是数据结构 栈。\n\n它支持两种操作：\n\n * push 在末端添加一个元素.\n * pop 从末端取出一个元素.\n\n所以新元素的添加和取出都是从“末端”开始的。\n\njavascript 中的数组既可以用作队列，也可以用作栈。它们允许你从首端/末端来添加/删除元素。\n\n这在计算机科学中，允许这样的操作的数据结构被称为 双端队列（deque）。\n\n作用于数组末端的方法：\n\npop : 取出并返回数组的最后一个元素：\n\n```js\nlet fruits = ["apple", "orange", "pear"];\nalert( fruits.pop() ); // 移除 "pear" 然后 alert 显示出来\nalert( fruits ); // apple, orange\n```\n\n`fruits.pop()` 和 `fruits.at(-1)` 都返回数组的最后一个元素，但 `fruits.pop()` 同时也删除了数组的最后一个元素，进而修改了原数组。\n\n\npush : 在数组末端添加元素：\n\n```js\nlet fruits = ["apple", "orange"];\nfruits.push("pear");\nalert( fruits ); // apple, orange, pear\n```\n\n调用 `fruits.push(...)` 与 `fruits[fruits.length] = ...` 是一样的。\n\n\n作用于数组首端的方法：\n\nshift : 取出数组的第一个元素并返回它：\n\n```js\nlet fruits = ["apple", "orange", "pear"];\nalert( fruits.shift() ); // 移除 apple 然后 alert 显示出来\nalert( fruits ); // orange, pear\n```\n\n\nunshift : 在数组的首端添加元素：\n\n```js\nlet fruits = ["orange", "pear"];\nfruits.unshift(\'apple\');\nalert( fruits ); // apple, orange, pear\n```\n\n\npush 和 unshift 方法都可以一次添加多个元素：\n\nlet fruits = ["apple"];\nfruits.push("orange", "peach");\nfruits.unshift("pineapple", "lemon");\n// ["pineapple", "lemon", "apple", "orange", "peach"]\nalert( fruits );\n\n\n1\n2\n3\n4\n5\n\n\n# 5.4.5 数组原理\n\n数组是一种特殊的对象。使用方括号来访问属性 arr[0] 实际上是来自于对象的语法。它其实与 obj[key] 相同，其中 arr 是对象，而数字用作键（key）。\n\n它们扩展了对象，提供了特殊的方法来处理有序的数据集合以及 length 属性。但从本质上讲，它仍然是一个对象。\n\n记住，在 javascript 中只有 8 种基本的数据类型。数组是一个对象，因此其行为也像一个对象。\n\n数组真正特殊的是它们的内部实现。javascript 引擎尝试把这些元素一个接一个地存储在连续的内存区域，就像本章的插图显示的一样，而且还有一些其它的优化，以使数组运行得非常快。\n\n但是，如果我们不像“有序集合”那样使用数组，而是像常规对象那样使用数组，这些就都不生效了。\n\nlet fruits = []; // 创建一个数组\nfruits[99999] = 5; // 分配索引远大于数组长度的属性\nfruits.age = 25; // 创建一个具有任意名称的属性\n\n\n1\n2\n3\n\n\n这是可以的，因为数组是基于对象的。我们可以给它们添加任何属性。\n\n但是 javascript 引擎会发现，我们在像使用常规对象一样使用数组，那么针对数组的优化就不再适用了，然后对应的优化就会被关闭，这些优化所带来的优势也就荡然无存了。\n\n数组误用的几种方式:\n\n * 添加一个非数字的属性，比如 arr.test = 5。\n * 制造空洞，比如：添加 arr[0]，然后添加 arr[1000] (它们中间什么都没有)。\n * 以倒序填充数组，比如 arr[1000]，arr[999] 等等。\n\n请将数组视为作用于 有序数据 的特殊结构。它们为此提供了特殊的方法。数组在 javascript 引擎内部是经过特殊调整的，使得更好地作用于连续的有序数据，所以请以正确的方式使用数组。如果你需要任意键值，那很有可能实际上你需要的是常规对象 {}\n\n# 5.4.6 数组性能\n\npush/pop 方法运行的比较快，而 shift/unshift 比较慢\n\nshift 操作必须做三件事:\n\n 1. 移除索引为 0 的元素。\n 2. 把所有的元素向左移动，把索引 1 改成 0，2 改成 1 以此类推，对其重新编号。\n 3. 更新 length 属性。\n\n\n\n数组里的元素越多，移动它们就要花越多的时间，也就意味着越多的内存操作。\n\nunshift 也是一样：为了在数组的首端添加元素，我们首先需要将现有的元素向右移动，增加它们的索引值。\n\npush/pop 不需要移动任何东西。如果从末端移除一个元素，pop 方法只需要清理索引值并缩短 length 就可以了\n\npop 和push方法不需要移动任何东西，因为其它元素都保留了各自的索引。这就是为什么 pop 和push 会特别快。\n\n# 5.4.7 数组循环\n\n遍历数组最古老的方式就是 for 循环：\n\nlet arr = ["apple", "orange", "pear"];\n*!*\nfor (let i = 0; i < arr.length; i++) {\n*/!*\n  alert( arr[i] );\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n但对于数组来说还有另一种循环方式，for..of：\n\nlet fruits = ["apple", "orange", "plum"];\n// 遍历数组元素\nfor (let fruit of fruits) {\n  alert( fruit ); \n}\n\n\n1\n2\n3\n4\n5\n\n\nfor..of 不能获取当前元素的索引，只是获取元素值\n\n技术上来讲，因为数组也是对象，所以使用 for..in 也是可以的：\n\nlet arr = ["apple", "orange", "pear"];\n*!*\nfor (let key in arr) {\n*/!*\n  alert( arr[key] ); // apple, orange, pear\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n但这其实是一个很不好的想法。会有一些潜在问题存在：\n\n 1. for..in 循环会遍历 所有属性，不仅仅是这些数字属性。\n    \n    在浏览器和其它环境中有一种称为“类数组”的对象，它们 看似是数组。也就是说，它们有 length 和索引属性，但是也可能有其它的非数字的属性和方法，这通常是我们不需要的。for..in 循环会把它们都列出来。所以如果我们需要处理类数组对象，这些“额外”的属性就会存在问题。\n\n 2. for..in 循环适用于普通对象，并且做了对应的优化。但是不适用于数组，因此速度要慢 10-100 倍。当然即使是这样也依然非常快。只有在遇到瓶颈时可能会有问题。但是我们仍然应该了解这其中的不同。\n\n通常来说，我们不应该用 for..in 来处理数组。\n\n# 5.4.8 数组 "length"\n\n当我们修改数组的时候，length 属性会自动更新。它实际上不是数组里元素的个数，而是最大的数字索引值加一。\n\n例如，一个数组只有一个元素，但是这个元素的索引值很大，那么这个数组的 length 也会很大：\n\nlet fruits = [];\nfruits[123] = "apple";\nalert( fruits.length ); // 124\n\n\n1\n2\n3\n\n\nlength 属性的另一个有意思的点是它是可写的。\n\n如果我们手动增加它，则不会发生任何有趣的事儿。但是如果我们减少它，数组就会被截断。该过程是不可逆的，下面是例子：\n\nlet arr = [1, 2, 3, 4, 5];\narr.length = 2; // 截断到只剩 2 个元素\nalert( arr ); // [1, 2]\narr.length = 5; // 又把 length 加回来\nalert( arr[3] ); // undefined：被截断的那些数值并没有回来\n\n\n1\n2\n3\n4\n5\n\n\n所以，清空数组最简单的方法就是：arr.length = 0;\n\n# 5.4.9 new array()\n\n创建数组的另一种语法：\n\nlet arr = new array("apple", "pear", "etc");\n\n\n1\n\n\n如果使用单个参数（即数字）调用 new array，那么它会创建一个 指定了长度，却没有任何项 的数组。\n\nlet arr = new array(2); // 会创建一个 [2] 的数组吗？\nalert( arr[0] ); // undefined！没有元素。\nalert( arr.length ); // length 2\n\n\n1\n2\n3\n\n\n# 5.4.10 多维数组\n\n数组里的项也可以是数组。我们可以将其用于多维数组，例如存储矩阵：\n\nlet matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\nalert( matrix[1][1] ); // 最中间的那个数\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 5.4.11 tostring\n\n数组有自己的 tostring 方法的实现，会返回以逗号隔开的元素列表。\n\n例如：\n\nlet arr = [1, 2, 3];\nalert( arr ); // 1,2,3\nalert( string(arr) === \'1,2,3\' ); // true\n\n\n1\n2\n3\n\n\n此外，我们试试运行一下这个：\n\nalert( [] + 1 ); // "1"\nalert( [1] + 1 ); // "11"\nalert( [1,2] + 1 ); // "1,21"\n\n\n1\n2\n3\n\n\n数组没有 symbol.toprimitive，也没有 valueof，它们只能执行 tostring 进行转换，所以这里 [] 就变成了一个空字符串，[1] 变成了 "1"，[1,2] 变成了 "1,2"。\n\n# 5.4.12 不要使用 == 比较数组\n\n该运算符不会对数组进行特殊处理，它会像处理任意对象那样处理数组。\n\n * 仅当两个对象引用的是同一个对象时，它们才相等 ==。\n * 如果 == 左右两个参数之中有一个参数是对象，另一个参数是原始类型，那么该对象将会被转换为原始类型\n * ……null 和 undefined 相等 ==，且各自不等于任何其他的值。\n\n严格比较 === 更简单，因为它不会进行类型转换。\n\n所以，如果我们使用 == 来比较数组，除非我们比较的是两个引用同一数组的变量，否则它们永远不相等。\n\n例如：\n\nalert( [] == [] ); // false\nalert( [0] == [0] ); // false\n\n\n1\n2\n\n\n从技术上讲，这些数组是不同的对象。所以它们不相等。== 运算符不会进行逐项比较。\n\n与原始类型的比较也可能会产生看似很奇怪的结果：\n\nalert( 0 == [] ); // true\nalert(\'0\' == [] ); // false\n// 在 [] 被转换为 \'\' 后\nalert( 0 == \'\' ); // true，因为 \'\' 被转换成了数字 0\nalert(\'0\' == \'\' ); // false，没有进一步的类型转换，是不同的字符串\n\n\n1\n2\n3\n4\n5\n\n\n在这里的两个例子中，我们将原始类型和数组对象进行比较。因此，数组 [] 被转换为原始类型以进行比较，被转换成了一个空字符串 \'\'。\n\n\n# 5.5 数组方法\n\n# 5.5.1 添加/移除数组元素\n\n * arr.push(...items) —— 从尾端添加元素，\n * arr.pop() —— 从尾端提取元素，\n * arr.shift() —— 从首端提取元素，\n * arr.unshift(...items) —— 从首端添加元素。\n\n# splice\n\n因为 delete方法是通过 key 来移除对应的值。对于对象来说是可以的。但是对于数组来说，我们希望剩下的元素能够移动并占据被释放的位置，否则length属性是不会自动变化的\n\narr.splice 方法可以说是处理数组的瑞士军刀。它可以做所有事情：添加，删除和插入元素。\n\narr.splice(start[, deletecount, elem1, ..., elemn])\n\n\n1\n\n\n它从索引 start 开始修改 arr：删除 deletecount 个元素并在当前位置插入 elem1, ..., elemn。最后返回已被删除元素的数组。\n\nlet arr = ["i", "study", "javascript","right", "now"];\n// 删除数组的前三项，并使用其他内容代替它们\nlet removed = arr.splice(0, 3, "let\'s", "dance");\nalert( arr ) // 现在 ["let\'s", "dance", "right", "now"]\nalert( removed ) //"i", "study", "javascript"\n\n\n1\n2\n3\n4\n5\n\n\n允许负向索引\n\n在这里和其他数组方法中，负向索引都是被允许的。它们从数组末尾计算位置，如下所示：\n\nlet arr = [1, 2, 5];\n// 从索引 -1（尾端前一位）\n// 删除 0 个元素，\n// 然后插入 3 和 4\narr.splice(-1, 0, 3, 4);\nalert( arr ); // 1,2,3,4,5\n\n\n1\n2\n3\n4\n5\n6\n\n\n# slice\n\narr.slice([start], [end])\n\n\n1\n\n\n它会返回一个新数组，将所有从索引 start 到 end（不包括 end）的数组项复制到一个新的数组。start 和 end 都可以是负数，在这种情况下，从末尾计算索引。\n\n它和字符串的 str.slice 方法有点像，就是把子字符串替换成子数组\n\nlet arr = ["t", "e", "s", "t"];\nalert( arr.slice(1, 3) ); // e,s（复制从位置 1 到位置 3 的元素）\nalert( arr.slice(-2) ); // s,t（复制从位置 -2 到尾端的元素）\n\n\n1\n2\n3\n\n\n我们也可以不带参数地调用它：arr.slice() 会创建一个 arr 的副本。其通常用于获取副本，以进行不影响原始数组的进一步转换。\n\n# concat\n\narr.concat 创建一个新数组，其中包含来自于其他数组和其他项的值。\n\narr.concat(arg1, arg2...)\n\n\n1\n\n\n它接受任意数量的参数 —— 数组或值都可以。结果是一个包含来自于 arr，然后是 arg1，arg2 的元素的新数组。\n\n如果参数 argn 是一个数组，那么其中的所有元素都会被复制。否则，将复制参数本身。\n\n例如：\n\nlet arr = [1, 2];\n// create an array from: arr and [3,4]\nalert( arr.concat([3, 4]) ); // 1,2,3,4\n// create an array from: arr and [3,4] and [5,6]\nalert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6\n// create an array from: arr and [3,4], then add values 5 and 6\nalert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通常，它只复制数组中的元素。其他对象，即使它们看起来像数组一样，但仍然会被作为一个整体添加：\n\nlet arr = [1, 2];\nlet arraylike = {\n  0: "something",\n  length: 1\n};\nalert( arr.concat(arraylike) ); // 1,2,[object object]\n\n\n1\n2\n3\n4\n5\n6\n\n\n……但是，如果类似数组的对象具有 symbol.isconcatspreadable 属性，那么它就会被 concat 当作一个数组来处理：此对象中的元素将被添加：\n\n\n\n\n\n\n \n\n\n\n\n\nlet arr = [1, 2];\nlet arraylike = {\n  0: "something",\n  1: "else",\n  [symbol.isconcatspreadable]: true,\n  length: 2\n};\nalert( arr.concat(arraylike) ); // 1,2,something,else\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 5.5.2 遍历：foreach\n\narr.foreach 方法允许为数组的每个元素都运行一个函数。\n\n语法：\n\narr.foreach(function(item, index, array) {\n  // ... do something with item\n});\n\n\n1\n2\n3\n\n\n["bilbo", "gandalf", "nazgul"].foreach((item, index, array) => {\n  alert(`${item} is at index ${index} in ${array}`);\n});\n\n\n1\n2\n3\n\n\n该函数的结果（如果它有返回）会被抛弃和忽略\n\n# 5.5.3 搜索数组\n\n# indexof/lastindexof 和 includes\n\narr.indexof 和 arr.includes 方法语法相似，并且作用基本上也与字符串的方法相同，只不过这里是对数组元素而不是字符进行操作：\n\n * arr.indexof(item, from) 从索引 from 开始搜索 item，如果找到则返回索引，否则返回 -1。\n * arr.includes(item, from) —— 从索引 from 开始搜索 item，如果找到则返回 true（译注：如果没找到，则返回 false）。\n\n注意\n\n请注意，indexof 使用严格相等 === 进行比较。所以，如果我们搜索 false，它会准确找到 false 而不是数字 0。\n\n如果我们想检查数组中是否包含元素 item，并且不需要知道其确切的索引，那么 arr.includes 是首选。\n\n方法 arr.lastindexof 与 indexof 相同，但从右向左查找。\n\nlet fruits = [\'apple\', \'orange\', \'apple\'];\nalert( arr.indexof(\'apple\') ); // 0（第一个 apple）\nalert( arr.lastindexof(\'apple\') ); // 2（最后一个 apple）\n\n\n1\n2\n3\n\n\n方法 `includes` 可以正确的处理 `nan`\n\n方法 includes 的一个次要但值得注意的特性是，它可以正确处理 nan，这与 indexof 不同：\n\nconst arr = [nan];\nalert( arr.indexof(nan) ); // -1（错，应该为 0）\nalert( arr.includes(nan) );// true（正确）\n\n\n1\n2\n3\n\n\n这是因为 includes 是在比较晚的时候才被添加到 javascript 中的，并且在内部使用了更新了的比较算法。\n\n# find 和 findindex/findlastindex\n\nlet result = arr.find(function(item, index, array) {\n  // 如果返回 true，则返回 item 并停止迭代\n  // 对于假值（false）的情况，则返回 undefined\n});\n\n\n1\n2\n3\n4\n\n\n依次对数组中的每个元素调用该函数：\n\n * item 是元素。\n * index 是它的索引。\n * array 是数组本身。\n\n如果它返回 true，则搜索停止，并返回 item。如果没有搜索到，则返回 undefined。\n\nlet users = [\n  {id: 1, name: "john"},\n  {id: 2, name: "pete"},\n  {id: 3, name: "mary"}\n];\nlet user = users.find(item => item.id == 1);\nalert(user.name); // john\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\narr.findindex 方法（与 arr.find）具有相同的语法，但它返回找到的元素的索引，而不是元素本身。如果没找到，则返回 -1。\n\narr.findlastindex 方法类似于 findindex，但从右向左搜索，类似于 lastindexof。\n\nlet users = [\n  {id: 1, name: "john"},\n  {id: 2, name: "pete"},\n  {id: 3, name: "mary"},\n  {id: 4, name: "john"}\n];\n// 寻找第一个 john 的索引\nalert(users.findindex(user => user.name == \'john\')); // 0\n// 寻找最后一个 john 的索引\nalert(users.findlastindex(user => user.name == \'john\')); // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# filter\n\nfilter 语法与 find 大致相同，但是返回的是所有匹配元素组成的数组：\n\nlet results = arr.filter(function(item, index, array) {\n  // 如果 true item 被 push 到 results，迭代继续\n  // 如果什么都没找到，则返回空数组\n});\n\n\n1\n2\n3\n4\n\n\nlet users = [\n  {id: 1, name: "john"},\n  {id: 2, name: "pete"},\n  {id: 3, name: "mary"}\n];\n// 返回前两个用户的数组\nlet someusers = users.filter(item => item.id < 3);\nalert(someusers.length); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 5.5.4 转换数组\n\n# map\n\narr.map 对数组的每个元素都调用函数，并返回结果数组。\n\nlet result = arr.map(function(item, index, array) {\n  // 返回新值而不是当前元素\n})\n\n\n1\n2\n3\n\n\nlet lengths = ["bilbo", "gandalf", "nazgul"].map(item => item.length);\nalert(lengths); // 5,7,6\n\n\n1\n2\n\n\n# sort(fn)\n\narr.sort 方法对数组进行 原位（in-place） 排序，更改元素的顺序。(译注：原位是指在此数组内，而非生成一个新数组。)\n\n它还返回排序后的数组，但是返回值通常会被忽略，因为修改了 arr 本身。\n\n语法：\n\nlet arr = [ 1, 2, 15 ];\n// 该方法重新排列 arr 的内容\narr.sort();\nalert( arr );  // 1, 15, 2\n\n\n1\n2\n3\n4\n\n\n这些元素默认情况下被按字符串进行排序。\n\n从字面上看，所有元素都被转换为字符串，然后进行比较。对于字符串，按照词典顺序进行排序，实际上应该是 "2" > "15"。\n\n要使用我们自己的排序顺序，我们需要提供一个函数作为 arr.sort() 的参数。\n\n该函数应该比较两个任意值并返回：\n\nfunction compare(a, b) {\n  if (a > b) return 1; // 如果第一个值比第二个值大\n  if (a == b) return 0; // 如果两个值相等\n  if (a < b) return -1; // 如果第一个值比第二个值小\n}\n\n\n1\n2\n3\n4\n5\n\n\n例如，按数字进行排序：\n\nfunction comparenumeric(a, b) {\n  if (a > b) return 1;\n  if (a == b) return 0;\n  if (a < b) return -1;\n}\nlet arr = [ 1, 2, 15 ];\narr.sort(comparenumeric);\nalert(arr);  // 1, 2, 15\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n现在结果符合预期了。\n\narr 可以是由任何内容组成的数组，它可能包含数字、字符串、对象或其他任何内容。我们有一组 一些元素。要对其进行排序，我们需要一个 排序函数 来确认如何比较这些元素。默认是按字符串进行排序的。\n\narr.sort(fn) 方法实现了通用的排序算法。我们不需要关心它的内部工作原理（大多数情况下都是经过 快速排序 或 timsort 算法优化的）。它将遍历数组，使用提供的函数比较其元素并对其重新排序，我们所需要的就是提供执行比较的函数 fn。\n\n比较函数可以返回任何数字\n\n实际上，比较函数只需要返回一个正数表示“大于”，一个负数表示“小于”。 通过这个原理我们可以编写更短的函数：\n\nlet arr = [ 1, 2, 15 ];\narr.sort(function(a, b) { return a - b; });\nalert(arr);  // *!*1, 2, 15*/!*\n\n\n1\n2\n3\n\n\n用 `localecompare` for strings\n\n字符串比较默认情况下，它通过字母的代码比较字母。 对于许多字母，最好使用 str.localecompare 方法正确地对字母进行排序，例如 o。\n\nlet countries = [\'osterreich\', \'andorra\', \'vietnam\'];\nalert( countries.sort( (a, b) => a > b ? 1 : -1) ); // andorra, vietnam, osterreich（错的）\nalert( countries.sort( (a, b) => a.localecompare(b) ) ); // andorra,osterreich,vietnam（对的！）\n\n\n1\n2\n3\n\n\n# reverse\n\narr.reverse 方法用于颠倒 arr 中元素的顺序。\n\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();\nalert( arr ); // 5,4,3,2,1\n\n\n1\n2\n3\n\n\n它也会返回颠倒后的数组 arr\n\n# split 和 join\n\nstr.split(delim) 通过给定的分隔符 delim 将字符串分割成一个数组。\n\nsplit 方法有一个可选的第二个数字参数 —— 对数组长度的限制。如果提供了，那么额外的元素会被忽略。但实际上它很少使用：\n\nlet arr = \'bilbo, gandalf, nazgul, saruman\'.split(\', \', 2);\nalert(arr); // bilbo, gandalf\n\n\n1\n2\n\n\narr.join(glue) 与 split 相反。它会在它们之间创建一串由 glue 粘合的 arr 项。\n\n例如：\n\nlet arr = [\'bilbo\', \'gandalf\', \'nazgul\'];\nlet str = arr.join(\';\'); // 使用分号 ; 将数组粘合成字符串\nalert( str ); // bilbo;gandalf;nazgul\n\n\n1\n2\n3\n\n\n# reduce/reduceright\n\narr.reduce 方法和 arr.reduceright 用于根据数组计算单个值。\n\n语法是：\n\nlet value = arr.reduce(function(accumulator, item, index, array) {\n  // ...\n}, [initial]);\n\n\n1\n2\n3\n\n\n该函数一个接一个地应用于所有数组元素，并将其结果“搬运（carry on）”到下一个调用。\n\n参数：\n\n * accumulator —— 是上一个函数调用的结果，第一次等于 initial（如果提供了 initial 的话）。\n * item —— 当前的数组元素。\n * index —— 当前索引。\n * arr —— 数组本身。\n\n应用函数时，上一个函数调用的结果将作为第一个参数传递给下一个函数。因此，第一个参数本质上是累加器，用于存储所有先前执行的组合结果。最后，它成为 reduce 的结果。\n\n在这里，我们通过一行代码得到一个数组的总和：\n\nlet arr = [1, 2, 3, 4, 5];\nlet result = arr.reduce((sum, current) => sum + current, 0);\nalert(result); // 15\n\n\n1\n2\n3\n\n\n让我们看看细节，到底发生了什么。\n\n 1. 在第一次运行时，sum 的值为初始值 initial（reduce 的最后一个参数），等于 0，current 是第一个数组元素，等于 1。所以函数运行的结果是 1。\n 2. 在第二次运行时，sum = 1，我们将第二个数组元素（2）与其相加并返回。\n 3. 在第三次运行中，sum = 3，我们继续把下一个元素与其相加，以此类推……\n\n计算流程： 每一行代表的是对下一个数组元素的函数调用：\n\n          sum   current   result\n第 1 次调用   0     1         1\n第 2 次调用   1     2         3\n第 3 次调用   3     3         6\n第 4 次调用   6     4         10\n第 5 次调用   10    5         15\n\n我们也可以省略初始值：\n\nlet arr = [1, 2, 3, 4, 5];\n// 删除 reduce 的初始值（没有 0）\nlet result = arr.reduce((sum, current) => sum + current);\nalert( result ); // 15\n\n\n1\n2\n3\n4\n\n\n结果是一样的。这是因为如果没有初始值，那么 reduce 会将数组的第一个元素作为初始值，并从第二个元素开始迭代。\n\n但是这种使用需要非常小心。如果数组为空，那么在没有初始值的情况下调用 reduce 会导致错误。\n\n例如：\n\nlet arr = [];\n// error: reduce of empty array with no initial value\n// 如果初始值存在，则 reduce 将为空 arr 返回它（即这个初始值）。\narr.reduce((sum, current) => sum + current);\n\n\n1\n2\n3\n4\n\n\n所以建议始终指定初始值。\n\narr.reduceright 和 arr.reduce 方法的功能一样，只是遍历为从右到左。\n\n# 5.5.5 array.isarray\n\n数组是基于对象的，不构成单独的语言类型。\n\n所以 typeof 不能帮助从数组中区分出普通对象：\n\nalert(typeof {}); // object\nalert(typeof []); // object（相同）\n\n\n1\n2\n\n\n……但是数组经常被使用，因此有一种特殊的方法用于判断：array.isarray(value)。如果 value 是一个数组，则返回 true；否则返回 false。\n\nalert(array.isarray({})); // false\nalert(array.isarray([])); // true\n\n\n1\n2\n\n\n# 5.5.6 大多数方法都支持 "thisarg"\n\n几乎所有调用函数的数组方法 —— 比如 find，filter，map，除了 sort 是一个特例，都接受一个可选的附加参数 thisarg。\n\n以下是这些方法的完整语法：\n\narr.find(func, thisarg);\narr.filter(func, thisarg);\narr.map(func, thisarg);\n// ...\n// thisarg 是可选的最后一个参数\n\n\n1\n2\n3\n4\n5\n\n\nthisarg 参数的值在 func 中变为 this。\n\n例如，在这里我们使用 army 对象方法作为过滤器，thisarg 用于传递上下文（passes the context）：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\nlet army = {\n  minage: 18,\n  maxage: 27,\n  canjoin(user) {\n    return user.age >= this.minage && user.age < this.maxage;\n  }\n};\nlet users = [\n  {age: 16},\n  {age: 20},\n  {age: 23},\n  {age: 30}\n];\n// 找到 army.canjoin 返回 true 的 user\nlet soldiers = users.filter(army.canjoin, army);\nalert(soldiers.length); // 2\nalert(soldiers[0].age); // 20\nalert(soldiers[1].age); // 23\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n如果在上面的示例中我们使用了 users.filter(army.canjoin)，那么 army.canjoin 将被作为独立函数调用，并且这时 this=undefined，从而会导致即时错误。\n\n\n# 5.6 可迭代对象\n\n可迭代（iterable） 对象是数组的泛化。这个概念是说任何对象都可以被定制为可在 for..of 循环中使用的对象。\n\n# 5.6.1 symbol.iterator\n\n为了让一个自己创建的对象可迭代（也就让 for..of 可以运行）我们需要为对象添加一个名为 symbol.iterator 的方法（一个专门用于使对象可迭代的内建 symbol）。\n\n 1. 当 for..of 循环启动时，它会调用这个方法（如果没找到，就会报错）。这个方法必须返回一个 迭代器（iterator） —— 一个有 next 方法的对象。\n 2. 从此开始，for..of 仅适用于这个被返回的对象。\n 3. 当 for..of 循环希望取得下一个数值，它就调用这个对象的 next() 方法。\n 4. next() 方法返回的结果的格式必须是 {done: boolean, value: any}，当 done=true 时，表示循环结束，否则 value 是下一个值。\n\nlet range = {\n  from: 1,\n  to: 5\n};\n// 1. for..of 调用首先会调用这个：\nrange[symbol.iterator] = function() {\n  // ……它返回迭代器对象（iterator object）：\n  // 2. 接下来，for..of 仅与下面的迭代器对象一起工作，要求它提供下一个值\n  return {\n    current: this.from,\n    last: this.to,\n    // 3. next() 在 for..of 的每一轮循环迭代中被调用\n    next() {\n      // 4. 它将会返回 {done:.., value :...} 格式的对象\n      if (this.current <= this.last) {\n        return { done: false, value: this.current++ };\n      } else {\n        return { done: true };\n      }\n    }\n  };\n};\n// 现在它可以运行了！\nfor (let num of range) {\n  alert(num); // 1, 然后是 2, 3, 4, 5\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n关注点分离\n\n关注点分离是可迭代对象的核心功能\n\n * range 自身没有 next() 方法。\n * 相反，是通过调用 range[symbol.iterator]() 创建了另一个对象，即所谓的“迭代器”对象，并且它的 next 会为迭代生成值。\n\n因此，迭代器对象和与其进行迭代的对象是分开的。\n\n从技术上说，我们可以将它们合并，并使用 range 自身作为迭代器来简化代码\n\nlet range = {\n  from: 1,\n  to: 5,\n  [symbol.iterator]() {\n    this.current = this.from;\n    return this;\n  },\n  next() {\n    if (this.current <= this.to) {\n      return { done: false, value: this.current++ };\n    } else {\n      return { done: true };\n    }\n  }\n};\nfor (let num of range) {\n  alert(num); // 1, 然后是 2, 3, 4, 5\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n但缺点是，现在不可能同时在对象上运行两个 for..of 循环了：它们将共享迭代状态，因为只有一个迭代器，即对象本身。但是两个并行的 for..of 是很罕见的，即使在异步情况下\n\n无穷迭代器（iterator）\n\n无穷迭代器也是可能的。例如，将 range 设置为 range.to = infinity，这时 range 则成为了无穷迭代器。或者我们可以创建一个可迭代对象，它生成一个无穷伪随机数序列。也是可能的。\n\nnext 没有什么限制，它可以返回越来越多的值，这是正常的。\n\n当然，迭代这种对象的 for..of 循环将不会停止。但是我们可以通过使用 break 来停止它。\n\n# 5.6.2 字符串迭代\n\n数组和字符串是使用最广泛的内建可迭代对象。\n\n对于一个字符串，for..of 遍历它的每个字符：\n\nfor (let char of "test") {\n  // 触发 4 次，每个字符一次\n  alert( char ); // t, then e, then s, then t\n}\n\n\n1\n2\n3\n4\n\n\n对于代理对（surrogate pairs），它也能正常工作！（译注：这里的代理对也就指的是 utf-16 的扩展字符）\n\nlet str = \'𝒳😂\';\nfor (let char of str) {\n    alert( char ); // 𝒳，然后是 😂\n}\n\n\n1\n2\n3\n4\n\n\n# 5.6.3 显示调用迭代器\n\n不使用for..of，直接通过迭代器遍历字符串\n\nlet str = "hello";\n// 和 for..of 做相同的事\n// for (let char of str) alert(char);\nlet iterator = str[symbol.iterator]();\nwhile (true) {\n  let result = iterator.next();\n  if (result.done) break;\n  alert(result.value); // 一个接一个地输出字符\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n很少需要我们这样做，但是比 for..of 给了我们更多的控制权。例如，我们可以拆分迭代过程：迭代一部分，然后停止，做一些其他处理，然后再恢复迭代。\n\n# 5.6.4 可迭代（iterable）和类数组（array-like）\n\n这两个官方术语看起来差不多，但其实大不相同。请确保你能够充分理解它们的含义，以免造成混淆。\n\n * iterable 如上所述，是实现了 symbol.iterator 方法的对象。\n * array-like 是有索引和 length 属性的对象，所以它们看起来很像数组。\n\n可迭代对象和类数组对象通常都 不是数组，它们没有 push 和 pop 等方法\n\n# 5.6.5 array.from\n\n有一个全局方法 array.from 可以接受一个可迭代或类数组的值，并从中获取一个“真正的”数组。然后我们就可以对其调用数组方法了。\n\nlet arraylike = {\n  0: "hello",\n  1: "world",\n  length: 2\n};\nlet arr = array.from(arraylike); // (*)\nalert(arr.pop()); // world（pop 方法有效）\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\narray.from 的完整语法允许我们提供一个可选的“映射（mapping）”函数：\n\narray.from(obj[, mapfn, thisarg])\n\n\n1\n\n\n可选的第二个参数 mapfn 可以是一个函数，该函数会在对象中的元素被添加到数组前，被应用于每个元素，此外 thisarg 允许我们为该函数设置 this。\n\n例如：\n\n// 假设 range 来自上文例子中\n// 求每个数的平方\nlet arr = array.from(range, num => num * num);\nalert(arr); // 1,4,9,16,25\n\n\n1\n2\n3\n4\n\n\n\n# 5.7 映射和集合\n\n# 5.7.1 map\n\nmap 是一个带键的数据项的集合，就像一个 object 一样。 但是它们最大的差别是 map 允许任何类型的键（key）。\n\n它的方法和属性如下：\n\n * new map() —— 创建 map。\n * map.set(key, value) —— 根据键存储值。\n * map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。\n * map.has(key) —— 如果 key 存在则返回 true，否则返回 false。\n * map.delete(key) —— 删除指定键的值。\n * map.clear() —— 清空 map。\n * map.size —— 返回当前元素个数\n\nlet map = new map();\nmap.set(\'1\', \'str1\');   // 字符串键\nmap.set(1, \'num1\');     // 数字键\nmap.set(true, \'bool1\'); // 布尔值键\n// 还记得普通的 object 吗? 它会将键转化为字符串\n// map 则会保留键的类型，所以下面这两个结果不同：\nalert( map.get(1)   ); // \'num1\'\nalert( map.get(\'1\') ); // \'str1\'\nalert( map.size ); // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如我们所见，与对象不同，键不会被转换成字符串。键可以是任何类型\n\n`map[key]` 不是使用 `map` 的正确方式\n\n虽然 map[key] 也有效，例如我们可以设置 map[key] = 2，这样会将 map 视为 javascript 的 plain object，因此它暗含了所有相应的限制（仅支持 string/symbol 键等）。\n所以我们应该使用 map 方法：set 和 get 等。\n\nmap 还可以使用对象作为键。 使用对象作为键是 map 最值得注意和重要的功能之一。在 object 中，我们则无法使用对象作为键。在 object 中使用字符串作为键是可以的，但我们无法使用另一个 object 作为 object 中的键\n\nlet john = { name: "john" };\n// 存储每个用户的来访次数\nlet visitscountmap = new map();\n// john 是 map 中的键\nvisitscountmap.set(john, 123);\nalert( visitscountmap.get(john) ); // 123\n\nlet john = { name: "john" };\nlet ben = { name: "ben" };\nlet visitscountobj = {}; // 尝试使用对象\nvisitscountobj[ben] = 234; // 尝试将对象 ben 用作键\nvisitscountobj[john] = 123; // 尝试将对象 john 用作键，但我们会发现使用对象 ben 作为键存下的值会被替换掉\n// 变成这样了！\nalert( visitscountobj["[object object]"] ); // 123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# map 比较键\n\nmap 使用 samevaluezero 算法来比较键是否相等。它和严格等于 === 差不多，但区别是 nan 被看成是等于 nan。所以 nan 也可以被用作键。\n这个算法不能被改变或者自定义。\n\n# 链式调用\n\n每一次 map.set 调用都会返回 map 本身，所以我们可以进行“链式”调用：\n\nmap.set(\'1\', \'str1\')\n  .set(1, \'num1\')\n  .set(true, \'bool1\');\n\n\n1\n2\n3\n\n\n# 5.7.2 map 迭代\n\n如果要在 map 里使用循环，可以使用以下三个方法：\n\n * map.keys() —— 遍历并返回一个包含所有键的可迭代对象，\n * map.values() —— 遍历并返回一个包含所有值的可迭代对象，\n * map.entries() —— 遍历并返回一个包含所有实体 [key, value] 的可迭代对象，for..of 在默认情况下使用的就是这个。\n\nlet recipemap = new map([\n  [\'cucumber\', 500],\n  [\'tomatoes\', 350],\n  [\'onion\',    50]\n]);\n// 遍历所有的键（vegetables）\nfor (let vegetable of recipemap.keys()) {\n  alert(vegetable); // cucumber, tomatoes, onion\n}\n// 遍历所有的值（amounts）\nfor (let amount of recipemap.values()) {\n  alert(amount); // 500, 350, 50\n}\n// 遍历所有的实体 [key, value]\nfor (let entry of recipemap) { // 与 recipemap.entries() 相同\n  alert(entry); // cucumber,500 (and so on)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n使用插入顺序\n\n迭代的顺序与插入值的顺序相同。与普通的 object 不同，map 保留了此顺序\n\n# 5.7.3 object.entries：从对象创建 map\n\n当创建一个 map 后，我们可以传入一个带有键值对的数组（或其它可迭代对象）来进行初始化，如下所示：\n\n// 键值对 [key, value] 数组\nlet map = new map([\n  [\'1\',  \'str1\'],\n  [1,    \'num1\'],\n  [true, \'bool1\']\n]);\nalert( map.get(\'1\') ); // str1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果我们想从一个已有的普通对象（plain object）来创建一个 map，那么我们可以使用内建方法 object.entries(obj)，该方法返回对象的键/值对数组，该数组格式完全按照 map 所需的格式。\n\n所以可以像下面这样从一个对象创建一个 map：\n\nlet obj = {\n  name: "john",\n  age: 30\n};\n*!*\nlet map = new map(object.entries(obj));\n*/!*\nalert( map.get(\'name\') ); // john\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这里，object.entries 返回键/值对数组：[ ["name","john"], ["age", 30] ]。这就是 map 所需要的格式\n\n# 5.7.4 object.fromentries：从 map 创建对象\n\nobject.fromentries 方法的作用是相反的：给定一个具有 [key, value] 键值对的数组，它会根据给定数组创建一个对象：\n\nlet prices = object.fromentries([\n  [\'banana\', 1],\n  [\'orange\', 2],\n  [\'meat\', 4]\n]);\n// 现在 prices = { banana: 1, orange: 2, meat: 4 }\nalert(prices.orange); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n我们可以使用 object.fromentries 从 map 得到一个普通对象（plain object）。\n\n例如，我们在 map 中存储了一些数据，但是我们需要把这些数据传给需要普通对象（plain object）的第三方代码。\n\n我们来开始：\n\nlet map = new map();\nmap.set(\'banana\', 1);\nmap.set(\'orange\', 2);\nmap.set(\'meat\', 4);\n*!*\nlet obj = object.fromentries(map.entries()); // 创建一个普通对象（plain object）(*)\n*/!*\n// 完成了！\n// obj = { banana: 1, orange: 2, meat: 4 }\nalert(obj.orange); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n调用 map.entries() 将返回一个可迭代的键/值对，这刚好是 object.fromentries 所需要的格式。\n\n我们可以把带 (*) 这一行写得更短：\n\nlet obj = object.fromentries(map); // 省掉 .entries()\n\n\n1\n\n\n上面的代码作用也是一样的，因为 object.fromentries 期望得到一个可迭代对象作为参数，而不一定是数组。并且 map 的标准迭代会返回跟 map.entries() 一样的键/值对。因此，我们可以获得一个普通对象（plain object），其键/值对与 map 相同。\n\n# 5.7.5 set\n\nset 是一个特殊的类型集合 —— “值的集合”（没有键），它的每一个值只能出现一次。\n\n它的主要方法如下：\n\n * new set(iterable) —— 创建一个 set，如果提供了一个 iterable 对象（通常是数组），将会从数组里面复制值到 set 中。\n * set.add(value) —— 添加一个值，返回 set 本身\n * set.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。\n * set.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。\n * set.clear() —— 清空 set。\n * set.size —— 返回元素个数。\n\n它的主要特点是，重复使用同一个值调用 set.add(value) 并不会发生什么改变。这就是 set 里面的每一个值只出现一次的原因。\n\nlet set = new set();\nlet john = { name: "john" };\nlet pete = { name: "pete" };\nlet mary = { name: "mary" };\n// visits，一些访客来访好几次\nset.add(john);\nset.add(pete);\nset.add(mary);\nset.add(john);\nset.add(mary);\n// set 只保留不重复的值\nalert( set.size ); // 3\nfor (let user of set) {\n  alert(user.name); // john（然后 pete 和 mary）\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nset 的替代方法可以是一个用户数组，用 arr.find 在每次插入值时检查是否重复。但是这样性能会很差，因为这个方法会遍历整个数组来检查每个元素。set 内部对唯一性检查进行了更好的优化。\n\n# 5.7.6 set 迭代（iteration）\n\n我们可以使用 for..of 或 foreach 来遍历 set：\n\nlet set = new set(["oranges", "apples", "bananas"]);\nfor (let value of set) alert(value);\n// 与 foreach 相同：\nset.foreach((value, valueagain, set) => {\n  alert(value);\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意一件有趣的事儿。foreach 的回调函数有三个参数：一个 value，然后是 同一个值 valueagain，最后是目标对象。没错，同一个值在参数里出现了两次。\n\nforeach 的回调函数有三个参数，是为了与 map 兼容。当然，这看起来确实有些奇怪。但是这对在特定情况下轻松地用 set 代替 map 很有帮助，反之亦然。\n\nmap 中用于迭代的方法在 set 中也同样支持：\n\n * set.keys() —— 遍历并返回一个包含所有值的可迭代对象，\n * set.values() —— 与 set.keys() 作用相同，这是为了兼容 map，\n * set.entries() —— 遍历并返回一个包含所有的实体 [value, value] 的可迭代对象，它的存在也是为了兼容 map。\n\n\n# 5.8 weakmap and weakset（弱映射和弱集合）\n\n通常，当对象、数组之类的数据结构在内存中时，它们的子元素，如对象的属性、数组的元素都被认为是可达的\n如果我们使用对象作为常规 map 的键，那么当 map 存在时，该对象也将存在。它会占用内存，并且不会被（垃圾回收机制）回收。\n\nlet john = { name: "john" };\nlet map = new map();\nmap.set(john, "...");\njohn = null; // 覆盖引用\n// john 被存储在了 map 中，\n// 我们可以使用 map.keys() 来获取它\n\n\n1\n2\n3\n4\n5\n6\n\n\nweakmap 在这方面有着根本上的不同。它不会阻止垃圾回收机制对作为键的对象（key object）的回收。\n\n# 5.8.1 weakmap\n\nweakmap 和 map 的第一个不同点就是，weakmap 的键必须是对象，不能是原始值 如果我们在 weakmap 中使用一个对象作为键，并且没有其他对这个对象的引用 —— 该对象将会被从内存（和map）中自动清除。\n\nlet john = { name: "john" };\nlet weakmap = new weakmap();\nweakmap.set(john, "...");\njohn = null; // 覆盖引用\n// john 被从内存中删除了！\n\n\n1\n2\n3\n4\n5\n\n\n与上面常规的 map 的例子相比，现在如果 john 仅仅是作为 weakmap 的键而存在 —— 它将会被从 map（和内存）中自动删除。\n\nweakmap 不支持迭代以及 keys()，values() 和 entries() 方法。所以没有办法获取 weakmap 的所有键或值。\n\nweakmap 只有以下的方法：\n\n * weakmap.get(key)\n * weakmap.set(key, value)\n * weakmap.delete(key)\n * weakmap.has(key)\n\n为什么会有这种限制呢？这是技术的原因。如果一个对象丢失了其它所有引用（就像上面示例中的 john），那么它就会被垃圾回收机制自动回收。但是在从技术的角度并不能准确知道 何时会被回收。\n\n这些都是由 javascript 引擎决定的。javascript 引擎可能会选择立即执行内存清理，如果现在正在发生很多删除操作，那么 javascript 引擎可能就会选择等一等，稍后再进行内存清理。因此，从技术上讲，weakmap 的当前元素的数量是未知的。javascript 引擎可能清理了其中的垃圾，可能没清理，也可能清理了一部分。因此，暂不支持访问 weakmap 的所有键/值的方法。\n\n# 5.8.2 weakmap使用案例\n\n# 额外的数据\n\nweakmap 的主要应用场景是 额外数据的存储。\n\n假如我们正在处理一个“属于”另一个代码的一个对象，也可能是第三方库，并想存储一些与之相关的数据，那么这些数据就应该与这个对象共存亡 —— 这时候 weakmap 正是我们所需要的利器。\n\n我们将这些数据放到 weakmap 中，并使用该对象作为这些数据的键，那么当该对象被垃圾回收机制回收后，这些数据也会被自动清除。\n\nweakmap.set(john, "secret documents");\n// 如果 john 消失，secret documents 将会被自动清除\n\n\n1\n2\n\n\n例如，我们有用于处理用户访问计数的代码。收集到的信息被存储在 map 中：一个用户对象作为键，其访问次数为值。当一个用户离开时（该用户对象将被垃圾回收机制回收），这时我们就不再需要他的访问次数了。\n\n下面是一个使用 map 的计数函数的例子：\n\n// 📁 visitscount.js\nlet visitscountmap = new map(); // map: user => visits count\n// 递增用户来访次数\nfunction countuser(user) {\n  let count = visitscountmap.get(user) || 0;\n  visitscountmap.set(user, count + 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n下面是其他部分的代码，可能是使用它的其它代码：\n\n// 📁 main.js\nlet john = { name: "john" };\ncountuser(john); // count his visits\n// 不久之后，john 离开了\njohn = null;\n\n\n1\n2\n3\n4\n5\n\n\n现在，john 这个对象应该被垃圾回收，但它仍在内存中，因为它是 visitscountmap 中的一个键。\n\n当我们移除用户时，我们需要清理 visitscountmap，否则它将在内存中无限增大。在复杂的架构中，这种清理会成为一项繁重的任务。\n\n我们可以通过使用 weakmap 来避免这样的问题：\n\n// 📁 visitscount.js\nlet visitscountmap = new weakmap(); // weakmap: user => visits count\n// 递增用户来访次数\nfunction countuser(user) {\n  let count = visitscountmap.get(user) || 0;\n  visitscountmap.set(user, count + 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n现在我们不需要去清理 visitscountmap 了。当 john 对象变成不可达时，即便它是 weakmap 里的一个键，它也会连同它作为 weakmap 里的键所对应的信息一同被从内存中删除。\n\n# 缓存\n\n另外一个常见的例子是缓存。我们可以存储（“缓存”）函数的结果，以便将来对同一个对象的调用可以重用这个结果。\n\n为了实现这一点，我们可以使用 map（非最佳方案）：\n\n// 📁 cache.js\nlet cache = new map();\n// 计算并记住结果\nfunction process(obj) {\n  if (!cache.has(obj)) {\n    let result = /* calculations of the result for */ obj;\n    cache.set(obj, result);\n  }\n  return cache.get(obj);\n}\n// 现在我们在其它文件中使用 process()\n// 📁 main.js\nlet obj = {/* 假设我们有个对象 */};\nlet result1 = process(obj); // 计算完成\n// ……稍后，来自代码的另外一个地方……\nlet result2 = process(obj); // 取自缓存的被记忆的结果\n// ……稍后，我们不再需要这个对象时：\nobj = null;\nalert(cache.size); // 1（啊！该对象依然在 cache 中，并占据着内存！）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n对于多次调用同一个对象，它只需在第一次调用时计算出结果，之后的调用可以直接从 cache 中获取。这样做的缺点是，当我们不再需要这个对象的时候需要清理 cache。\n\n如果我们用 weakmap 替代 map，便不会存在这个问题。当对象被垃圾回收时，对应缓存的结果也会被自动从内存中清除。\n\n// 📁 cache.js\nlet cache = new weakmap();\n// 计算并记结果\nfunction process(obj) {\n  if (!cache.has(obj)) {\n    let result = /* calculate the result for */ obj;\n    cache.set(obj, result);\n  }\n  return cache.get(obj);\n}\n// 📁 main.js\nlet obj = {/* some object */};\nlet result1 = process(obj);\nlet result2 = process(obj);\n// ……稍后，我们不再需要这个对象时：\nobj = null;\n// 无法获取 cache.size，因为它是一个 weakmap，\n// 要么是 0，或即将变为 0\n// 当 obj 被垃圾回收，缓存的数据也会被清除\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 5.8.3 weakset\n\nweakset 的表现类似：\n\n * 与 set 类似，但是我们只能向 weakset 添加对象（而不能是原始值）。\n * 对象只有在其它某个（些）地方能被访问的时候，才能留在 weakset 中。\n * 跟 set 一样，weakset 支持 add，has 和 delete 方法，但不支持 size 和 keys()，并且不可迭代。\n\n变“弱（weak）”的同时，它也可以作为额外的存储空间。但并非针对任意数据，而是针对“是/否”的事实。weakset 的元素可能代表着有关该对象的某些信息。\n\n例如，我们可以将用户添加到 weakset 中，以追踪访问过我们网站的用户：\n\nlet visitedset = new weakset();\nlet john = { name: "john" };\nlet pete = { name: "pete" };\nlet mary = { name: "mary" };\nvisitedset.add(john); // john 访问了我们\nvisitedset.add(pete); // 然后是 pete\nvisitedset.add(john); // john 再次访问\n// visitedset 现在有两个用户了\n// 检查 john 是否来访过？\nalert(visitedset.has(john)); // true\n// 检查 mary 是否来访过？\nalert(visitedset.has(mary)); // false\njohn = null;\n// visitedset 将被自动清理(即自动清除其中已失效的值 john)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nweakmap 和 weakset 最明显的局限性就是不能迭代，并且无法获取所有当前内容。那样可能会造成不便，但是并不会阻止 weakmap/weakset 完成其主要工作 —— 为在其它地方存储/管理的对象数据提供“额外”存储。\n\n\n# 5.9 对象迭代\n\n在前面的章节中，我们认识了 map.keys()，map.values() 和 map.entries() 方法。\n\n这些方法是通用的，有一个共同的约定来将它们用于各种数据结构。如果我们创建一个我们自己的数据结构，我们也应该实现这些方法。\n\n它们支持：\n\n * map\n * set\n * array\n\n普通对象也支持类似的方法，但是语法上有一些不同\n\n# 5.9.1 object.keys，values，entries\n\n对于普通对象，下列这些方法是可用的：\n\n * object.keys(obj) —— 返回一个包含该对象所有的键的数组。\n * object.values(obj) —— 返回一个包含该对象所有的值的数组。\n * object.entries(obj) —— 返回一个包含该对象所有 [key, value] 键值对的数组。\n\n……但是请注意区别（比如说跟 map 的区别）：\n\n       map          object\n调用语法   map.keys()   object.keys(obj)，而不是 obj.keys()\n返回值    可迭代对象        “真正的”数组\n\n第一个区别是，对于对象我们使用的调用语法是 object.keys(obj)，而不是 obj.keys()。\n\n为什么会这样？主要原因是灵活性。请记住，在 javascript 中，对象是所有复杂结构的基础。因此，我们可能有一个自己创建的对象，比如 data，并实现了它自己的 data.values() 方法。同时，我们依然可以对它调用 object.values(data) 方法。\n\n第二个区别是 object.* 方法返回的是“真正的”数组对象，而不只是一个可迭代对象。这主要是历史原因。\n\n举个例子：\n\nlet user = {\n  name: "john",\n  age: 30\n};\n\n\n1\n2\n3\n4\n\n * object.keys(user) = ["name", "age"]\n * object.values(user) = ["john", 30]\n * object.entries(user) = [ ["name","john"], ["age",30] ]\n\n这里有一个使用 object.values 来遍历属性值的例子：\n\nlet user = {\n  name: "john",\n  age: 30\n};\n// 遍历所有的值\nfor (let value of object.values(user)) {\n  alert(value); // john, then 30\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nobject.keys/values/entries 会忽略 symbol 属性\n\n就像 for..in 循环一样，这些方法会忽略使用 symbol(...) 作为键的属性。 通常这很方便。但是，如果我们也想要 symbol 类型的键，那么这儿有一个单独的方法 object.getownpropertysymbols，它会返回一个只包含 symbol 类型的键的数组。另外，还有一种方法 reflect.ownkeys(obj)，它会返回 所有 键。\n\n# 5.9.2 转换对象\n\n对象缺少数组存在的许多方法，例如 map 和 filter 等。\n\n如果我们想应用它们，那么我们可以使用 object.entries，然后使用 object.fromentries：\n\n 1. 使用 object.entries(obj) 从 obj 获取由键/值对组成的数组。\n 2. 对该数组使用数组方法，例如 map，对这些键/值对进行转换。\n 3. 对结果数组使用 object.fromentries(array) 方法，将结果转回成对象。\n\n例如，我们有一个带有价格的对象，并想将它们加倍：\n\nlet prices = {\n  banana: 1,\n  orange: 2,\n  meat: 4,\n};\nlet doubleprices = object.fromentries(\n  // 将价格转换为数组，将每个键/值对映射为另一对\n  // 然后通过 fromentries 再将结果转换为对象\n  object.entries(prices).map(entry => [entry[0], entry[1] * 2])\n);\nalert(doubleprices.meat); // 8\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 5.10 解构赋值\n\njavascript 中最常用的两种数据结构是 object 和 array。\n\n * 对象是一种根据键存储数据的实体。\n * 数组是一种直接存储数据的有序列表。\n\n但是，当我们把它们传递给函数时，函数可能不需要整个对象/数组，而只需要其中一部分。\n\n解构赋值 是一种特殊的语法，它使我们可以将数组或对象“拆包”至一系列变量中。有时这样做更方便\n\n# 5.10.1 数组解构\n\n// 我们有一个存放了名字和姓氏的数组\nlet arr = ["john", "smith"]\n*!*\n// 解构赋值\n// 设置 firstname = arr[0]\n// 以及 surname = arr[1]\nlet [firstname, surname] = arr;\n*/!*\nalert(firstname); // john\nalert(surname);  // smith\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们可以使用这些变量而非原来的数组项了。\n\n当与 split 函数（或其他返回值为数组的函数）结合使用时，看起来更优雅：\n\nlet [firstname, surname] = "john smith".split(\' \');\nalert(firstname); // john\nalert(surname);  // smith\n\n\n1\n2\n3\n\n\n“解构”并不意味着“破坏”\n\n这种语法被叫做“解构赋值”，是因为它“拆开”了数组或对象，将其中的各元素复制给一些变量。原来的数组或对象自身没有被修改。\n换句话说，解构赋值只是写起来简洁一点。以下两种写法是等价的：\n\n// let [firstname, surname] = arr;\nlet firstname = arr[0];\nlet surname = arr[1];\n\n\n1\n2\n3\n\n\n忽略使用逗号的元素\n\n可以通过添加额外的逗号来丢弃数组中不想要的元素：\n\n// 不需要第二个元素\nlet [firstname, , title] = ["julius", "caesar", "consul", "of the roman republic"];\nalert( title ); // consul\n\n\n1\n2\n3\n\n\n在上面的代码中，数组的第二个元素被跳过了，第三个元素被赋值给了 title 变量。数组中剩下的元素也都被跳过了（因为在这没有对应给它们的变量）\n\n等号右侧可以是任何可迭代对\n\n实际上，我们可以将其与任何可迭代对象一起使用，而不仅限于数组：\n\nlet [a, b, c] = "abc"; // ["a", "b", "c"]\nlet [one, two, three] = new set([1, 2, 3]);\n\n\n1\n2\n\n\n这种情况下解构赋值是通过迭代右侧的值来完成工作的。这是一种用于对在 = 右侧的值上调用 for..of 并进行赋值的操作的语法糖\n\n赋值给等号左侧的任何内容\n\n我们可以在等号左侧使用任何“可以被赋值的”东西。 例如，一个对象的属性：\n\nlet user = {};\n[user.name, user.surname] = "john smith".split(\' \');\nalert(user.name); // john\nalert(user.surname); // smith\n\n\n1\n2\n3\n4\n\n\n与 .entries() 方法进行循环操作\n\n在前面的章节中我们已经见过了 object.entries(obj) 方法。 我们可以将 .entries() 方法与解构语法一同使用，来遍历一个对象的“键—值”对：\n\nlet user = {\n  name: "john",\n  age: 30\n};\n// 使用循环遍历键—值对\nfor (let [key, value] of object.entries(user)) {\n  alert(`${key}:${value}`); // name:john, then age:30\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n用于 map 的类似代码更简单，因为 map 是可迭代的：\n\nlet user = new map();\nuser.set("name", "john");\nuser.set("age", "30");\n// map 是以 [key, value] 对的形式进行迭代的，非常便于解构\nfor (let [key, value] of user) {\n  alert(`${key}:${value}`); // name:john, then age:30\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n交换变量值的技巧\n\n使用解构赋值来交换两个变量的值是一个著名的技巧：\n\nlet guest = "jane";\nlet admin = "pete";\n// 让我们来交换变量的值：使得 guest = pete，admin = jane\n[guest, admin] = [admin, guest];\nalert(`${guest} ${admin}`); // pete jane（成功交换！）\n\n\n1\n2\n3\n4\n5\n\n\n这里我们创建了一个由两个变量组成的临时数组，并且立即以颠倒的顺序对其进行了解构赋值。\n我们也可以用这种方式交换两个以上的变量\n\n# 其余的 \'...\'\n\n通常，如果数组比左边的列表长，那么“其余”的数组项会被省略。\n\n例如，这里只取了两项，其余的就被忽略了：\n\nlet [name1, name2] = ["julius", "caesar", "consul", "of the roman republic"];\nalert(name1); // julius\nalert(name2); // caesar\n// 其余数组项未被分配到任何地方\n\n\n1\n2\n3\n4\n\n\n如果我们还想收集其余的数组项 —— 我们可以使用三个点 "..." 来再加一个参数以获取其余数组项：\n\nlet [name1, name2, ...rest] = ["julius", "caesar", "consul", "of the roman republic"];\n// rest 是包含从第三项开始的其余数组项的数组\nalert(rest[0]); // consul\nalert(rest[1]); // of the roman republic\nalert(rest.length); // 2\n\n\n\n1\n2\n3\n4\n5\n6\n\n\nrest 的值就是数组中剩下的元素组成的数组。\n\n不一定要使用变量名 rest，我们也可以使用任何其他的变量名。只要确保它前面有三个点，并且在解构赋值的最后一个参数位置上就行了：\n\nlet [name1, name2, ...titles] = ["julius", "caesar", "consul", "of the roman republic"];\n// 现在 titles = ["consul", "of the roman republic"]\n\n\n1\n2\n\n\n# 默认值\n\n如果数组比左边的变量列表短，这里不会出现报错。缺少对应值的变量都会被赋 undefined：\n\nlet [firstname, surname] = [];\nalert(firstname); // undefined\nalert(surname); // undefined\n\n\n1\n2\n3\n\n\n如果我们想要一个“默认”值给未赋值的变量，我们可以使用 = 来提供：\n\n// 默认值\nlet [name = "guest", surname = "anonymous"] = ["julius"];\nalert(name);    // julius（来自数组的值）\nalert(surname); // anonymous（默认值被使用了）\n\n\n1\n2\n3\n4\n\n\n默认值可以是更加复杂的表达式，甚至可以是函数调用。不过，这些表达式或函数只会在这个变量未被赋值的时候才会被计算。\n\n举个例子，我们使用了 prompt 函数来提供两个默认值：\n\n// 只会提示输入姓氏\nlet [name = prompt(\'name?\'), surname = prompt(\'surname?\')] = ["julius"];\nalert(name);    // julius（来自数组）\nalert(surname); // 你输入的值\n\n\n1\n2\n3\n4\n\n\n请注意：prompt 将仅针对缺失值（surname）运行\n\n# 5.10.2 对象解构\n\n解构赋值同样适用于对象。基本语法是：\n\nlet {var1, var2} = {var1:…, var2:…}\n\n\n1\n\n\n在等号右侧是一个已经存在的对象，我们想把它拆分到变量中。等号左侧包含了对象相应属性的一个类对象“模式（pattern）”。在最简单的情况下，等号左侧的就是 {...} 中的变量名列表。\n\n如下所示：\n\nlet options = {\n  title: "menu",\n  width: 100,\n  height: 200\n};\n*!*\nlet {title, width, height} = options;\n*/!*\nalert(title);  // menu\nalert(width);  // 100\nalert(height); // 200\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n属性 options.title、options.width 和 options.height 值被赋给了对应的变量。\n\n变量的顺序并不重要，下面这个代码也是等价的：\n\n// 改变 let {...} 中元素的顺序\nlet {height, width, title} = { title: "menu", height: 200, width: 100 }\n\n\n1\n2\n\n\n等号左侧的模式（pattern）可以更加复杂，指定属性和变量之间的映射关系。\n\n如果我们想把一个属性赋值给另一个名字的变量，比如把 options.width 属性赋值给名为 w 的变量，那么我们可以使用冒号来设置变量名称：\n\nlet options = {\n  title: "menu",\n  width: 100,\n  height: 200\n};\n// { sourceproperty: targetvariable }\nlet {width: w, height: h, title} = options;\n// width -> w\n// height -> h\n// title -> title\nalert(title);  // menu\nalert(w);      // 100\nalert(h);      // 200\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n冒号的语法是“从对象中什么属性的值：赋值给哪个变量”。上面的例子中，属性 width 被赋值给了 w，属性 height 被赋值给了 h，属性 title 被赋值给了同名变量。\n\n对于可能缺失的属性，我们可以使用 "=" 设置默认值，如下所示：\n\nlet options = {\n  title: "menu"\n};\n*!*\nlet {width = 100, height = 200, title} = options;\n*/!*\nalert(title);  // menu\nalert(width);  // 100\nalert(height); // 200\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n就像数组或函数参数一样，默认值可以是任意表达式甚至可以是函数调用。它们只会在未提供对应的值时才会被计算/调用。\n\n在下面的代码中，prompt 提示输入 width 值，但不会提示输入 title 值：\n\nlet options = {\n  title: "menu"\n};\n*!*\nlet {width = prompt("width?"), title = prompt("title?")} = options;\n*/!*\nalert(title);  // menu\nalert(width);  // (prompt 的返回值)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们还可以将冒号和等号结合起来：\n\nlet options = {\n  title: "menu"\n};\n*!*\nlet {width: w = 100, height: h = 200, title} = options;\n*/!*\nalert(title);  // menu\nalert(w);      // 100\nalert(h);      // 200\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果我们有一个具有很多属性的复杂对象，那么我们可以只提取所需的内容：\n\nlet options = {\n  title: "menu",\n  width: 100,\n  height: 200\n};\n// 仅提取 title 作为变量\nlet { title } = options;\nalert(title); // menu\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 剩余模式（pattern）"..."\n\n如果对象拥有的属性数量比我们提供的变量数量还多，该怎么办？我们可以只取其中的某一些属性，然后把“剩余的”赋值到其他地方吗？\n\n我们可以使用剩余模式（pattern），与数组类似。一些较旧的浏览器不支持此功能（例如 ie，可以使用 babel 对其进行 polyfill），但可以在现代浏览器中使用。\n\n看起来就像这样：\n\nlet options = {\n  title: "menu",\n  height: 200,\n  width: 100\n};\n// title = 名为 title 的属性\n// rest = 存有剩余属性的对象\nlet {title, ...rest} = options;\n// 现在 title="menu", rest={height: 200, width: 100}\nalert(rest.height);  // 200\nalert(rest.width);   // 100\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n不使用 `let` 时的陷阱\n\n在上面的示例中，变量都是在赋值中通过正确方式声明的：let {…} = {…}。当然，我们也可以使用已有的变量，而不用 let，但这里有一个陷阱。 以下代码无法正常运行：\n\nlet title, width, height;\n// 这一行发生了错误\n{title, width, height} = {title: "menu", width: 200, height: 100};\n\n\n1\n2\n3\n\n\n问题在于 javascript 把主代码流（即不在其他表达式中）的 {...} 当做一个代码块。这样的代码块可以用于对语句分组，如下所示：\n\n{\n  // 一个代码块\n  let message = "hello";\n  // ...\n  alert( message );\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n因此，这里 javascript 假定我们有一个代码块，这就是报错的原因。我们需要解构它。 为了告诉 javascript 这不是一个代码块，我们可以把整个赋值表达式用括号 (...) 包起来：\n\nlet title, width, height;\n// 现在就可以了\n({title, width, height} = {title: "menu", width: 200, height: 100});\nalert( title ); // menu\n\n\n1\n2\n3\n4\n\n\n# 5.10.3 嵌套解构\n\n如果一个对象或数组嵌套了其他的对象和数组，我们可以在等号左侧使用更复杂的模式（pattern）来提取更深层的数据。\n\n在下面的代码中，options 的属性 size 是另一个对象，属性 items 是另一个数组。赋值语句中等号左侧的模式（pattern）具有相同的结构以从中提取值：\n\nlet options = {\n  size: {\n    width: 100,\n    height: 200\n  },\n  items: ["cake", "donut"],\n  extra: true\n};\n// 为了清晰起见，解构赋值语句被写成多行的形式\nlet {\n  size: { // 把 size 赋值到这里\n    width,\n    height\n  },\n  items: [item1, item2], // 把 items 赋值到这里\n  title = "menu" // 在对象中不存在（使用默认值）\n} = options;\nalert(title);  // menu\nalert(width);  // 100\nalert(height); // 200\nalert(item1);  // cake\nalert(item2);  // donut\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n对象 options 的所有属性，除了 extra 属性在等号左侧不存在，都被赋值给了对应的变量：\n\n\n\n最终，我们得到了 width、height、item1、item2 和具有默认值的 title 变量。\n\n注意，size 和 items 没有对应的变量，因为我们取的是它们的内容。\n\n# 5.10.4 智能函数参数\n\n有时，一个函数有很多参数，其中大部分的参数都是可选的。对用户界面来说更是如此。想象一个创建菜单的函数。它可能具有宽度参数，高度参数，标题参数和项目列表等。\n\n下面是实现这种函数的一个很不好的写法：\n\nfunction showmenu(title = "untitled", width = 200, height = 100, items = []) {\n  // ...\n}\n\n\n1\n2\n3\n\n\n在实际开发中，记忆如此多的参数的位置是一个很大的负担。通常集成开发环境（ide）会尽力帮助我们，特别是当代码有良好的文档注释的时候，但是…… 另一个问题就是，在大部分的参数只需采用默认值的情况下，调用这个函数时会需要写大量的 undefined。\n\n像这样：\n\n// 在采用默认值就可以的位置设置 undefined\nshowmenu("my menu", undefined, undefined, ["item1", "item2"])\n\n\n1\n2\n\n\n这太难看了。而且，当我们处理更多参数的时候可读性会变得很差。\n\n解构赋值可以解决这些问题。\n\n我们可以用一个对象来传递所有参数，而函数负责把这个对象解构成各个参数：\n\n// 我们传递一个对象给函数\nlet options = {\n  title: "my menu",\n  items: ["item1", "item2"]\n};\n// ……然后函数马上把对象解构成变量\nfunction showmenu({title = "untitled", width = 200, height = 100, items = []}) {\n  // title, items – 提取于 options，\n  // width, height – 使用默认值\n  alert( `${title} ${width} ${height}` ); // my menu 200 100\n  alert( items ); // item1, item2\n}\nshowmenu(options);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们也可以使用带有嵌套对象和冒号映射的更加复杂的解构：\n\nlet options = {\n  title: "my menu",\n  items: ["item1", "item2"]\n};\nfunction showmenu({\n  title = "untitled",\n  width: w = 100,  // width goes to w\n  height: h = 200, // height goes to h\n  items: [item1, item2] // items first element goes to item1, second to item2\n}) {\n  alert( `${title} ${w} ${h}` ); // my menu 100 200\n  alert( item1 ); // item1\n  alert( item2 ); // item2\n}\nshowmenu(options);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n完整语法和解构赋值是一样的：\n\nfunction({\n  incomingproperty: varname = defaultvalue\n  ...\n})\n\n\n1\n2\n3\n4\n\n\n对于参数对象，属性 incomingproperty 对应的变量是 varname，默认值是 defaultvalue。 请注意，这种解构假定了 showmenu() 函数确实存在参数。如果我们想让所有的参数都使用默认值，那我们应该传递一个空对象：\n\nshowmenu({}); // 不错，所有值都取默认值\nshowmenu(); // 这样会导致错误\n\n\n1\n2\n\n\n我们可以通过指定空对象 {} 为整个参数对象的默认值来解决这个问题：\n\nfunction showmenu({ title = "menu", width = 100, height = 200 }*!* = {}*/!*) {\n  alert( `${title} ${width} ${height}` );\n}\nshowmenu(); // menu 100 200\n\n\n1\n2\n3\n4\n\n\n在上面的代码中，整个参数对象的默认是 {}，因此总会有内容可以用来解构\n\n\n# 5.11 日期和时间\n\n日期（date）存储日期和时间，并提供了日期/时间的管理方法。\n\n我们可以使用它来存储创建/修改时间，测量时间，或者仅用来打印当前时间\n\n# 5.11.1 创建\n\n调用 new date() 来创建一个新的 date 对象。在调用时可以带有一些参数，如下所示：\n\nnew date() : 不带参数 —— 创建一个表示当前日期和时间的 date 对象：\n\n```js\nlet now = new date();\nalert( now ); // 显示当前的日期/时间\n```\n\n\nnew date(milliseconds) : 创建一个 date 对象，其时间等于 1970 年 1 月 1 日 utc+0 之后经过的毫秒数（1/1000 秒）。\n\n```js\n// 0 表示 01.01.1970 utc+0\nlet jan01_1970 = new date(0);\nalert( jan01_1970 );\n// 现在增加 24 小时，得到 02.01.1970 utc+0\nlet jan02_1970 = new date(24 * 3600 * 1000);\nalert( jan02_1970 );\n```\n\n传入的整数参数代表的是自 1970-01-01 00:00:00 以来经过的毫秒数，该整数被称为 **时间戳**。\n\n这是一种日期的轻量级数字表示形式。我们通常使用 `new date(timestamp)` 通过时间戳来创建日期，并可以使用 `date.gettime()` 将现有的 `date` 对象转化为时间戳（下文会讲到）。\n\n在 01.01.1970 之前的日期带有负的时间戳，例如：\n```js\n// 31 dec 1969\nlet dec31_1969 = new date(-24 * 3600 * 1000);\nalert( dec31_1969 );\n```\n\n\nnew date(datestring) : 如果只有一个参数，并且是字符串，那么它会被自动解析。该算法与 date.parse 所使用的算法相同，将在下文中进行介绍。\n\n```js\nlet date = new date("2017-01-26");\nalert(date);\n// 未指定具体时间，所以假定时间为格林尼治标准时间（gmt）的午夜零点\n// 并根据运行代码时的用户的时区进行调整\n// 因此，结果可能是\n// thu jan 26 2017 11:00:00 gmt+1100 (australian eastern daylight time)\n// 或\n// wed jan 25 2017 16:00:00 gmt-0800 (pacific standard time)\n```\n\n\nnew date(year, month, date, hours, minutes, seconds, ms) : 使用当前时区中的给定组件创建日期。只有前两个参数是必须的。\n\n- `year` 应该是四位数。为了兼容性，也接受 2 位数，并将其视为 `19xx`，例如 `98` 与 `1998` 相同，但强烈建议始终使用 4 位数。\n- `month` 计数从 `0`（一月）开始，到 `11`（十二月）结束。\n- `date` 是当月的具体某一天，如果缺失，则为默认值 `1`。\n- 如果 `hours/minutes/seconds/ms` 缺失，则均为默认值 `0`。\n\n例如：\n\n```js\nnew date(2011, 0, 1, 0, 0, 0, 0); // 1 jan 2011, 00:00:00\nnew date(2011, 0, 1); // 同样，时分秒等均为默认值 0\n```\n\n时间度量最大精确到 1 毫秒（1/1000 秒）：\n\n```js\nlet date = new date(2011, 0, 1, 2, 3, 4, 567);\nalert( date ); // 1.01.2011, 02:03:04.567\n```\n\n\n# 5.11.2 访问日期组件\n\n从 date 对象中访问年、月等信息有多种方式：\n\ngetfullyear() : 获取年份（4 位数）\n\ngetmonth() : 获取月份，从 0 到 11。\n\ngetdate() : 获取当月的具体日期，从 1 到 31，这个方法名称可能看起来有些令人疑惑。\n\ngethours()，getminutes()，getseconds()，getmilliseconds() : 获取相应的时间组件。\n\n不是 `getyear()`，而是 `getfullyear()`\n\n很多 javascript 引擎都实现了一个非标准化的方法 getyear()。不推荐使用这个方法。它有时候可能会返回 2 位的年份信息。永远不要使用它。要获取年份就使用 getfullyear()。\n\n另外，我们还可以获取一周中的第几天：\n\ngetday() : 获取一周中的第几天，从 0（星期日）到 6（星期六）。第一天始终是星期日，在某些国家可能不是这样的习惯，但是这不能被改变。\n\n以上的所有方法返回的组件都是基于当地时区的。\n\n当然，也有与当地时区的 utc 对应项，它们会返回基于 utc+0 时区的日、月、年等：getutcfullyear()，getutcmonth()，getutcday()。只需要在 "get" 之后插入 "utc" 即可。\n\n如果你当地时区相对于 utc 有偏移，那么下面代码会显示不同的小时数：\n\n//  当前日期\nlet date = new date();\n// 当地时区的小时数\nalert( date.gethours() );\n// 在 utc+0 时区的小时数（非夏令时的伦敦时间）\nalert( date.getutchours() );\n\n\n1\n2\n3\n4\n5\n6\n\n\n除了上述给定的方法，还有两个没有 utc 变体的特殊方法：\n\ngettime() : 返回日期的时间戳 —— 从 1970-1-1 00:00:00 utc+0 开始到现在所经过的毫秒数。\n\ngettimezoneoffset() : 返回 utc 与本地时区之间的时差，以分钟为单位：\n\n```js\n// 如果你在时区 utc-1，输出 60\n// 如果你在时区 utc+3，输出 -180\nalert( new date().gettimezoneoffset() );\n```\n\n\n# 5.11.3 设置日期组件\n\n下列方法可以设置日期/时间组件：\n\n * setfullyear(year, [month], [date])\n * setmonth(month, [date])\n * setdate(date)\n * sethours(hour, [min], [sec], [ms])\n * setminutes(min, [sec], [ms])\n * setseconds(sec, [ms])\n * setmilliseconds(ms)\n * settime(milliseconds)（使用自 1970-01-01 00:00:00 utc+0 以来的毫秒数来设置整个日期）\n\n以上方法除了 settime() 都有 utc 变体，例如：setutchours()。\n\n我们可以看到，有些方法可以一次性设置多个组件，比如 sethours。未提及的组件不会被修改。\n\n举个例子：\n\nlet today = new date();\ntoday.sethours(0);\nalert(today); // 日期依然是今天，但是小时数被改为了 0\ntoday.sethours(0, 0, 0, 0);\nalert(today); // 日期依然是今天，时间为 00:00:00。\n\n\n1\n2\n3\n4\n5\n\n\n# 5.11.4 自动校准（autocorrection）\n\n自动校准 是 date 对象的一个非常方便的特性。我们可以设置超范围的数值，它会自动校准。\n\n举个例子：\n\nlet date = new date(2013, 0, *!*32*/!*); // 32 jan 2013 ?!?\nalert(date); // ……是 1st feb 2013!\n\n\n1\n2\n\n\n超出范围的日期组件将会被自动分配。\n\n假设我们要在日期 "28 feb 2016" 上加 2 天。结果可能是 "2 mar" 或 "1 mar"，因为存在闰年。但是我们不需要考虑这些，只需要直接加 2 天，剩下的 date 对象会帮我们处理：\n\nlet date = new date(2016, 1, 28);\n*!*\ndate.setdate(date.getdate() + 2);\n*/!*\nalert( date ); // 1 mar 2016\n\n\n1\n2\n3\n4\n5\n\n\n这个特性经常被用来获取给定时间段后的日期。例如，我们想获取“现在 70 秒后”的日期：\n\nlet date = new date();\ndate.setseconds(date.getseconds() + 70);\nalert( date ); // 显示正确的日期信息\n\n\n1\n2\n3\n\n\n我们还可以设置 0 甚至可以设置负值。例如：\n\nlet date = new date(2016, 0, 2); // 2016 年 1 月 2 日\ndate.setdate(1); // 设置为当月的第一天\nalert( date );\ndate.setdate(0); // 天数最小可以设置为 1，所以这里设置的是上一月的最后一天\nalert( date ); // 31 dec 2015\n\n\n1\n2\n3\n4\n5\n\n\n# 5.11.5 日期转化为数字，日期差值\n\n当 date 对象被转化为数字时，得到的是对应的时间戳，与使用 date.gettime() 的结果相同：\n\nlet date = new date();\nalert(+date); // 以毫秒为单位的数值，与使用 date.gettime() 的结果相同\n\n\n1\n2\n\n\n有一个重要的副作用：日期可以相减，相减的结果是以毫秒为单位时间差。\n\n这个作用可以用于时间测量：\n\nlet start = new date(); // 开始测量时间\n// do the job\nfor (let i = 0; i < 100000; i++) {\n  let dosomething = i * i * i;\n}\nlet end = new date(); // 结束测量时间\nalert( `the loop took ${end - start} ms` );\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 5.11.6 date.now()\n\n如果我们仅仅想要测量时间间隔，我们不需要 date 对象。\n\n有一个特殊的方法 date.now()，它会返回当前的时间戳。\n\n它相当于 new date().gettime()，但它不会创建中间的 date 对象。因此它更快，而且不会对垃圾回收造成额外的压力。\n\n这种方法很多时候因为方便，又或是因性能方面的考虑而被采用，例如使用 javascript 编写游戏或其他的特殊应用场景。\n\n因此这样做可能会更好：\n\nlet start = date.now(); // 从 1 jan 1970 至今的时间戳\n// do the job\nfor (let i = 0; i < 100000; i++) {\n  let dosomething = i * i * i;\n}\nlet end = date.now(); // 完成\nalert( `the loop took ${end - start} ms` ); // 相减的是时间戳，而不是日期\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 5.11.7 基准测试（benchmarking）\n\n在对一个很耗 cpu 性能的函数进行可靠的基准测试（benchmarking）时，我们需要谨慎一点。\n\n例如，我们想判断以下两个计算日期差值的函数：哪个更快？\n\n这种性能测量通常称为“基准测试（benchmark）”。\n\n// 我们有 date1 和 date2，哪个函数会更快地返回两者的时间差？\nfunction diffsubtract(date1, date2) {\n  return date2 - date1;\n}\n// or\nfunction diffgettime(date1, date2) {\n  return date2.gettime() - date1.gettime();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这两个函数做的事情完全相同，但是其中一个函数使用显式的 date.gettime() 来获取毫秒形式的日期，另一个则依赖于“日期 — 数字”的转换。它们的结果是一样的。\n\n那么，哪个更快呢？\n\n首先想到的方法可能是连续运行两者很多次，并计算所消耗的时间之差。就这个例子而言，函数过于简单，所以我们必须执行至少 100000 次。\n\n让我们开始测量：\n\nfunction diffsubtract(date1, date2) {\n  return date2 - date1;\n}\nfunction diffgettime(date1, date2) {\n  return date2.gettime() - date1.gettime();\n}\nfunction bench(f) {\n  let date1 = new date(0);\n  let date2 = new date();\n  let start = date.now();\n  for (let i = 0; i < 100000; i++) f(date1, date2);\n  return date.now() - start;\n}\nalert( \'time of diffsubtract: \' + bench(diffsubtract) + \'ms\' );\nalert( \'time of diffgettime: \' + bench(diffgettime) + \'ms\' );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n看起来使用 gettime() 这种方式快得多，这是因为它没有进行类型转换，对引擎优化来说更加简单。\n\n我们得到了结论，但是这并不是一个很好的度量的例子。\n\n想象一下当运行 bench(diffsubtract) 的同时，cpu 还在并行处理其他事务，并且这也会占用资源。然而，运行 bench(diffgettime) 的时候，并行处理的事务完成了。\n\n对于现代多进程操作系统来说，这是一个非常常见的场景。\n\n比起第二个函数，第一个函数所能使用的 cpu 资源更少。这可能导致错误的结论。\n\n为了得到更加可靠的度量，整个度量测试包应该重新运行多次。\n\n例如，像下面的代码这样：\n\nfunction diffsubtract(date1, date2) {\n  return date2 - date1;\n}\nfunction diffgettime(date1, date2) {\n  return date2.gettime() - date1.gettime();\n}\nfunction bench(f) {\n  let date1 = new date(0);\n  let date2 = new date();\n  let start = date.now();\n  for (let i = 0; i < 100000; i++) f(date1, date2);\n  return date.now() - start;\n}\nlet time1 = 0;\nlet time2 = 0;\n*!*\n// 交替运行 bench(diffsubtract) 和 bench(diffgettime) 各 10 次\nfor (let i = 0; i < 10; i++) {\n  time1 += bench(diffsubtract);\n  time2 += bench(diffgettime);\n}\n*/!*\nalert( \'total time for diffsubtract: \' + time1 );\nalert( \'total time for diffgettime: \' + time2 );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n现代的 javascript 引擎的先进优化策略只对执行很多次的 "hot code" 有效（对于执行很少次数的代码没有必要优化）。因此，在上面的例子中，第一次执行的优化程度不高。我们可能需要增加一个预热步骤：\n\n// 在主循环中增加预热环节\nbench(diffsubtract);\nbench(diffgettime);\n// 开始度量\nfor (let i = 0; i < 10; i++) {\n  time1 += bench(diffsubtract);\n  time2 += bench(diffgettime);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n进行微型基准测试时要小心\n\n现代的 javascript 引擎执行了很多优化。与正常编写的代码相比，它们可能会改变“人为编写的专用于测试的代码”的执行流程，特别是在我们对很小的代码片段进行基准测试时，例如某个运算符或内建函数的工作方式。因此，为了深入理解性能问题，请学习 javascript 引擎的工作原理。在那之后，你或许再也不需要进行微型基准测试了。 http://mrale.ph 提供了很多 v8 引擎相关的文章。\n\n# 5.11.8 对字符串调用 date.parse\n\ndate.parse(str) 方法可以从一个字符串中读取日期。\n\n字符串的格式应该为：yyyy-mm-ddthh:mm:ss.sssz，其中：\n\n * yyyy-mm-dd —— 日期：年-月-日。\n * 字符 "t" 是一个分隔符。\n * hh:mm:ss.sss —— 时间：小时，分钟，秒，毫秒。\n * 可选字符 \'z\' 为 +-hh:mm 格式的时区。单个字符 z 代表 utc+0 时区。\n\n简短形式也是可以的，比如 yyyy-mm-dd 或 yyyy-mm，甚至可以是 yyyy。\n\ndate.parse(str) 调用会解析给定格式的字符串，并返回时间戳（自 1970-01-01 00:00:00 起所经过的毫秒数）。如果给定字符串的格式不正确，则返回 nan。\n\n举个例子：\n\nlet ms = date.parse(\'2012-01-26t13:51:50.417-07:00\');\nalert(ms); // 1327611110417  (时间戳)\n\n\n1\n2\n\n\n我们可以通过时间戳来立即创建一个 new date 对象：\n\nlet date = new date( date.parse(\'2012-01-26t13:51:50.417-07:00\') );\nalert(date);\n\n\n1\n2\n\n\n\n# 5.12 json\n\njson（javascript object notation）是表示值和对象的通用格式。在 rfc 4627 标准中有对其的描述。最初它是为 javascript 而创建的，但许多其他编程语言也有用于处理它的库。因此，当客户端使用 javascript 而服务器端是使用 ruby/php/java 等语言编写的时，使用 json 可以很容易地进行数据交换。\n\njavascript 提供了如下方法：\n\n * json.stringify 将对象转换为 json。\n * json.parse 将 json 转换回对象。\n\n# 5.12.1 json.stringify\n\n例如，在这里我们 json.stringify 一个 student 对象：\n\nlet student = {\n  name: \'john\',\n  age: 30,\n  isadmin: false,\n  courses: [\'html\', \'css\', \'js\'],\n  spouse: null\n};\nlet json = json.stringify(student);\nalert(typeof json); // we\'ve got a string!\nalert(json);\n/* json 编码的对象：\n{\n  "name": "john",\n  "age": 30,\n  "isadmin": false,\n  "courses": ["html", "css", "js"],\n  "spouse": null\n}\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n方法 json.stringify(student) 接收对象并将其转换为字符串。\n\n得到的 json 字符串是一个被称为 json 编码（json-encoded） 或 序列化（serialized） 或 字符串化（stringified） 或 编组化（marshalled） 的对象。我们现在已经准备好通过有线发送它或将其放入普通数据存储。\n\n请注意，json 编码的对象与对象字面量有几个重要的区别：\n\n * 字符串使用双引号。json 中没有单引号或反引号。所以 \'john\' 被转换为 "john"。\n * 对象属性名称也是双引号的。这是强制性的。所以 age:30 被转换成 "age":30。\n\njson.stringify 也可以应用于原始（primitive）数据类型。\n\njson 支持以下数据类型：\n\n * objects { ... }\n * arrays [ ... ]\n * primitives：\n   * strings，\n   * numbers，\n   * boolean values true/false，\n   * null。\n\n例如：\n\n// 数字在 json 还是数字\nalert( json.stringify(1) ) // 1\n// 字符串在 json 中还是字符串，只是被双引号扩起来\nalert( json.stringify(\'test\') ) // "test"\nalert( json.stringify(true) ); // true\nalert( json.stringify([1, 2, 3]) ); // [1,2,3]\n\n\n1\n2\n3\n4\n5\n6\n\n\njson 是语言无关的纯数据规范，因此一些特定于 javascript 的对象属性会被 json.stringify 跳过。\n\n即：\n\n * 函数属性（方法）。\n * symbol 类型的键和值。\n * 存储 undefined 的属性。\n\nlet user = {\n  sayhi() { // 被忽略\n    alert("hello");\n  },\n  [symbol("id")]: 123, // 被忽略\n  something: undefined // 被忽略\n};\nalert( json.stringify(user) ); // {}（空对象）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n通常这很好。如果这不是我们想要的方式，那么我们很快就会看到如何自定义转换方式。\n\n最棒的是支持嵌套对象转换，并且可以自动对其进行转换。\n\n例如：\n\nlet meetup = {\n  title: "conference",\n  room: {\n    number: 23,\n    participants: ["john", "ann"]\n  }\n};\nalert( json.stringify(meetup) );\n/* 整个结构都被字符串化了\n{\n  "title":"conference",\n  "room":{"number":23,"participants":["john","ann"]},\n}\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n重要的限制：不得有循环引用。\n\n例如：\n\nlet room = {\n  number: 23\n};\nlet meetup = {\n  title: "conference",\n  participants: ["john", "ann"]\n};\nmeetup.place = room;       // meetup 引用了 room\nroom.occupiedby = meetup; // room 引用了 meetup\njson.stringify(meetup); // error: converting circular structure to json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在这里，转换失败了，因为循环引用：room.occupiedby 引用了 meetup，meetup.place 引用了 room：\n\n# 5.12.2 排除和转换：replacer\n\njson.stringify 的完整语法是：\n\nlet json = json.stringify(value[, replacer, space])\n\n\n1\n\n\nvalue : 要编码的值。\n\nreplacer : 要编码的属性数组或映射函数 function(key, value)。\n\nspace : 用于格式化的空格数量\n\n大部分情况，json.stringify 仅与第一个参数一起使用。但是，如果我们需要微调替换过程，比如过滤掉循环引用，我们可以使用 json.stringify 的第二个参数。\n\n如果我们传递一个属性数组给它，那么只有这些属性会被编码。\n\n例如：\n\nlet room = {\n  number: 23\n};\nlet meetup = {\n  title: "conference",\n  participants: [{name: "john"}, {name: "alice"}],\n  place: room // meetup 引用了 room\n};\nroom.occupiedby = meetup; // room 引用了 meetup\nalert( json.stringify(meetup, [\'title\', \'participants\']) );\n// {"title":"conference","participants":[{},{}]}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这里我们可能过于严格了。属性列表应用于了整个对象结构。所以 participants 是空的，因为 name 不在列表中。\n\n让我们包含除了会导致循环引用的 room.occupiedby 之外的所有属性：\n\nlet room = {\n  number: 23\n};\nlet meetup = {\n  title: "conference",\n  participants: [{name: "john"}, {name: "alice"}],\n  place: room // meetup 引用了 room\n};\nroom.occupiedby = meetup; // room 引用了 meetup\nalert( json.stringify(meetup, [\'title\', \'participants\', \'place\', \'name\', \'number\']) );\n/*\n{\n  "title":"conference",\n  "participants":[{"name":"john"},{"name":"alice"}],\n  "place":{"number":23}\n}\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n现在，除 occupiedby 以外的所有内容都被序列化了。但是属性的列表太长了。\n\n幸运的是，我们可以使用一个函数代替数组作为 replacer。\n\n该函数会为每个 (key,value) 对调用并返回“已替换”的值，该值将替换原有的值。如果值被跳过了，则为 undefined。\n\n在我们的例子中，我们可以为 occupiedby 以外的所有内容按原样返回 value。为了 occupiedby，下面的代码返回 undefined：\n\nlet room = {\n  number: 23\n};\nlet meetup = {\n  title: "conference",\n  participants: [{name: "john"}, {name: "alice"}],\n  place: room // meetup 引用了 room\n};\nroom.occupiedby = meetup; // room 引用了 meetup\nalert( json.stringify(meetup, function replacer(key, value) {\n  alert(`${key}: ${value}`);\n  return (key == \'occupiedby\') ? undefined : value;\n}));\n/* key:value pairs that come to replacer:\n:             [object object]\ntitle:        conference\nparticipants: [object object],[object object]\n0:            [object object]\nname:         john\n1:            [object object]\nname:         alice\nplace:        [object object]\nnumber:       23\noccupiedby: [object object]\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n请注意 replacer 函数会获取每个键/值对，包括嵌套对象和数组项。它被递归地应用。replacer 中的 this 的值是包含当前属性的对象。\n\n第一个调用很特别。它是使用特殊的“包装对象”制作的：{"": meetup}。换句话说，第一个 (key, value) 对的键是空的，并且该值是整个目标对象。这就是上面的示例中第一行是 ":[object object]" 的原因。\n\n这个理念是为了给 replacer 提供尽可能多的功能：如果有必要，它有机会分析并替换/跳过整个对象。\n\n# 5.12.3 格式化：space\n\njson.stringify(value, replacer, spaces) 的第三个参数是用于优化格式的空格数量。\n\n以前，所有字符串化的对象都没有缩进和额外的空格。如果我们想通过网络发送一个对象，那就没什么问题。space 参数专门用于调整出更美观的输出。\n\n这里的 space = 2 告诉 javascript 在多行中显示嵌套的对象，对象内部缩进 2 个空格：\n\nlet user = {\n  name: "john",\n  age: 25,\n  roles: {\n    isadmin: false,\n    iseditor: true\n  }\n};\nalert(json.stringify(user, null, 2));\n/* 两个空格的缩进：\n{\n  "name": "john",\n  "age": 25,\n  "roles": {\n    "isadmin": false,\n    "iseditor": true\n  }\n}\n*/\n/* 对于 json.stringify(user, null, 4) 的结果会有更多缩进：\n{\n    "name": "john",\n    "age": 25,\n    "roles": {\n        "isadmin": false,\n        "iseditor": true\n    }\n}\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n第三个参数也可以是字符串。在这种情况下，字符串用于缩进，而不是空格的数量。\n\nspaces 参数仅用于日志记录和美化输出。\n\n# 5.12.4 自定义 "tojson"\n\n像 tostring 进行字符串转换，对象也可以提供 tojson 方法来进行 json 转换。如果可用，json.stringify 会自动调用它。\n\n例如：\n\nlet room = {\n  number: 23\n};\nlet meetup = {\n  title: "conference",\n  date: new date(date.utc(2017, 0, 1)),\n  room\n};\nalert( json.stringify(meetup) );\n/*\n  {\n    "title":"conference",\n    "date":"2017-01-01t00:00:00.000z",  // (1)\n    "room": {"number":23}               // (2)\n  }\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n在这儿我们可以看到 date (1) 变成了一个字符串。这是因为所有日期都有一个内建的 tojson 方法来返回这种类型的字符串。\n\n现在让我们为对象 room 添加一个自定义的 tojson：\n\nlet room = {\n  number: 23,\n  tojson() {\n    return this.number;\n  }\n};\nlet meetup = {\n  title: "conference",\n  room\n};\nalert( json.stringify(room) ); // 23\nalert( json.stringify(meetup) );\n/*\n  {\n    "title":"conference",\n    "room": 23\n  }\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n正如我们所看到的，tojson 既可以用于直接调用 json.stringify(room) 也可以用于当 room 嵌套在另一个编码对象中时。\n\n# 5.12.5 json.parse\n\n要解码 json 字符串，我们需要另一个方法 json.parse。\n\n语法：\n\nlet value = json.parse(str, [reviver]);\n\n\n1\n\n\nstr : 要解析的 json 字符串。\n\nreviver : 可选的函数 function(key,value)，该函数将为每个 (key, value) 对调用，并可以对值进行转换。\n\n例如：\n\n// 字符串化数组\nlet numbers = "[0, 1, 2, 3]";\nnumbers = json.parse(numbers);\nalert( numbers[1] ); // 1\n\n\n1\n2\n3\n4\n\n\n对于嵌套对象：\n\nlet userdata = \'{ "name": "john", "age": 35, "isadmin": false, "friends": [0,1,2,3] }\';\nlet user = json.parse(userdata);\nalert( user.friends[1] ); // 1\n\n\n1\n2\n3\n\n\njson 可能会非常复杂，对象和数组可以包含其他对象和数组。但是它们必须遵循相同的 json 格式。\n\n以下是手写 json 时的典型错误（有时我们必须出于调试目的编写它）：\n\nlet json = `{\n  name: "john",                     // 错误：属性名没有双引号\n  "surname": \'smith\',               // 错误：值使用的是单引号（必须使用双引号）\n  \'isadmin\': false                  // 错误：键使用的是单引号（必须使用双引号）\n  "birthday": new date(2000, 2, 3), // 错误：不允许使用 "new"，只能是裸值\n  "friends": [0,1,2,3]              // 这个没问题\n}`;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n此外，json 不支持注释。向 json 添加注释无效。\n\n还有另一种名为 json5 的格式，它允许未加引号的键，也允许注释等。但这是一个独立的库，不在语言的规范中。\n\n常规的 json 格式严格，并不是因为它的开发者很懒，而是为了实现简单，可靠且快速地实现解析算法。\n\n# 5.12.6 使用 reviver\n\n想象一下，我们从服务器上获得了一个字符串化的 meetup 对象。\n\n它看起来像这样：\n\n// title: (meetup title), date: (meetup date)\nlet str = \'{"title":"conference","date":"2017-11-30t12:00:00.000z"}\';\n\n\n1\n2\n\n\n……现在我们需要对它进行 反序列（deserialize），把它转换回 javascript 对象。\n\n让我们通过调用 json.parse 来完成：\n\nlet str = \'{"title":"conference","date":"2017-11-30t12:00:00.000z"}\';\nlet meetup = json.parse(str);\nalert( meetup.date.getdate() ); // error!\n\n\n1\n2\n3\n\n\n啊！报错了！\n\nmeetup.date 的值是一个字符串，而不是 date 对象。json.parse 怎么知道应该将字符串转换为 date 呢？\n\n让我们将 reviver 函数传递给 json.parse 作为第二个参数，该函数按照“原样”返回所有值，但是 date 会变成 date：\n\nlet str = \'{"title":"conference","date":"2017-11-30t12:00:00.000z"}\';\nlet meetup = json.parse(str, function(key, value) {\n  if (key == \'date\') return new date(value);\n  return value;\n});\nalert( meetup.date.getdate() ); // 现在正常运行了！\n\n\n1\n2\n3\n4\n5\n6\n\n\n顺便说一下，这也适用于嵌套对象：\n\nlet schedule = `{\n  "meetups": [\n    {"title":"conference","date":"2017-11-30t12:00:00.000z"},\n    {"title":"birthday","date":"2017-04-18t12:00:00.000z"}\n  ]\n}`;\nschedule = json.parse(schedule, function(key, value) {\n  if (key == \'date\') return new date(value);\n  return value;\n});\nalert( schedule.meetups[1].date.getdate() ); // 正常运行了！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n',charsets:{cjk:!0}},{title:"泛型",frontmatter:{title:"泛型",date:"2020-01-05T10:17:47.000Z",permalink:"/pages/8045759ec4ad3c01",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","TypeScript 常用语法"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/02.TypeScript%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/06.%E6%B3%9B%E5%9E%8B.html",relativePath:"《TypeScript 从零实现 axios》/02.TypeScript 常用语法/06.泛型.md",key:"v-ea774b7a",path:"/pages/8045759ec4ad3c01/",headers:[{level:2,title:"基础示例",slug:"基础示例",normalizedTitle:"基础示例",charIndex:177},{level:2,title:"使用泛型变量",slug:"使用泛型变量",normalizedTitle:"使用泛型变量",charIndex:1239},{level:2,title:"泛型类型",slug:"泛型类型",normalizedTitle:"泛型类型",charIndex:2001},{level:2,title:"泛型类",slug:"泛型类",normalizedTitle:"泛型类",charIndex:2001},{level:2,title:"泛型约束",slug:"泛型约束",normalizedTitle:"泛型约束",charIndex:3897},{level:3,title:"在泛型约束中使用类型参数",slug:"在泛型约束中使用类型参数",normalizedTitle:"在泛型约束中使用类型参数",charIndex:4595}],headersStr:"基础示例 使用泛型变量 泛型类型 泛型类 泛型约束 在泛型约束中使用类型参数",content:"# 泛型\n\n软件工程中，我们不仅要创建定义良好且一致的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。\n\n在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。\n\n\n# 基础示例\n\n下面来创建第一个使用泛型的例子：identity 函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 echo 命令。\n\n不用泛型的话，这个函数可能是下面这样：\n\nfunction identity(arg: number): number {\n  return arg\n}\n\n\n1\n2\n3\n\n\n或者，我们使用 any 类型来定义函数：\n\nfunction identity(arg: any): any {\n  return arg\n}\n\n\n1\n2\n3\n\n\n使用 any 类型会导致这个函数可以接收任何类型的 arg 参数，但是这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。\n\n因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。这里，我们使用了类型变量，它是一种特殊的变量，只用于表示类型而不是值。\n\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\n\n1\n2\n3\n\n\n我们给 identity 添加了类型变量 T。 T 帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。 之后我们再次使用了 T 当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型的信息。\n\n我们把这个版本的 identity 函数叫做泛型，因为它可以适用于多个类型。 不同于使用 any，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。\n\n我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：\n\nlet output = identity<string>('myString')\n\n\n1\n\n\n这里我们明确的指定了 T 是 string 类型，并做为一个参数传给函数，使用了 <> 括起来而不是 ()。\n\n第二种方法更普遍。利用了类型推论 -- 即编译器会根据传入的参数自动地帮助我们确定 T 的类型：\n\nlet output = identity('myString')\n\n\n1\n\n\n注意我们没必要使用尖括号（<>）来明确地传入类型；编译器可以查看 myString 的值，然后把 T 设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入 T 的类型，在一些复杂的情况下，这是可能出现的。\n\n\n# 使用泛型变量\n\n使用泛型创建像 identity 这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。\n\n看下之前 identity 例子：\n\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\n\n1\n2\n3\n\n\n如果我们想打印出 arg 的长度。 我们很可能会这样做：\n\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length)\n  return arg\n}\n\n\n1\n2\n3\n4\n\n\n如果这么做，编译器会报错说我们使用了 arg 的 .length 属性，但是没有地方指明 arg 具有这个属性。记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 .length 属性的。\n\n现在假设我们想操作 T 类型的数组而不直接是 T。由于我们操作的是数组，所以 .length 属性是应该存在的。我们可以像创建其它数组一样创建这个数组：\n\nfunction loggingIdentity<T>(arg: T[]): T[] {\n  console.log(arg.length)\n  return arg\n}\n\n\n1\n2\n3\n4\n\n\n你可以这样理解 loggingIdentity 的类型：泛型函数 loggingIdentity，接收类型参数 T 和参数 arg，它是个元素类型是 T 的数组，并返回元素类型是T 的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 T 的的类型为 number。 这可以让我们把泛型变量 T 当做类型的一部分使用，而不是整个类型，增加了灵活性。\n\n\n# 泛型类型\n\n上一节，我们创建了 identity 通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。\n\n泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：\n\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: <T>(arg: T) => T = identity\n\n\n1\n2\n3\n4\n5\n\n\n我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。\n\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: <U>(arg: U) => U = identity\n\n\n1\n2\n3\n4\n5\n\n\n我们还可以使用带有调用签名的对象字面量来定义泛型函数：\n\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: {<T>(arg: T): T} = identity\n\n\n1\n2\n3\n4\n5\n\n\n这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口：\n\ninterface GenericIdentityFn {\n  <T>(arg: T): T\n}\n\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: GenericIdentityFn = identity\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n我们甚至可以把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： Dictionary<string> 而不只是Dictionary）。这样接口里的其它成员也能知道这个参数的类型了。\n\ninterface GenericIdentityFn<T> {\n  (arg: T): T\n}\n\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: GenericIdentityFn<number> = identity\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 GenericIdentityFn 的时候，还得传入一个类型参数来指定泛型类型（这里是：number），锁定了之后代码里使用的类型。对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。\n\n除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。\n\n\n# 泛型类\n\n泛型类看上去与泛型接口差不多。 泛型类使用（ <>）括起泛型类型，跟在类名后面。\n\nclass GenericNumber<T> {\n  zeroValue: T\n  add: (x: T, y: T) => T\n}\n\nlet myGenericNumber = new GenericNumber<number>()\nmyGenericNumber.zeroValue = 0\nmyGenericNumber.add = function(x, y) {\n  return x + y\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nGenericNumber 类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用 number 类型。 也可以使用字符串或其它更复杂的类型。\n\nlet stringNumeric = new GenericNumber<string>()\nstringNumeric.zeroValue = ''\nstringNumeric.add = function(x, y) {\n  return x + y\n}\n\nconsole.log(stringNumeric.add(stringNumeric.zeroValue, 'test'))\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。\n\n我们在类那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。\n\n\n# 泛型约束\n\n我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。在 loggingIdentity 例子中，我们想访问 arg 的 length 属性，但是编译器并不能证明每种类型都有 length 属性，所以就报错了。\n\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length)\n  return arg\n}\n\n\n1\n2\n3\n4\n\n\n相比于操作 any 所有类型，我们想要限制函数去处理任意带有 .length 属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 T 的约束要求。\n\n我们定义一个接口来描述约束条件，创建一个包含 .length 属性的接口，使用这个接口和 extends 关键字来实现约束：\n\ninterface Lengthwise {\n  length: number\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length) // OK\n  return arg\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：\n\nloggingIdentity(3);  // Error\n\n\n1\n\n\n我们需要传入符合约束类型的值，必须包含必须的属性：\n\nloggingIdentity({length: 10, value: 3}) // OK\n\n\n1\n\n\n\n# 在泛型约束中使用类型参数\n\n你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 obj 上，因此我们需要在这两个类型之间使用约束。\n\nfunction getProperty<T, K extends keyof T> (obj: T, key: K ) {\n  return obj[key]\n}\n\nlet x = {a: 1, b: 2, c: 3, d: 4}\n\ngetProperty(x, 'a') // okay\ngetProperty(x, 'm') // error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",normalizedContent:"# 泛型\n\n软件工程中，我们不仅要创建定义良好且一致的 api，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。\n\n在像 c# 和 java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。\n\n\n# 基础示例\n\n下面来创建第一个使用泛型的例子：identity 函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 echo 命令。\n\n不用泛型的话，这个函数可能是下面这样：\n\nfunction identity(arg: number): number {\n  return arg\n}\n\n\n1\n2\n3\n\n\n或者，我们使用 any 类型来定义函数：\n\nfunction identity(arg: any): any {\n  return arg\n}\n\n\n1\n2\n3\n\n\n使用 any 类型会导致这个函数可以接收任何类型的 arg 参数，但是这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。\n\n因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。这里，我们使用了类型变量，它是一种特殊的变量，只用于表示类型而不是值。\n\nfunction identity<t>(arg: t): t {\n  return arg\n}\n\n\n1\n2\n3\n\n\n我们给 identity 添加了类型变量 t。 t 帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。 之后我们再次使用了 t 当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型的信息。\n\n我们把这个版本的 identity 函数叫做泛型，因为它可以适用于多个类型。 不同于使用 any，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。\n\n我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：\n\nlet output = identity<string>('mystring')\n\n\n1\n\n\n这里我们明确的指定了 t 是 string 类型，并做为一个参数传给函数，使用了 <> 括起来而不是 ()。\n\n第二种方法更普遍。利用了类型推论 -- 即编译器会根据传入的参数自动地帮助我们确定 t 的类型：\n\nlet output = identity('mystring')\n\n\n1\n\n\n注意我们没必要使用尖括号（<>）来明确地传入类型；编译器可以查看 mystring 的值，然后把 t 设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入 t 的类型，在一些复杂的情况下，这是可能出现的。\n\n\n# 使用泛型变量\n\n使用泛型创建像 identity 这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。\n\n看下之前 identity 例子：\n\nfunction identity<t>(arg: t): t {\n  return arg\n}\n\n\n1\n2\n3\n\n\n如果我们想打印出 arg 的长度。 我们很可能会这样做：\n\nfunction loggingidentity<t>(arg: t): t {\n  console.log(arg.length)\n  return arg\n}\n\n\n1\n2\n3\n4\n\n\n如果这么做，编译器会报错说我们使用了 arg 的 .length 属性，但是没有地方指明 arg 具有这个属性。记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 .length 属性的。\n\n现在假设我们想操作 t 类型的数组而不直接是 t。由于我们操作的是数组，所以 .length 属性是应该存在的。我们可以像创建其它数组一样创建这个数组：\n\nfunction loggingidentity<t>(arg: t[]): t[] {\n  console.log(arg.length)\n  return arg\n}\n\n\n1\n2\n3\n4\n\n\n你可以这样理解 loggingidentity 的类型：泛型函数 loggingidentity，接收类型参数 t 和参数 arg，它是个元素类型是 t 的数组，并返回元素类型是t 的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 t 的的类型为 number。 这可以让我们把泛型变量 t 当做类型的一部分使用，而不是整个类型，增加了灵活性。\n\n\n# 泛型类型\n\n上一节，我们创建了 identity 通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。\n\n泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：\n\nfunction identity<t>(arg: t): t {\n  return arg\n}\n\nlet myidentity: <t>(arg: t) => t = identity\n\n\n1\n2\n3\n4\n5\n\n\n我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。\n\nfunction identity<t>(arg: t): t {\n  return arg\n}\n\nlet myidentity: <u>(arg: u) => u = identity\n\n\n1\n2\n3\n4\n5\n\n\n我们还可以使用带有调用签名的对象字面量来定义泛型函数：\n\nfunction identity<t>(arg: t): t {\n  return arg\n}\n\nlet myidentity: {<t>(arg: t): t} = identity\n\n\n1\n2\n3\n4\n5\n\n\n这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口：\n\ninterface genericidentityfn {\n  <t>(arg: t): t\n}\n\nfunction identity<t>(arg: t): t {\n  return arg\n}\n\nlet myidentity: genericidentityfn = identity\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n我们甚至可以把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： dictionary<string> 而不只是dictionary）。这样接口里的其它成员也能知道这个参数的类型了。\n\ninterface genericidentityfn<t> {\n  (arg: t): t\n}\n\nfunction identity<t>(arg: t): t {\n  return arg\n}\n\nlet myidentity: genericidentityfn<number> = identity\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 genericidentityfn 的时候，还得传入一个类型参数来指定泛型类型（这里是：number），锁定了之后代码里使用的类型。对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。\n\n除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。\n\n\n# 泛型类\n\n泛型类看上去与泛型接口差不多。 泛型类使用（ <>）括起泛型类型，跟在类名后面。\n\nclass genericnumber<t> {\n  zerovalue: t\n  add: (x: t, y: t) => t\n}\n\nlet mygenericnumber = new genericnumber<number>()\nmygenericnumber.zerovalue = 0\nmygenericnumber.add = function(x, y) {\n  return x + y\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\ngenericnumber 类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用 number 类型。 也可以使用字符串或其它更复杂的类型。\n\nlet stringnumeric = new genericnumber<string>()\nstringnumeric.zerovalue = ''\nstringnumeric.add = function(x, y) {\n  return x + y\n}\n\nconsole.log(stringnumeric.add(stringnumeric.zerovalue, 'test'))\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。\n\n我们在类那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。\n\n\n# 泛型约束\n\n我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。在 loggingidentity 例子中，我们想访问 arg 的 length 属性，但是编译器并不能证明每种类型都有 length 属性，所以就报错了。\n\nfunction loggingidentity<t>(arg: t): t {\n  console.log(arg.length)\n  return arg\n}\n\n\n1\n2\n3\n4\n\n\n相比于操作 any 所有类型，我们想要限制函数去处理任意带有 .length 属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 t 的约束要求。\n\n我们定义一个接口来描述约束条件，创建一个包含 .length 属性的接口，使用这个接口和 extends 关键字来实现约束：\n\ninterface lengthwise {\n  length: number\n}\n\nfunction loggingidentity<t extends lengthwise>(arg: t): t {\n  console.log(arg.length) // ok\n  return arg\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：\n\nloggingidentity(3);  // error\n\n\n1\n\n\n我们需要传入符合约束类型的值，必须包含必须的属性：\n\nloggingidentity({length: 10, value: 3}) // ok\n\n\n1\n\n\n\n# 在泛型约束中使用类型参数\n\n你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 obj 上，因此我们需要在这两个类型之间使用约束。\n\nfunction getproperty<t, k extends keyof t> (obj: t, key: k ) {\n  return obj[key]\n}\n\nlet x = {a: 1, b: 2, c: 3, d: 4}\n\ngetproperty(x, 'a') // okay\ngetproperty(x, 'm') // error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"类型推断",frontmatter:{title:"类型推断",date:"2020-01-05T10:17:47.000Z",permalink:"/pages/7279420c899c505d",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","TypeScript 常用语法"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/02.TypeScript%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/07.%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD.html",relativePath:"《TypeScript 从零实现 axios》/02.TypeScript 常用语法/07.类型推断.md",key:"v-a29aacc4",path:"/pages/7279420c899c505d/",headers:[{level:2,title:"基础",slug:"基础",normalizedTitle:"基础",charIndex:51},{level:2,title:"最佳通用类型",slug:"最佳通用类型",normalizedTitle:"最佳通用类型",charIndex:216},{level:2,title:"上下文类型",slug:"上下文类型",normalizedTitle:"上下文类型",charIndex:799}],headersStr:"基础 最佳通用类型 上下文类型",content:"# 类型推断\n\n这节介绍 TypeScript 里的类型推断。即，类型是在哪里如何被推断的。\n\n\n# 基础\n\nTypeScript 里，在有些没有明确指出类型的地方，类型推断会帮助提供类型。如下面的例子：\n\nlet x = 3\n\n\n1\n\n\n变量 x 的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。\n\n大多数情况下，类型推断是直截了当地。后面的小节，我们会浏览类型推断时的细微差别。\n\n\n# 最佳通用类型\n\n有些时候我们需要从几个表达式中推断类型，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，\n\nlet x = [0, 1, null]\n\n\n1\n\n\n为了推断 x 的类型，我们必须考虑所有元素的类型。 这里有两种选择：number 和 null。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。\n\n由于最终的通用类型取自候选类型，有些时候候选类型共享一个公共结构，但是却没有一个类型能做为所有候选类型的超级类型。例如：\n\nclass Animal {\n  numLegs: number\n}\n\nclass Bee extends Animal {\n}\n\nclass Lion extends Animal {\n}\n\nlet zoo = [new Bee(), new Lion()]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这里，我们想让 zoo 被推断为 Animal[] 类型，但是这个数组里没有对象是 Animal 类型的，因此不能推断出这个结果。 为了更正，我们可以明确的声明我们期望的类型：\n\nlet zoo: Animal[] = [new Bee(), new Lion()]\n\n\n1\n\n\n如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，(Bee | Lion)[]\n\n\n# 上下文类型\n\n有些时候，TypeScript 类型推断会按另外一种方式，我们称作“上下文类型”；上下文类型的出现和表达式的类型以及所处的位置相关。比如：\n\nwindow.onmousedown = function(mouseEvent) {\n  console.log(mouseEvent.clickTime)  // Error\n}\n\n\n1\n2\n3\n\n\n这个例子会得到一个类型错误，TypeScript 类型检查器使用 window.onmousedown 函数的类型来推断右边函数表达式的类型。 因此，就能推断出 mouseEvent 参数的类型了，所以 mouseEvent 访问了一个不存在的属性，就报错了。\n\n如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。重写上面的例子：\n\nwindow.onmousedown = function(mouseEvent:any) {\n  console.log(mouseEvent.clickTime)  // OK\n}\n\n\n1\n2\n3\n\n\n这个函数表达式有明确的参数类型注解，上下文类型被忽略。这样的话就不报错了，因为这里不会使用到上下文类型。\n\n上下文类型会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员，数组字面量和返回值语句。上下文类型也会做为最佳通用类型的候选类型。比如：\n\nfunction createZoo(): Animal[] {\n  return [new Bee(), new Lion()]\n}\n\nlet zoo = createZoo()\n\n\n1\n2\n3\n4\n5\n\n\n这个例子里，最佳通用类型有 3 个候选者：Animal，Bee 和 Lion。 其中，Animal 会被做为最佳通用类型。",normalizedContent:"# 类型推断\n\n这节介绍 typescript 里的类型推断。即，类型是在哪里如何被推断的。\n\n\n# 基础\n\ntypescript 里，在有些没有明确指出类型的地方，类型推断会帮助提供类型。如下面的例子：\n\nlet x = 3\n\n\n1\n\n\n变量 x 的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。\n\n大多数情况下，类型推断是直截了当地。后面的小节，我们会浏览类型推断时的细微差别。\n\n\n# 最佳通用类型\n\n有些时候我们需要从几个表达式中推断类型，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，\n\nlet x = [0, 1, null]\n\n\n1\n\n\n为了推断 x 的类型，我们必须考虑所有元素的类型。 这里有两种选择：number 和 null。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。\n\n由于最终的通用类型取自候选类型，有些时候候选类型共享一个公共结构，但是却没有一个类型能做为所有候选类型的超级类型。例如：\n\nclass animal {\n  numlegs: number\n}\n\nclass bee extends animal {\n}\n\nclass lion extends animal {\n}\n\nlet zoo = [new bee(), new lion()]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这里，我们想让 zoo 被推断为 animal[] 类型，但是这个数组里没有对象是 animal 类型的，因此不能推断出这个结果。 为了更正，我们可以明确的声明我们期望的类型：\n\nlet zoo: animal[] = [new bee(), new lion()]\n\n\n1\n\n\n如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，(bee | lion)[]\n\n\n# 上下文类型\n\n有些时候，typescript 类型推断会按另外一种方式，我们称作“上下文类型”；上下文类型的出现和表达式的类型以及所处的位置相关。比如：\n\nwindow.onmousedown = function(mouseevent) {\n  console.log(mouseevent.clicktime)  // error\n}\n\n\n1\n2\n3\n\n\n这个例子会得到一个类型错误，typescript 类型检查器使用 window.onmousedown 函数的类型来推断右边函数表达式的类型。 因此，就能推断出 mouseevent 参数的类型了，所以 mouseevent 访问了一个不存在的属性，就报错了。\n\n如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。重写上面的例子：\n\nwindow.onmousedown = function(mouseevent:any) {\n  console.log(mouseevent.clicktime)  // ok\n}\n\n\n1\n2\n3\n\n\n这个函数表达式有明确的参数类型注解，上下文类型被忽略。这样的话就不报错了，因为这里不会使用到上下文类型。\n\n上下文类型会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员，数组字面量和返回值语句。上下文类型也会做为最佳通用类型的候选类型。比如：\n\nfunction createzoo(): animal[] {\n  return [new bee(), new lion()]\n}\n\nlet zoo = createzoo()\n\n\n1\n2\n3\n4\n5\n\n\n这个例子里，最佳通用类型有 3 个候选者：animal，bee 和 lion。 其中，animal 会被做为最佳通用类型。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"高级类型",frontmatter:{title:"高级类型",date:"2020-01-05T10:17:47.000Z",permalink:"/pages/3fb6c2f52ab398e3",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","TypeScript 常用语法"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/02.TypeScript%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/08.%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B.html",relativePath:"《TypeScript 从零实现 axios》/02.TypeScript 常用语法/08.高级类型.md",key:"v-0496ed8a",path:"/pages/3fb6c2f52ab398e3/",headers:[{level:2,title:"交叉类型",slug:"交叉类型",normalizedTitle:"交叉类型",charIndex:11},{level:2,title:"联合类型",slug:"联合类型",normalizedTitle:"联合类型",charIndex:860},{level:2,title:"类型保护",slug:"类型保护",normalizedTitle:"类型保护",charIndex:2185},{level:3,title:"用户自定义的类型保护",slug:"用户自定义的类型保护",normalizedTitle:"用户自定义的类型保护",charIndex:2588},{level:3,title:"typeof 类型保护",slug:"typeof-类型保护",normalizedTitle:"typeof 类型保护",charIndex:3165},{level:3,title:"instanceof 类型保护",slug:"instanceof-类型保护",normalizedTitle:"instanceof 类型保护",charIndex:4317},{level:2,title:"可以为 null 的类型",slug:"可以为-null-的类型",normalizedTitle:"可以为 null 的类型",charIndex:4975},{level:3,title:"可选参数和可选属性",slug:"可选参数和可选属性",normalizedTitle:"可选参数和可选属性",charIndex:5604},{level:3,title:"类型保护和类型断言",slug:"类型保护和类型断言",normalizedTitle:"类型保护和类型断言",charIndex:6070},{level:2,title:"字符串字面量类型",slug:"字符串字面量类型",normalizedTitle:"字符串字面量类型",charIndex:7095},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:7817}],headersStr:"交叉类型 联合类型 类型保护 用户自定义的类型保护 typeof 类型保护 instanceof 类型保护 可以为 null 的类型 可选参数和可选属性 类型保护和类型断言 字符串字面量类型 总结",content:"# 高级类型\n\n\n# 交叉类型\n\n交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，Person & Loggable 同时是 Person 和 Loggable。 就是说这个类型的对象同时拥有了这两种类型的成员。\n\n我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript 里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：\n\nfunction extend<T, U> (first: T, second: U): T & U {\n  let result = {} as T & U\n  for (let id in first) {\n    result[id] = first[id] as any\n  }\n  for (let id in second) {\n    if (!result.hasOwnProperty(id)) {\n      result[id] = second[id] as any\n    }\n  }\n  return result\n}\n\nclass Person {\n  constructor (public name: string) {\n  }\n}\n\ninterface Loggable {\n  log (): void\n}\n\nclass ConsoleLogger implements Loggable {\n  log () {\n    // ...\n  }\n}\n\nvar jim = extend(new Person('Jim'), new ConsoleLogger())\nvar n = jim.name\njim.log()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 联合类型\n\n联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 number 或 string 类型的参数。 例如下面的函数：\n\nfunction padLeft(value: string, padding: any) {\n  if (typeof padding === 'number') {\n    return Array(padding + 1).join(' ') + value\n  }\n  if (typeof padding === 'string') {\n    return padding + value\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`)\n}\n\npadLeft('Hello world', 4) // returns \"    Hello world\"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\npadLeft 存在一个问题，padding 参数的类型指定成了 any。 这就是说我们可以传入一个既不是 number 也不是 string 类型的参数，但是 TypeScript 却不报错。\n\nlet indentedString = padLeft('Hello world', true) // 编译阶段通过，运行时报错\n\n\n1\n\n\n为了解决这个问题，我们可以使用 联合类型做为 padding 的参数：\n\nfunction padLeft(value: string, padding: string | number) {\n  // ...\n}\n\nlet indentedString = padLeft('Hello world', true) // 编译阶段报错\n\n\n1\n2\n3\n4\n5\n\n\n联合类型表示一个值可以是几种类型之一。我们用竖线（|）分隔每个类型，所以 number | string 表示一个值可以是 number 或 string。\n\n如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。\n\ninterface Bird {\n  fly()\n  layEggs()\n}\n\ninterface Fish {\n  swim()\n  layEggs()\n}\n\nfunction getSmallPet(): Fish | Bird {\n  // ...\n}\n\nlet pet = getSmallPet()\npet.layEggs() // okay\npet.swim()    // error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这里的联合类型可能有点复杂：如果一个值的类型是 A | B，我们能够确定的是它包含了 A 和 B 中共有的成员。这个例子里，Fish 具有一个 swim 方法，我们不能确定一个 Bird | Fish 类型的变量是否有 swim方法。 如果变量在运行时是 Bird 类型，那么调用 pet.swim() 就出错了。\n\n\n# 类型保护\n\n联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 Fish 或者是 Bird 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。\n\nlet pet = getSmallPet()\n\n// 每一个成员访问都会报错\nif (pet.swim) {\n  pet.swim()\n} else if (pet.fly) {\n  pet.fly()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n为了让这段代码工作，我们要使用类型断言：\n\nlet pet = getSmallPet()\n\nif ((pet as Fish).swim) {\n  (pet as Fish).swim()\n} else {\n  (pet as Bird).fly()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 用户自定义的类型保护\n\n这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 pet 的类型的话就好了。\n\nTypeScript 里的类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个类型谓词：\n\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined\n}\n\n\n1\n2\n3\n\n\n在这个例子里，pet is Fish 就是类型谓词。谓词为 parameterName is Type 这种形式， parameterName 必须是来自于当前函数签名里的一个参数名。\n\n每当使用一些变量调用 isFish 时，TypeScript 会将变量缩减为那个具体的类型。\n\nif (isFish(pet)) {\n  pet.swim()\n}\nelse {\n  pet.fly()\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意 TypeScript 不仅知道在 if 分支里 pet 是 Fish 类型；它还清楚在 else 分支里，一定不是 Fish类型而是 Bird 类型。\n\n\n# typeof 类型保护\n\n现在我们回过头来看看怎么使用联合类型书写 padLeft 代码。我们可以像下面这样利用类型断言来写：\n\nfunction isNumber (x: any):x is string {\n  return typeof x === 'number'\n}\n\nfunction isString (x: any): x is string {\n  return typeof x === 'string'\n}\n\nfunction padLeft (value: string, padding: string | number) {\n  if (isNumber(padding)) {\n    return Array(padding + 1).join(' ') + value\n  }\n  if (isString(padding)) {\n    return padding + value\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 typeof x === 'number'抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。\n\nfunction padLeft (value: string, padding: string | number) {\n  if (typeof padding === 'number') {\n    return Array(padding + 1).join(' ') + value\n  }\n  if (typeof padding === 'string') {\n    return padding + value\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这些 typeof 类型保护只有两种形式能被识别：typeof v === \"typename\" 和 typeof v !== \"typename\"， \"typename\"必须是 \"number\"， \"string\"，\"boolean\" 或 \"symbol\"。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。\n\n\n# instanceof 类型保护\n\n如果你已经阅读了 typeof 类型保护并且对 JavaScript 里的 instanceof 操作符熟悉的话，你可能已经猜到了这节要讲的内容。\n\ninstanceof 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造：\n\nclass Bird {\n  fly () {\n    console.log('bird fly')\n  }\n\n  layEggs () {\n    console.log('bird lay eggs')\n  }\n}\n\nclass Fish {\n  swim () {\n    console.log('fish swim')\n  }\n\n  layEggs () {\n    console.log('fish lay eggs')\n  }\n}\n\nfunction getRandomPet () {\n  return Math.random() > 0.5 ? new Bird() : new Fish()\n}\n\nlet pet = getRandomPet()\n\nif (pet instanceof Bird) {\n  pet.fly()\n}\nif (pet instanceof Fish) {\n  pet.swim()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 可以为 null 的类型\n\nTypeScript 具有两种特殊的类型，null 和 undefined，它们分别具有值 null 和 undefined。我们在基础类型一节里已经做过简要说明。 默认情况下，类型检查器认为 null 与 undefined 可以赋值给任何类型。 null 与 undefined 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。null的发明者，Tony Hoare，称它为价值亿万美金的错误。\n\n--strictNullChecks 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 null 或 undefined。 你可以使用联合类型明确的包含它们：\n\nlet s = 'foo'\ns = null // 错误, 'null'不能赋值给'string'\nlet sn: string | null = 'bar'\nsn = null // 可以\n\nsn = undefined // error, 'undefined'不能赋值给'string | null'\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意，按照 JavaScript 的语义，TypeScript 会把 null 和 undefined 区别对待。string | null，string | undefined 和 string | undefined | null 是不同的类型。\n\n\n# 可选参数和可选属性\n\n使用了 --strictNullChecks，可选参数会被自动地加上 | undefined:\n\nfunction f(x: number, y?: number) {\n  return x + (y || 0)\n}\nf(1, 2)\nf(1)\nf(1, undefined)\nf(1, null) // error, 'null' 不能赋值给 'number | undefined'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可选属性也会有同样的处理：\n\nclass C {\n  a: number\n  b?: number\n}\nlet c = new C()\nc.a = 12\nc.a = undefined // error, 'undefined' 不能赋值给 'number'\nc.b = 13\nc.b = undefined // ok\nc.b = null // error, 'null' 不能赋值给 'number | undefined'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 类型保护和类型断言\n\n由于可以为 null 的类型能和其它类型定义为联合类型，那么你需要使用类型保护来去除 null。幸运地是这与在 JavaScript 里写的代码一致：\n\nfunction f(sn: string | null): string {\n  if (sn === null) {\n    return 'default'\n  } else {\n    return sn\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这里很明显地去除了 null，你也可以使用短路运算符：\n\nfunction f(sn: string | null): string {\n  return sn || 'default'\n}\n\n\n1\n2\n3\n\n\n如果编译器不能够去除 null 或 undefined，你可以使用类型断言手动去除。语法是添加 ! 后缀： identifier! 从 identifier 的类型里去除了 null 和 undefined：\n\nfunction broken(name: string | null): string {\n  function postfix(epithet: string) {\n    return name.charAt(0) + '.  the ' + epithet // error, 'name' 可能为 null\n  }\n  name = name || 'Bob'\n  return postfix('great')\n}\n\nfunction fixed(name: string | null): string {\n  function postfix(epithet: string) {\n    return name!.charAt(0) + '.  the ' + epithet // ok\n  }\n  name = name || 'Bob'\n  return postfix('great')\n}\n\nbroken(null)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n本例使用了嵌套函数，因为编译器无法去除嵌套函数的 null（除非是立即调用的函数表达式）。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 name 的类型。\n\n\n# 字符串字面量类型\n\n字符串字面量类型允许你指定字符串必须具有的确切值。在实际应用中，字符串字面量类型可以与联合类型，类型保护很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。\n\ntype Easing = 'ease-in' | 'ease-out' | 'ease-in-out'\n\nclass UIElement {\n  animate (dx: number, dy: number, easing: Easing) {\n    if (easing === 'ease-in') {\n      // ...\n    } else if (easing === 'ease-out') {\n    } else if (easing === 'ease-in-out') {\n    } else {\n      // error! 不能传入 null 或者 undefined.\n    }\n  }\n}\n\nlet button = new UIElement()\nbutton.animate(0, 0, 'ease-in')\nbutton.animate(0, 0, 'uneasy') // error\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。\n\nArgument of type '\"uneasy\"' is not assignable to parameter of type '\"ease-in\" | \"ease-out\" | \"ease-in-out\"'\n\n\n1\n\n\n\n# 总结\n\n那么到这里，我们的 TypeScript 常用语法学习就告一段落了，当然 TypeScript 还有其他的语法我们并没有讲，我们只是讲了 TypeScript 的一些常用语法，你们把这些知识学会已经足以开发一般的应用了。如果你在使用 TypeScript 开发项目中遇到了其他的 TypeScript 语法知识，你可以通过 TypeScript 的官网文档学习。因为学基础最好的方法还是去阅读它的官网文档，敲上面的小例子。其实我们课程的基础知识结构也是大部分参考了官网文档，要记住学习一门技术的基础官网文档永远是最好的第一手资料。\n\n但是 TypeScript 的学习不能仅仅靠看官网文档，你还需要动手实践，在实践中你才能真正掌握 TypeScript。相信很多同学学习到这里已经迫不及待想要大展身手了，那么下面我们就开始把理论转换为实践，一起来用 TypeScript 重构 axios 吧！",normalizedContent:"# 高级类型\n\n\n# 交叉类型\n\n交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，person & loggable 同时是 person 和 loggable。 就是说这个类型的对象同时拥有了这两种类型的成员。\n\n我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 javascript 里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：\n\nfunction extend<t, u> (first: t, second: u): t & u {\n  let result = {} as t & u\n  for (let id in first) {\n    result[id] = first[id] as any\n  }\n  for (let id in second) {\n    if (!result.hasownproperty(id)) {\n      result[id] = second[id] as any\n    }\n  }\n  return result\n}\n\nclass person {\n  constructor (public name: string) {\n  }\n}\n\ninterface loggable {\n  log (): void\n}\n\nclass consolelogger implements loggable {\n  log () {\n    // ...\n  }\n}\n\nvar jim = extend(new person('jim'), new consolelogger())\nvar n = jim.name\njim.log()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 联合类型\n\n联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 number 或 string 类型的参数。 例如下面的函数：\n\nfunction padleft(value: string, padding: any) {\n  if (typeof padding === 'number') {\n    return array(padding + 1).join(' ') + value\n  }\n  if (typeof padding === 'string') {\n    return padding + value\n  }\n  throw new error(`expected string or number, got '${padding}'.`)\n}\n\npadleft('hello world', 4) // returns \"    hello world\"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\npadleft 存在一个问题，padding 参数的类型指定成了 any。 这就是说我们可以传入一个既不是 number 也不是 string 类型的参数，但是 typescript 却不报错。\n\nlet indentedstring = padleft('hello world', true) // 编译阶段通过，运行时报错\n\n\n1\n\n\n为了解决这个问题，我们可以使用 联合类型做为 padding 的参数：\n\nfunction padleft(value: string, padding: string | number) {\n  // ...\n}\n\nlet indentedstring = padleft('hello world', true) // 编译阶段报错\n\n\n1\n2\n3\n4\n5\n\n\n联合类型表示一个值可以是几种类型之一。我们用竖线（|）分隔每个类型，所以 number | string 表示一个值可以是 number 或 string。\n\n如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。\n\ninterface bird {\n  fly()\n  layeggs()\n}\n\ninterface fish {\n  swim()\n  layeggs()\n}\n\nfunction getsmallpet(): fish | bird {\n  // ...\n}\n\nlet pet = getsmallpet()\npet.layeggs() // okay\npet.swim()    // error\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这里的联合类型可能有点复杂：如果一个值的类型是 a | b，我们能够确定的是它包含了 a 和 b 中共有的成员。这个例子里，fish 具有一个 swim 方法，我们不能确定一个 bird | fish 类型的变量是否有 swim方法。 如果变量在运行时是 bird 类型，那么调用 pet.swim() 就出错了。\n\n\n# 类型保护\n\n联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 fish 或者是 bird 时怎么办？ javascript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。\n\nlet pet = getsmallpet()\n\n// 每一个成员访问都会报错\nif (pet.swim) {\n  pet.swim()\n} else if (pet.fly) {\n  pet.fly()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n为了让这段代码工作，我们要使用类型断言：\n\nlet pet = getsmallpet()\n\nif ((pet as fish).swim) {\n  (pet as fish).swim()\n} else {\n  (pet as bird).fly()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 用户自定义的类型保护\n\n这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 pet 的类型的话就好了。\n\ntypescript 里的类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个类型谓词：\n\nfunction isfish(pet: fish | bird): pet is fish {\n  return (pet as fish).swim !== undefined\n}\n\n\n1\n2\n3\n\n\n在这个例子里，pet is fish 就是类型谓词。谓词为 parametername is type 这种形式， parametername 必须是来自于当前函数签名里的一个参数名。\n\n每当使用一些变量调用 isfish 时，typescript 会将变量缩减为那个具体的类型。\n\nif (isfish(pet)) {\n  pet.swim()\n}\nelse {\n  pet.fly()\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意 typescript 不仅知道在 if 分支里 pet 是 fish 类型；它还清楚在 else 分支里，一定不是 fish类型而是 bird 类型。\n\n\n# typeof 类型保护\n\n现在我们回过头来看看怎么使用联合类型书写 padleft 代码。我们可以像下面这样利用类型断言来写：\n\nfunction isnumber (x: any):x is string {\n  return typeof x === 'number'\n}\n\nfunction isstring (x: any): x is string {\n  return typeof x === 'string'\n}\n\nfunction padleft (value: string, padding: string | number) {\n  if (isnumber(padding)) {\n    return array(padding + 1).join(' ') + value\n  }\n  if (isstring(padding)) {\n    return padding + value\n  }\n  throw new error(`expected string or number, got '${padding}'.`)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 typeof x === 'number'抽象成一个函数，因为 typescript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。\n\nfunction padleft (value: string, padding: string | number) {\n  if (typeof padding === 'number') {\n    return array(padding + 1).join(' ') + value\n  }\n  if (typeof padding === 'string') {\n    return padding + value\n  }\n  throw new error(`expected string or number, got '${padding}'.`)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这些 typeof 类型保护只有两种形式能被识别：typeof v === \"typename\" 和 typeof v !== \"typename\"， \"typename\"必须是 \"number\"， \"string\"，\"boolean\" 或 \"symbol\"。 但是 typescript 并不会阻止你与其它字符串比较，只是 typescript 不会把那些表达式识别为类型保护。\n\n\n# instanceof 类型保护\n\n如果你已经阅读了 typeof 类型保护并且对 javascript 里的 instanceof 操作符熟悉的话，你可能已经猜到了这节要讲的内容。\n\ninstanceof 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造：\n\nclass bird {\n  fly () {\n    console.log('bird fly')\n  }\n\n  layeggs () {\n    console.log('bird lay eggs')\n  }\n}\n\nclass fish {\n  swim () {\n    console.log('fish swim')\n  }\n\n  layeggs () {\n    console.log('fish lay eggs')\n  }\n}\n\nfunction getrandompet () {\n  return math.random() > 0.5 ? new bird() : new fish()\n}\n\nlet pet = getrandompet()\n\nif (pet instanceof bird) {\n  pet.fly()\n}\nif (pet instanceof fish) {\n  pet.swim()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 可以为 null 的类型\n\ntypescript 具有两种特殊的类型，null 和 undefined，它们分别具有值 null 和 undefined。我们在基础类型一节里已经做过简要说明。 默认情况下，类型检查器认为 null 与 undefined 可以赋值给任何类型。 null 与 undefined 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。null的发明者，tony hoare，称它为价值亿万美金的错误。\n\n--strictnullchecks 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 null 或 undefined。 你可以使用联合类型明确的包含它们：\n\nlet s = 'foo'\ns = null // 错误, 'null'不能赋值给'string'\nlet sn: string | null = 'bar'\nsn = null // 可以\n\nsn = undefined // error, 'undefined'不能赋值给'string | null'\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意，按照 javascript 的语义，typescript 会把 null 和 undefined 区别对待。string | null，string | undefined 和 string | undefined | null 是不同的类型。\n\n\n# 可选参数和可选属性\n\n使用了 --strictnullchecks，可选参数会被自动地加上 | undefined:\n\nfunction f(x: number, y?: number) {\n  return x + (y || 0)\n}\nf(1, 2)\nf(1)\nf(1, undefined)\nf(1, null) // error, 'null' 不能赋值给 'number | undefined'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可选属性也会有同样的处理：\n\nclass c {\n  a: number\n  b?: number\n}\nlet c = new c()\nc.a = 12\nc.a = undefined // error, 'undefined' 不能赋值给 'number'\nc.b = 13\nc.b = undefined // ok\nc.b = null // error, 'null' 不能赋值给 'number | undefined'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 类型保护和类型断言\n\n由于可以为 null 的类型能和其它类型定义为联合类型，那么你需要使用类型保护来去除 null。幸运地是这与在 javascript 里写的代码一致：\n\nfunction f(sn: string | null): string {\n  if (sn === null) {\n    return 'default'\n  } else {\n    return sn\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这里很明显地去除了 null，你也可以使用短路运算符：\n\nfunction f(sn: string | null): string {\n  return sn || 'default'\n}\n\n\n1\n2\n3\n\n\n如果编译器不能够去除 null 或 undefined，你可以使用类型断言手动去除。语法是添加 ! 后缀： identifier! 从 identifier 的类型里去除了 null 和 undefined：\n\nfunction broken(name: string | null): string {\n  function postfix(epithet: string) {\n    return name.charat(0) + '.  the ' + epithet // error, 'name' 可能为 null\n  }\n  name = name || 'bob'\n  return postfix('great')\n}\n\nfunction fixed(name: string | null): string {\n  function postfix(epithet: string) {\n    return name!.charat(0) + '.  the ' + epithet // ok\n  }\n  name = name || 'bob'\n  return postfix('great')\n}\n\nbroken(null)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n本例使用了嵌套函数，因为编译器无法去除嵌套函数的 null（除非是立即调用的函数表达式）。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 name 的类型。\n\n\n# 字符串字面量类型\n\n字符串字面量类型允许你指定字符串必须具有的确切值。在实际应用中，字符串字面量类型可以与联合类型，类型保护很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。\n\ntype easing = 'ease-in' | 'ease-out' | 'ease-in-out'\n\nclass uielement {\n  animate (dx: number, dy: number, easing: easing) {\n    if (easing === 'ease-in') {\n      // ...\n    } else if (easing === 'ease-out') {\n    } else if (easing === 'ease-in-out') {\n    } else {\n      // error! 不能传入 null 或者 undefined.\n    }\n  }\n}\n\nlet button = new uielement()\nbutton.animate(0, 0, 'ease-in')\nbutton.animate(0, 0, 'uneasy') // error\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。\n\nargument of type '\"uneasy\"' is not assignable to parameter of type '\"ease-in\" | \"ease-out\" | \"ease-in-out\"'\n\n\n1\n\n\n\n# 总结\n\n那么到这里，我们的 typescript 常用语法学习就告一段落了，当然 typescript 还有其他的语法我们并没有讲，我们只是讲了 typescript 的一些常用语法，你们把这些知识学会已经足以开发一般的应用了。如果你在使用 typescript 开发项目中遇到了其他的 typescript 语法知识，你可以通过 typescript 的官网文档学习。因为学基础最好的方法还是去阅读它的官网文档，敲上面的小例子。其实我们课程的基础知识结构也是大部分参考了官网文档，要记住学习一门技术的基础官网文档永远是最好的第一手资料。\n\n但是 typescript 的学习不能仅仅靠看官网文档，你还需要动手实践，在实践中你才能真正掌握 typescript。相信很多同学学习到这里已经迫不及待想要大展身手了，那么下面我们就开始把理论转换为实践，一起来用 typescript 重构 axios 吧！",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"需求分析",frontmatter:{title:"需求分析",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/195af93fcc871b8b",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 项目初始化"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/03.ts-axios%20%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/01.%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90.html",relativePath:"《TypeScript 从零实现 axios》/03.ts-axios 项目初始化/01.需求分析.md",key:"v-2ef9475e",path:"/pages/195af93fcc871b8b/",headers:[{level:2,title:"Features",slug:"features",normalizedTitle:"features",charIndex:91}],headersStr:"Features",content:"# 需求分析\n\n接下来的章节，我们会使用 TypeScript 来重构 axios，重构之前，我们需要简单地做一些需求分析，看一下我们这次重构需要支持哪些 feature。\n\n\n# Features\n\n * 在浏览器端使用 XMLHttpRequest 对象通讯\n * 支持 Promise API\n * 支持请求和响应的拦截器\n * 支持请求数据和响应数据的转换\n * 支持请求的取消\n * JSON 数据的自动转换\n * 客户端防止 XSRF\n\n此外，我们还会支持一些 axios 库支持的一些其它的 feature。这里要注意的，我们这次重构不包括 axios 在 Node 中的实现，因为这部分我们在平时项目中应用的很少，还涉及到很多 Node.js 的知识，如果都讲的话，一是比较占用时间，另一个可能会喧宾夺主了。当然，这部分知识点我会根据同学们学习的反馈，如果大家很感兴趣想学习的话，我就作为课程的补充内容加到后期视频的扩展中，也当做课程的福利送给大家，所以大家务必要支持一下正版课程喔~\n\n那么接下来我们就开始初始化项目吧！",normalizedContent:"# 需求分析\n\n接下来的章节，我们会使用 typescript 来重构 axios，重构之前，我们需要简单地做一些需求分析，看一下我们这次重构需要支持哪些 feature。\n\n\n# features\n\n * 在浏览器端使用 xmlhttprequest 对象通讯\n * 支持 promise api\n * 支持请求和响应的拦截器\n * 支持请求数据和响应数据的转换\n * 支持请求的取消\n * json 数据的自动转换\n * 客户端防止 xsrf\n\n此外，我们还会支持一些 axios 库支持的一些其它的 feature。这里要注意的，我们这次重构不包括 axios 在 node 中的实现，因为这部分我们在平时项目中应用的很少，还涉及到很多 node.js 的知识，如果都讲的话，一是比较占用时间，另一个可能会喧宾夺主了。当然，这部分知识点我会根据同学们学习的反馈，如果大家很感兴趣想学习的话，我就作为课程的补充内容加到后期视频的扩展中，也当做课程的福利送给大家，所以大家务必要支持一下正版课程喔~\n\n那么接下来我们就开始初始化项目吧！",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"初始化项目",frontmatter:{title:"初始化项目",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/6e11ac76475a2b3e",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 项目初始化"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/03.ts-axios%20%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/02.%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE.html",relativePath:"《TypeScript 从零实现 axios》/03.ts-axios 项目初始化/02.初始化项目.md",key:"v-6be602be",path:"/pages/6e11ac76475a2b3e/",headers:[{level:2,title:"创建代码仓库",slug:"创建代码仓库",normalizedTitle:"创建代码仓库",charIndex:12},{level:2,title:"TypeScript library starter",slug:"typescript-library-starter",normalizedTitle:"typescript library starter",charIndex:361},{level:3,title:"使用方式",slug:"使用方式",normalizedTitle:"使用方式",charIndex:508},{level:3,title:"目录文件介绍",slug:"目录文件介绍",normalizedTitle:"目录文件介绍",charIndex:748},{level:3,title:"优秀工具集成",slug:"优秀工具集成",normalizedTitle:"优秀工具集成",charIndex:1154},{level:3,title:"Npm Scripts",slug:"npm-scripts",normalizedTitle:"npm scripts",charIndex:1548},{level:2,title:"关联远程分支",slug:"关联远程分支",normalizedTitle:"关联远程分支",charIndex:1953},{level:3,title:"拉取代码",slug:"拉取代码",normalizedTitle:"拉取代码",charIndex:2230},{level:3,title:"提交代码",slug:"提交代码",normalizedTitle:"提交代码",charIndex:2636}],headersStr:"创建代码仓库 TypeScript library starter 使用方式 目录文件介绍 优秀工具集成 Npm Scripts 关联远程分支 拉取代码 提交代码",content:"# 初始化项目\n\n\n# 创建代码仓库\n\n接下来，我们开始初始化项目，首先我们先去 GitHub 上创建一个 repo，填好 repo 名称，以及写一下 README，对项目先做个简单的描述。\n\n通常我们初始化一个项目，需要配置一大堆东西，比如 package.json、.editorconfig、.gitignore 等；还包括一些构建工具如 rollup、webpack 以及它们的配置。\n\n当我们使用 TypeScript 去写一个项目的时候，还需要配置 TypeScript 的编译配置文件 tsconfig.json 以及 tslint.json 文件。\n\n这些茫茫多的配置往往会让一个想从零开始写项目的同学望而却步，如果有一个脚手架工具帮我们生成好这些初始化文件该多好。好在确实有这样的工具，接下来我们的主角 TypeScript library starter 隆重登场。\n\n\n# TypeScript library starter\n\n它是一个开源的 TypeScript 开发基础库的脚手架工具，可以帮助我们快速初始化一个 TypeScript 项目，我们可以去它的官网地址学习和使用它。\n\n\n# 使用方式\n\ngit clone https://github.com/alexjoverm/typescript-library-starter.git ts-axios\ncd ts-axios\n\nnpm install\n\n\n1\n2\n3\n4\n\n\n先通过 git clone 把项目代码拉下来到我们的 ts-axios 目录，然后运行 npm install 安装依赖，并且给项目命名，我们仍然使用 ts-axios。\n\n安装好依赖后，我们先来预览一下这个项目的目录结构。\n\n\n# 目录文件介绍\n\nTypeScript library starter 生成的目录结构如下：\n\n├── CONTRIBUTING.md\n├── LICENSE\n├── README.md\n├── code-of-conduct.md\n├── node_modules\n├── package-lock.json\n├── package.json\n├── rollup.config.ts // rollup 配置文件\n├── src // 源码目录\n├── test // 测试目录\n├── tools // 发布到 GitHup pages 以及 发布到 npm 的一些配置脚本工具\n├── tsconfig.json // TypeScript 编译配置文件\n└── tslint.json // TypeScript lint 文件\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 优秀工具集成\n\n使用 TypeScript library starter 创建的项目集成了很多优秀的开源工具：\n\n * 使用 RollupJS 帮助我们打包。\n * 使用 Prettier 和 TSLint 帮助我们格式化代码以及保证代码风格一致性。\n * 使用 TypeDoc 帮助我们自动生成文档并部署到 GitHub pages。\n * 使用 Jest帮助我们做单元测试。\n * 使用 Commitizen帮助我们生成规范化的提交注释。\n * 使用 Semantic release帮助我们管理版本和发布。\n * 使用 husky帮助我们更简单地使用 git hooks。\n * 使用 Conventional changelog帮助我们通过代码提交信息自动生成 change log。\n\n这里我们列举了很多工具，感兴趣的同学们可以点开他们的链接对这些工具做进一步学习。\n\n\n# Npm Scripts\n\nTypeScript library starter 同样在 package.json 中帮我们配置了一些 npm scripts，接下来我们先列举一下我们开发中常用的 npm scripts，剩余的我们在之后学习中遇到的时候再来介绍。\n\n * npm run lint: 使用 TSLint 工具检查 src 和 test 目录下 TypeScript 代码的可读性、可维护性和功能性错误。\n * npm start: 观察者模式运行 rollup 工具打包代码。\n * npm test: 运行 jest 工具跑单元测试。\n * npm run commit: 运行 commitizen 工具提交格式化的 git commit 注释。\n * npm run build: 运行 rollup 编译打包 TypeScript 代码，并运行 typedoc 工具生成文档。\n\n\n# 关联远程分支\n\n代码已经初始化好，接下来我们要把当前代码仓库关联我们的远程仓库，首先在命令行中运行命令查看远程分支：\n\ngit remote -v\n\n\n1\n\n\n这里我们不会得到任何输出，因为我们还没有关联远程分支，我们先去 GitHub 上找到我们仓库的地址，在命令行运行：\n\ngit remote add origin 仓库地址\n\n\n1\n\n\n关联后，远程库的名字就是 origin，这是 Git 默认的叫法，也可以改成别的，但是 origin 这个名字一看就知道是远程库。\n\n接着你就可以继续运行 git remote -v 查看关联结果了。\n\n\n# 拉取代码\n\n运行如下命令从远程仓库拉取 master 分支代码并合并：\n\ngit pull origin master\n\n\n1\n\n\n这个时候会报错：\n\nerror: The following untracked working tree files would be overwritten by merge:\n\tREADME.md\nPlease move or remove them before you merge.\nAborting\n\n\n1\n2\n3\n4\n\n\n因为我们在使用 typescript library starter 初始化代码的时候也创建了 README.md，和远程仓库的 README.md 冲突了。我们把 README.md 文件删除，再次运行：\n\ngit pull origin master\n\n\n1\n\n\n这次代码就拉取成功了，并且在本地也创建了一个 master 分支。\n\n\n# 提交代码\n\n最后我们来提交代码，首先运行：\n\ngit add .\n\n\n1\n\n\n把提交的代码从工作区添加到暂存区，然后运行 npm run commit 这个 npm 脚本来提交代码，运行后它会依次询问你几个问题，比如你这次修改的范围包括哪些、提交的描述、是否有 break change、影响了哪些 issue 等等。\n\n填写完毕，工具会帮我们运行 git commit 并且自动把我们提交的信息合成一条提交注释。接着运行命令把代码推送到远程 git 仓库中：\n\ngit push origin master\n\n\n1\n\n\n接着我们去 GitHub 仓库中就可以看到刚才这条提交记录了。\n\n至此，我们项目已经初始化完毕，接下来我们就开始编写源码实现 axios 了。",normalizedContent:"# 初始化项目\n\n\n# 创建代码仓库\n\n接下来，我们开始初始化项目，首先我们先去 github 上创建一个 repo，填好 repo 名称，以及写一下 readme，对项目先做个简单的描述。\n\n通常我们初始化一个项目，需要配置一大堆东西，比如 package.json、.editorconfig、.gitignore 等；还包括一些构建工具如 rollup、webpack 以及它们的配置。\n\n当我们使用 typescript 去写一个项目的时候，还需要配置 typescript 的编译配置文件 tsconfig.json 以及 tslint.json 文件。\n\n这些茫茫多的配置往往会让一个想从零开始写项目的同学望而却步，如果有一个脚手架工具帮我们生成好这些初始化文件该多好。好在确实有这样的工具，接下来我们的主角 typescript library starter 隆重登场。\n\n\n# typescript library starter\n\n它是一个开源的 typescript 开发基础库的脚手架工具，可以帮助我们快速初始化一个 typescript 项目，我们可以去它的官网地址学习和使用它。\n\n\n# 使用方式\n\ngit clone https://github.com/alexjoverm/typescript-library-starter.git ts-axios\ncd ts-axios\n\nnpm install\n\n\n1\n2\n3\n4\n\n\n先通过 git clone 把项目代码拉下来到我们的 ts-axios 目录，然后运行 npm install 安装依赖，并且给项目命名，我们仍然使用 ts-axios。\n\n安装好依赖后，我们先来预览一下这个项目的目录结构。\n\n\n# 目录文件介绍\n\ntypescript library starter 生成的目录结构如下：\n\n├── contributing.md\n├── license\n├── readme.md\n├── code-of-conduct.md\n├── node_modules\n├── package-lock.json\n├── package.json\n├── rollup.config.ts // rollup 配置文件\n├── src // 源码目录\n├── test // 测试目录\n├── tools // 发布到 githup pages 以及 发布到 npm 的一些配置脚本工具\n├── tsconfig.json // typescript 编译配置文件\n└── tslint.json // typescript lint 文件\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 优秀工具集成\n\n使用 typescript library starter 创建的项目集成了很多优秀的开源工具：\n\n * 使用 rollupjs 帮助我们打包。\n * 使用 prettier 和 tslint 帮助我们格式化代码以及保证代码风格一致性。\n * 使用 typedoc 帮助我们自动生成文档并部署到 github pages。\n * 使用 jest帮助我们做单元测试。\n * 使用 commitizen帮助我们生成规范化的提交注释。\n * 使用 semantic release帮助我们管理版本和发布。\n * 使用 husky帮助我们更简单地使用 git hooks。\n * 使用 conventional changelog帮助我们通过代码提交信息自动生成 change log。\n\n这里我们列举了很多工具，感兴趣的同学们可以点开他们的链接对这些工具做进一步学习。\n\n\n# npm scripts\n\ntypescript library starter 同样在 package.json 中帮我们配置了一些 npm scripts，接下来我们先列举一下我们开发中常用的 npm scripts，剩余的我们在之后学习中遇到的时候再来介绍。\n\n * npm run lint: 使用 tslint 工具检查 src 和 test 目录下 typescript 代码的可读性、可维护性和功能性错误。\n * npm start: 观察者模式运行 rollup 工具打包代码。\n * npm test: 运行 jest 工具跑单元测试。\n * npm run commit: 运行 commitizen 工具提交格式化的 git commit 注释。\n * npm run build: 运行 rollup 编译打包 typescript 代码，并运行 typedoc 工具生成文档。\n\n\n# 关联远程分支\n\n代码已经初始化好，接下来我们要把当前代码仓库关联我们的远程仓库，首先在命令行中运行命令查看远程分支：\n\ngit remote -v\n\n\n1\n\n\n这里我们不会得到任何输出，因为我们还没有关联远程分支，我们先去 github 上找到我们仓库的地址，在命令行运行：\n\ngit remote add origin 仓库地址\n\n\n1\n\n\n关联后，远程库的名字就是 origin，这是 git 默认的叫法，也可以改成别的，但是 origin 这个名字一看就知道是远程库。\n\n接着你就可以继续运行 git remote -v 查看关联结果了。\n\n\n# 拉取代码\n\n运行如下命令从远程仓库拉取 master 分支代码并合并：\n\ngit pull origin master\n\n\n1\n\n\n这个时候会报错：\n\nerror: the following untracked working tree files would be overwritten by merge:\n\treadme.md\nplease move or remove them before you merge.\naborting\n\n\n1\n2\n3\n4\n\n\n因为我们在使用 typescript library starter 初始化代码的时候也创建了 readme.md，和远程仓库的 readme.md 冲突了。我们把 readme.md 文件删除，再次运行：\n\ngit pull origin master\n\n\n1\n\n\n这次代码就拉取成功了，并且在本地也创建了一个 master 分支。\n\n\n# 提交代码\n\n最后我们来提交代码，首先运行：\n\ngit add .\n\n\n1\n\n\n把提交的代码从工作区添加到暂存区，然后运行 npm run commit 这个 npm 脚本来提交代码，运行后它会依次询问你几个问题，比如你这次修改的范围包括哪些、提交的描述、是否有 break change、影响了哪些 issue 等等。\n\n填写完毕，工具会帮我们运行 git commit 并且自动把我们提交的信息合成一条提交注释。接着运行命令把代码推送到远程 git 仓库中：\n\ngit push origin master\n\n\n1\n\n\n接着我们去 github 仓库中就可以看到刚才这条提交记录了。\n\n至此，我们项目已经初始化完毕，接下来我们就开始编写源码实现 axios 了。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"编写基础请求代码",frontmatter:{title:"编写基础请求代码",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/acfe1e0b401fa984",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 项目初始化"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/03.ts-axios%20%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/03.%E7%BC%96%E5%86%99%E5%9F%BA%E7%A1%80%E8%AF%B7%E6%B1%82%E4%BB%A3%E7%A0%81.html",relativePath:"《TypeScript 从零实现 axios》/03.ts-axios 项目初始化/03.编写基础请求代码.md",key:"v-f7a43d88",path:"/pages/acfe1e0b401fa984/",headers:[{level:2,title:"创建入口文件",slug:"创建入口文件",normalizedTitle:"创建入口文件",charIndex:256},{level:3,title:"编译配置文件 tsconfig.json",slug:"编译配置文件-tsconfig-json",normalizedTitle:"编译配置文件 tsconfig.json",charIndex:537},{level:3,title:"定义 AxiosRequestConfig 接口类型",slug:"定义-axiosrequestconfig-接口类型",normalizedTitle:"定义 axiosrequestconfig 接口类型",charIndex:1025},{level:2,title:"利用 XMLHttpRequest 发送请求",slug:"利用-xmlhttprequest-发送请求",normalizedTitle:"利用 xmlhttprequest 发送请求",charIndex:2065},{level:3,title:"引入 xhr 模块",slug:"引入-xhr-模块",normalizedTitle:"引入 xhr 模块",charIndex:2885},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:3183},{level:3,title:"依赖安装",slug:"依赖安装",normalizedTitle:"依赖安装",charIndex:3260},{level:3,title:"编写 webpack 配置文件",slug:"编写-webpack-配置文件",normalizedTitle:"编写 webpack 配置文件",charIndex:3732},{level:3,title:"编写 server 文件",slug:"编写-server-文件",normalizedTitle:"编写 server 文件",charIndex:5367},{level:3,title:"编写 demo 代码",slug:"编写-demo-代码",normalizedTitle:"编写 demo 代码",charIndex:6293},{level:3,title:"运行 demo",slug:"运行-demo",normalizedTitle:"运行 demo",charIndex:7824}],headersStr:"创建入口文件 编译配置文件 tsconfig.json 定义 AxiosRequestConfig 接口类型 利用 XMLHttpRequest 发送请求 引入 xhr 模块 demo 编写 依赖安装 编写 webpack 配置文件 编写 server 文件 编写 demo 代码 运行 demo",content:"# 编写基础请求代码\n\n我们这节课开始编写 ts-axios 库，我们的目标是实现简单的发送请求功能，即客户端通过 XMLHttpRequest 对象把请求发送到 server 端，server 端能收到请求并响应即可。\n\n我们实现 axios 最基本的操作，通过传入一个对象发送请求，如下：\n\naxios({\n  method: 'get',\n  url: '/simple/get',\n  params: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 创建入口文件\n\n我们删除 src 目录下的文件，先创建一个 index.ts 文件，作为整个库的入口文件，然后我们先定义一个 axios 方法，并把它导出，如下：\n\n\nfunction axios(config) {\n\n}\n\nexport default axios\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这里 TypeScript 编译器会检查到错误，分别是 config 的声明上有隐含的 any 报错，以及代码块为空。代码块为空我们比较好理解，第一个错误的原因是因为我们给 TypeScript 编译配置的 strict 设置为 true 导致。\n\n\n# 编译配置文件 tsconfig.json\n\ntsconfig.json 文件中指定了用来编译这个项目的根文件和编译选项，关于它的具体学习，我希望同学们去官网系统学习一下\n\n我们在之前讲 TypeScript 的基础时，会运行 tsc 命令去编译 TypeScript 文件，编译器会从当前目录开始去查找 tsconfig.json 文件，作为编译时的一些编译选项。\n\n我们来看一下 tsconfig.json 文件，它包含了很多编译时的配置，其中我们把 strict 设置为 true，它相当于启用所有严格类型的检查选项。启用 --strict 相当于启用 --noImplicitAny,--noImplicitThis,--alwaysStrict，--strictNullChecks 和 --strictFunctionTypes 和 --strictPropertyInitialization。\n\n我们讲 TypeScript 的基础时提到了 --strictNullChecks，其它的编译配置我建议同学们都去查看它的官网文档，把它当做手册去查阅即可。\n\n\n# 定义 AxiosRequestConfig 接口类型\n\n接下来，我们需要给 config 参数定义一种接口类型。我们创建一个 types 目录，在下面创建一个 index.ts 文件，作为我们项目中公用的类型定义文件。\n\n接下来我们来定义 AxiosRequestConfig 接口类型：\n\nexport interface AxiosRequestConfig {\n  url: string\n  method?: string\n  data?: any\n  params?: any\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n其中，url 为请求的地址，必选属性；而其余属性都是可选属性。method 是请求的 HTTP 方法；data 是 post、patch 等类型请求的数据，放到 request body 中的；params 是 get、head 等类型请求的数据，拼接到 url 的 query string 中的。\n\n为了让 method 只能传入合法的字符串，我们定义一种字符串字面量类型 Method：\n\nexport type Method = 'get' | 'GET'\n  | 'delete' | 'Delete'\n  | 'head' | 'HEAD'\n  | 'options' | 'OPTIONS'\n  | 'post' | 'POST'\n  | 'put' | 'PUT'\n  | 'patch' | 'PATCH'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n接着我们把 AxiosRequestConfig 中的 method 属性类型改成这种字符串字面量类型：\n\nexport interface AxiosRequestConfig {\n  url: string\n  method?: Method\n  data?: any\n  params?: any\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n然后回到 index.ts，我们引入 AxiosRequestConfig 类型，作为 config 的参数类型，如下：\n\nimport { AxiosRequestConfig } from './types'\n\nfunction axios(config: AxiosRequestConfig) {\n}\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n6\n\n\n那么接下来，我们就来实现这个函数体内部的逻辑——发送请求。\n\n\n# 利用 XMLHttpRequest 发送请求\n\n我们并不想在 index.ts 中去实现发送请求的逻辑，我们利用模块化的编程思想，把这个功能拆分到一个单独的模块中。\n\n于是我们在 src 目录下创建一个 xhr.ts 文件，我们导出一个 xhr 方法，它接受一个 config 参数，类型也是 AxiosRequestConfig 类型。\n\nimport { AxiosRequestConfig } from './types'\n\nexport default function xhr(config: AxiosRequestConfig) {\n}\n\n\n1\n2\n3\n4\n\n\n接下来，我们来实现这个函数体逻辑，如下：\n\nexport default function xhr(config: AxiosRequestConfig): void {\n  const { data = null, url, method = 'get' } = config\n\n  const request = new XMLHttpRequest()\n\n  request.open(method.toUpperCase(), url, true)\n\n  request.send(data)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n我们首先通过解构赋值的语法从 config 中拿到对应的属性值赋值给我的变量，并且还定义了一些默认值，因为在 AxiosRequestConfig 接口的定义中，有些属性是可选的。\n\n接着我们实例化了一个 XMLHttpRequest 对象，然后调用了它的 open 方法，传入了对应的一些参数，最后调用 send 方法发送请求。\n\n对于 XMLHttpRequest 的学习，我希望同学们去 mdn 上系统地学习一下它的一些属性和方法，当做参考资料，因为在后续的开发中我们可能会反复查阅这些文档资料。\n\n\n# 引入 xhr 模块\n\n编写好了 xhr 模块，我们就需要在 index.ts 中去引入这个模块，如下：\n\nimport { AxiosRequestConfig } from './types'\nimport xhr from './xhr'\n\nfunction axios(config: AxiosRequestConfig): void {\n  xhr(config)\n}\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n那么至此，我们基本的发送请求代码就编写完毕了，接下来我们来写一个小 demo，来使用我们编写的 axios 库去发送请求。\n\n\n# demo 编写\n\n我们会利用 Node.js 的 express 库去运行我们的 demo，利用 webpack 来作为 demo 的构建工具。\n\n\n# 依赖安装\n\n我们先来安装一些编写 demo 需要的依赖包，如下：\n\n\"webpack\": \"^4.28.4\",\n\"webpack-dev-middleware\": \"^3.5.0\",\n\"webpack-hot-middleware\": \"^2.24.3\",\n\"ts-loader\": \"^5.3.3\",\n\"tslint-loader\": \"^3.5.4\",\n\"express\": \"^4.16.4\",\n\"body-parser\": \"^1.18.3\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n其中，webpack 是打包构建工具，webpack-dev-middleware 和 webpack-hot-middleware 是 2 个 express 的 webpack 中间件，ts-loader 和 tslint-loader 是 webpack 需要的 TypeScript 相关 loader，express 是 Node.js 的服务端框架，body-parser 是 express 的一个中间件，解析 body 数据用的。\n\n\n# 编写 webpack 配置文件\n\n在 examples 目录下创建 webpack 配置文件 webpack.config.js：\n\nconst fs = require('fs')\nconst path = require('path')\nconst webpack = require('webpack')\n\nmodule.exports = {\n  mode: 'development',\n\n  /**\n   * 我们会在 examples 目录下建多个子目录\n   * 我们会把不同章节的 demo 放到不同的子目录中\n   * 每个子目录的下会创建一个 app.ts\n   * app.ts 作为 webpack 构建的入口文件\n   * entries 收集了多目录个入口文件，并且每个入口还引入了一个用于热更新的文件\n   * entries 是一个对象，key 为目录名\n   */\n  entry: fs.readdirSync(__dirname).reduce((entries, dir) => {\n    const fullDir = path.join(__dirname, dir)\n    const entry = path.join(fullDir, 'app.ts')\n    if (fs.statSync(fullDir).isDirectory() && fs.existsSync(entry)) {\n      entries[dir] = ['webpack-hot-middleware/client', entry]\n    }\n\n    return entries\n  }, {}),\n\n  /**\n   * 根据不同的目录名称，打包生成目标 js，名称和目录名一致\n   */\n  output: {\n    path: path.join(__dirname, '__build__'),\n    filename: '[name].js',\n    publicPath: '/__build__/'\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        enforce: 'pre',\n        use: [\n          {\n            loader: 'tslint-loader'\n          }\n        ]\n      },\n      {\n        test: /\\.tsx?$/,\n        use: [\n          {\n            loader: 'ts-loader',\n            options: {\n              transpileOnly: true\n            }\n          }\n        ]\n      }\n    ]\n  },\n\n  resolve: {\n    extensions: ['.ts', '.tsx', '.js']\n  },\n\n  plugins: [\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NoEmitOnErrorsPlugin()\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# 编写 server 文件\n\n在 examples 目录下创建 server.js 文件：\n\nconst express = require('express')\nconst bodyParser = require('body-parser')\nconst webpack = require('webpack')\nconst webpackDevMiddleware = require('webpack-dev-middleware')\nconst webpackHotMiddleware = require('webpack-hot-middleware')\nconst WebpackConfig = require('./webpack.config')\n\nconst app = express()\nconst compiler = webpack(WebpackConfig)\n\napp.use(webpackDevMiddleware(compiler, {\n  publicPath: '/__build__/',\n  stats: {\n    colors: true,\n    chunks: false\n  }\n}))\n\napp.use(webpackHotMiddleware(compiler))\n\napp.use(express.static(__dirname))\n\napp.use(bodyParser.json())\napp.use(bodyParser.urlencoded({ extended: true }))\n\nconst port = process.env.PORT || 8080\nmodule.exports = app.listen(port, () => {\n  console.log(`Server listening on http://localhost:${port}, Ctrl+C to stop`)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 编写 demo 代码\n\n首先在 examples 目录下创建 index.html 和 global.css，作为所有 demo 的入口文件已全局样式文件。\n\nindex.html：\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>ts-axios examples</title>\n    <link rel=\"stylesheet\" href=\"/global.css\">\n  </head>\n  <body style=\"padding: 0 20px\">\n    <h1>ts-axios examples</h1>\n    <ul>\n      <li><a href=\"simple\">Simple</a></li>\n    </ul>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nglobal.css：\n\nhtml, body {\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n  color: #2c3e50;\n}\n\nul {\n  line-height: 1.5em;\n  padding-left: 1.5em;\n}\n\na {\n  color: #7f8c8d;\n  text-decoration: none;\n}\n\na:hover {\n  color: #4fc08d;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n然后在 examples 目录下创建 simple 目录，作为本章节的 demo 目录，在该目录下再创建 index.html 和 app.ts 文件\n\nindex.html 文件如下:\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Simple example</title>\n  </head>\n  <body>\n    <script src=\"/__build__/simple.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\napp.ts 文件如下：\n\nimport axios from '../../src/index'\n\naxios({\n  method: 'get',\n  url: '/simple/get',\n  params: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n因为我们这里通过 axios 发送了请求，那么我们的 server 端要实现对应的路由接口，我们来修改 server.js，添加如下代码：\n\nconst router = express.Router()\n\nrouter.get('/simple/get', function(req, res) {\n  res.json({\n    msg: `hello world`\n  })\n})\n\napp.use(router)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 运行 demo\n\n接着我们在 package.json 中去新增一个 npm script：\n\n\"dev\": \"node examples/server.js\"\n\n\n1\n\n\n然后我们去控制台执行命令\n\nnpm run dev\n\n\n1\n\n\n相当于执行了 node examples/server.js，会开启我们的 server。\n\n接着我们打开 chrome 浏览器，访问 http://localhost:8080/ 即可访问我们的 demo 了，我们点到 Simple 目录下，通过开发者工具的 network 部分我们可以看到成功发送到了一条请求，并在 response 中看到了服务端返回的数据。\n\n至此，我们就实现了一个简单的请求发送，并编写了相关的 demo。但是现在存在一些问题：我们传入的 params 数据并没有用，也没有拼接到 url 上；我们对 request body 的数据格式、请求头 headers 也没有做处理；另外我们虽然从网络层面收到了响应的数据，但是我们代码层面也并没有对响应的数据做处理。那么下面一章，我们就来解决这些问题。",normalizedContent:"# 编写基础请求代码\n\n我们这节课开始编写 ts-axios 库，我们的目标是实现简单的发送请求功能，即客户端通过 xmlhttprequest 对象把请求发送到 server 端，server 端能收到请求并响应即可。\n\n我们实现 axios 最基本的操作，通过传入一个对象发送请求，如下：\n\naxios({\n  method: 'get',\n  url: '/simple/get',\n  params: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 创建入口文件\n\n我们删除 src 目录下的文件，先创建一个 index.ts 文件，作为整个库的入口文件，然后我们先定义一个 axios 方法，并把它导出，如下：\n\n\nfunction axios(config) {\n\n}\n\nexport default axios\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这里 typescript 编译器会检查到错误，分别是 config 的声明上有隐含的 any 报错，以及代码块为空。代码块为空我们比较好理解，第一个错误的原因是因为我们给 typescript 编译配置的 strict 设置为 true 导致。\n\n\n# 编译配置文件 tsconfig.json\n\ntsconfig.json 文件中指定了用来编译这个项目的根文件和编译选项，关于它的具体学习，我希望同学们去官网系统学习一下\n\n我们在之前讲 typescript 的基础时，会运行 tsc 命令去编译 typescript 文件，编译器会从当前目录开始去查找 tsconfig.json 文件，作为编译时的一些编译选项。\n\n我们来看一下 tsconfig.json 文件，它包含了很多编译时的配置，其中我们把 strict 设置为 true，它相当于启用所有严格类型的检查选项。启用 --strict 相当于启用 --noimplicitany,--noimplicitthis,--alwaysstrict，--strictnullchecks 和 --strictfunctiontypes 和 --strictpropertyinitialization。\n\n我们讲 typescript 的基础时提到了 --strictnullchecks，其它的编译配置我建议同学们都去查看它的官网文档，把它当做手册去查阅即可。\n\n\n# 定义 axiosrequestconfig 接口类型\n\n接下来，我们需要给 config 参数定义一种接口类型。我们创建一个 types 目录，在下面创建一个 index.ts 文件，作为我们项目中公用的类型定义文件。\n\n接下来我们来定义 axiosrequestconfig 接口类型：\n\nexport interface axiosrequestconfig {\n  url: string\n  method?: string\n  data?: any\n  params?: any\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n其中，url 为请求的地址，必选属性；而其余属性都是可选属性。method 是请求的 http 方法；data 是 post、patch 等类型请求的数据，放到 request body 中的；params 是 get、head 等类型请求的数据，拼接到 url 的 query string 中的。\n\n为了让 method 只能传入合法的字符串，我们定义一种字符串字面量类型 method：\n\nexport type method = 'get' | 'get'\n  | 'delete' | 'delete'\n  | 'head' | 'head'\n  | 'options' | 'options'\n  | 'post' | 'post'\n  | 'put' | 'put'\n  | 'patch' | 'patch'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n接着我们把 axiosrequestconfig 中的 method 属性类型改成这种字符串字面量类型：\n\nexport interface axiosrequestconfig {\n  url: string\n  method?: method\n  data?: any\n  params?: any\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n然后回到 index.ts，我们引入 axiosrequestconfig 类型，作为 config 的参数类型，如下：\n\nimport { axiosrequestconfig } from './types'\n\nfunction axios(config: axiosrequestconfig) {\n}\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n6\n\n\n那么接下来，我们就来实现这个函数体内部的逻辑——发送请求。\n\n\n# 利用 xmlhttprequest 发送请求\n\n我们并不想在 index.ts 中去实现发送请求的逻辑，我们利用模块化的编程思想，把这个功能拆分到一个单独的模块中。\n\n于是我们在 src 目录下创建一个 xhr.ts 文件，我们导出一个 xhr 方法，它接受一个 config 参数，类型也是 axiosrequestconfig 类型。\n\nimport { axiosrequestconfig } from './types'\n\nexport default function xhr(config: axiosrequestconfig) {\n}\n\n\n1\n2\n3\n4\n\n\n接下来，我们来实现这个函数体逻辑，如下：\n\nexport default function xhr(config: axiosrequestconfig): void {\n  const { data = null, url, method = 'get' } = config\n\n  const request = new xmlhttprequest()\n\n  request.open(method.touppercase(), url, true)\n\n  request.send(data)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n我们首先通过解构赋值的语法从 config 中拿到对应的属性值赋值给我的变量，并且还定义了一些默认值，因为在 axiosrequestconfig 接口的定义中，有些属性是可选的。\n\n接着我们实例化了一个 xmlhttprequest 对象，然后调用了它的 open 方法，传入了对应的一些参数，最后调用 send 方法发送请求。\n\n对于 xmlhttprequest 的学习，我希望同学们去 mdn 上系统地学习一下它的一些属性和方法，当做参考资料，因为在后续的开发中我们可能会反复查阅这些文档资料。\n\n\n# 引入 xhr 模块\n\n编写好了 xhr 模块，我们就需要在 index.ts 中去引入这个模块，如下：\n\nimport { axiosrequestconfig } from './types'\nimport xhr from './xhr'\n\nfunction axios(config: axiosrequestconfig): void {\n  xhr(config)\n}\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n那么至此，我们基本的发送请求代码就编写完毕了，接下来我们来写一个小 demo，来使用我们编写的 axios 库去发送请求。\n\n\n# demo 编写\n\n我们会利用 node.js 的 express 库去运行我们的 demo，利用 webpack 来作为 demo 的构建工具。\n\n\n# 依赖安装\n\n我们先来安装一些编写 demo 需要的依赖包，如下：\n\n\"webpack\": \"^4.28.4\",\n\"webpack-dev-middleware\": \"^3.5.0\",\n\"webpack-hot-middleware\": \"^2.24.3\",\n\"ts-loader\": \"^5.3.3\",\n\"tslint-loader\": \"^3.5.4\",\n\"express\": \"^4.16.4\",\n\"body-parser\": \"^1.18.3\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n其中，webpack 是打包构建工具，webpack-dev-middleware 和 webpack-hot-middleware 是 2 个 express 的 webpack 中间件，ts-loader 和 tslint-loader 是 webpack 需要的 typescript 相关 loader，express 是 node.js 的服务端框架，body-parser 是 express 的一个中间件，解析 body 数据用的。\n\n\n# 编写 webpack 配置文件\n\n在 examples 目录下创建 webpack 配置文件 webpack.config.js：\n\nconst fs = require('fs')\nconst path = require('path')\nconst webpack = require('webpack')\n\nmodule.exports = {\n  mode: 'development',\n\n  /**\n   * 我们会在 examples 目录下建多个子目录\n   * 我们会把不同章节的 demo 放到不同的子目录中\n   * 每个子目录的下会创建一个 app.ts\n   * app.ts 作为 webpack 构建的入口文件\n   * entries 收集了多目录个入口文件，并且每个入口还引入了一个用于热更新的文件\n   * entries 是一个对象，key 为目录名\n   */\n  entry: fs.readdirsync(__dirname).reduce((entries, dir) => {\n    const fulldir = path.join(__dirname, dir)\n    const entry = path.join(fulldir, 'app.ts')\n    if (fs.statsync(fulldir).isdirectory() && fs.existssync(entry)) {\n      entries[dir] = ['webpack-hot-middleware/client', entry]\n    }\n\n    return entries\n  }, {}),\n\n  /**\n   * 根据不同的目录名称，打包生成目标 js，名称和目录名一致\n   */\n  output: {\n    path: path.join(__dirname, '__build__'),\n    filename: '[name].js',\n    publicpath: '/__build__/'\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        enforce: 'pre',\n        use: [\n          {\n            loader: 'tslint-loader'\n          }\n        ]\n      },\n      {\n        test: /\\.tsx?$/,\n        use: [\n          {\n            loader: 'ts-loader',\n            options: {\n              transpileonly: true\n            }\n          }\n        ]\n      }\n    ]\n  },\n\n  resolve: {\n    extensions: ['.ts', '.tsx', '.js']\n  },\n\n  plugins: [\n    new webpack.hotmodulereplacementplugin(),\n    new webpack.noemitonerrorsplugin()\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# 编写 server 文件\n\n在 examples 目录下创建 server.js 文件：\n\nconst express = require('express')\nconst bodyparser = require('body-parser')\nconst webpack = require('webpack')\nconst webpackdevmiddleware = require('webpack-dev-middleware')\nconst webpackhotmiddleware = require('webpack-hot-middleware')\nconst webpackconfig = require('./webpack.config')\n\nconst app = express()\nconst compiler = webpack(webpackconfig)\n\napp.use(webpackdevmiddleware(compiler, {\n  publicpath: '/__build__/',\n  stats: {\n    colors: true,\n    chunks: false\n  }\n}))\n\napp.use(webpackhotmiddleware(compiler))\n\napp.use(express.static(__dirname))\n\napp.use(bodyparser.json())\napp.use(bodyparser.urlencoded({ extended: true }))\n\nconst port = process.env.port || 8080\nmodule.exports = app.listen(port, () => {\n  console.log(`server listening on http://localhost:${port}, ctrl+c to stop`)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 编写 demo 代码\n\n首先在 examples 目录下创建 index.html 和 global.css，作为所有 demo 的入口文件已全局样式文件。\n\nindex.html：\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>ts-axios examples</title>\n    <link rel=\"stylesheet\" href=\"/global.css\">\n  </head>\n  <body style=\"padding: 0 20px\">\n    <h1>ts-axios examples</h1>\n    <ul>\n      <li><a href=\"simple\">simple</a></li>\n    </ul>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nglobal.css：\n\nhtml, body {\n  font-family: -apple-system, blinkmacsystemfont, \"segoe ui\", roboto, helvetica, arial, sans-serif, \"apple color emoji\", \"segoe ui emoji\", \"segoe ui symbol\";\n  color: #2c3e50;\n}\n\nul {\n  line-height: 1.5em;\n  padding-left: 1.5em;\n}\n\na {\n  color: #7f8c8d;\n  text-decoration: none;\n}\n\na:hover {\n  color: #4fc08d;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n然后在 examples 目录下创建 simple 目录，作为本章节的 demo 目录，在该目录下再创建 index.html 和 app.ts 文件\n\nindex.html 文件如下:\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>simple example</title>\n  </head>\n  <body>\n    <script src=\"/__build__/simple.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\napp.ts 文件如下：\n\nimport axios from '../../src/index'\n\naxios({\n  method: 'get',\n  url: '/simple/get',\n  params: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n因为我们这里通过 axios 发送了请求，那么我们的 server 端要实现对应的路由接口，我们来修改 server.js，添加如下代码：\n\nconst router = express.router()\n\nrouter.get('/simple/get', function(req, res) {\n  res.json({\n    msg: `hello world`\n  })\n})\n\napp.use(router)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 运行 demo\n\n接着我们在 package.json 中去新增一个 npm script：\n\n\"dev\": \"node examples/server.js\"\n\n\n1\n\n\n然后我们去控制台执行命令\n\nnpm run dev\n\n\n1\n\n\n相当于执行了 node examples/server.js，会开启我们的 server。\n\n接着我们打开 chrome 浏览器，访问 http://localhost:8080/ 即可访问我们的 demo 了，我们点到 simple 目录下，通过开发者工具的 network 部分我们可以看到成功发送到了一条请求，并在 response 中看到了服务端返回的数据。\n\n至此，我们就实现了一个简单的请求发送，并编写了相关的 demo。但是现在存在一些问题：我们传入的 params 数据并没有用，也没有拼接到 url 上；我们对 request body 的数据格式、请求头 headers 也没有做处理；另外我们虽然从网络层面收到了响应的数据，但是我们代码层面也并没有对响应的数据做处理。那么下面一章，我们就来解决这些问题。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"处理请求 url 参数",frontmatter:{title:"处理请求 url 参数",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/1313dae575f6dddf",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 基础功能实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/04.ts-axios%20%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/01.%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%20url%20%E5%8F%82%E6%95%B0.html",relativePath:"《TypeScript 从零实现 axios》/04.ts-axios 基础功能实现/01.处理请求 url 参数.md",key:"v-19bb367d",path:"/pages/1313dae575f6dddf/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:18},{level:3,title:"参数值为数组",slug:"参数值为数组",normalizedTitle:"参数值为数组",charIndex:278},{level:3,title:"参数值为对象",slug:"参数值为对象",normalizedTitle:"参数值为对象",charIndex:440},{level:3,title:"参数值为 Date 类型",slug:"参数值为-date-类型",normalizedTitle:"参数值为 date 类型",charIndex:662},{level:3,title:"特殊字符支持",slug:"特殊字符支持",normalizedTitle:"特殊字符支持",charIndex:888},{level:3,title:"空值忽略",slug:"空值忽略",normalizedTitle:"空值忽略",charIndex:1095},{level:3,title:"丢弃 url 中的哈希标记",slug:"丢弃-url-中的哈希标记",normalizedTitle:"丢弃 url 中的哈希标记",charIndex:1297},{level:3,title:"保留 url 中已存在的参数",slug:"保留-url-中已存在的参数",normalizedTitle:"保留 url 中已存在的参数",charIndex:1448},{level:2,title:"buildURL 函数实现",slug:"buildurl-函数实现",normalizedTitle:"buildurl 函数实现",charIndex:1611},{level:2,title:"实现 url 参数处理逻辑",slug:"实现-url-参数处理逻辑",normalizedTitle:"实现 url 参数处理逻辑",charIndex:3424},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:4074}],headersStr:"需求分析 参数值为数组 参数值为对象 参数值为 Date 类型 特殊字符支持 空值忽略 丢弃 url 中的哈希标记 保留 url 中已存在的参数 buildURL 函数实现 实现 url 参数处理逻辑 demo 编写",content:"# 处理请求 url 参数\n\n\n# 需求分析\n\n还记得我们上节课遗留了一个问题，再来看这个例子：\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们希望最终请求的 url 是 /base/get?a=1&b=2，这样服务端就可以通过请求的 url 解析到我们传来的参数数据了。实际上就是把 params 对象的 key 和 value 拼接到 url 上。\n\n再来看几个更复杂的例子。\n\n\n# 参数值为数组\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: ['bar', 'baz']\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n最终请求的 url 是 /base/get?foo[]=bar&foo[]=baz'。\n\n\n# 参数值为对象\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: {\n      bar: 'baz'\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n最终请求的 url 是 /base/get?foo=%7B%22bar%22:%22baz%22%7D，foo 后面拼接的是 {\"bar\":\"baz\"} encode 后的结果。\n\n\n# 参数值为 Date 类型\n\nconst date = new Date()\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    date\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n最终请求的 url 是 /base/get?date=2019-04-01T05:55:39.030Z，date 后面拼接的是 date.toISOString() 的结果。\n\n\n# 特殊字符支持\n\n对于字符 @、:、$、,、、[、]，我们是允许出现在 url 中的，不希望被 encode。\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: '@:$, '\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n最终请求的 url 是 /base/get?foo=@:$+，注意，我们会把空格 转换成 +。\n\n\n# 空值忽略\n\n对于值为 null 或者 undefined 的属性，我们是不会添加到 url 参数中的。\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: 'bar',\n    baz: null\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n最终请求的 url 是 /base/get?foo=bar。\n\n\n# 丢弃 url 中的哈希标记\n\naxios({\n  method: 'get',\n  url: '/base/get#hash',\n  params: {\n    foo: 'bar'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n最终请求的 url 是 /base/get?foo=bar\n\n\n# 保留 url 中已存在的参数\n\naxios({\n  method: 'get',\n  url: '/base/get?foo=bar',\n  params: {\n    bar: 'baz'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n最终请求的 url 是 /base/get?foo=bar&bar=baz\n\n\n# buildURL 函数实现\n\n根据我们之前的需求分析，我们要实现一个工具函数，把 params 拼接到 url 上。我们希望把项目中的一些工具函数、辅助方法独立管理，于是我们创建一个 helpers 目录，在这个目录下创建 url.ts 文件，未来会把处理 url 相关的工具函数都放在该文件中。\n\nhelpers/url.ts：\n\nimport { isDate, isObject } from './util'\n\nfunction encode (val: string): string {\n  return encodeURIComponent(val)\n    .replace(/%40/g, '@')\n    .replace(/%3A/gi, ':')\n    .replace(/%24/g, '$')\n    .replace(/%2C/gi, ',')\n    .replace(/%20/g, '+')\n    .replace(/%5B/gi, '[')\n    .replace(/%5D/gi, ']')\n}\n\nexport function bulidURL (url: string, params?: any) {\n  if (!params) {\n    return url\n  }\n\n  const parts: string[] = []\n\n  Object.keys(params).forEach((key) => {\n    let val = params[key]\n    if (val === null || typeof val === 'undefined') {\n      return\n    }\n    let values: string[]\n    if (Array.isArray(val)) {\n      values = val\n      key += '[]'\n    } else {\n      values = [val]\n    }\n    values.forEach((val) => {\n      if (isDate(val)) {\n        val = val.toISOString()\n      } else if (isObject(val)) {\n        val = JSON.stringify(val)\n      }\n      parts.push(`${encode(key)}=${encode(val)}`)\n    })\n  })\n\n  let serializedParams = parts.join('&')\n\n  if (serializedParams) {\n    const markIndex = url.indexOf('#')\n    if (markIndex !== -1) {\n      url = url.slice(0, markIndex)\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams\n  }\n\n  return url\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\nhelpers/util.ts：\n\nconst toString = Object.prototype.toString\n\nexport function isDate (val: any): val is Date {\n  return toString.call(val) === '[object Date]'\n}\n\nexport function isObject (val: any): val is Object {\n  return val !== null && typeof val === 'object'\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 实现 url 参数处理逻辑\n\n我们已经实现了 buildURL 函数，接下来我们来利用它实现 url 参数的处理逻辑。\n\n在 index.ts 文件中添加如下代码：\n\nfunction axios (config: AxiosRequestConfig): void {\n  processConfig(config)\n  xhr(config)\n}\n\nfunction processConfig (config: AxiosRequestConfig): void {\n  config.url = transformUrl(config)\n}\n\nfunction transformUrl (config: AxiosRequestConfig): string {\n  const { url, params } = config\n  return bulidURL(url, params)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在执行 xhr 函数前，我们先执行 processConfig 方法，对 config 中的数据做处理，除了对 url 和 params 处理之外，未来还会处理其它属性。\n\n在 processConfig 函数内部，我们通过执行 transformUrl 函数修改了 config.url，该函数内部调用了 buildURL。\n\n那么至此，我们对 url 参数处理逻辑就实现完了，接下来我们就开始编写 demo 了。\n\n\n# demo 编写\n\n在 examples 目录下创建 base 目录，在 base 目录下创建 index.html:\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Base example</title>\n  </head>\n  <body>\n    <script src=\"/__build__/base.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n接着创建 app.ts 作为入口文件：\n\nimport axios from '../../src/index'\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: ['bar', 'baz']\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: {\n      bar: 'baz'\n    }\n  }\n})\n\nconst date = new Date()\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    date\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: '@:$, '\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: 'bar',\n    baz: null\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get#hash',\n  params: {\n    foo: 'bar'\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get?foo=bar',\n  params: {\n    bar: 'baz'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n接着在 server.js 添加新的接口路由：\n\nrouter.get('/base/get', function(req, res) {\n  res.json(req.query)\n})\n\n\n1\n2\n3\n\n\n然后在命令行运行 npm run dev，接着打开 chrome 浏览器，访问 http://localhost:8080/ 即可访问我们的 demo 了，我们点到 Base 目录下，通过开发者工具的 network 部分我们可以看到成功发送的多条请求，并可以观察它们最终请求的 url，已经如期添加了请求参数。\n\n那么至此我们的请求 url 参数处理编写完了，下一小节我们会对 request body 数据做处理。",normalizedContent:"# 处理请求 url 参数\n\n\n# 需求分析\n\n还记得我们上节课遗留了一个问题，再来看这个例子：\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们希望最终请求的 url 是 /base/get?a=1&b=2，这样服务端就可以通过请求的 url 解析到我们传来的参数数据了。实际上就是把 params 对象的 key 和 value 拼接到 url 上。\n\n再来看几个更复杂的例子。\n\n\n# 参数值为数组\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: ['bar', 'baz']\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n最终请求的 url 是 /base/get?foo[]=bar&foo[]=baz'。\n\n\n# 参数值为对象\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: {\n      bar: 'baz'\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n最终请求的 url 是 /base/get?foo=%7b%22bar%22:%22baz%22%7d，foo 后面拼接的是 {\"bar\":\"baz\"} encode 后的结果。\n\n\n# 参数值为 date 类型\n\nconst date = new date()\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    date\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n最终请求的 url 是 /base/get?date=2019-04-01t05:55:39.030z，date 后面拼接的是 date.toisostring() 的结果。\n\n\n# 特殊字符支持\n\n对于字符 @、:、$、,、、[、]，我们是允许出现在 url 中的，不希望被 encode。\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: '@:$, '\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n最终请求的 url 是 /base/get?foo=@:$+，注意，我们会把空格 转换成 +。\n\n\n# 空值忽略\n\n对于值为 null 或者 undefined 的属性，我们是不会添加到 url 参数中的。\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: 'bar',\n    baz: null\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n最终请求的 url 是 /base/get?foo=bar。\n\n\n# 丢弃 url 中的哈希标记\n\naxios({\n  method: 'get',\n  url: '/base/get#hash',\n  params: {\n    foo: 'bar'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n最终请求的 url 是 /base/get?foo=bar\n\n\n# 保留 url 中已存在的参数\n\naxios({\n  method: 'get',\n  url: '/base/get?foo=bar',\n  params: {\n    bar: 'baz'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n最终请求的 url 是 /base/get?foo=bar&bar=baz\n\n\n# buildurl 函数实现\n\n根据我们之前的需求分析，我们要实现一个工具函数，把 params 拼接到 url 上。我们希望把项目中的一些工具函数、辅助方法独立管理，于是我们创建一个 helpers 目录，在这个目录下创建 url.ts 文件，未来会把处理 url 相关的工具函数都放在该文件中。\n\nhelpers/url.ts：\n\nimport { isdate, isobject } from './util'\n\nfunction encode (val: string): string {\n  return encodeuricomponent(val)\n    .replace(/%40/g, '@')\n    .replace(/%3a/gi, ':')\n    .replace(/%24/g, '$')\n    .replace(/%2c/gi, ',')\n    .replace(/%20/g, '+')\n    .replace(/%5b/gi, '[')\n    .replace(/%5d/gi, ']')\n}\n\nexport function bulidurl (url: string, params?: any) {\n  if (!params) {\n    return url\n  }\n\n  const parts: string[] = []\n\n  object.keys(params).foreach((key) => {\n    let val = params[key]\n    if (val === null || typeof val === 'undefined') {\n      return\n    }\n    let values: string[]\n    if (array.isarray(val)) {\n      values = val\n      key += '[]'\n    } else {\n      values = [val]\n    }\n    values.foreach((val) => {\n      if (isdate(val)) {\n        val = val.toisostring()\n      } else if (isobject(val)) {\n        val = json.stringify(val)\n      }\n      parts.push(`${encode(key)}=${encode(val)}`)\n    })\n  })\n\n  let serializedparams = parts.join('&')\n\n  if (serializedparams) {\n    const markindex = url.indexof('#')\n    if (markindex !== -1) {\n      url = url.slice(0, markindex)\n    }\n\n    url += (url.indexof('?') === -1 ? '?' : '&') + serializedparams\n  }\n\n  return url\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\nhelpers/util.ts：\n\nconst tostring = object.prototype.tostring\n\nexport function isdate (val: any): val is date {\n  return tostring.call(val) === '[object date]'\n}\n\nexport function isobject (val: any): val is object {\n  return val !== null && typeof val === 'object'\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 实现 url 参数处理逻辑\n\n我们已经实现了 buildurl 函数，接下来我们来利用它实现 url 参数的处理逻辑。\n\n在 index.ts 文件中添加如下代码：\n\nfunction axios (config: axiosrequestconfig): void {\n  processconfig(config)\n  xhr(config)\n}\n\nfunction processconfig (config: axiosrequestconfig): void {\n  config.url = transformurl(config)\n}\n\nfunction transformurl (config: axiosrequestconfig): string {\n  const { url, params } = config\n  return bulidurl(url, params)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在执行 xhr 函数前，我们先执行 processconfig 方法，对 config 中的数据做处理，除了对 url 和 params 处理之外，未来还会处理其它属性。\n\n在 processconfig 函数内部，我们通过执行 transformurl 函数修改了 config.url，该函数内部调用了 buildurl。\n\n那么至此，我们对 url 参数处理逻辑就实现完了，接下来我们就开始编写 demo 了。\n\n\n# demo 编写\n\n在 examples 目录下创建 base 目录，在 base 目录下创建 index.html:\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>base example</title>\n  </head>\n  <body>\n    <script src=\"/__build__/base.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n接着创建 app.ts 作为入口文件：\n\nimport axios from '../../src/index'\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: ['bar', 'baz']\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: {\n      bar: 'baz'\n    }\n  }\n})\n\nconst date = new date()\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    date\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: '@:$, '\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get',\n  params: {\n    foo: 'bar',\n    baz: null\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get#hash',\n  params: {\n    foo: 'bar'\n  }\n})\n\naxios({\n  method: 'get',\n  url: '/base/get?foo=bar',\n  params: {\n    bar: 'baz'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n接着在 server.js 添加新的接口路由：\n\nrouter.get('/base/get', function(req, res) {\n  res.json(req.query)\n})\n\n\n1\n2\n3\n\n\n然后在命令行运行 npm run dev，接着打开 chrome 浏览器，访问 http://localhost:8080/ 即可访问我们的 demo 了，我们点到 base 目录下，通过开发者工具的 network 部分我们可以看到成功发送的多条请求，并可以观察它们最终请求的 url，已经如期添加了请求参数。\n\n那么至此我们的请求 url 参数处理编写完了，下一小节我们会对 request body 数据做处理。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"处理请求 body 数据",frontmatter:{title:"处理请求 body 数据",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/887cd0918e2543d8",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 基础功能实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/04.ts-axios%20%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/02.%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%20body%20%E6%95%B0%E6%8D%AE.html",relativePath:"《TypeScript 从零实现 axios》/04.ts-axios 基础功能实现/02.处理请求 body 数据.md",key:"v-7ea8d084",path:"/pages/887cd0918e2543d8/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:19},{level:2,title:"transformRequest 函数实现",slug:"transformrequest-函数实现",normalizedTitle:"transformrequest 函数实现",charIndex:445},{level:2,title:"实现请求 body 处理逻辑",slug:"实现请求-body-处理逻辑",normalizedTitle:"实现请求 body 处理逻辑",charIndex:1429},{level:2,title:"编写 demo",slug:"编写-demo",normalizedTitle:"编写 demo",charIndex:1949}],headersStr:"需求分析 transformRequest 函数实现 实现请求 body 处理逻辑 编写 demo",content:"# 处理请求 body 数据\n\n\n# 需求分析\n\n我们通过执行 XMLHttpRequest 对象实例的 send 方法来发送请求，并通过该方法的参数设置请求 body 数据，我们可以去 mdn 查阅该方法支持的参数类型。\n\n我们发现 send 方法的参数支持 Document 和 BodyInit 类型，BodyInit 包括了 Blob, BufferSource, FormData, URLSearchParams, ReadableStream、USVString，当没有数据的时候，我们还可以传入 null。\n\n但是我们最常用的场景还是传一个普通对象给服务端，例如：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这个时候 data是不能直接传给 send 函数的，我们需要把它转换成 JSON 字符串。\n\n\n# transformRequest 函数实现\n\n根据需求分析，我们要实现一个工具函数，对 request 中的 data 做一层转换。我们在 helpers 目录新建 data.ts 文件。\n\nhelpers/data.ts：\n\nimport { isPlainObject } from './util'\n\nexport function transformRequest (data: any): any {\n  if (isPlainObject(data)) {\n    return JSON.stringify(data)\n  }\n  return data\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nhelpers/util.js：\n\nexport function isPlainObject (val: any): val is Object {\n  return toString.call(val) === '[object Object]'\n}\n\n\n1\n2\n3\n\n\n这里为什么要使用 isPlainObject 函数判断，而不用之前的 isObject 函数呢，因为 isObject 的判断方式，对于 FormData、ArrayBuffer 这些类型，isObject 判断也为 true，但是这些类型的数据我们是不需要做处理的，而 isPlainObject 的判断方式，只有我们定义的普通 JSON 对象才能满足。\n\nhelpers/url.ts：\n\nif (isDate(val)) {\n  val = val.toISOString()\n} else if (isPlainObject(val)) {\n  val = JSON.stringify(val)\n}\n\n\n1\n2\n3\n4\n5\n\n\n对于上节课我们对请求参数值的判断，我们也应该用 isPlainObject 才更加合理。\n\nhelpers/util.js\n\n// export function isObject (val: any): val is Object {\n//   return val !== null && typeof val === 'object'\n// }\n\n\n1\n2\n3\n\n\n既然现在 isObject 方法不再使用，我们先将其注释。\n\n\n# 实现请求 body 处理逻辑\n\nindex.ts：\n\nimport { transformRequest } from './helpers/data'\n\n```typescript\nfunction processConfig (config: AxiosRequestConfig): void {\n  config.url = transformURL(config)\n  config.data = transformRequestData(config)\n}\n\nfunction transformRequestData (config: AxiosRequestConfig): any {\n  return transformRequest(config.data)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n我们定义了 transformRequestData 函数，去转换请求 body 的数据，内部调用了我们刚刚实现的的 transformRequest 方法。\n\n然后我们在 processConfig 内部添加了这段逻辑，在处理完 url 后接着对 config 中的 data 做处理。\n\n\n# 编写 demo\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\nconst arr = new Int32Array([21, 31])\n\naxios({\n  method: 'post',\n  url: '/base/buffer',\n  data: arr\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n我们在 examples/base/app.ts 添加 2 段代码，第一个 post 请求的 data 是一个普通对象，第二个请求的 data 是一个 Int32Array 类型的数据，它是可以直接传给 XMLHttpRequest 对象的 send 方法的。\n\nrouter.post('/base/post', function(req, res) {\n  res.json(req.body)\n})\n\nrouter.post('/base/buffer', function(req, res) {\n  let msg = []\n  req.on('data', (chunk) => {\n    if (chunk) {\n      msg.push(chunk)\n    }\n  })\n  req.on('end', () => {\n    let buf = Buffer.concat(msg)\n    res.json(buf.toJSON())\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n我们接着在 examples/server.js 中添加 2 个路由，分别针对这俩种请求，返回请求传入的数据。\n\n然后我们打开浏览器运行 demo，看一下结果，我们发现 /base/buffer 的请求是可以拿到数据，但是 base/post 请求的 response 里却返回的是一个空对象，这是什么原因呢？\n\n实际上是因为我们虽然执行 send 方法的时候把普通对象 data 转换成一个 JSON 字符串，但是我们请求header 的 Content-Type 是 text/plain;charset=UTF-8，导致了服务端接受到请求并不能正确解析请求 body 的数据。\n\n知道这个问题后，下面一节课我们来实现对请求 header 的处理。",normalizedContent:"# 处理请求 body 数据\n\n\n# 需求分析\n\n我们通过执行 xmlhttprequest 对象实例的 send 方法来发送请求，并通过该方法的参数设置请求 body 数据，我们可以去 mdn 查阅该方法支持的参数类型。\n\n我们发现 send 方法的参数支持 document 和 bodyinit 类型，bodyinit 包括了 blob, buffersource, formdata, urlsearchparams, readablestream、usvstring，当没有数据的时候，我们还可以传入 null。\n\n但是我们最常用的场景还是传一个普通对象给服务端，例如：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这个时候 data是不能直接传给 send 函数的，我们需要把它转换成 json 字符串。\n\n\n# transformrequest 函数实现\n\n根据需求分析，我们要实现一个工具函数，对 request 中的 data 做一层转换。我们在 helpers 目录新建 data.ts 文件。\n\nhelpers/data.ts：\n\nimport { isplainobject } from './util'\n\nexport function transformrequest (data: any): any {\n  if (isplainobject(data)) {\n    return json.stringify(data)\n  }\n  return data\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nhelpers/util.js：\n\nexport function isplainobject (val: any): val is object {\n  return tostring.call(val) === '[object object]'\n}\n\n\n1\n2\n3\n\n\n这里为什么要使用 isplainobject 函数判断，而不用之前的 isobject 函数呢，因为 isobject 的判断方式，对于 formdata、arraybuffer 这些类型，isobject 判断也为 true，但是这些类型的数据我们是不需要做处理的，而 isplainobject 的判断方式，只有我们定义的普通 json 对象才能满足。\n\nhelpers/url.ts：\n\nif (isdate(val)) {\n  val = val.toisostring()\n} else if (isplainobject(val)) {\n  val = json.stringify(val)\n}\n\n\n1\n2\n3\n4\n5\n\n\n对于上节课我们对请求参数值的判断，我们也应该用 isplainobject 才更加合理。\n\nhelpers/util.js\n\n// export function isobject (val: any): val is object {\n//   return val !== null && typeof val === 'object'\n// }\n\n\n1\n2\n3\n\n\n既然现在 isobject 方法不再使用，我们先将其注释。\n\n\n# 实现请求 body 处理逻辑\n\nindex.ts：\n\nimport { transformrequest } from './helpers/data'\n\n```typescript\nfunction processconfig (config: axiosrequestconfig): void {\n  config.url = transformurl(config)\n  config.data = transformrequestdata(config)\n}\n\nfunction transformrequestdata (config: axiosrequestconfig): any {\n  return transformrequest(config.data)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n我们定义了 transformrequestdata 函数，去转换请求 body 的数据，内部调用了我们刚刚实现的的 transformrequest 方法。\n\n然后我们在 processconfig 内部添加了这段逻辑，在处理完 url 后接着对 config 中的 data 做处理。\n\n\n# 编写 demo\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\nconst arr = new int32array([21, 31])\n\naxios({\n  method: 'post',\n  url: '/base/buffer',\n  data: arr\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n我们在 examples/base/app.ts 添加 2 段代码，第一个 post 请求的 data 是一个普通对象，第二个请求的 data 是一个 int32array 类型的数据，它是可以直接传给 xmlhttprequest 对象的 send 方法的。\n\nrouter.post('/base/post', function(req, res) {\n  res.json(req.body)\n})\n\nrouter.post('/base/buffer', function(req, res) {\n  let msg = []\n  req.on('data', (chunk) => {\n    if (chunk) {\n      msg.push(chunk)\n    }\n  })\n  req.on('end', () => {\n    let buf = buffer.concat(msg)\n    res.json(buf.tojson())\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n我们接着在 examples/server.js 中添加 2 个路由，分别针对这俩种请求，返回请求传入的数据。\n\n然后我们打开浏览器运行 demo，看一下结果，我们发现 /base/buffer 的请求是可以拿到数据，但是 base/post 请求的 response 里却返回的是一个空对象，这是什么原因呢？\n\n实际上是因为我们虽然执行 send 方法的时候把普通对象 data 转换成一个 json 字符串，但是我们请求header 的 content-type 是 text/plain;charset=utf-8，导致了服务端接受到请求并不能正确解析请求 body 的数据。\n\n知道这个问题后，下面一节课我们来实现对请求 header 的处理。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"处理请求 header",frontmatter:{title:"处理请求 header",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/35c0ec1bb0b0faaf",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 基础功能实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/04.ts-axios%20%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/03.%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%20header.html",relativePath:"《TypeScript 从零实现 axios》/04.ts-axios 基础功能实现/03.处理请求 header.md",key:"v-07547a19",path:"/pages/35c0ec1bb0b0faaf/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:18},{level:2,title:"processHeaders 函数实现",slug:"processheaders-函数实现",normalizedTitle:"processheaders 函数实现",charIndex:594},{level:2,title:"实现请求 header 处理逻辑",slug:"实现请求-header-处理逻辑",normalizedTitle:"实现请求 header 处理逻辑",charIndex:1538},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:2772}],headersStr:"需求分析 processHeaders 函数实现 实现请求 header 处理逻辑 demo 编写",content:"# 处理请求 header\n\n\n# 需求分析\n\n我们上节课遗留了一个问题：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们做了请求数据的处理，把 data 转换成了 JSON 字符串，但是数据发送到服务端的时候，服务端并不能正常解析我们发送的数据，因为我们并没有给请求 header 设置正确的 Content-Type。\n\n所以首先我们要支持发送请求的时候，可以支持配置 headers 属性，如下：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  headers: {\n    'content-type': 'application/json;charset=utf-8'\n  },\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n并且在当我们传入的 data 为普通对象的时候，headers 如果没有配置 Content-Type 属性，需要自动设置请求 header 的 Content-Type 字段为：application/json;charset=utf-8。\n\n\n# processHeaders 函数实现\n\n根据需求分析，我们要实现一个工具函数，对 request 中的 headers 做一层加工。我们在 helpers 目录新建 headers.ts 文件。\n\nhelpers/headers.ts：\n\nimport { isPlainObject } from './util'\n\nfunction normalizeHeaderName (headers: any, normalizedName: string): void {\n  if (!headers) {\n    return\n  }\n  Object.keys(headers).forEach(name => {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = headers[name]\n      delete headers[name]\n    }\n  })\n}\n\nexport function processHeaders (headers: any, data: any): any {\n  normalizeHeaderName(headers, 'Content-Type')\n\n  if (isPlainObject(data)) {\n    if (headers && !headers['Content-Type']) {\n      headers['Content-Type'] = 'application/json;charset=utf-8'\n    }\n  }\n  return headers\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n这里有个需要注意的点，因为请求 header 属性是大小写不敏感的，比如我们之前的例子传入 header 的属性名 content-type 就是全小写的，所以我们先要把一些 header 属性名规范化。\n\n\n# 实现请求 header 处理逻辑\n\n在这之前，我们先修改一下 AxiosRequestConfig 接口类型的定义，添加 headers 这个可选属性：\n\ntypes/index.ts\n\nexport interface AxiosRequestConfig {\n  url: string\n  method?: Method\n  data?: any\n  params?: any\n  headers?: any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nindex.ts：\n\nfunction processConfig (config: AxiosRequestConfig): void {\n  config.url = transformURL(config)\n  config.headers = transformHeaders(config)\n  config.data = transformRequestData(config)\n}\n\nfunction transformHeaders (config: AxiosRequestConfig) {\n  const { headers = {}, data } = config\n  return processHeaders(headers, data)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n因为我们处理 header 的时候依赖了 data，所以要在处理请求 body 数据之前处理请求 header。\n\nxhr.ts：\n\nexport default function xhr (config: AxiosRequestConfig): void {\n  const { data = null, url, method = 'get', headers } = config\n\n  const request = new XMLHttpRequest()\n\n  request.open(method.toUpperCase(), url, true)\n\n  Object.keys(headers).forEach((name) => {\n    if (data === null && name.toLowerCase() === 'content-type') {\n      delete headers[name]\n    } else {\n      request.setRequestHeader(name, headers[name])\n    }\n  })\n\n  request.send(data)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这里要额外判断一个逻辑，当我们传入的 data 为空的时候，请求 header 配置 Content-Type 是没有意义的，于是我们把它删除。\n\n\n# demo 编写\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  headers: {\n    'content-type': 'application/json;'\n  },\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\nconst paramsString = 'q=URLUtils.searchParams&topic=api'\nconst searchParams = new URLSearchParams(paramsString)\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: searchParams\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n通过 demo 我们可以看到，当我们请求的数据是普通对象并且没有配置 headers 的时候，会自动为其添加 Content-Type:application/json;charset=utf-8；同时我们发现当 data 是某些类型如 URLSearchParams 的时候，浏览器会自动为请求 header加上合适的 Content-Type。\n\n至此我们对于请求的处理逻辑暂时告一段落。目前我们的请求从网络层面是可以收到服务端的响应的，下一节课我们就从代码层面来处理服务端响应，并且让调用方可以拿到从服务端返回的数据。",normalizedContent:"# 处理请求 header\n\n\n# 需求分析\n\n我们上节课遗留了一个问题：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们做了请求数据的处理，把 data 转换成了 json 字符串，但是数据发送到服务端的时候，服务端并不能正常解析我们发送的数据，因为我们并没有给请求 header 设置正确的 content-type。\n\n所以首先我们要支持发送请求的时候，可以支持配置 headers 属性，如下：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  headers: {\n    'content-type': 'application/json;charset=utf-8'\n  },\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n并且在当我们传入的 data 为普通对象的时候，headers 如果没有配置 content-type 属性，需要自动设置请求 header 的 content-type 字段为：application/json;charset=utf-8。\n\n\n# processheaders 函数实现\n\n根据需求分析，我们要实现一个工具函数，对 request 中的 headers 做一层加工。我们在 helpers 目录新建 headers.ts 文件。\n\nhelpers/headers.ts：\n\nimport { isplainobject } from './util'\n\nfunction normalizeheadername (headers: any, normalizedname: string): void {\n  if (!headers) {\n    return\n  }\n  object.keys(headers).foreach(name => {\n    if (name !== normalizedname && name.touppercase() === normalizedname.touppercase()) {\n      headers[normalizedname] = headers[name]\n      delete headers[name]\n    }\n  })\n}\n\nexport function processheaders (headers: any, data: any): any {\n  normalizeheadername(headers, 'content-type')\n\n  if (isplainobject(data)) {\n    if (headers && !headers['content-type']) {\n      headers['content-type'] = 'application/json;charset=utf-8'\n    }\n  }\n  return headers\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n这里有个需要注意的点，因为请求 header 属性是大小写不敏感的，比如我们之前的例子传入 header 的属性名 content-type 就是全小写的，所以我们先要把一些 header 属性名规范化。\n\n\n# 实现请求 header 处理逻辑\n\n在这之前，我们先修改一下 axiosrequestconfig 接口类型的定义，添加 headers 这个可选属性：\n\ntypes/index.ts\n\nexport interface axiosrequestconfig {\n  url: string\n  method?: method\n  data?: any\n  params?: any\n  headers?: any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nindex.ts：\n\nfunction processconfig (config: axiosrequestconfig): void {\n  config.url = transformurl(config)\n  config.headers = transformheaders(config)\n  config.data = transformrequestdata(config)\n}\n\nfunction transformheaders (config: axiosrequestconfig) {\n  const { headers = {}, data } = config\n  return processheaders(headers, data)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n因为我们处理 header 的时候依赖了 data，所以要在处理请求 body 数据之前处理请求 header。\n\nxhr.ts：\n\nexport default function xhr (config: axiosrequestconfig): void {\n  const { data = null, url, method = 'get', headers } = config\n\n  const request = new xmlhttprequest()\n\n  request.open(method.touppercase(), url, true)\n\n  object.keys(headers).foreach((name) => {\n    if (data === null && name.tolowercase() === 'content-type') {\n      delete headers[name]\n    } else {\n      request.setrequestheader(name, headers[name])\n    }\n  })\n\n  request.send(data)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这里要额外判断一个逻辑，当我们传入的 data 为空的时候，请求 header 配置 content-type 是没有意义的，于是我们把它删除。\n\n\n# demo 编写\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  headers: {\n    'content-type': 'application/json;'\n  },\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\nconst paramsstring = 'q=urlutils.searchparams&topic=api'\nconst searchparams = new urlsearchparams(paramsstring)\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: searchparams\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n通过 demo 我们可以看到，当我们请求的数据是普通对象并且没有配置 headers 的时候，会自动为其添加 content-type:application/json;charset=utf-8；同时我们发现当 data 是某些类型如 urlsearchparams 的时候，浏览器会自动为请求 header加上合适的 content-type。\n\n至此我们对于请求的处理逻辑暂时告一段落。目前我们的请求从网络层面是可以收到服务端的响应的，下一节课我们就从代码层面来处理服务端响应，并且让调用方可以拿到从服务端返回的数据。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"获取响应数据",frontmatter:{title:"获取响应数据",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/a57debe141e1e4f4",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 基础功能实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/04.ts-axios%20%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/04.%E8%8E%B7%E5%8F%96%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE.html",relativePath:"《TypeScript 从零实现 axios》/04.ts-axios 基础功能实现/04.获取响应数据.md",key:"v-10e417f0",path:"/pages/a57debe141e1e4f4/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:13},{level:2,title:"定义接口类型",slug:"定义接口类型",normalizedTitle:"定义接口类型",charIndex:399},{level:2,title:"实现获取响应数据逻辑",slug:"实现获取响应数据逻辑",normalizedTitle:"实现获取响应数据逻辑",charIndex:1203},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:2908}],headersStr:"需求分析 定义接口类型 实现获取响应数据逻辑 demo 编写",content:"# 获取响应数据\n\n\n# 需求分析\n\n在前面的章节中，我们发送的请求都可以从网络层面接收到服务端返回的数据，但是代码层面并没有做任何关于返回数据的处理。我们希望能处理服务端响应的数据，并支持 Promise 链式调用的方式，如下：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n}).then((res) => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们可以拿到 res 对象，并且我们希望该对象包括：服务端返回的数据 data，HTTP 状态码status，状态消息 statusText，响应头 headers、请求配置对象 config 以及请求的 XMLHttpRequest 对象实例 request。\n\n\n# 定义接口类型\n\n根据需求，我们可以定义一个 AxiosResponse 接口类型，如下：\n\nexport interface AxiosResponse {\n  data: any\n  status: number\n  statusText: string\n  headers: any\n  config: AxiosRequestConfig\n  request: any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n另外，axios 函数返回的是一个 Promise 对象，我们可以定义一个 AxiosPromise 接口，它继承于 Promise<AxiosResponse> 这个泛型接口：\n\nexport interface AxiosPromise extends Promise<AxiosResponse> {\n}\n\n\n1\n2\n\n\n这样的话，当 axios 返回的是 AxiosPromise 类型，那么 resolve 函数中的参数就是一个 AxiosResponse 类型。\n\n对于一个 AJAX 请求的 response，我们是可以指定它的响应的数据类型的，通过设置 XMLHttpRequest 对象的 responseType 属性，于是我们可以给 AxiosRequestConfig 类型添加一个可选属性：\n\nexport interface AxiosRequestConfig {\n  // ...\n  responseType?: XMLHttpRequestResponseType\n}\n\n\n1\n2\n3\n4\n\n\nresponseType 的类型是一个 XMLHttpRequestResponseType 类型，它的定义是 \"\" | \"arraybuffer\" | \"blob\" | \"document\" | \"json\" | \"text\" 字符串字面量类型。\n\n\n# 实现获取响应数据逻辑\n\n首先我们要在 xhr 函数添加 onreadystatechange 事件处理函数，并且让 xhr 函数返回的是 AxiosPromise 类型。\n\nxhr.ts：\n\nexport default function xhr(config: AxiosRequestConfig): AxiosPromise {\n  return new Promise((resolve) => {\n    const { data = null, url, method = 'get', headers, responseType } = config\n\n    const request = new XMLHttpRequest()\n\n    if (responseType) {\n      request.responseType = responseType\n    }\n\n    request.open(method.toUpperCase(), url, true)\n\n    request.onreadystatechange = function handleLoad() {\n      if (request.readyState !== 4) {\n        return\n      }\n\n      const responseHeaders = request.getAllResponseHeaders()\n      const responseData = responseType && responseType !== 'text' ? request.response : request.responseText\n      const response: AxiosResponse = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      }\n      resolve(response)\n    }\n\n    Object.keys(headers).forEach((name) => {\n      if (data === null && name.toLowerCase() === 'content-type') {\n        delete headers[name]\n      } else {\n        request.setRequestHeader(name, headers[name])\n      }\n    })\n\n    request.send(data)\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n注意，我们这里还判断了如果 config 中配置了 responseType，我们把它设置到 request.responseType 中。在 onreadystatechange 事件函数中，我们构造了 AxiosResponse 类型的 reponse 对象，并把它 resolve 出去。\n\n修改了 xhr 函数，我们同样也要对应修改 axios 函数：\n\nindex.ts：\n\nfunction axios(config: AxiosRequestConfig): AxiosPromise {\n  processConfig(config)\n  return xhr(config)\n}\n\n\n1\n2\n3\n4\n\n\n这样我们就实现了 axios 函数的 Promise 化。\n\n\n# demo 编写\n\n我们在 examples/base/app.ts 文件中添加 2 段代码：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n}).then((res) => {\n  console.log(res)\n})\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  responseType: 'json',\n  data: {\n    a: 3,\n    b: 4\n  }\n}).then((res) => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n我们打开浏览器运行 demo，看一下结果，发现我们可以正常 log 出这个 res 变量，它包含 AxiosResponse 类型中定义的那些属性，不过我们发现 2 个小问题：第一个是 headers 属性是一个字符串，我们需要把它解析成对象类型；第二个是在第一个请求中，得到的数据是一个 JSON 字符串，我们也需要把它转换成对象类型。\n\n那么下一小节，我们将来解决第一个问题，对于响应的 header 做处理。",normalizedContent:"# 获取响应数据\n\n\n# 需求分析\n\n在前面的章节中，我们发送的请求都可以从网络层面接收到服务端返回的数据，但是代码层面并没有做任何关于返回数据的处理。我们希望能处理服务端响应的数据，并支持 promise 链式调用的方式，如下：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n}).then((res) => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们可以拿到 res 对象，并且我们希望该对象包括：服务端返回的数据 data，http 状态码status，状态消息 statustext，响应头 headers、请求配置对象 config 以及请求的 xmlhttprequest 对象实例 request。\n\n\n# 定义接口类型\n\n根据需求，我们可以定义一个 axiosresponse 接口类型，如下：\n\nexport interface axiosresponse {\n  data: any\n  status: number\n  statustext: string\n  headers: any\n  config: axiosrequestconfig\n  request: any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n另外，axios 函数返回的是一个 promise 对象，我们可以定义一个 axiospromise 接口，它继承于 promise<axiosresponse> 这个泛型接口：\n\nexport interface axiospromise extends promise<axiosresponse> {\n}\n\n\n1\n2\n\n\n这样的话，当 axios 返回的是 axiospromise 类型，那么 resolve 函数中的参数就是一个 axiosresponse 类型。\n\n对于一个 ajax 请求的 response，我们是可以指定它的响应的数据类型的，通过设置 xmlhttprequest 对象的 responsetype 属性，于是我们可以给 axiosrequestconfig 类型添加一个可选属性：\n\nexport interface axiosrequestconfig {\n  // ...\n  responsetype?: xmlhttprequestresponsetype\n}\n\n\n1\n2\n3\n4\n\n\nresponsetype 的类型是一个 xmlhttprequestresponsetype 类型，它的定义是 \"\" | \"arraybuffer\" | \"blob\" | \"document\" | \"json\" | \"text\" 字符串字面量类型。\n\n\n# 实现获取响应数据逻辑\n\n首先我们要在 xhr 函数添加 onreadystatechange 事件处理函数，并且让 xhr 函数返回的是 axiospromise 类型。\n\nxhr.ts：\n\nexport default function xhr(config: axiosrequestconfig): axiospromise {\n  return new promise((resolve) => {\n    const { data = null, url, method = 'get', headers, responsetype } = config\n\n    const request = new xmlhttprequest()\n\n    if (responsetype) {\n      request.responsetype = responsetype\n    }\n\n    request.open(method.touppercase(), url, true)\n\n    request.onreadystatechange = function handleload() {\n      if (request.readystate !== 4) {\n        return\n      }\n\n      const responseheaders = request.getallresponseheaders()\n      const responsedata = responsetype && responsetype !== 'text' ? request.response : request.responsetext\n      const response: axiosresponse = {\n        data: responsedata,\n        status: request.status,\n        statustext: request.statustext,\n        headers: responseheaders,\n        config,\n        request\n      }\n      resolve(response)\n    }\n\n    object.keys(headers).foreach((name) => {\n      if (data === null && name.tolowercase() === 'content-type') {\n        delete headers[name]\n      } else {\n        request.setrequestheader(name, headers[name])\n      }\n    })\n\n    request.send(data)\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n注意，我们这里还判断了如果 config 中配置了 responsetype，我们把它设置到 request.responsetype 中。在 onreadystatechange 事件函数中，我们构造了 axiosresponse 类型的 reponse 对象，并把它 resolve 出去。\n\n修改了 xhr 函数，我们同样也要对应修改 axios 函数：\n\nindex.ts：\n\nfunction axios(config: axiosrequestconfig): axiospromise {\n  processconfig(config)\n  return xhr(config)\n}\n\n\n1\n2\n3\n4\n\n\n这样我们就实现了 axios 函数的 promise 化。\n\n\n# demo 编写\n\n我们在 examples/base/app.ts 文件中添加 2 段代码：\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  data: {\n    a: 1,\n    b: 2\n  }\n}).then((res) => {\n  console.log(res)\n})\n\naxios({\n  method: 'post',\n  url: '/base/post',\n  responsetype: 'json',\n  data: {\n    a: 3,\n    b: 4\n  }\n}).then((res) => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n我们打开浏览器运行 demo，看一下结果，发现我们可以正常 log 出这个 res 变量，它包含 axiosresponse 类型中定义的那些属性，不过我们发现 2 个小问题：第一个是 headers 属性是一个字符串，我们需要把它解析成对象类型；第二个是在第一个请求中，得到的数据是一个 json 字符串，我们也需要把它转换成对象类型。\n\n那么下一小节，我们将来解决第一个问题，对于响应的 header 做处理。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"处理响应 header",frontmatter:{title:"处理响应 header",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/927161662ca32c24",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 基础功能实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/04.ts-axios%20%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/05.%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94%20header.html",relativePath:"《TypeScript 从零实现 axios》/04.ts-axios 基础功能实现/05.处理响应 header.md",key:"v-1a4a2e8e",path:"/pages/927161662ca32c24/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:18},{level:2,title:"parseHeaders 函数实现及应用",slug:"parseheaders-函数实现及应用",normalizedTitle:"parseheaders 函数实现及应用",charIndex:606}],headersStr:"需求分析 parseHeaders 函数实现及应用",content:"# 处理响应 header\n\n\n# 需求分析\n\n我们通过 XMLHttpRequest 对象的 getAllResponseHeaders 方法获取到的值是如下一段字符串：\n\ndate: Fri, 05 Apr 2019 12:40:49 GMT\netag: W/\"d-Ssxx4FRxEutDLwo2+xkkxKc4y0k\"\nconnection: keep-alive\nx-powered-by: Express\ncontent-length: 13\ncontent-type: application/json; charset=utf-8\n\n\n1\n2\n3\n4\n5\n6\n\n\n每一行都是以回车符和换行符 \\r\\n 结束，它们是每个 header 属性的分隔符。对于上面这串字符串，我们希望最终解析成一个对象结构：\n\n{\n  date: 'Fri, 05 Apr 2019 12:40:49 GMT'\n  etag: 'W/\"d-Ssxx4FRxEutDLwo2+xkkxKc4y0k\"',\n  connection: 'keep-alive',\n  'x-powered-by': 'Express',\n  'content-length': '13'\n  'content-type': 'application/json; charset=utf-8'\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# parseHeaders 函数实现及应用\n\n根据需求分析，我们要实现一个 parseHeaders 工具函数。\n\nhelpers/headers.ts：\n\nexport function parseHeaders(headers: string): any {\n  let parsed = Object.create(null)\n  if (!headers) {\n    return parsed\n  }\n\n  headers.split('\\r\\n').forEach(line => {\n    let [key, val] = line.split(':')\n    key = key.trim().toLowerCase()\n    if (!key) {\n      return\n    }\n    if (val) {\n      val = val.trim()\n    }\n    parsed[key] = val\n  })\n\n  return parsed\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n然后我们使用这个工具函数：\n\nxhr.ts：\n\nconst responseHeaders = parseHeaders(request.getAllResponseHeaders())\n\n\n1\n\n\n接着我们再去看刚才的 demo，发现我们已经把响应的 headers 字段从字符串解析成对象结构了。那么接下来，我们在解决之前遗留的第二个问题：对响应 data 字段的处理。",normalizedContent:"# 处理响应 header\n\n\n# 需求分析\n\n我们通过 xmlhttprequest 对象的 getallresponseheaders 方法获取到的值是如下一段字符串：\n\ndate: fri, 05 apr 2019 12:40:49 gmt\netag: w/\"d-ssxx4frxeutdlwo2+xkkxkc4y0k\"\nconnection: keep-alive\nx-powered-by: express\ncontent-length: 13\ncontent-type: application/json; charset=utf-8\n\n\n1\n2\n3\n4\n5\n6\n\n\n每一行都是以回车符和换行符 \\r\\n 结束，它们是每个 header 属性的分隔符。对于上面这串字符串，我们希望最终解析成一个对象结构：\n\n{\n  date: 'fri, 05 apr 2019 12:40:49 gmt'\n  etag: 'w/\"d-ssxx4frxeutdlwo2+xkkxkc4y0k\"',\n  connection: 'keep-alive',\n  'x-powered-by': 'express',\n  'content-length': '13'\n  'content-type': 'application/json; charset=utf-8'\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# parseheaders 函数实现及应用\n\n根据需求分析，我们要实现一个 parseheaders 工具函数。\n\nhelpers/headers.ts：\n\nexport function parseheaders(headers: string): any {\n  let parsed = object.create(null)\n  if (!headers) {\n    return parsed\n  }\n\n  headers.split('\\r\\n').foreach(line => {\n    let [key, val] = line.split(':')\n    key = key.trim().tolowercase()\n    if (!key) {\n      return\n    }\n    if (val) {\n      val = val.trim()\n    }\n    parsed[key] = val\n  })\n\n  return parsed\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n然后我们使用这个工具函数：\n\nxhr.ts：\n\nconst responseheaders = parseheaders(request.getallresponseheaders())\n\n\n1\n\n\n接着我们再去看刚才的 demo，发现我们已经把响应的 headers 字段从字符串解析成对象结构了。那么接下来，我们在解决之前遗留的第二个问题：对响应 data 字段的处理。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"处理响应 data",frontmatter:{title:"处理响应 data",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/922cb4268499dc3f",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 基础功能实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/04.ts-axios%20%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/06.%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94%20data.html",relativePath:"《TypeScript 从零实现 axios》/04.ts-axios 基础功能实现/06.处理响应 data.md",key:"v-2cd68ace",path:"/pages/922cb4268499dc3f/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:16},{level:2,title:"transformResponse 函数实现及应用",slug:"transformresponse-函数实现及应用",normalizedTitle:"transformresponse 函数实现及应用",charIndex:173}],headersStr:"需求分析 transformResponse 函数实现及应用",content:'# 处理响应 data\n\n\n# 需求分析\n\n在我们不去设置 responseType 的情况下，当服务端返回给我们的数据是字符串类型，我们可以尝试去把它转换成一个 JSON 对象。例如：\n\ndata: "{"a":1,"b":2}"\n\n\n1\n\n\n我们把它转换成：\n\ndata: {\n  a: 1,\n  b: 2\n}\n\n\n1\n2\n3\n4\n\n\n\n# transformResponse 函数实现及应用\n\n根据需求分析，我们要实现一个 transformResponse 工具函数。\n\nhelpers/data.ts：\n\nexport function transformResponse(data: any): any {\n  if (typeof data === \'string\') {\n    try {\n      data = JSON.parse(data)\n    } catch (e) {\n      // do nothing\n    }\n  }\n  return data\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nindex.ts：\n\nfunction axios(config: AxiosRequestConfig): AxiosPromise {\n  processConfig(config)\n  return xhr(config).then((res) => {\n    return transformResponseData(res)\n  })\n}\n\nfunction transformResponseData(res: AxiosResponse): AxiosResponse {\n  res.data = transformResponse(res.data)\n  return res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n接着我们再去看刚才的 demo，发现我们已经把响应的 data 字段从字符串解析成 JSON 对象结构了。\n\n那么至此，我们的 ts-axios 的基础功能已经实现完毕。不过到目前为止，我们都仅仅实现的是正常情况的逻辑，下面一章我们要处理各种异常情况的逻辑。',normalizedContent:'# 处理响应 data\n\n\n# 需求分析\n\n在我们不去设置 responsetype 的情况下，当服务端返回给我们的数据是字符串类型，我们可以尝试去把它转换成一个 json 对象。例如：\n\ndata: "{"a":1,"b":2}"\n\n\n1\n\n\n我们把它转换成：\n\ndata: {\n  a: 1,\n  b: 2\n}\n\n\n1\n2\n3\n4\n\n\n\n# transformresponse 函数实现及应用\n\n根据需求分析，我们要实现一个 transformresponse 工具函数。\n\nhelpers/data.ts：\n\nexport function transformresponse(data: any): any {\n  if (typeof data === \'string\') {\n    try {\n      data = json.parse(data)\n    } catch (e) {\n      // do nothing\n    }\n  }\n  return data\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nindex.ts：\n\nfunction axios(config: axiosrequestconfig): axiospromise {\n  processconfig(config)\n  return xhr(config).then((res) => {\n    return transformresponsedata(res)\n  })\n}\n\nfunction transformresponsedata(res: axiosresponse): axiosresponse {\n  res.data = transformresponse(res.data)\n  return res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n接着我们再去看刚才的 demo，发现我们已经把响应的 data 字段从字符串解析成 json 对象结构了。\n\n那么至此，我们的 ts-axios 的基础功能已经实现完毕。不过到目前为止，我们都仅仅实现的是正常情况的逻辑，下面一章我们要处理各种异常情况的逻辑。',charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"错误处理",frontmatter:{title:"错误处理",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/6a8bef7b98dfdcf9",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 异常情况处理"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/05.ts-axios%20%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86/01.%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html",relativePath:"《TypeScript 从零实现 axios》/05.ts-axios 异常情况处理/01.错误处理.md",key:"v-7a34485c",path:"/pages/6a8bef7b98dfdcf9/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:11},{level:2,title:"处理网络异常错误",slug:"处理网络异常错误",normalizedTitle:"处理网络异常错误",charIndex:373},{level:2,title:"处理超时错误",slug:"处理超时错误",normalizedTitle:"处理超时错误",charIndex:585},{level:2,title:"处理非 200 状态码",slug:"处理非-200-状态码",normalizedTitle:"处理非 200 状态码",charIndex:1021},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:2121}],headersStr:"需求分析 处理网络异常错误 处理超时错误 处理非 200 状态码 demo 编写",content:"# 错误处理\n\n\n# 需求分析\n\n在上一章节，我们实现了 ts-axios 的基础功能，但目前为止我们都是处理了正常接收请求的逻辑，并没有考虑到任何错误情况的处理，这对于一个程序的健壮性而言是远不够的，因此我们这一章需要对 AJAX 各种错误情况做处理。\n\n并且我们希望程序也能捕获到这些错误，做进一步的处理。\n\naxios({\n  method: 'get',\n  url: '/error/get'\n}).then((res) => {\n  console.log(res)\n}).catch((e) => {\n  console.log(e)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果在请求的过程中发生任何错误，我们都可以在 reject 回调函数中捕获到。\n\n我们把错误分成了几类，接下来我们就来分别处理这些错误情况。\n\n\n# 处理网络异常错误\n\n当网络出现异常（比如不通）的时候发送请求会触发 XMLHttpRequest 对象实例的 error 事件，于是我们可以在 onerror 的事件回调函数中捕获此类错误。\n\n我们在 xhr 函数中添加如下代码：\n\nrequest.onerror = function handleError() {\n  reject(new Error('Network Error'))\n}\n\n\n1\n2\n3\n\n\n\n# 处理超时错误\n\n我们可以设置某个请求的超时时间 timeout，也就是当请求发送后超过某个时间后仍然没收到响应，则请求自动终止，并触发 timeout 事件。\n\n请求默认的超时时间是 0，即永不超时。所以我们首先需要允许程序可以配置超时时间：\n\nexport interface AxiosRequestConfig {\n  // ...\n  timeout?: number\n}\n\n\n1\n2\n3\n4\n\n\n接着在 xhr 函数中添加如下代码：\n\nconst { /*...*/ timeout } = config\n\nif (timeout) {\n  request.timeout = timeout\n}\n\nrequest.ontimeout = function handleTimeout() {\n  reject(new Error(`Timeout of ${timeout} ms exceeded`))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 处理非 200 状态码\n\n对于一个正常的请求，往往会返回 200-300 之间的 HTTP 状态码，对于不在这个区间的状态码，我们也把它们认为是一种错误的情况做处理。\n\nrequest.onreadystatechange = function handleLoad() {\n  if (request.readyState !== 4) {\n    return\n  }\n\n  if (request.status === 0) {\n    return\n  }\n\n  const responseHeaders = parseHeaders(request.getAllResponseHeaders())\n  const responseData =\n    responseType && responseType !== 'text' ? request.response : request.responseText\n  const response: AxiosResponse = {\n    data: responseData,\n    status: request.status,\n    statusText: request.statusText,\n    headers: responseHeaders,\n    config,\n    request\n  }\n  handleResponse(response)\n}\n\nfunction handleResponse(response: AxiosResponse) {\n  if (response.status >= 200 && response.status < 300) {\n    resolve(response)\n  } else {\n    reject(new Error(`Request failed with status code ${response.status}`))\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n我们在 onreadystatechange 的回调函数中，添加了对 request.status 的判断，因为当出现网络错误或者超时错误的时候，该值都为 0。\n\n接着我们在 handleResponse 函数中对 request.status 的值再次判断，如果是 2xx 的状态码，则认为是一个正常的请求，否则抛错。\n\n\n# demo 编写\n\n在 examples 目录下创建 error 目录，在 error 目录下创建 index.html:\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Error example</title>\n  </head>\n  <body>\n    <script src=\"/__build__/error.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n接着创建 app.ts 作为入口文件：\n\nimport axios from '../../src/index'\n\naxios({\n  method: 'get',\n  url: '/error/get1'\n}).then((res) => {\n  console.log(res)\n}).catch((e) => {\n  console.log(e)\n})\n\naxios({\n  method: 'get',\n  url: '/error/get'\n}).then((res) => {\n  console.log(res)\n}).catch((e) => {\n  console.log(e)\n})\n\nsetTimeout(() => {\n  axios({\n    method: 'get',\n    url: '/error/get'\n  }).then((res) => {\n    console.log(res)\n  }).catch((e) => {\n    console.log(e)\n  })\n}, 5000)\n\naxios({\n  method: 'get',\n  url: '/error/timeout',\n  timeout: 2000\n}).then((res) => {\n  console.log(res)\n}).catch((e) => {\n  console.log(e.message)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n接着在 server.js 添加新的接口路由：\n\nrouter.get('/error/get', function(req, res) {\n  if (Math.random() > 0.5) {\n    res.json({\n      msg: `hello world`\n    })\n  } else {\n    res.status(500)\n    res.end()\n  }\n})\n\nrouter.get('/error/timeout', function(req, res) {\n  setTimeout(() => {\n    res.json({\n      msg: `hello world`\n    })\n  }, 3000)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n然后在命令行运行 npm run dev，接着打开 chrome 浏览器，访问 http://localhost:8080/ 即可访问我们的 demo 了，我们点到 Error 目录下，通过开发者工具的 network 部分我们可以看到不同的错误情况。\n\n至此我们对各种错误都做了处理，并把它们抛给了程序应用方，让他们对错误可以做进一步的处理。但是这里我们的错误都仅仅是简单的 Error 实例，只有错误文本信息，并不包含是哪个请求、请求的配置、响应对象等其它信息。那么下一节课，我们会对错误信息做增强。",normalizedContent:"# 错误处理\n\n\n# 需求分析\n\n在上一章节，我们实现了 ts-axios 的基础功能，但目前为止我们都是处理了正常接收请求的逻辑，并没有考虑到任何错误情况的处理，这对于一个程序的健壮性而言是远不够的，因此我们这一章需要对 ajax 各种错误情况做处理。\n\n并且我们希望程序也能捕获到这些错误，做进一步的处理。\n\naxios({\n  method: 'get',\n  url: '/error/get'\n}).then((res) => {\n  console.log(res)\n}).catch((e) => {\n  console.log(e)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果在请求的过程中发生任何错误，我们都可以在 reject 回调函数中捕获到。\n\n我们把错误分成了几类，接下来我们就来分别处理这些错误情况。\n\n\n# 处理网络异常错误\n\n当网络出现异常（比如不通）的时候发送请求会触发 xmlhttprequest 对象实例的 error 事件，于是我们可以在 onerror 的事件回调函数中捕获此类错误。\n\n我们在 xhr 函数中添加如下代码：\n\nrequest.onerror = function handleerror() {\n  reject(new error('network error'))\n}\n\n\n1\n2\n3\n\n\n\n# 处理超时错误\n\n我们可以设置某个请求的超时时间 timeout，也就是当请求发送后超过某个时间后仍然没收到响应，则请求自动终止，并触发 timeout 事件。\n\n请求默认的超时时间是 0，即永不超时。所以我们首先需要允许程序可以配置超时时间：\n\nexport interface axiosrequestconfig {\n  // ...\n  timeout?: number\n}\n\n\n1\n2\n3\n4\n\n\n接着在 xhr 函数中添加如下代码：\n\nconst { /*...*/ timeout } = config\n\nif (timeout) {\n  request.timeout = timeout\n}\n\nrequest.ontimeout = function handletimeout() {\n  reject(new error(`timeout of ${timeout} ms exceeded`))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 处理非 200 状态码\n\n对于一个正常的请求，往往会返回 200-300 之间的 http 状态码，对于不在这个区间的状态码，我们也把它们认为是一种错误的情况做处理。\n\nrequest.onreadystatechange = function handleload() {\n  if (request.readystate !== 4) {\n    return\n  }\n\n  if (request.status === 0) {\n    return\n  }\n\n  const responseheaders = parseheaders(request.getallresponseheaders())\n  const responsedata =\n    responsetype && responsetype !== 'text' ? request.response : request.responsetext\n  const response: axiosresponse = {\n    data: responsedata,\n    status: request.status,\n    statustext: request.statustext,\n    headers: responseheaders,\n    config,\n    request\n  }\n  handleresponse(response)\n}\n\nfunction handleresponse(response: axiosresponse) {\n  if (response.status >= 200 && response.status < 300) {\n    resolve(response)\n  } else {\n    reject(new error(`request failed with status code ${response.status}`))\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n我们在 onreadystatechange 的回调函数中，添加了对 request.status 的判断，因为当出现网络错误或者超时错误的时候，该值都为 0。\n\n接着我们在 handleresponse 函数中对 request.status 的值再次判断，如果是 2xx 的状态码，则认为是一个正常的请求，否则抛错。\n\n\n# demo 编写\n\n在 examples 目录下创建 error 目录，在 error 目录下创建 index.html:\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>error example</title>\n  </head>\n  <body>\n    <script src=\"/__build__/error.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n接着创建 app.ts 作为入口文件：\n\nimport axios from '../../src/index'\n\naxios({\n  method: 'get',\n  url: '/error/get1'\n}).then((res) => {\n  console.log(res)\n}).catch((e) => {\n  console.log(e)\n})\n\naxios({\n  method: 'get',\n  url: '/error/get'\n}).then((res) => {\n  console.log(res)\n}).catch((e) => {\n  console.log(e)\n})\n\nsettimeout(() => {\n  axios({\n    method: 'get',\n    url: '/error/get'\n  }).then((res) => {\n    console.log(res)\n  }).catch((e) => {\n    console.log(e)\n  })\n}, 5000)\n\naxios({\n  method: 'get',\n  url: '/error/timeout',\n  timeout: 2000\n}).then((res) => {\n  console.log(res)\n}).catch((e) => {\n  console.log(e.message)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n接着在 server.js 添加新的接口路由：\n\nrouter.get('/error/get', function(req, res) {\n  if (math.random() > 0.5) {\n    res.json({\n      msg: `hello world`\n    })\n  } else {\n    res.status(500)\n    res.end()\n  }\n})\n\nrouter.get('/error/timeout', function(req, res) {\n  settimeout(() => {\n    res.json({\n      msg: `hello world`\n    })\n  }, 3000)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n然后在命令行运行 npm run dev，接着打开 chrome 浏览器，访问 http://localhost:8080/ 即可访问我们的 demo 了，我们点到 error 目录下，通过开发者工具的 network 部分我们可以看到不同的错误情况。\n\n至此我们对各种错误都做了处理，并把它们抛给了程序应用方，让他们对错误可以做进一步的处理。但是这里我们的错误都仅仅是简单的 error 实例，只有错误文本信息，并不包含是哪个请求、请求的配置、响应对象等其它信息。那么下一节课，我们会对错误信息做增强。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"错误信息增强",frontmatter:{title:"错误信息增强",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/22d581d8c2860b8a",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 异常情况处理"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/05.ts-axios%20%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86/02.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%BC%BA.html",relativePath:"《TypeScript 从零实现 axios》/05.ts-axios 异常情况处理/02.错误信息增强.md",key:"v-6e98cc5e",path:"/pages/22d581d8c2860b8a/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:13},{level:2,title:"创建 AxiosError 类",slug:"创建-axioserror-类",normalizedTitle:"创建 axioserror 类",charIndex:456},{level:2,title:"createError 方法应用",slug:"createerror-方法应用",normalizedTitle:"createerror 方法应用",charIndex:1948},{level:2,title:"导出类型定义",slug:"导出类型定义",normalizedTitle:"导出类型定义",charIndex:2731}],headersStr:"需求分析 创建 AxiosError 类 createError 方法应用 导出类型定义",content:"# 错误信息增强\n\n\n# 需求分析\n\n上一节课我们已经捕获了几类 AJAX 的错误，但是对于错误信息提供的非常有限，我们希望对外提供的信息不仅仅包含错误文本信息，还包括了请求对象配置 config，错误代码 code，XMLHttpRequest 对象实例 request以及自定义响应对象 response。\n\naxios({\n  method: 'get',\n  url: '/error/timeout',\n  timeout: 2000\n}).then((res) => {\n  console.log(res)\n}).catch((e: AxiosError) => {\n  console.log(e.message)\n  console.log(e.request)\n  console.log(e.code)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这样对于应用方来说，他们就可以捕获到这些错误的详细信息，做进一步的处理。\n\n那么接下来，我们就来对错误信息做增强。\n\n\n# 创建 AxiosError 类\n\n我们先来定义 AxiosError 类型接口，用于外部使用。\n\ntypes/index.ts：\n\nexport interface AxiosError extends Error {\n  config: AxiosRequestConfig\n  code?: string\n  request?: any\n  response?: AxiosResponse\n  isAxiosError: boolean\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n接着我们创建 error.ts 文件，然后实现 AxiosError 类，它是继承于 Error 类。\n\nhelpers/error.ts：\n\nimport { AxiosRequestConfig, AxiosResponse } from '../types'\n\nexport class AxiosError extends Error {\n  isAxiosError: boolean\n  config: AxiosRequestConfig\n  code?: string | null\n  request?: any\n  response?: AxiosResponse\n\n  constructor(\n    message: string,\n    config: AxiosRequestConfig,\n    code?: string | null,\n    request?: any,\n    response?: AxiosResponse\n  ) {\n    super(message)\n\n    this.config = config\n    this.code = code\n    this.request = request\n    this.response = response\n    this.isAxiosError = true\n\n    Object.setPrototypeOf(this, AxiosError.prototype)\n  }\n}\n\nexport function createError(\n  message: string,\n  config: AxiosRequestConfig,\n  code?: string | null,\n  request?: any,\n  response?: AxiosResponse\n): AxiosError {\n  const error = new AxiosError(message, config, code, request, response)\n\n  return error\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\nAxiosError 继承于 Error 类，添加了一些自己的属性：config、code、request、response、isAxiosError 等属性。这里要注意一点，我们使用了 Object.setPrototypeOf(this, AxiosError.prototype)，这段代码的目的是为了解决 TypeScript 继承一些内置对象的时候的坑，参考。\n\n另外，为了方便使用，我们对外暴露了一个 createError 的工厂方法。\n\n\n# createError 方法应用\n\n修改关于错误对象创建部分的逻辑，如下：\n\nxhr.ts：\n\nimport { createError } from './helpers/error'\n\nrequest.onerror = function handleError() {\n  reject(createError(\n    'Network Error',\n    config,\n    null,\n    request\n  ))\n}\n\nrequest.ontimeout = function handleTimeout() {\n  reject(createError(\n    `Timeout of ${config.timeout} ms exceeded`,\n    config,\n    'ECONNABORTED',\n    request\n  ))\n}\n\nfunction handleResponse(response: AxiosResponse) {\n  if (response.status >= 200 && response.status < 300) {\n    resolve(response)\n  } else {\n    reject(createError(\n      `Request failed with status code ${response.status}`,\n      config,\n      null,\n      request,\n      response\n    ))\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 导出类型定义\n\n在 demo 中，TypeScript 并不能把 e 参数推断为 AxiosError 类型，于是我们需要手动指明类型，为了让外部应用能引入 AxiosError 类型，我们也需要把它们导出。\n\n我们创建 axios.ts 文件，把之前的 index.ts 的代码拷贝过去，然后修改 index.ts 的代码。\n\nindex.ts：\n\nimport axios from './axios'\n\nexport * from './types'\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n\n\n这样我们在 demo 中就可以引入 AxiosError 类型了。\n\nexamples/error/app.ts：\n\nimport axios, { AxiosError } from '../../src/index'\n\naxios({\n  method: 'get',\n  url: '/error/timeout',\n  timeout: 2000\n}).then((res) => {\n  console.log(res)\n}).catch((e: AxiosError) => {\n  console.log(e.message)\n  console.log(e.code)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n至此，我们关于 ts-axios 的异常处理逻辑就告一段落。下面的章节，我们会对 ts-axios 的接口做扩展，让它提供更多好用和方便的 API。",normalizedContent:"# 错误信息增强\n\n\n# 需求分析\n\n上一节课我们已经捕获了几类 ajax 的错误，但是对于错误信息提供的非常有限，我们希望对外提供的信息不仅仅包含错误文本信息，还包括了请求对象配置 config，错误代码 code，xmlhttprequest 对象实例 request以及自定义响应对象 response。\n\naxios({\n  method: 'get',\n  url: '/error/timeout',\n  timeout: 2000\n}).then((res) => {\n  console.log(res)\n}).catch((e: axioserror) => {\n  console.log(e.message)\n  console.log(e.request)\n  console.log(e.code)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这样对于应用方来说，他们就可以捕获到这些错误的详细信息，做进一步的处理。\n\n那么接下来，我们就来对错误信息做增强。\n\n\n# 创建 axioserror 类\n\n我们先来定义 axioserror 类型接口，用于外部使用。\n\ntypes/index.ts：\n\nexport interface axioserror extends error {\n  config: axiosrequestconfig\n  code?: string\n  request?: any\n  response?: axiosresponse\n  isaxioserror: boolean\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n接着我们创建 error.ts 文件，然后实现 axioserror 类，它是继承于 error 类。\n\nhelpers/error.ts：\n\nimport { axiosrequestconfig, axiosresponse } from '../types'\n\nexport class axioserror extends error {\n  isaxioserror: boolean\n  config: axiosrequestconfig\n  code?: string | null\n  request?: any\n  response?: axiosresponse\n\n  constructor(\n    message: string,\n    config: axiosrequestconfig,\n    code?: string | null,\n    request?: any,\n    response?: axiosresponse\n  ) {\n    super(message)\n\n    this.config = config\n    this.code = code\n    this.request = request\n    this.response = response\n    this.isaxioserror = true\n\n    object.setprototypeof(this, axioserror.prototype)\n  }\n}\n\nexport function createerror(\n  message: string,\n  config: axiosrequestconfig,\n  code?: string | null,\n  request?: any,\n  response?: axiosresponse\n): axioserror {\n  const error = new axioserror(message, config, code, request, response)\n\n  return error\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\naxioserror 继承于 error 类，添加了一些自己的属性：config、code、request、response、isaxioserror 等属性。这里要注意一点，我们使用了 object.setprototypeof(this, axioserror.prototype)，这段代码的目的是为了解决 typescript 继承一些内置对象的时候的坑，参考。\n\n另外，为了方便使用，我们对外暴露了一个 createerror 的工厂方法。\n\n\n# createerror 方法应用\n\n修改关于错误对象创建部分的逻辑，如下：\n\nxhr.ts：\n\nimport { createerror } from './helpers/error'\n\nrequest.onerror = function handleerror() {\n  reject(createerror(\n    'network error',\n    config,\n    null,\n    request\n  ))\n}\n\nrequest.ontimeout = function handletimeout() {\n  reject(createerror(\n    `timeout of ${config.timeout} ms exceeded`,\n    config,\n    'econnaborted',\n    request\n  ))\n}\n\nfunction handleresponse(response: axiosresponse) {\n  if (response.status >= 200 && response.status < 300) {\n    resolve(response)\n  } else {\n    reject(createerror(\n      `request failed with status code ${response.status}`,\n      config,\n      null,\n      request,\n      response\n    ))\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 导出类型定义\n\n在 demo 中，typescript 并不能把 e 参数推断为 axioserror 类型，于是我们需要手动指明类型，为了让外部应用能引入 axioserror 类型，我们也需要把它们导出。\n\n我们创建 axios.ts 文件，把之前的 index.ts 的代码拷贝过去，然后修改 index.ts 的代码。\n\nindex.ts：\n\nimport axios from './axios'\n\nexport * from './types'\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n\n\n这样我们在 demo 中就可以引入 axioserror 类型了。\n\nexamples/error/app.ts：\n\nimport axios, { axioserror } from '../../src/index'\n\naxios({\n  method: 'get',\n  url: '/error/timeout',\n  timeout: 2000\n}).then((res) => {\n  console.log(res)\n}).catch((e: axioserror) => {\n  console.log(e.message)\n  console.log(e.code)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n至此，我们关于 ts-axios 的异常处理逻辑就告一段落。下面的章节，我们会对 ts-axios 的接口做扩展，让它提供更多好用和方便的 api。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"扩展接口",frontmatter:{title:"扩展接口",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/034e320f4af88bd4",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 接口扩展"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/06.ts-axios%20%E6%8E%A5%E5%8F%A3%E6%89%A9%E5%B1%95/01.%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3.html",relativePath:"《TypeScript 从零实现 axios》/06.ts-axios 接口扩展/01.扩展接口.md",key:"v-1e209392",path:"/pages/034e320f4af88bd4/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:11},{level:2,title:"接口类型定义",slug:"接口类型定义",normalizedTitle:"接口类型定义",charIndex:449},{level:2,title:"创建 Axios 类",slug:"创建-axios-类",normalizedTitle:"创建 axios 类",charIndex:1506},{level:2,title:"混合对象实现",slug:"混合对象实现",normalizedTitle:"混合对象实现",charIndex:4992},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:6225}],headersStr:"需求分析 接口类型定义 创建 Axios 类 混合对象实现 demo 编写",content:"# 扩展接口\n\n\n# 需求分析\n\n为了用户更加方便地使用 axios 发送请求，我们可以为所有支持请求方法扩展一些接口：\n\n * axios.request(config)\n\n * axios.get(url[, config])\n\n * axios.delete(url[, config])\n\n * axios.head(url[, config])\n\n * axios.options(url[, config])\n\n * axios.post(url[, data[, config]])\n\n * axios.put(url[, data[, config]])\n\n * axios.patch(url[, data[, config]])\n\n如果使用了这些方法，我们就不必在 config 中指定 url、method、data 这些属性了。\n\n从需求上来看，axios 不再单单是一个方法，更像是一个混合对象，本身是一个方法，又有很多方法属性，接下来我们就来实现这个混合对象。\n\n\n# 接口类型定义\n\n根据需求分析，混合对象 axios 本身是一个函数，我们再实现一个包括它属性方法的类，然后把这个类的原型属性和自身属性再拷贝到 axios 上。\n\n我们先来给 axios 混合对象定义接口：\n\ntypes/index.ts：\n\nexport interface Axios {\n  request(config: AxiosRequestConfig): AxiosPromise\n\n  get(url: string, config?: AxiosRequestConfig): AxiosPromise\n\n  delete(url: string, config?: AxiosRequestConfig): AxiosPromise\n\n  head(url: string, config?: AxiosRequestConfig): AxiosPromise\n\n  options(url: string, config?: AxiosRequestConfig): AxiosPromise\n\n  post(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise\n\n  put(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise\n\n  patch(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise\n}\n\nexport interface AxiosInstance extends Axios {\n  (config: AxiosRequestConfig): AxiosPromise\n}\n\nexport interface AxiosRequestConfig {\n  url?: string\n  // ...\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n首先定义一个 Axios 类型接口，它描述了 Axios 类中的公共方法，接着定义了 AxiosInstance 接口继承 Axios，它就是一个混合类型的接口。\n\n另外 AxiosRequestConfig 类型接口中的 url 属性变成了可选属性。\n\n\n# 创建 Axios 类\n\n我们创建一个 Axios 类，来实现接口定义的公共方法。我们创建了一个 core 目录，用来存放发送请求核心流程的代码。我们在 core 目录下创建 Axios.ts 文件。\n\ncore/Axios.ts\n\nimport { AxiosRequestConfig, AxiosPromise, Method } from '../types'\nimport dispatchRequest from './dispatchRequest'\n\nexport default class Axios {\n  request(config: AxiosRequestConfig): AxiosPromise {\n    return dispatchRequest(config)\n  }\n\n  get(url: string, config?: AxiosRequestConfig): AxiosPromise {\n    return this._requestMethodWithoutData('get', url, config)\n  }\n\n  delete(url: string, config?: AxiosRequestConfig): AxiosPromise {\n    return this._requestMethodWithoutData('delete', url, config)\n  }\n\n  head(url: string, config?: AxiosRequestConfig): AxiosPromise {\n    return this._requestMethodWithoutData('head', url, config)\n  }\n\n  options(url: string, config?: AxiosRequestConfig): AxiosPromise {\n    return this._requestMethodWithoutData('options', url, config)\n  }\n\n  post(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise {\n    return this._requestMethodWithData('post', url, data, config)\n  }\n\n  put(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise {\n    return this._requestMethodWithData('put', url, data, config)\n  }\n\n  patch(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise {\n    return this._requestMethodWithData('patch', url, data, config)\n  }\n\n  _requestMethodWithoutData(method: Method, url: string, config?: AxiosRequestConfig) {\n    return this.request(\n      Object.assign(config || {}, {\n        method,\n        url\n      })\n    )\n  }\n\n  _requestMethodWithData(method: Method, url: string, data?: any, config?: AxiosRequestConfig) {\n    return this.request(\n      Object.assign(config || {}, {\n        method,\n        url,\n        data\n      })\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n其中 request 方法的功能和我们之前的 axios 函数功能是一致。axios 函数的功能就是发送请求，基于模块化编程的思想，我们把这部分功能抽出一个单独的模块，在 core 目录下创建 dispatchRequest 方法，把之前 axios.ts 的相关代码拷贝过去。另外我们把 xhr.ts 文件也迁移到 core 目录下。\n\ncore/dispatchRequest.ts：\n\nimport { AxiosPromise, AxiosRequestConfig, AxiosResponse } from '../types'\nimport xhr from './xhr'\nimport { buildURL } from '../helpers/url'\nimport { transformRequest, transformResponse } from '../helpers/data'\nimport { processHeaders } from '../helpers/headers'\n\nexport default function dispatchRequest(config: AxiosRequestConfig): AxiosPromise {\n  processConfig(config)\n  return xhr(config).then(res => {\n    return transformResponseData(res)\n  })\n}\n\nfunction processConfig(config: AxiosRequestConfig): void {\n  config.url = transformURL(config)\n  config.headers = transformHeaders(config)\n  config.data = transformRequestData(config)\n}\n\nfunction transformURL(config: AxiosRequestConfig): string {\n  const { url, params } = config\n  return buildURL(url, params)\n}\n\nfunction transformRequestData(config: AxiosRequestConfig): any {\n  return transformRequest(config.data)\n}\n\nfunction transformHeaders(config: AxiosRequestConfig) {\n  const { headers = {}, data } = config\n  return processHeaders(headers, data)\n}\n\nfunction transformResponseData(res: AxiosResponse): AxiosResponse {\n  res.data = transformResponse(res.data)\n  return res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n回到 Axios.ts 文件，对于 get、delete、head、options、post、patch、put 这些方法，都是对外提供的语法糖，内部都是通过调用 request 方法实现发送请求，只不过在调用之前对 config 做了一层合并处理。\n\n\n# 混合对象实现\n\n混合对象实现思路很简单，首先这个对象是一个函数，其次这个对象要包括 Axios 类的所有原型属性和实例属性，我们首先来实现一个辅助函数 extend。\n\nhelpers/util.ts\n\nexport function extend<T, U>(to: T, from: U): T & U {\n  for (const key in from) {\n    ;(to as T & U)[key] = from[key] as any\n  }\n  return to as T & U\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nextend 方法的实现用到了交叉类型，并且用到了类型断言。extend 的最终目的是把 from 里的属性都扩展到 to 中，包括原型上的属性。\n\n我们接下来对 axios.ts 文件做修改，我们用工厂模式去创建一个 axios 混合对象。\n\naxios.ts：\n\nimport { AxiosInstance } from './types'\nimport Axios from './core/Axios'\nimport { extend } from './helpers/util'\n\nfunction createInstance(): AxiosInstance {\n  const context = new Axios()\n  const instance = Axios.prototype.request.bind(context)\n\n  extend(instance, context)\n\n  return instance as AxiosInstance\n}\n\nconst axios = createInstance()\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n在 createInstance 工厂函数的内部，我们首先实例化了 Axios 实例 context，接着创建instance 指向 Axios.prototype.request 方法，并绑定了上下文 context；接着通过 extend 方法把 context 中的原型方法和实例方法全部拷贝到 instance 上，这样就实现了一个混合对象：instance 本身是一个函数，又拥有了 Axios 类的所有原型和实例属性，最终把这个 instance 返回。由于这里 TypeScript 不能正确推断 instance 的类型，我们把它断言成 AxiosInstance 类型。\n\n这样我们就可以通过 createInstance 工厂函数创建了 axios，当直接调用 axios 方法就相当于执行了 Axios 类的 request 方法发送请求，当然我们也可以调用 axios.get、axios.post 等方法。\n\n\n# demo 编写\n\n在 examples 目录下创建 extend 目录，在 extend 目录下创建 index.html:\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Extend example</title>\n  </head>\n  <body>\n    <script src=\"/__build__/extend.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n接着创建 app.ts 作为入口文件：\n\nimport axios from '../../src/index'\n\naxios({\n  url: '/extend/post',\n  method: 'post',\n  data: {\n    msg: 'hi'\n  }\n})\n\naxios.request({\n  url: '/extend/post',\n  method: 'post',\n  data: {\n    msg: 'hello'\n  }\n})\n\naxios.get('/extend/get')\n\naxios.options('/extend/options')\n\naxios.delete('/extend/delete')\n\naxios.head('/extend/head')\n\naxios.post('/extend/post', { msg: 'post' })\n\naxios.put('/extend/put', { msg: 'put' })\n\naxios.patch('/extend/patch', { msg: 'patch' })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n然后在命令行运行 npm run dev，接着打开 chrome 浏览器，访问 http://localhost:8080/ 即可访问我们的 demo 了，我们点到 Extend 目录下，通过开发者工具的 network 部分我们可以看到每个请求的发送情况。\n\n至此我们支持了对 axios API 的扩展，把它变成了一个混合对象。官方的 axios 实例除了支持了 axios(config)，还支持了传入 2 个参数 axios(url, config)，这里就涉及到函数重载的概念了，下一节我们来实现这个 feature。",normalizedContent:"# 扩展接口\n\n\n# 需求分析\n\n为了用户更加方便地使用 axios 发送请求，我们可以为所有支持请求方法扩展一些接口：\n\n * axios.request(config)\n\n * axios.get(url[, config])\n\n * axios.delete(url[, config])\n\n * axios.head(url[, config])\n\n * axios.options(url[, config])\n\n * axios.post(url[, data[, config]])\n\n * axios.put(url[, data[, config]])\n\n * axios.patch(url[, data[, config]])\n\n如果使用了这些方法，我们就不必在 config 中指定 url、method、data 这些属性了。\n\n从需求上来看，axios 不再单单是一个方法，更像是一个混合对象，本身是一个方法，又有很多方法属性，接下来我们就来实现这个混合对象。\n\n\n# 接口类型定义\n\n根据需求分析，混合对象 axios 本身是一个函数，我们再实现一个包括它属性方法的类，然后把这个类的原型属性和自身属性再拷贝到 axios 上。\n\n我们先来给 axios 混合对象定义接口：\n\ntypes/index.ts：\n\nexport interface axios {\n  request(config: axiosrequestconfig): axiospromise\n\n  get(url: string, config?: axiosrequestconfig): axiospromise\n\n  delete(url: string, config?: axiosrequestconfig): axiospromise\n\n  head(url: string, config?: axiosrequestconfig): axiospromise\n\n  options(url: string, config?: axiosrequestconfig): axiospromise\n\n  post(url: string, data?: any, config?: axiosrequestconfig): axiospromise\n\n  put(url: string, data?: any, config?: axiosrequestconfig): axiospromise\n\n  patch(url: string, data?: any, config?: axiosrequestconfig): axiospromise\n}\n\nexport interface axiosinstance extends axios {\n  (config: axiosrequestconfig): axiospromise\n}\n\nexport interface axiosrequestconfig {\n  url?: string\n  // ...\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n首先定义一个 axios 类型接口，它描述了 axios 类中的公共方法，接着定义了 axiosinstance 接口继承 axios，它就是一个混合类型的接口。\n\n另外 axiosrequestconfig 类型接口中的 url 属性变成了可选属性。\n\n\n# 创建 axios 类\n\n我们创建一个 axios 类，来实现接口定义的公共方法。我们创建了一个 core 目录，用来存放发送请求核心流程的代码。我们在 core 目录下创建 axios.ts 文件。\n\ncore/axios.ts\n\nimport { axiosrequestconfig, axiospromise, method } from '../types'\nimport dispatchrequest from './dispatchrequest'\n\nexport default class axios {\n  request(config: axiosrequestconfig): axiospromise {\n    return dispatchrequest(config)\n  }\n\n  get(url: string, config?: axiosrequestconfig): axiospromise {\n    return this._requestmethodwithoutdata('get', url, config)\n  }\n\n  delete(url: string, config?: axiosrequestconfig): axiospromise {\n    return this._requestmethodwithoutdata('delete', url, config)\n  }\n\n  head(url: string, config?: axiosrequestconfig): axiospromise {\n    return this._requestmethodwithoutdata('head', url, config)\n  }\n\n  options(url: string, config?: axiosrequestconfig): axiospromise {\n    return this._requestmethodwithoutdata('options', url, config)\n  }\n\n  post(url: string, data?: any, config?: axiosrequestconfig): axiospromise {\n    return this._requestmethodwithdata('post', url, data, config)\n  }\n\n  put(url: string, data?: any, config?: axiosrequestconfig): axiospromise {\n    return this._requestmethodwithdata('put', url, data, config)\n  }\n\n  patch(url: string, data?: any, config?: axiosrequestconfig): axiospromise {\n    return this._requestmethodwithdata('patch', url, data, config)\n  }\n\n  _requestmethodwithoutdata(method: method, url: string, config?: axiosrequestconfig) {\n    return this.request(\n      object.assign(config || {}, {\n        method,\n        url\n      })\n    )\n  }\n\n  _requestmethodwithdata(method: method, url: string, data?: any, config?: axiosrequestconfig) {\n    return this.request(\n      object.assign(config || {}, {\n        method,\n        url,\n        data\n      })\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n其中 request 方法的功能和我们之前的 axios 函数功能是一致。axios 函数的功能就是发送请求，基于模块化编程的思想，我们把这部分功能抽出一个单独的模块，在 core 目录下创建 dispatchrequest 方法，把之前 axios.ts 的相关代码拷贝过去。另外我们把 xhr.ts 文件也迁移到 core 目录下。\n\ncore/dispatchrequest.ts：\n\nimport { axiospromise, axiosrequestconfig, axiosresponse } from '../types'\nimport xhr from './xhr'\nimport { buildurl } from '../helpers/url'\nimport { transformrequest, transformresponse } from '../helpers/data'\nimport { processheaders } from '../helpers/headers'\n\nexport default function dispatchrequest(config: axiosrequestconfig): axiospromise {\n  processconfig(config)\n  return xhr(config).then(res => {\n    return transformresponsedata(res)\n  })\n}\n\nfunction processconfig(config: axiosrequestconfig): void {\n  config.url = transformurl(config)\n  config.headers = transformheaders(config)\n  config.data = transformrequestdata(config)\n}\n\nfunction transformurl(config: axiosrequestconfig): string {\n  const { url, params } = config\n  return buildurl(url, params)\n}\n\nfunction transformrequestdata(config: axiosrequestconfig): any {\n  return transformrequest(config.data)\n}\n\nfunction transformheaders(config: axiosrequestconfig) {\n  const { headers = {}, data } = config\n  return processheaders(headers, data)\n}\n\nfunction transformresponsedata(res: axiosresponse): axiosresponse {\n  res.data = transformresponse(res.data)\n  return res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n回到 axios.ts 文件，对于 get、delete、head、options、post、patch、put 这些方法，都是对外提供的语法糖，内部都是通过调用 request 方法实现发送请求，只不过在调用之前对 config 做了一层合并处理。\n\n\n# 混合对象实现\n\n混合对象实现思路很简单，首先这个对象是一个函数，其次这个对象要包括 axios 类的所有原型属性和实例属性，我们首先来实现一个辅助函数 extend。\n\nhelpers/util.ts\n\nexport function extend<t, u>(to: t, from: u): t & u {\n  for (const key in from) {\n    ;(to as t & u)[key] = from[key] as any\n  }\n  return to as t & u\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nextend 方法的实现用到了交叉类型，并且用到了类型断言。extend 的最终目的是把 from 里的属性都扩展到 to 中，包括原型上的属性。\n\n我们接下来对 axios.ts 文件做修改，我们用工厂模式去创建一个 axios 混合对象。\n\naxios.ts：\n\nimport { axiosinstance } from './types'\nimport axios from './core/axios'\nimport { extend } from './helpers/util'\n\nfunction createinstance(): axiosinstance {\n  const context = new axios()\n  const instance = axios.prototype.request.bind(context)\n\n  extend(instance, context)\n\n  return instance as axiosinstance\n}\n\nconst axios = createinstance()\n\nexport default axios\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n在 createinstance 工厂函数的内部，我们首先实例化了 axios 实例 context，接着创建instance 指向 axios.prototype.request 方法，并绑定了上下文 context；接着通过 extend 方法把 context 中的原型方法和实例方法全部拷贝到 instance 上，这样就实现了一个混合对象：instance 本身是一个函数，又拥有了 axios 类的所有原型和实例属性，最终把这个 instance 返回。由于这里 typescript 不能正确推断 instance 的类型，我们把它断言成 axiosinstance 类型。\n\n这样我们就可以通过 createinstance 工厂函数创建了 axios，当直接调用 axios 方法就相当于执行了 axios 类的 request 方法发送请求，当然我们也可以调用 axios.get、axios.post 等方法。\n\n\n# demo 编写\n\n在 examples 目录下创建 extend 目录，在 extend 目录下创建 index.html:\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>extend example</title>\n  </head>\n  <body>\n    <script src=\"/__build__/extend.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n接着创建 app.ts 作为入口文件：\n\nimport axios from '../../src/index'\n\naxios({\n  url: '/extend/post',\n  method: 'post',\n  data: {\n    msg: 'hi'\n  }\n})\n\naxios.request({\n  url: '/extend/post',\n  method: 'post',\n  data: {\n    msg: 'hello'\n  }\n})\n\naxios.get('/extend/get')\n\naxios.options('/extend/options')\n\naxios.delete('/extend/delete')\n\naxios.head('/extend/head')\n\naxios.post('/extend/post', { msg: 'post' })\n\naxios.put('/extend/put', { msg: 'put' })\n\naxios.patch('/extend/patch', { msg: 'patch' })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n然后在命令行运行 npm run dev，接着打开 chrome 浏览器，访问 http://localhost:8080/ 即可访问我们的 demo 了，我们点到 extend 目录下，通过开发者工具的 network 部分我们可以看到每个请求的发送情况。\n\n至此我们支持了对 axios api 的扩展，把它变成了一个混合对象。官方的 axios 实例除了支持了 axios(config)，还支持了传入 2 个参数 axios(url, config)，这里就涉及到函数重载的概念了，下一节我们来实现这个 feature。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"axios 函数重载",frontmatter:{title:"axios 函数重载",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/8af227eae851ec97",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 接口扩展"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/06.ts-axios%20%E6%8E%A5%E5%8F%A3%E6%89%A9%E5%B1%95/02.axios%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD.html",relativePath:"《TypeScript 从零实现 axios》/06.ts-axios 接口扩展/02.axios 函数重载.md",key:"v-3261ab78",path:"/pages/8af227eae851ec97/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:17},{level:2,title:"重载实现",slug:"重载实现",normalizedTitle:"重载实现",charIndex:406},{level:2,title:"编写 demo",slug:"编写-demo",normalizedTitle:"编写 demo",charIndex:1343}],headersStr:"需求分析 重载实现 编写 demo",content:"# axios 函数重载\n\n\n# 需求分析\n\n目前我们的 axios 函数只支持传入 1 个参数，如下：\n\naxios({\n  url: '/extend/post',\n  method: 'post',\n  data: {\n    msg: 'hi'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n我们希望该函数也能支持传入 2 个参数，如下：\n\naxios('/extend/post', {\n  method: 'post',\n  data: {\n    msg: 'hello'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n第一个参数是 url，第二个参数是 config，这个函数有点类似 axios.get 方法支持的参数类型，不同的是如果我们想要指定 HTTP 方法类型，仍然需要在 config 传入 method。\n\n这就用到我们之前所学的函数重载知识点了，接下来我们来实现它。\n\n\n# 重载实现\n\n首先我们要修改 AxiosInstance 的类型定义。\n\ntypes/index.ts：\n\nexport interface AxiosInstance extends Axios {\n  (config: AxiosRequestConfig): AxiosPromise\n\n  (url: string, config?: AxiosRequestConfig): AxiosPromise\n}\n\n\n1\n2\n3\n4\n5\n\n\n我们增加一种函数的定义，它支持 2 个参数，其中 url 是必选参数，config 是可选参数。\n\n由于 axios 函数实际上指向的是 request 函数，所以我们来修改 request 函数的实现。\n\ncore/Axios.ts：\n\n  request(url: any, config?: any): AxiosPromise {\n    if (typeof url === 'string') {\n      if (!config) {\n        config = {}\n      }\n      config.url = url\n    } else {\n      config = url\n    }\n    return dispatchRequest(config)\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n我们把 request 函数的参数改成 2 个，url 和 config 都是 any 类型，config 还是可选参数。\n\n接着在函数体我们判断 url 是否为字符串类型，一旦它为字符串类型，则继续对 config 判断，因为它可能不传，如果为空则构造一个空对象，然后把 url 添加到 config.url 中。如果 url 不是字符串类型，则说明我们传入的就是单个参数，且 url 就是 config，因此把 url 赋值给 config。\n\n这里要注意的是，我们虽然修改了 request 的实现，支持了 2 种参数，但是我们对外提供的 request 接口仍然不变，可以理解为这仅仅是内部的实现的修改，与对外接口不必一致，只要保留实现兼容接口即可。\n\n\n# 编写 demo\n\nexamples/extend/app.ts：\n\naxios({\n  url: '/extend/post',\n  method: 'post',\n  data: {\n    msg: 'hi'\n  }\n})\n\naxios('/extend/post', {\n  method: 'post',\n  data: {\n    msg: 'hello'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n我们使用了 axios 2 种请求方式，打开页面运行 demo，通过 network 我们可以看到 2 种请求都是运行正常的。\n\n至此我们实现了 axios 函数的重载。官方 axios 支持了一种能力，我们可以去定义返回数据的类型，并在请求的时候指定该类型，然后在响应数据中我们就可以获取到该数据类型。下一节课我们就来实现这个 feature。",normalizedContent:"# axios 函数重载\n\n\n# 需求分析\n\n目前我们的 axios 函数只支持传入 1 个参数，如下：\n\naxios({\n  url: '/extend/post',\n  method: 'post',\n  data: {\n    msg: 'hi'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n我们希望该函数也能支持传入 2 个参数，如下：\n\naxios('/extend/post', {\n  method: 'post',\n  data: {\n    msg: 'hello'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n第一个参数是 url，第二个参数是 config，这个函数有点类似 axios.get 方法支持的参数类型，不同的是如果我们想要指定 http 方法类型，仍然需要在 config 传入 method。\n\n这就用到我们之前所学的函数重载知识点了，接下来我们来实现它。\n\n\n# 重载实现\n\n首先我们要修改 axiosinstance 的类型定义。\n\ntypes/index.ts：\n\nexport interface axiosinstance extends axios {\n  (config: axiosrequestconfig): axiospromise\n\n  (url: string, config?: axiosrequestconfig): axiospromise\n}\n\n\n1\n2\n3\n4\n5\n\n\n我们增加一种函数的定义，它支持 2 个参数，其中 url 是必选参数，config 是可选参数。\n\n由于 axios 函数实际上指向的是 request 函数，所以我们来修改 request 函数的实现。\n\ncore/axios.ts：\n\n  request(url: any, config?: any): axiospromise {\n    if (typeof url === 'string') {\n      if (!config) {\n        config = {}\n      }\n      config.url = url\n    } else {\n      config = url\n    }\n    return dispatchrequest(config)\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n我们把 request 函数的参数改成 2 个，url 和 config 都是 any 类型，config 还是可选参数。\n\n接着在函数体我们判断 url 是否为字符串类型，一旦它为字符串类型，则继续对 config 判断，因为它可能不传，如果为空则构造一个空对象，然后把 url 添加到 config.url 中。如果 url 不是字符串类型，则说明我们传入的就是单个参数，且 url 就是 config，因此把 url 赋值给 config。\n\n这里要注意的是，我们虽然修改了 request 的实现，支持了 2 种参数，但是我们对外提供的 request 接口仍然不变，可以理解为这仅仅是内部的实现的修改，与对外接口不必一致，只要保留实现兼容接口即可。\n\n\n# 编写 demo\n\nexamples/extend/app.ts：\n\naxios({\n  url: '/extend/post',\n  method: 'post',\n  data: {\n    msg: 'hi'\n  }\n})\n\naxios('/extend/post', {\n  method: 'post',\n  data: {\n    msg: 'hello'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n我们使用了 axios 2 种请求方式，打开页面运行 demo，通过 network 我们可以看到 2 种请求都是运行正常的。\n\n至此我们实现了 axios 函数的重载。官方 axios 支持了一种能力，我们可以去定义返回数据的类型，并在请求的时候指定该类型，然后在响应数据中我们就可以获取到该数据类型。下一节课我们就来实现这个 feature。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"响应数据支持泛型",frontmatter:{title:"响应数据支持泛型",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/c4489d0bab02cc0c",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 接口扩展"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/06.ts-axios%20%E6%8E%A5%E5%8F%A3%E6%89%A9%E5%B1%95/03.%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B.html",relativePath:"《TypeScript 从零实现 axios》/06.ts-axios 接口扩展/03.响应数据支持泛型.md",key:"v-ba76f414",path:"/pages/c4489d0bab02cc0c/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:15},{level:2,title:"接口添加泛型参数",slug:"接口添加泛型参数",normalizedTitle:"接口添加泛型参数",charIndex:881},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:2312}],headersStr:"需求分析 接口添加泛型参数 demo 编写",content:"# 响应数据支持泛型\n\n\n# 需求分析\n\n通常情况下，我们会把后端返回数据格式单独放入一个接口中：\n\n// 请求接口数据\nexport interface ResponseData<T = any> {\n  /**\n   * 状态码\n   * @type { number }\n   */\n  code: number\n\n  /**\n   * 数据\n   * @type { T }\n   */\n  result: T\n\n  /**\n   * 消息\n   * @type { string }\n   */\n  message: string\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n我们可以把 API 抽离成单独的模块：\n\nimport { ResponseData } from './interface.ts';\n\nexport function getUser<T>() {\n  return axios.get<ResponseData<T>>('/somepath')\n    .then(res => res.data)\n    .catch(err => console.error(err))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n接着我们写入返回的数据类型 User，这可以让 TypeScript 顺利推断出我们想要的类型：\n\ninterface User {\n  name: string\n  age: number\n}\n\nasync function test() {\n  // user 被推断出为\n  // {\n  //  code: number,\n  //  result: { name: string, age: number },\n  //  message: string\n  // }\n  const user = await getUser<User>()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 接口添加泛型参数\n\n根据需求分析，我们需要给相关的接口定义添加泛型参数。\n\ntypes/index.ts：\n\nexport interface AxiosResponse<T = any> {\n  data: T\n  status: number\n  statusText: string\n  headers: any\n  config: AxiosRequestConfig\n  request: any\n}\n\nexport interface AxiosPromise<T = any> extends Promise<AxiosResponse<T>> {\n}\n\nexport interface Axios {\n  request<T = any>(config: AxiosRequestConfig): AxiosPromise<T>\n\n  get<T = any>(url: string, config?: AxiosRequestConfig): AxiosPromise<T>\n\n  delete<T = any>(url: string, config?: AxiosRequestConfig): AxiosPromise<T>\n\n  head<T = any>(url: string, config?: AxiosRequestConfig): AxiosPromise<T>\n\n  options<T = any>(url: string, config?: AxiosRequestConfig): AxiosPromise<T>\n\n  post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise<T>\n\n  put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise<T>\n\n  patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): AxiosPromise<T>\n}\n\nexport interface AxiosInstance extends Axios {\n  <T = any>(config: AxiosRequestConfig): AxiosPromise<T>\n\n  <T = any>(url: string, config?: AxiosRequestConfig): AxiosPromise<T>\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n这里我们先给 AxiosResponse 接口添加了泛型参数 T，T=any 表示泛型的类型参数默认值为 any。\n\n接着我们为 AxiosPromise、Axios 以及 AxiosInstance 接口都加上了泛型参数。我们可以看到这些请求的返回类型都变成了 AxiosPromise<T>，也就是 Promise<AxiosResponse<T>>，这样我们就可以从响应中拿到了类型 T 了。\n\n\n# demo 编写\n\nexamples/extend/app.ts：\n\ninterface ResponseData<T = any> {\n  code: number\n  result: T\n  message: string\n}\n\ninterface User {\n  name: string\n  age: number\n}\n\nfunction getUser<T>() {\n  return axios<ResponseData<T>>('/extend/user')\n    .then(res => res.data)\n    .catch(err => console.error(err))\n}\n\n\nasync function test() {\n  const user = await getUser<User>()\n  if (user) {\n    console.log(user.result.name)\n  }\n}\n\ntest()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n当我们调用 getUser<User> 的时候，相当于调用了 axios<ResponseData<User>>，也就是我们传入给 axios 函数的类型 T 为 ResponseData<User>；相当于返回值 AxiosPromise<T> 的 T，实际上也是 Promise<AxiosResponse<T>> 中的 T 的类型是 ResponseData<User>，所以响应数据中的 data 类型就是 ResponseData<User>，也就是如下数据结构：\n\n{\n  code: number\n  result: User\n  message: string\n}\n\n\n1\n2\n3\n4\n5\n\n\n这个也是 const user = await getUser<User>() 返回值 user 的数据类型，所以 TypeScript 能正确推断出 user 的类型。\n\n至此，我们的 ts-axios 接口扩展章节就告一段落了，下一章我们来实现 axios 的一个非常好用的功能 —— 拦截器。",normalizedContent:"# 响应数据支持泛型\n\n\n# 需求分析\n\n通常情况下，我们会把后端返回数据格式单独放入一个接口中：\n\n// 请求接口数据\nexport interface responsedata<t = any> {\n  /**\n   * 状态码\n   * @type { number }\n   */\n  code: number\n\n  /**\n   * 数据\n   * @type { t }\n   */\n  result: t\n\n  /**\n   * 消息\n   * @type { string }\n   */\n  message: string\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n我们可以把 api 抽离成单独的模块：\n\nimport { responsedata } from './interface.ts';\n\nexport function getuser<t>() {\n  return axios.get<responsedata<t>>('/somepath')\n    .then(res => res.data)\n    .catch(err => console.error(err))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n接着我们写入返回的数据类型 user，这可以让 typescript 顺利推断出我们想要的类型：\n\ninterface user {\n  name: string\n  age: number\n}\n\nasync function test() {\n  // user 被推断出为\n  // {\n  //  code: number,\n  //  result: { name: string, age: number },\n  //  message: string\n  // }\n  const user = await getuser<user>()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 接口添加泛型参数\n\n根据需求分析，我们需要给相关的接口定义添加泛型参数。\n\ntypes/index.ts：\n\nexport interface axiosresponse<t = any> {\n  data: t\n  status: number\n  statustext: string\n  headers: any\n  config: axiosrequestconfig\n  request: any\n}\n\nexport interface axiospromise<t = any> extends promise<axiosresponse<t>> {\n}\n\nexport interface axios {\n  request<t = any>(config: axiosrequestconfig): axiospromise<t>\n\n  get<t = any>(url: string, config?: axiosrequestconfig): axiospromise<t>\n\n  delete<t = any>(url: string, config?: axiosrequestconfig): axiospromise<t>\n\n  head<t = any>(url: string, config?: axiosrequestconfig): axiospromise<t>\n\n  options<t = any>(url: string, config?: axiosrequestconfig): axiospromise<t>\n\n  post<t = any>(url: string, data?: any, config?: axiosrequestconfig): axiospromise<t>\n\n  put<t = any>(url: string, data?: any, config?: axiosrequestconfig): axiospromise<t>\n\n  patch<t = any>(url: string, data?: any, config?: axiosrequestconfig): axiospromise<t>\n}\n\nexport interface axiosinstance extends axios {\n  <t = any>(config: axiosrequestconfig): axiospromise<t>\n\n  <t = any>(url: string, config?: axiosrequestconfig): axiospromise<t>\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n这里我们先给 axiosresponse 接口添加了泛型参数 t，t=any 表示泛型的类型参数默认值为 any。\n\n接着我们为 axiospromise、axios 以及 axiosinstance 接口都加上了泛型参数。我们可以看到这些请求的返回类型都变成了 axiospromise<t>，也就是 promise<axiosresponse<t>>，这样我们就可以从响应中拿到了类型 t 了。\n\n\n# demo 编写\n\nexamples/extend/app.ts：\n\ninterface responsedata<t = any> {\n  code: number\n  result: t\n  message: string\n}\n\ninterface user {\n  name: string\n  age: number\n}\n\nfunction getuser<t>() {\n  return axios<responsedata<t>>('/extend/user')\n    .then(res => res.data)\n    .catch(err => console.error(err))\n}\n\n\nasync function test() {\n  const user = await getuser<user>()\n  if (user) {\n    console.log(user.result.name)\n  }\n}\n\ntest()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n当我们调用 getuser<user> 的时候，相当于调用了 axios<responsedata<user>>，也就是我们传入给 axios 函数的类型 t 为 responsedata<user>；相当于返回值 axiospromise<t> 的 t，实际上也是 promise<axiosresponse<t>> 中的 t 的类型是 responsedata<user>，所以响应数据中的 data 类型就是 responsedata<user>，也就是如下数据结构：\n\n{\n  code: number\n  result: user\n  message: string\n}\n\n\n1\n2\n3\n4\n5\n\n\n这个也是 const user = await getuser<user>() 返回值 user 的数据类型，所以 typescript 能正确推断出 user 的类型。\n\n至此，我们的 ts-axios 接口扩展章节就告一段落了，下一章我们来实现 axios 的一个非常好用的功能 —— 拦截器。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"拦截器设计与实现",frontmatter:{title:"拦截器设计与实现",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/70651900f022f586",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 拦截器实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/07.ts-axios%20%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0/01.%E6%8B%A6%E6%88%AA%E5%99%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.html",relativePath:"《TypeScript 从零实现 axios》/07.ts-axios 拦截器实现/01.拦截器设计与实现.md",key:"v-633879ee",path:"/pages/70651900f022f586/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:13},{level:2,title:"整体设计",slug:"整体设计",normalizedTitle:"整体设计",charIndex:1127},{level:2,title:"拦截器管理类实现",slug:"拦截器管理类实现",normalizedTitle:"拦截器管理类实现",charIndex:1367},{level:3,title:"接口定义",slug:"接口定义",normalizedTitle:"接口定义",charIndex:1669},{level:3,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:2060},{level:2,title:"链式调用实现",slug:"链式调用实现",normalizedTitle:"链式调用实现",charIndex:3170},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:5025}],headersStr:"需求分析 整体设计 拦截器管理类实现 接口定义 代码实现 链式调用实现 demo 编写",content:"拦截器设计与实现\n\n\n# 需求分析\n\n我们希望能对请求的发送和响应做拦截，也就是在发送请求之前和接收到响应之后做一些额外逻辑。\n\n我们希望设计的拦截器的使用方式如下：\n\n// 添加一个请求拦截器\naxios.interceptors.request.use(function (config) {\n  // 在发送请求之前可以做一些事情\n  return config;\n}, function (error) {\n  // 处理请求错误\n  return Promise.reject(error);\n});\n// 添加一个响应拦截器\naxios.interceptors.response.use(function (response) {\n  // 处理响应数据\n  return response;\n}, function (error) {\n  // 处理响应错误\n  return Promise.reject(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n在 axios 对象上有一个 interceptors 对象属性，该属性又有 request 和 response 2 个属性，它们都有一个 use 方法，use 方法支持 2 个参数，第一个参数类似 Promise 的 resolve 函数，第二个参数类似 Promise 的 reject 函数。我们可以在 resolve 函数和 reject 函数中执行同步代码或者是异步代码逻辑。\n\n并且我们是可以添加多个拦截器的，拦截器的执行顺序是链式依次执行的方式。对于 request 拦截器，后添加的拦截器会在请求前的过程中先执行；对于 response 拦截器，先添加的拦截器会在响应后先执行。\n\naxios.interceptors.request.use(config => {\n  config.headers.test += '1'\n  return config\n})\naxios.interceptors.request.use(config => {\n  config.headers.test += '2'\n  return config\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n此外，我们也可以支持删除某个拦截器，如下：\n\nconst myInterceptor = axios.interceptors.request.use(function () {/*...*/})\naxios.interceptors.request.eject(myInterceptor)\n\n\n1\n2\n\n\n\n# 整体设计\n\n我们先用一张图来展示一下拦截器工作流程：\n\n\n\n整个过程是一个链式调用的方式，并且每个拦截器都可以支持同步和异步处理，我们自然而然地就联想到使用 Promise 链的方式来实现整个调用过程。\n\n在这个 Promise 链的执行过程中，请求拦截器 resolve 函数处理的是 config 对象，而相应拦截器 resolve 函数处理的是 response 对象。\n\n在了解了拦截器工作流程后，我们先要创建一个拦截器管理类，允许我们去添加 删除和遍历拦截器。\n\n\n# 拦截器管理类实现\n\n根据需求，axios 拥有一个 interceptors 对象属性，该属性又有 request 和 response 2 个属性，它们对外提供一个 use 方法来添加拦截器，我们可以把这俩属性看做是一个拦截器管理对象。use 方法支持 2 个参数，第一个是 resolve 函数，第二个是 reject 函数，对于 resolve 函数的参数，请求拦截器是 AxiosRequestConfig 类型的，而响应拦截器是 AxiosResponse 类型的；而对于 reject 函数的参数类型则是 any 类型的。\n\n根据上述分析，我们先来定义一下拦截器管理对象对外的接口。\n\n\n# 接口定义\n\ntypes/index.ts：\n\nexport interface AxiosInterceptorManager<T> {\n  use(resolved: ResolvedFn<T>, rejected?: RejectedFn): number\n\n  eject(id: number): void\n}\n\nexport interface ResolvedFn<T=any> {\n  (val: T): T | Promise<T>\n}\n\nexport interface RejectedFn {\n  (error: any): any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这里我们定义了 AxiosInterceptorManager 泛型接口，因为对于 resolve 函数的参数，请求拦截器和响应拦截器是不同的。\n\n\n# 代码实现\n\nimport { ResolvedFn, RejectedFn } from '../types'\n\ninterface Interceptor<T> {\n  resolved: ResolvedFn<T>\n  rejected?: RejectedFn\n}\n\nexport default class InterceptorManager<T> {\n  private interceptors: Array<Interceptor<T> | null>\n\n  constructor() {\n    this.interceptors = []\n  }\n\n  use(resolved: ResolvedFn<T>, rejected?: RejectedFn): number {\n    this.interceptors.push({\n      resolved,\n      rejected\n    })\n    return this.interceptors.length - 1\n  }\n\n  forEach(fn: (interceptor: Interceptor<T>) => void): void {\n    this.interceptors.forEach(interceptor => {\n      if (interceptor !== null) {\n        fn(interceptor)\n      }\n    })\n  }\n\n  eject(id: number): void {\n    if (this.interceptors[id]) {\n      this.interceptors[id] = null\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n我们定义了一个 InterceptorManager 泛型类，内部维护了一个私有属性 interceptors，它是一个数组，用来存储拦截器。该类还对外提供了 3 个方法，其中 use 接口就是添加拦截器到 interceptors 中，并返回一个 id 用于删除；forEach 接口就是遍历 interceptors 用的，它支持传入一个函数，遍历过程中会调用该函数，并把每一个 interceptor 作为该函数的参数传入；eject 就是删除一个拦截器，通过传入拦截器的 id 删除。\n\n\n# 链式调用实现\n\n> 本小节需要你对 Promise 掌握和理解，可以前往 mdn 学习。\n\n当我们实现好拦截器管理类，接下来就是在 Axios 中定义一个 interceptors 属性，它的类型如下：\n\ninterface Interceptors {\n  request: InterceptorManager<AxiosRequestConfig>\n  response: InterceptorManager<AxiosResponse>\n}\n\nexport default class Axios {\n  interceptors: Interceptors\n\n  constructor() {\n    this.interceptors = {\n      request: new InterceptorManager<AxiosRequestConfig>(),\n      response: new InterceptorManager<AxiosResponse>()\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nInterceptors 类型拥有 2 个属性，一个请求拦截器管理类实例，一个是响应拦截器管理类实例。我们在实例化 Axios 类的时候，在它的构造器去初始化这个 interceptors 实例属性。\n\n接下来，我们修改 request 方法的逻辑，添加拦截器链式调用的逻辑：\n\ncore/Axios.ts：\n\ninterface PromiseChain {\n  resolved: ResolvedFn | ((config: AxiosRequestConfig) => AxiosPromise)\n  rejected?: RejectedFn\n}\n\nrequest(url: any, config?: any): AxiosPromise {\n  if (typeof url === 'string') {\n    if (!config) {\n      config = {}\n    }\n    config.url = url\n  } else {\n    config = url\n  }\n\n  const chain: PromiseChain[] = [{\n    resolved: dispatchRequest,\n    rejected: undefined\n  }]\n\n  this.interceptors.request.forEach(interceptor => {\n    chain.unshift(interceptor)\n  })\n\n  this.interceptors.response.forEach(interceptor => {\n    chain.push(interceptor)\n  })\n\n  let promise = Promise.resolve(config)\n\n  while (chain.length) {\n    const { resolved, rejected } = chain.shift()!\n    promise = promise.then(resolved, rejected)\n  }\n\n  return promise\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n首先，构造一个 PromiseChain 类型的数组 chain，并把 dispatchRequest 函数赋值给 resolved 属性；接着先遍历请求拦截器插入到 chain 的前面；然后再遍历响应拦截器插入到 chain 后面。\n\n接下来定义一个已经 resolve 的 promise，循环这个 chain，拿到每个拦截器对象，把它们的 resolved 函数和 rejected 函数添加到 promise.then 的参数中，这样就相当于通过 Promise 的链式调用方式，实现了拦截器一层层的链式调用的效果。\n\n注意我们拦截器的执行顺序，对于请求拦截器，先执行后添加的，再执行先添加的；而对于响应拦截器，先执行先添加的，后执行后添加的。\n\n\n# demo 编写\n\n在 examples 目录下创建 interceptor 目录，在 interceptor 目录下创建 index.html:\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Interceptor example</title>\n  </head>\n  <body>\n    <script src=\"/__build__/interceptor.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n接着创建 app.ts 作为入口文件：\n\nimport axios from '../../src/index'\n\naxios.interceptors.request.use(config => {\n  config.headers.test += '1'\n  return config\n})\naxios.interceptors.request.use(config => {\n  config.headers.test += '2'\n  return config\n})\naxios.interceptors.request.use(config => {\n  config.headers.test += '3'\n  return config\n})\n\naxios.interceptors.response.use(res => {\n  res.data += '1'\n  return res\n})\nlet interceptor = axios.interceptors.response.use(res => {\n  res.data += '2'\n  return res\n})\naxios.interceptors.response.use(res => {\n  res.data += '3'\n  return res\n})\n\naxios.interceptors.response.eject(interceptor)\n\naxios({\n  url: '/interceptor/get',\n  method: 'get',\n  headers: {\n    test: ''\n  }\n}).then((res) => {\n  console.log(res.data)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n该 demo 我们添加了 3 个请求拦截器，添加了 3 个响应拦截器并删除了第二个。运行该 demo 我们通过浏览器访问，我们发送的请求添加了一个 test 的请求 header，它的值是 321；我们的响应数据返回的是 hello，经过响应拦截器的处理，最终我们输出的数据是 hello13。\n\n至此，我们给 ts-axios 实现了拦截器功能，它是一个非常实用的功能，在实际工作中我们可以利用它做一些需求如登录权限认证。\n\n我们目前通过 axios 发送请求，往往会传入一堆配置，但是我们也希望 ts-axios 本身也会有一些默认配置，我们把用户传入的自定义配置和默认配置做一层合并。其实，大部分的 JS 库都是类似的玩法。下面一章我们就来实现这个 feature。",normalizedContent:"拦截器设计与实现\n\n\n# 需求分析\n\n我们希望能对请求的发送和响应做拦截，也就是在发送请求之前和接收到响应之后做一些额外逻辑。\n\n我们希望设计的拦截器的使用方式如下：\n\n// 添加一个请求拦截器\naxios.interceptors.request.use(function (config) {\n  // 在发送请求之前可以做一些事情\n  return config;\n}, function (error) {\n  // 处理请求错误\n  return promise.reject(error);\n});\n// 添加一个响应拦截器\naxios.interceptors.response.use(function (response) {\n  // 处理响应数据\n  return response;\n}, function (error) {\n  // 处理响应错误\n  return promise.reject(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n在 axios 对象上有一个 interceptors 对象属性，该属性又有 request 和 response 2 个属性，它们都有一个 use 方法，use 方法支持 2 个参数，第一个参数类似 promise 的 resolve 函数，第二个参数类似 promise 的 reject 函数。我们可以在 resolve 函数和 reject 函数中执行同步代码或者是异步代码逻辑。\n\n并且我们是可以添加多个拦截器的，拦截器的执行顺序是链式依次执行的方式。对于 request 拦截器，后添加的拦截器会在请求前的过程中先执行；对于 response 拦截器，先添加的拦截器会在响应后先执行。\n\naxios.interceptors.request.use(config => {\n  config.headers.test += '1'\n  return config\n})\naxios.interceptors.request.use(config => {\n  config.headers.test += '2'\n  return config\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n此外，我们也可以支持删除某个拦截器，如下：\n\nconst myinterceptor = axios.interceptors.request.use(function () {/*...*/})\naxios.interceptors.request.eject(myinterceptor)\n\n\n1\n2\n\n\n\n# 整体设计\n\n我们先用一张图来展示一下拦截器工作流程：\n\n\n\n整个过程是一个链式调用的方式，并且每个拦截器都可以支持同步和异步处理，我们自然而然地就联想到使用 promise 链的方式来实现整个调用过程。\n\n在这个 promise 链的执行过程中，请求拦截器 resolve 函数处理的是 config 对象，而相应拦截器 resolve 函数处理的是 response 对象。\n\n在了解了拦截器工作流程后，我们先要创建一个拦截器管理类，允许我们去添加 删除和遍历拦截器。\n\n\n# 拦截器管理类实现\n\n根据需求，axios 拥有一个 interceptors 对象属性，该属性又有 request 和 response 2 个属性，它们对外提供一个 use 方法来添加拦截器，我们可以把这俩属性看做是一个拦截器管理对象。use 方法支持 2 个参数，第一个是 resolve 函数，第二个是 reject 函数，对于 resolve 函数的参数，请求拦截器是 axiosrequestconfig 类型的，而响应拦截器是 axiosresponse 类型的；而对于 reject 函数的参数类型则是 any 类型的。\n\n根据上述分析，我们先来定义一下拦截器管理对象对外的接口。\n\n\n# 接口定义\n\ntypes/index.ts：\n\nexport interface axiosinterceptormanager<t> {\n  use(resolved: resolvedfn<t>, rejected?: rejectedfn): number\n\n  eject(id: number): void\n}\n\nexport interface resolvedfn<t=any> {\n  (val: t): t | promise<t>\n}\n\nexport interface rejectedfn {\n  (error: any): any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这里我们定义了 axiosinterceptormanager 泛型接口，因为对于 resolve 函数的参数，请求拦截器和响应拦截器是不同的。\n\n\n# 代码实现\n\nimport { resolvedfn, rejectedfn } from '../types'\n\ninterface interceptor<t> {\n  resolved: resolvedfn<t>\n  rejected?: rejectedfn\n}\n\nexport default class interceptormanager<t> {\n  private interceptors: array<interceptor<t> | null>\n\n  constructor() {\n    this.interceptors = []\n  }\n\n  use(resolved: resolvedfn<t>, rejected?: rejectedfn): number {\n    this.interceptors.push({\n      resolved,\n      rejected\n    })\n    return this.interceptors.length - 1\n  }\n\n  foreach(fn: (interceptor: interceptor<t>) => void): void {\n    this.interceptors.foreach(interceptor => {\n      if (interceptor !== null) {\n        fn(interceptor)\n      }\n    })\n  }\n\n  eject(id: number): void {\n    if (this.interceptors[id]) {\n      this.interceptors[id] = null\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n我们定义了一个 interceptormanager 泛型类，内部维护了一个私有属性 interceptors，它是一个数组，用来存储拦截器。该类还对外提供了 3 个方法，其中 use 接口就是添加拦截器到 interceptors 中，并返回一个 id 用于删除；foreach 接口就是遍历 interceptors 用的，它支持传入一个函数，遍历过程中会调用该函数，并把每一个 interceptor 作为该函数的参数传入；eject 就是删除一个拦截器，通过传入拦截器的 id 删除。\n\n\n# 链式调用实现\n\n> 本小节需要你对 promise 掌握和理解，可以前往 mdn 学习。\n\n当我们实现好拦截器管理类，接下来就是在 axios 中定义一个 interceptors 属性，它的类型如下：\n\ninterface interceptors {\n  request: interceptormanager<axiosrequestconfig>\n  response: interceptormanager<axiosresponse>\n}\n\nexport default class axios {\n  interceptors: interceptors\n\n  constructor() {\n    this.interceptors = {\n      request: new interceptormanager<axiosrequestconfig>(),\n      response: new interceptormanager<axiosresponse>()\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\ninterceptors 类型拥有 2 个属性，一个请求拦截器管理类实例，一个是响应拦截器管理类实例。我们在实例化 axios 类的时候，在它的构造器去初始化这个 interceptors 实例属性。\n\n接下来，我们修改 request 方法的逻辑，添加拦截器链式调用的逻辑：\n\ncore/axios.ts：\n\ninterface promisechain {\n  resolved: resolvedfn | ((config: axiosrequestconfig) => axiospromise)\n  rejected?: rejectedfn\n}\n\nrequest(url: any, config?: any): axiospromise {\n  if (typeof url === 'string') {\n    if (!config) {\n      config = {}\n    }\n    config.url = url\n  } else {\n    config = url\n  }\n\n  const chain: promisechain[] = [{\n    resolved: dispatchrequest,\n    rejected: undefined\n  }]\n\n  this.interceptors.request.foreach(interceptor => {\n    chain.unshift(interceptor)\n  })\n\n  this.interceptors.response.foreach(interceptor => {\n    chain.push(interceptor)\n  })\n\n  let promise = promise.resolve(config)\n\n  while (chain.length) {\n    const { resolved, rejected } = chain.shift()!\n    promise = promise.then(resolved, rejected)\n  }\n\n  return promise\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n首先，构造一个 promisechain 类型的数组 chain，并把 dispatchrequest 函数赋值给 resolved 属性；接着先遍历请求拦截器插入到 chain 的前面；然后再遍历响应拦截器插入到 chain 后面。\n\n接下来定义一个已经 resolve 的 promise，循环这个 chain，拿到每个拦截器对象，把它们的 resolved 函数和 rejected 函数添加到 promise.then 的参数中，这样就相当于通过 promise 的链式调用方式，实现了拦截器一层层的链式调用的效果。\n\n注意我们拦截器的执行顺序，对于请求拦截器，先执行后添加的，再执行先添加的；而对于响应拦截器，先执行先添加的，后执行后添加的。\n\n\n# demo 编写\n\n在 examples 目录下创建 interceptor 目录，在 interceptor 目录下创建 index.html:\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>interceptor example</title>\n  </head>\n  <body>\n    <script src=\"/__build__/interceptor.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n接着创建 app.ts 作为入口文件：\n\nimport axios from '../../src/index'\n\naxios.interceptors.request.use(config => {\n  config.headers.test += '1'\n  return config\n})\naxios.interceptors.request.use(config => {\n  config.headers.test += '2'\n  return config\n})\naxios.interceptors.request.use(config => {\n  config.headers.test += '3'\n  return config\n})\n\naxios.interceptors.response.use(res => {\n  res.data += '1'\n  return res\n})\nlet interceptor = axios.interceptors.response.use(res => {\n  res.data += '2'\n  return res\n})\naxios.interceptors.response.use(res => {\n  res.data += '3'\n  return res\n})\n\naxios.interceptors.response.eject(interceptor)\n\naxios({\n  url: '/interceptor/get',\n  method: 'get',\n  headers: {\n    test: ''\n  }\n}).then((res) => {\n  console.log(res.data)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n该 demo 我们添加了 3 个请求拦截器，添加了 3 个响应拦截器并删除了第二个。运行该 demo 我们通过浏览器访问，我们发送的请求添加了一个 test 的请求 header，它的值是 321；我们的响应数据返回的是 hello，经过响应拦截器的处理，最终我们输出的数据是 hello13。\n\n至此，我们给 ts-axios 实现了拦截器功能，它是一个非常实用的功能，在实际工作中我们可以利用它做一些需求如登录权限认证。\n\n我们目前通过 axios 发送请求，往往会传入一堆配置，但是我们也希望 ts-axios 本身也会有一些默认配置，我们把用户传入的自定义配置和默认配置做一层合并。其实，大部分的 js 库都是类似的玩法。下面一章我们就来实现这个 feature。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"合并配置的设计与实现",frontmatter:{title:"合并配置的设计与实现",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/937e4de6b81edeca",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 配置化实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/08.ts-axios%20%E9%85%8D%E7%BD%AE%E5%8C%96%E5%AE%9E%E7%8E%B0/01.%E5%90%88%E5%B9%B6%E9%85%8D%E7%BD%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.html",relativePath:"《TypeScript 从零实现 axios》/08.ts-axios 配置化实现/01.合并配置的设计与实现.md",key:"v-4cdeeb1e",path:"/pages/937e4de6b81edeca/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:17},{level:2,title:"默认配置",slug:"默认配置",normalizedTitle:"默认配置",charIndex:81},{level:3,title:"默认配置定义",slug:"默认配置定义",normalizedTitle:"默认配置定义",charIndex:557},{level:3,title:"添加到 axios 对象中",slug:"添加到-axios-对象中",normalizedTitle:"添加到 axios 对象中",charIndex:1295},{level:2,title:"配置合并及策略",slug:"配置合并及策略",normalizedTitle:"配置合并及策略",charIndex:2299},{level:3,title:"合并方法",slug:"合并方法",normalizedTitle:"合并方法",charIndex:2967},{level:3,title:"默认合并策略",slug:"默认合并策略",normalizedTitle:"默认合并策略",charIndex:3871},{level:3,title:"只接受自定义配置合并策略",slug:"只接受自定义配置合并策略",normalizedTitle:"只接受自定义配置合并策略",charIndex:4085},{level:3,title:"复杂对象合并策略",slug:"复杂对象合并策略",normalizedTitle:"复杂对象合并策略",charIndex:4465},{level:2,title:"flatten headers",slug:"flatten-headers",normalizedTitle:"flatten headers",charIndex:5716},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:7102}],headersStr:"需求分析 默认配置 默认配置定义 添加到 axios 对象中 配置合并及策略 合并方法 默认合并策略 只接受自定义配置合并策略 复杂对象合并策略 flatten headers demo 编写",content:"# 合并配置的设计与实现\n\n\n# 需求分析\n\n在之前的章节我们了解到，在发送请求的时候可以传入一个配置，来决定请求的不同行为。我们也希望 ts-axios 可以有默认配置，定义一些默认的行为。这样在发送每个请求，用户传递的配置可以和默认配置做一层合并。\n\n和官网 axios 库保持一致，我们给 axios 对象添加一个 defaults 属性，表示默认配置，你甚至可以直接修改这些默认配置：\n\naxios.defaults.headers.common['test'] = 123\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'\naxios.defaults.timeout = 2000\n\n\n1\n2\n3\n\n\n其中对于 headers 的默认配置支持 common 和一些请求 method 字段，common 表示对于任何类型的请求都要添加该属性，而 method 表示只有该类型请求方法才会添加对应的属性。\n\n在上述例子中，我们会默认为所有请求的 header 添加 test 属性，会默认为 post 请求的 header 添加 Content-Type 属性。\n\n\n# 默认配置\n\n\n# 默认配置定义\n\n接下来，我们先实现默认配置\n\ndefaults.ts：\n\nimport { AxiosRequestConfig } from './types'\n\nconst defaults: AxiosRequestConfig = {\n  method: 'get',\n\n  timeout: 0,\n\n  headers: {\n    common: {\n      Accept: 'application/json, text/plain, */*'\n    }\n  }\n}\n\nconst methodsNoData = ['delete', 'get', 'head', 'options']\n\nmethodsNoData.forEach(method => {\n  defaults.headers[method] = {}\n})\n\nconst methodsWithData = ['post', 'put', 'patch']\n\nmethodsWithData.forEach(method => {\n  defaults.headers[method] = {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  }\n})\n\nexport default defaults\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n我们定义了 defaults 常量，它包含默认请求的方法、超时时间，以及 headers 配置。\n\n未来我们会根据新的需求添加更多的默认配置。\n\n\n# 添加到 axios 对象中\n\n根据需求，我们要给 axios 对象添加一个 defaults 属性，表示默认配置：\n\nexport default class Axios {\n  defaults: AxiosRequestConfig\n  interceptors: Interceptors\n\n  constructor(initConfig: AxiosRequestConfig) {\n    this.defaults = initConfig\n    this.interceptors = {\n      request: new InterceptorManager<AxiosRequestConfig>(),\n      response: new InterceptorManager<AxiosResponse>()\n    }\n  }\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们给 Axios 类添加一个 defaults 成员属性，并且让 Axios 的构造函数接受一个 initConfig 对象，把 initConfig 赋值给 this.defaults。\n\n接着修改 createInstance 方法，支持传入 config 对象。\n\nimport defaults from './defaults'\n\nfunction createInstance(config: AxiosRequestConfig): AxiosStatic {\n  const context = new Axios(config)\n  const instance = Axios.prototype.request.bind(context)\n\n  // extend(instance, Axios.prototype, context)\n\n  extend(instance, context)\n\n  return instance as AxiosStatic\n}\n\nconst axios = createInstance(defaults)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这样我们就可以在执行 createInstance 创建 axios 对象的时候，把默认配置传入了。\n\n\n# 配置合并及策略\n\n定义了默认配置后，我们发送每个请求的时候需要把自定义配置和默认配置做合并，它并不是简单的 2 个普通对象的合并，对于不同的字段合并，会有不同的合并策略。举个例子：\n\nconfig1 = {\n  method: 'get',\n\n  timeout: 0,\n\n  headers: {\n    common: {\n      Accept: 'application/json, text/plain, */*'\n    }\n  }\n}\n\nconfig2 = {\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  },\n  headers: {\n    test: '321'\n  }\n}\n\nmerged = {\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  },\n  timeout: 0,\n  headers: {\n    common: {\n      Accept: 'application/json, text/plain, */*'\n    }\n    test: '321'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n我们在 core/mergeConfig.ts 中实现合并方法。\n\n\n# 合并方法\n\nexport default function mergeConfig(\n  config1: AxiosRequestConfig,\n  config2?: AxiosRequestConfig\n): AxiosRequestConfig {\n  if (!config2) {\n    config2 = {}\n  }\n\n  const config = Object.create(null)\n\n  for (let key in config2) {\n    mergeField(key)\n  }\n\n  for (let key in config1) {\n    if (!config2[key]) {\n      mergeField(key)\n    }\n  }\n\n  function mergeField(key: string): void {\n    const strat = strats[key] || defaultStrat\n    config[key] = strat(config1[key], config2![key])\n  }\n\n  return config\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n合并方法的整体思路就是对 config1 和 config2 中的属性遍历，执行 mergeField 方法做合并，这里 config1 代表默认配置，config2 代表自定义配置。\n\n遍历过程中，我们会通过 config2[key] 这种索引的方式访问，所以需要给 AxiosRequestConfig 的接口定义添加一个字符串索引签名：\n\nexport interface AxiosRequestConfig {\n  // ...\n\n  [propName: string]: any\n}\n\n\n1\n2\n3\n4\n5\n\n\n在 mergeField 方法中，我们会针对不同的属性使用不同的合并策略。\n\n\n# 默认合并策略\n\n这是大部分属性的合并策略，如下：\n\nfunction defaultStrat(val1: any, val2: any): any {\n  return typeof val2 !== 'undefined' ? val2 : val1\n}\n\n\n1\n2\n3\n\n\n它很简单，如果有 val2 则返回 val2，否则返回 val1，也就是如果自定义配置中定义了某个属性，就采用自定义的，否则就用默认配置。\n\n\n# 只接受自定义配置合并策略\n\n对于一些属性如 url、params、data，合并策略如下：\n\nfunction fromVal2Strat(val1: any, val2: any): any {\n  if (typeof val2 !== 'undefined') {\n    return val2\n  }\n}\n\nconst stratKeysFromVal2 = ['url', 'params', 'data']\n\nstratKeysFromVal2.forEach(key => {\n  strats[key] = fromVal2Strat\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n因为对于 url、params、data 这些属性，默认配置显然是没有意义的，它们是和每个请求强相关的，所以我们只从自定义配置中获取。\n\n\n# 复杂对象合并策略\n\n对于一些属性如 headers，合并策略如下：\n\nfunction deepMergeStrat(val1: any, val2: any): any {\n  if (isPlainObject(val2)) {\n    return deepMerge(val1, val2)\n  } else if (typeof val2 !== 'undefined') {\n    return val2\n  } else if (isPlainObject(val1)) {\n    return deepMerge(val1)\n  } else if (typeof val1 !== 'undefined') {\n    return val1\n  }\n}\n\nconst stratKeysDeepMerge = ['headers']\n\nstratKeysDeepMerge.forEach(key => {\n  strats[key] = deepMergeStrat\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nhelpers/util.ts：\n\nexport function deepMerge(...objs: any[]): any {\n  const result = Object.create(null)\n\n  objs.forEach(obj => {\n    if (obj) {\n      Object.keys(obj).forEach(key => {\n        const val = obj[key]\n        if (isPlainObject(val)) {\n          if (isPlainObject(result[key])) {\n            result[key] = deepMerge(result[key], val)\n          } else {\n            result[key] = deepMerge({}, val)\n          }\n        } else {\n          result[key] = val\n        }\n      })\n    }\n  })\n\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n对于 headers 这类的复杂对象属性，我们需要使用深拷贝的方式，同时也处理了其它一些情况，因为它们也可能是一个非对象的普通值。未来我们讲到认证授权的时候，auth 属性也是这个合并策略。\n\n最后我们在 request 方法里添加合并配置的逻辑：\n\nconfig = mergeConfig(this.defaults, config)\n\n\n1\n\n\n\n# flatten headers\n\n经过合并后的配置中的 headers 是一个复杂对象，多了 common、post、get 等属性，而这些属性中的值才是我们要真正添加到请求 header 中的。\n\n举个例子：\n\nheaders: {\n  common: {\n    Accept: 'application/json, text/plain, */*'\n  },\n  post: {\n    'Content-Type':'application/x-www-form-urlencoded'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们需要把它压成一级的，如下：\n\nheaders: {\n  Accept: 'application/json, text/plain, */*',\n 'Content-Type':'application/x-www-form-urlencoded'\n}\n\n\n1\n2\n3\n4\n\n\n这里要注意的是，对于 common 中定义的 header 字段，我们都要提取，而对于 post、get 这类提取，需要和该次请求的方法对应。\n\n接下来我们实现 flattenHeaders 方法。\n\nhelpers/header.ts：\n\nexport function flattenHeaders(headers: any, method: Method): any {\n  if (!headers) {\n    return headers\n  }\n  headers = deepMerge(headers.common || {}, headers[method] || {}, headers)\n\n  const methodsToDelete = ['delete', 'get', 'head', 'options', 'post', 'put', 'patch', 'common']\n\n  methodsToDelete.forEach(method => {\n    delete headers[method]\n  })\n\n  return headers\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n我们可以通过 deepMerge 的方式把 common、post 的属性拷贝到 headers 这一级，然后再把 common、post 这些属性删掉。\n\n然后我们在真正发送请求前执行这个逻辑。\n\ncore/dispatchRequest.ts：\n\nfunction processConfig(config: AxiosRequestConfig): void {\n  config.url = transformURL(config)\n  config.headers = transformHeaders(config)\n  config.data = transformRequestData(config)\n  config.headers = flattenHeaders(config.headers, config.method!)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这样确保我们了配置中的 headers 是可以正确添加到请求 header 中的\n\n\n# demo 编写\n\n在 examples 目录下创建 config 目录，在 config 目录下创建 index.html:\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Config example</title>\n  </head>\n  <body>\n    <script src=\"/__build__/config.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n接着创建 app.ts 作为入口文件：\n\nimport axios from '../../src/index'\nimport qs from 'qs'\n\naxios.defaults.headers.common['test2'] = 123\n\naxios({\n  url: '/config/post',\n  method: 'post',\n  data: qs.stringify({\n    a: 1\n  }),\n  headers: {\n    test: '321'\n  }\n}).then((res) => {\n  console.log(res.data)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这个例子中我们额外引入了 qs 库，它是一个查询字符串解析和字符串化的库。\n\n比如我们的例子中对于 {a:1} 经过 qs.stringify 变成 a=1。\n\n由于我们的例子给默认值添加了 post 和 common 的 headers，我们在请求前做配置合并，于是我们请求的 header 就添加了 Content-Type 字段，它的值是 application/x-www-form-urlencoded；另外我们也添加了 test2 字段，它的值是 123。\n\n至此，我们合并配置的逻辑就实现完了。我们在前面的章节编写 axios 的基础功能的时候对请求数据和响应数据都做了处理，官方 axios 则把这俩部分逻辑也做到了默认配置中，意味这用户可以去修改这俩部分的逻辑，实现自己对请求和响应数据处理的逻辑。那么下一节我们就来实现这个 feature。",normalizedContent:"# 合并配置的设计与实现\n\n\n# 需求分析\n\n在之前的章节我们了解到，在发送请求的时候可以传入一个配置，来决定请求的不同行为。我们也希望 ts-axios 可以有默认配置，定义一些默认的行为。这样在发送每个请求，用户传递的配置可以和默认配置做一层合并。\n\n和官网 axios 库保持一致，我们给 axios 对象添加一个 defaults 属性，表示默认配置，你甚至可以直接修改这些默认配置：\n\naxios.defaults.headers.common['test'] = 123\naxios.defaults.headers.post['content-type'] = 'application/x-www-form-urlencoded'\naxios.defaults.timeout = 2000\n\n\n1\n2\n3\n\n\n其中对于 headers 的默认配置支持 common 和一些请求 method 字段，common 表示对于任何类型的请求都要添加该属性，而 method 表示只有该类型请求方法才会添加对应的属性。\n\n在上述例子中，我们会默认为所有请求的 header 添加 test 属性，会默认为 post 请求的 header 添加 content-type 属性。\n\n\n# 默认配置\n\n\n# 默认配置定义\n\n接下来，我们先实现默认配置\n\ndefaults.ts：\n\nimport { axiosrequestconfig } from './types'\n\nconst defaults: axiosrequestconfig = {\n  method: 'get',\n\n  timeout: 0,\n\n  headers: {\n    common: {\n      accept: 'application/json, text/plain, */*'\n    }\n  }\n}\n\nconst methodsnodata = ['delete', 'get', 'head', 'options']\n\nmethodsnodata.foreach(method => {\n  defaults.headers[method] = {}\n})\n\nconst methodswithdata = ['post', 'put', 'patch']\n\nmethodswithdata.foreach(method => {\n  defaults.headers[method] = {\n    'content-type': 'application/x-www-form-urlencoded'\n  }\n})\n\nexport default defaults\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n我们定义了 defaults 常量，它包含默认请求的方法、超时时间，以及 headers 配置。\n\n未来我们会根据新的需求添加更多的默认配置。\n\n\n# 添加到 axios 对象中\n\n根据需求，我们要给 axios 对象添加一个 defaults 属性，表示默认配置：\n\nexport default class axios {\n  defaults: axiosrequestconfig\n  interceptors: interceptors\n\n  constructor(initconfig: axiosrequestconfig) {\n    this.defaults = initconfig\n    this.interceptors = {\n      request: new interceptormanager<axiosrequestconfig>(),\n      response: new interceptormanager<axiosresponse>()\n    }\n  }\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们给 axios 类添加一个 defaults 成员属性，并且让 axios 的构造函数接受一个 initconfig 对象，把 initconfig 赋值给 this.defaults。\n\n接着修改 createinstance 方法，支持传入 config 对象。\n\nimport defaults from './defaults'\n\nfunction createinstance(config: axiosrequestconfig): axiosstatic {\n  const context = new axios(config)\n  const instance = axios.prototype.request.bind(context)\n\n  // extend(instance, axios.prototype, context)\n\n  extend(instance, context)\n\n  return instance as axiosstatic\n}\n\nconst axios = createinstance(defaults)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这样我们就可以在执行 createinstance 创建 axios 对象的时候，把默认配置传入了。\n\n\n# 配置合并及策略\n\n定义了默认配置后，我们发送每个请求的时候需要把自定义配置和默认配置做合并，它并不是简单的 2 个普通对象的合并，对于不同的字段合并，会有不同的合并策略。举个例子：\n\nconfig1 = {\n  method: 'get',\n\n  timeout: 0,\n\n  headers: {\n    common: {\n      accept: 'application/json, text/plain, */*'\n    }\n  }\n}\n\nconfig2 = {\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  },\n  headers: {\n    test: '321'\n  }\n}\n\nmerged = {\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  },\n  timeout: 0,\n  headers: {\n    common: {\n      accept: 'application/json, text/plain, */*'\n    }\n    test: '321'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n我们在 core/mergeconfig.ts 中实现合并方法。\n\n\n# 合并方法\n\nexport default function mergeconfig(\n  config1: axiosrequestconfig,\n  config2?: axiosrequestconfig\n): axiosrequestconfig {\n  if (!config2) {\n    config2 = {}\n  }\n\n  const config = object.create(null)\n\n  for (let key in config2) {\n    mergefield(key)\n  }\n\n  for (let key in config1) {\n    if (!config2[key]) {\n      mergefield(key)\n    }\n  }\n\n  function mergefield(key: string): void {\n    const strat = strats[key] || defaultstrat\n    config[key] = strat(config1[key], config2![key])\n  }\n\n  return config\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n合并方法的整体思路就是对 config1 和 config2 中的属性遍历，执行 mergefield 方法做合并，这里 config1 代表默认配置，config2 代表自定义配置。\n\n遍历过程中，我们会通过 config2[key] 这种索引的方式访问，所以需要给 axiosrequestconfig 的接口定义添加一个字符串索引签名：\n\nexport interface axiosrequestconfig {\n  // ...\n\n  [propname: string]: any\n}\n\n\n1\n2\n3\n4\n5\n\n\n在 mergefield 方法中，我们会针对不同的属性使用不同的合并策略。\n\n\n# 默认合并策略\n\n这是大部分属性的合并策略，如下：\n\nfunction defaultstrat(val1: any, val2: any): any {\n  return typeof val2 !== 'undefined' ? val2 : val1\n}\n\n\n1\n2\n3\n\n\n它很简单，如果有 val2 则返回 val2，否则返回 val1，也就是如果自定义配置中定义了某个属性，就采用自定义的，否则就用默认配置。\n\n\n# 只接受自定义配置合并策略\n\n对于一些属性如 url、params、data，合并策略如下：\n\nfunction fromval2strat(val1: any, val2: any): any {\n  if (typeof val2 !== 'undefined') {\n    return val2\n  }\n}\n\nconst stratkeysfromval2 = ['url', 'params', 'data']\n\nstratkeysfromval2.foreach(key => {\n  strats[key] = fromval2strat\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n因为对于 url、params、data 这些属性，默认配置显然是没有意义的，它们是和每个请求强相关的，所以我们只从自定义配置中获取。\n\n\n# 复杂对象合并策略\n\n对于一些属性如 headers，合并策略如下：\n\nfunction deepmergestrat(val1: any, val2: any): any {\n  if (isplainobject(val2)) {\n    return deepmerge(val1, val2)\n  } else if (typeof val2 !== 'undefined') {\n    return val2\n  } else if (isplainobject(val1)) {\n    return deepmerge(val1)\n  } else if (typeof val1 !== 'undefined') {\n    return val1\n  }\n}\n\nconst stratkeysdeepmerge = ['headers']\n\nstratkeysdeepmerge.foreach(key => {\n  strats[key] = deepmergestrat\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nhelpers/util.ts：\n\nexport function deepmerge(...objs: any[]): any {\n  const result = object.create(null)\n\n  objs.foreach(obj => {\n    if (obj) {\n      object.keys(obj).foreach(key => {\n        const val = obj[key]\n        if (isplainobject(val)) {\n          if (isplainobject(result[key])) {\n            result[key] = deepmerge(result[key], val)\n          } else {\n            result[key] = deepmerge({}, val)\n          }\n        } else {\n          result[key] = val\n        }\n      })\n    }\n  })\n\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n对于 headers 这类的复杂对象属性，我们需要使用深拷贝的方式，同时也处理了其它一些情况，因为它们也可能是一个非对象的普通值。未来我们讲到认证授权的时候，auth 属性也是这个合并策略。\n\n最后我们在 request 方法里添加合并配置的逻辑：\n\nconfig = mergeconfig(this.defaults, config)\n\n\n1\n\n\n\n# flatten headers\n\n经过合并后的配置中的 headers 是一个复杂对象，多了 common、post、get 等属性，而这些属性中的值才是我们要真正添加到请求 header 中的。\n\n举个例子：\n\nheaders: {\n  common: {\n    accept: 'application/json, text/plain, */*'\n  },\n  post: {\n    'content-type':'application/x-www-form-urlencoded'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们需要把它压成一级的，如下：\n\nheaders: {\n  accept: 'application/json, text/plain, */*',\n 'content-type':'application/x-www-form-urlencoded'\n}\n\n\n1\n2\n3\n4\n\n\n这里要注意的是，对于 common 中定义的 header 字段，我们都要提取，而对于 post、get 这类提取，需要和该次请求的方法对应。\n\n接下来我们实现 flattenheaders 方法。\n\nhelpers/header.ts：\n\nexport function flattenheaders(headers: any, method: method): any {\n  if (!headers) {\n    return headers\n  }\n  headers = deepmerge(headers.common || {}, headers[method] || {}, headers)\n\n  const methodstodelete = ['delete', 'get', 'head', 'options', 'post', 'put', 'patch', 'common']\n\n  methodstodelete.foreach(method => {\n    delete headers[method]\n  })\n\n  return headers\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n我们可以通过 deepmerge 的方式把 common、post 的属性拷贝到 headers 这一级，然后再把 common、post 这些属性删掉。\n\n然后我们在真正发送请求前执行这个逻辑。\n\ncore/dispatchrequest.ts：\n\nfunction processconfig(config: axiosrequestconfig): void {\n  config.url = transformurl(config)\n  config.headers = transformheaders(config)\n  config.data = transformrequestdata(config)\n  config.headers = flattenheaders(config.headers, config.method!)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这样确保我们了配置中的 headers 是可以正确添加到请求 header 中的\n\n\n# demo 编写\n\n在 examples 目录下创建 config 目录，在 config 目录下创建 index.html:\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>config example</title>\n  </head>\n  <body>\n    <script src=\"/__build__/config.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n接着创建 app.ts 作为入口文件：\n\nimport axios from '../../src/index'\nimport qs from 'qs'\n\naxios.defaults.headers.common['test2'] = 123\n\naxios({\n  url: '/config/post',\n  method: 'post',\n  data: qs.stringify({\n    a: 1\n  }),\n  headers: {\n    test: '321'\n  }\n}).then((res) => {\n  console.log(res.data)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这个例子中我们额外引入了 qs 库，它是一个查询字符串解析和字符串化的库。\n\n比如我们的例子中对于 {a:1} 经过 qs.stringify 变成 a=1。\n\n由于我们的例子给默认值添加了 post 和 common 的 headers，我们在请求前做配置合并，于是我们请求的 header 就添加了 content-type 字段，它的值是 application/x-www-form-urlencoded；另外我们也添加了 test2 字段，它的值是 123。\n\n至此，我们合并配置的逻辑就实现完了。我们在前面的章节编写 axios 的基础功能的时候对请求数据和响应数据都做了处理，官方 axios 则把这俩部分逻辑也做到了默认配置中，意味这用户可以去修改这俩部分的逻辑，实现自己对请求和响应数据处理的逻辑。那么下一节我们就来实现这个 feature。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"请求和响应配置化",frontmatter:{title:"请求和响应配置化",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/f5b627bfebba87fc",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 配置化实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/08.ts-axios%20%E9%85%8D%E7%BD%AE%E5%8C%96%E5%AE%9E%E7%8E%B0/02.%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E9%85%8D%E7%BD%AE%E5%8C%96.html",relativePath:"《TypeScript 从零实现 axios》/08.ts-axios 配置化实现/02.请求和响应配置化.md",key:"v-a637d8d0",path:"/pages/f5b627bfebba87fc/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:15},{level:2,title:"修改默认配置",slug:"修改默认配置",normalizedTitle:"修改默认配置",charIndex:800},{level:2,title:"transform 逻辑重构",slug:"transform-逻辑重构",normalizedTitle:"transform 逻辑重构",charIndex:1711},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:2959}],headersStr:"需求分析 修改默认配置 transform 逻辑重构 demo 编写",content:"# 请求和响应配置化\n\n\n# 需求分析\n\n官方的 axios 库 给默认配置添加了 transformRequest 和 transformResponse 两个字段，它们的值是一个数组或者是一个函数。\n\n其中 transformRequest 允许你在将请求数据发送到服务器之前对其进行修改，这只适用于请求方法 put、post 和 patch，如果值是数组，则数组中的最后一个函数必须返回一个字符串或 FormData、URLSearchParams、Blob 等类型作为 xhr.send 方法的参数，而且在 transform 过程中可以修改 headers 对象。\n\n而 transformResponse 允许你在把响应数据传递给 then 或者 catch 之前对它们进行修改。\n\n当值为数组的时候，数组的每一个函数都是一个转换函数，数组中的函数就像管道一样依次执行，前者的输出作为后者的输入。\n\n举个例子：\n\naxios({\n  transformRequest: [(function(data) {\n    return qs.stringify(data)\n  }), ...axios.defaults.transformRequest],\n  transformResponse: [axios.defaults.transformResponse, function(data) {\n    if (typeof data === 'object') {\n      data.b = 2\n    }\n    return data\n  }],\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 修改默认配置\n\n先修改 AxiosRequestConfig 的类型定义，添加 transformRequest 和 transformResponse 俩个可选属性。\n\ntypes/index.ts：\n\nexport interface AxiosRequestConfig {\n  // ...\n  transformRequest?: AxiosTransformer | AxiosTransformer[]\n  transformResponse?: AxiosTransformer | AxiosTransformer[]\n}\n\nexport interface AxiosTransformer {\n  (data: any, headers?: any): any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n接着修改默认配置，如下：\n\ndefaults.ts：\n\nimport { processHeaders } from './helpers/headers'\nimport { transformRequest, transformResponse } from './helpers/data'\n\nconst defaults: AxiosRequestConfig = {\n  // ...\n  transformRequest: [\n    function(data: any, headers: any): any {\n      processHeaders(headers, data)\n      return transformRequest(data)\n    }\n  ],\n\n  transformResponse: [\n    function(data: any): any {\n      return transformResponse(data)\n    }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n我们把之前对请求数据和响应数据的处理逻辑，放到了默认配置中，也就是默认处理逻辑。\n\n\n# transform 逻辑重构\n\n接下来，我们就要重构之前写的对请求数据和响应数据的处理逻辑了。由于我们可能会编写多个转换函数，我们先定义一个 transform 函数来处理这些转换函数的调用逻辑。\n\ncore/transform.ts\n\nimport { AxiosTransformer } from '../types'\n\nexport default function transform(\n  data: any,\n  headers: any,\n  fns?: AxiosTransformer | AxiosTransformer[]\n): any {\n  if (!fns) {\n    return data\n  }\n  if (!Array.isArray(fns)) {\n    fns = [fns]\n  }\n  fns.forEach(fn => {\n    data = fn(data, headers)\n  })\n  return data\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\ntransform 函数中接收 data、headers、fns 3 个参数，其中 fns 代表一个或者多个转换函数，内部逻辑很简单，遍历 fns，执行这些转换函数，并且把 data 和 headers 作为参数传入，每个转换函数返回的 data 会作为下一个转换函数的参数 data 传入。\n\n接下来修改对请求数据和响应数据的处理逻辑。\n\ndispatchRequest.ts：\n\n\nimport transform from './transform'\n\nfunction processConfig(config: AxiosRequestConfig): void {\n  config.url = transformURL(config)\n  config.data = transform(config.data, config.headers, config.transformRequest)\n  config.headers = flattenHeaders(config.headers, config.method!)\n}\n\nfunction transformResponseData(res: AxiosResponse): AxiosResponse {\n  res.data = transform(res.data, res.headers, res.config.transformResponse)\n  return res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们把对请求数据的处理和对响应数据的处理改成使用 transform 函数实现，并把配置中的 transformRequest 及 transformResponse 分别传入。\n\n\n# demo 编写\n\naxios({\n  transformRequest: [(function(data) {\n    return qs.stringify(data)\n  }), ...(axios.defaults.transformRequest as AxiosTransformer[])],\n  transformResponse: [...(axios.defaults.transformResponse as AxiosTransformer[]), function(data) {\n    if (typeof data === 'object') {\n      data.b = 2\n    }\n    return data\n  }],\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  }\n}).then((res) => {\n  console.log(res.data)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n我们对 transformRequest 做了修改，在执行它默认的 transformRequest 之前，我们先用 qs.stringify 库对传入的数据 data 做了一层转换。同时也对 transformResponse 做了修改，在执行完默认的 transformResponse 后，会给响应的 data 对象添加一个 data.b = 2。\n\n因为之前我们实现了配置的合并，而且我们传入的 transformRequest 和 transformResponse 遵循默认合并策略，它们会覆盖默认的值。\n\n至此，我们就实现了请求和响应的配置化。到目前为止，我们的 axios 都是一个单例，一旦我们修改了 axios 的默认配置，会影响所有的请求。官网提供了一个 axios.create 的工厂方法允许我们创建一个新的 axios 实例，同时允许我们传入新的配置和默认配置合并，并做为新的默认配置。下面一节课我们就来实现这个 feature。",normalizedContent:"# 请求和响应配置化\n\n\n# 需求分析\n\n官方的 axios 库 给默认配置添加了 transformrequest 和 transformresponse 两个字段，它们的值是一个数组或者是一个函数。\n\n其中 transformrequest 允许你在将请求数据发送到服务器之前对其进行修改，这只适用于请求方法 put、post 和 patch，如果值是数组，则数组中的最后一个函数必须返回一个字符串或 formdata、urlsearchparams、blob 等类型作为 xhr.send 方法的参数，而且在 transform 过程中可以修改 headers 对象。\n\n而 transformresponse 允许你在把响应数据传递给 then 或者 catch 之前对它们进行修改。\n\n当值为数组的时候，数组的每一个函数都是一个转换函数，数组中的函数就像管道一样依次执行，前者的输出作为后者的输入。\n\n举个例子：\n\naxios({\n  transformrequest: [(function(data) {\n    return qs.stringify(data)\n  }), ...axios.defaults.transformrequest],\n  transformresponse: [axios.defaults.transformresponse, function(data) {\n    if (typeof data === 'object') {\n      data.b = 2\n    }\n    return data\n  }],\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 修改默认配置\n\n先修改 axiosrequestconfig 的类型定义，添加 transformrequest 和 transformresponse 俩个可选属性。\n\ntypes/index.ts：\n\nexport interface axiosrequestconfig {\n  // ...\n  transformrequest?: axiostransformer | axiostransformer[]\n  transformresponse?: axiostransformer | axiostransformer[]\n}\n\nexport interface axiostransformer {\n  (data: any, headers?: any): any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n接着修改默认配置，如下：\n\ndefaults.ts：\n\nimport { processheaders } from './helpers/headers'\nimport { transformrequest, transformresponse } from './helpers/data'\n\nconst defaults: axiosrequestconfig = {\n  // ...\n  transformrequest: [\n    function(data: any, headers: any): any {\n      processheaders(headers, data)\n      return transformrequest(data)\n    }\n  ],\n\n  transformresponse: [\n    function(data: any): any {\n      return transformresponse(data)\n    }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n我们把之前对请求数据和响应数据的处理逻辑，放到了默认配置中，也就是默认处理逻辑。\n\n\n# transform 逻辑重构\n\n接下来，我们就要重构之前写的对请求数据和响应数据的处理逻辑了。由于我们可能会编写多个转换函数，我们先定义一个 transform 函数来处理这些转换函数的调用逻辑。\n\ncore/transform.ts\n\nimport { axiostransformer } from '../types'\n\nexport default function transform(\n  data: any,\n  headers: any,\n  fns?: axiostransformer | axiostransformer[]\n): any {\n  if (!fns) {\n    return data\n  }\n  if (!array.isarray(fns)) {\n    fns = [fns]\n  }\n  fns.foreach(fn => {\n    data = fn(data, headers)\n  })\n  return data\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\ntransform 函数中接收 data、headers、fns 3 个参数，其中 fns 代表一个或者多个转换函数，内部逻辑很简单，遍历 fns，执行这些转换函数，并且把 data 和 headers 作为参数传入，每个转换函数返回的 data 会作为下一个转换函数的参数 data 传入。\n\n接下来修改对请求数据和响应数据的处理逻辑。\n\ndispatchrequest.ts：\n\n\nimport transform from './transform'\n\nfunction processconfig(config: axiosrequestconfig): void {\n  config.url = transformurl(config)\n  config.data = transform(config.data, config.headers, config.transformrequest)\n  config.headers = flattenheaders(config.headers, config.method!)\n}\n\nfunction transformresponsedata(res: axiosresponse): axiosresponse {\n  res.data = transform(res.data, res.headers, res.config.transformresponse)\n  return res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们把对请求数据的处理和对响应数据的处理改成使用 transform 函数实现，并把配置中的 transformrequest 及 transformresponse 分别传入。\n\n\n# demo 编写\n\naxios({\n  transformrequest: [(function(data) {\n    return qs.stringify(data)\n  }), ...(axios.defaults.transformrequest as axiostransformer[])],\n  transformresponse: [...(axios.defaults.transformresponse as axiostransformer[]), function(data) {\n    if (typeof data === 'object') {\n      data.b = 2\n    }\n    return data\n  }],\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  }\n}).then((res) => {\n  console.log(res.data)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n我们对 transformrequest 做了修改，在执行它默认的 transformrequest 之前，我们先用 qs.stringify 库对传入的数据 data 做了一层转换。同时也对 transformresponse 做了修改，在执行完默认的 transformresponse 后，会给响应的 data 对象添加一个 data.b = 2。\n\n因为之前我们实现了配置的合并，而且我们传入的 transformrequest 和 transformresponse 遵循默认合并策略，它们会覆盖默认的值。\n\n至此，我们就实现了请求和响应的配置化。到目前为止，我们的 axios 都是一个单例，一旦我们修改了 axios 的默认配置，会影响所有的请求。官网提供了一个 axios.create 的工厂方法允许我们创建一个新的 axios 实例，同时允许我们传入新的配置和默认配置合并，并做为新的默认配置。下面一节课我们就来实现这个 feature。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"扩展 create 静态接口",frontmatter:{title:"扩展 create 静态接口",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/7b49658c26f613bf",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 配置化实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/08.ts-axios%20%E9%85%8D%E7%BD%AE%E5%8C%96%E5%AE%9E%E7%8E%B0/03.%E6%89%A9%E5%B1%95%20create%20%E9%9D%99%E6%80%81%E6%8E%A5%E5%8F%A3.html",relativePath:"《TypeScript 从零实现 axios》/08.ts-axios 配置化实现/03.扩展 create 静态接口.md",key:"v-74a249be",path:"/pages/7b49658c26f613bf/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:27},{level:2,title:"静态方法扩展",slug:"静态方法扩展",normalizedTitle:"静态方法扩展",charIndex:656},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:1398}],headersStr:"需求分析 静态方法扩展 demo 编写",content:"# 扩展 axios.create 静态接口\n\n\n# 需求分析\n\n目前为止，我们的 axios 都是一个单例，一旦我们修改了 axios 的默认配置，会影响所有的请求。我们希望提供了一个 axios.create 的静态接口允许我们创建一个新的 axios 实例，同时允许我们传入新的配置和默认配置合并，并做为新的默认配置。\n\n举个例子：\n\nconst instance = axios.create({\n  transformRequest: [(function(data) {\n    return qs.stringify(data)\n  }), ...(axios.defaults.transformRequest as AxiosTransformer[])],\n  transformResponse: [...(axios.defaults.transformResponse as AxiosTransformer[]), function(data) {\n    if (typeof data === 'object') {\n      data.b = 2\n    }\n    return data\n  }]\n})\n\ninstance({\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 静态方法扩展\n\n由于 axios 扩展了一个静态接口，因此我们先来修改接口类型定义。\n\ntypes/index.ts：\n\nexport interface AxiosStatic extends AxiosInstance{\n  create(config?: AxiosRequestConfig): AxiosInstance\n}\n\n\n1\n2\n3\n\n\ncreate 函数可以接受一个 AxiosRequestConfig 类型的配置，作为默认配置的扩展，也可以接受不传参数。\n\n接着我们来实现 axios.create 静态方法。\n\naxios.ts：\n\nfunction createInstance(config: AxiosRequestConfig): AxiosStatic {\n  const context = new Axios(config)\n  const instance = Axios.prototype.request.bind(context)\n\n  extend(instance, context)\n\n  return instance as AxiosStatic\n}\naxios.create = function create(config) {\n  return createInstance(mergeConfig(defaults, config))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n内部调用了 createInstance 函数，并且把参数 config 与 defaults 合并，作为新的默认配置。注意这里我们需要 createInstance 函数的返回值类型为 AxiosStatic。\n\n\n# demo 编写\n\nconst instance = axios.create({\n  transformRequest: [(function(data) {\n    return qs.stringify(data)\n  }), ...(axios.defaults.transformRequest as AxiosTransformer[])],\n  transformResponse: [...(axios.defaults.transformResponse as AxiosTransformer[]), function(data) {\n    if (typeof data === 'object') {\n      data.b = 2\n    }\n    return data\n  }]\n})\n\ninstance({\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  }\n}).then((res) => {\n  console.log(res.data)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n我们对上节课的示例做了小小的修改，通过 axios.create 方法创建一个新的实例 instance，并传入了 transformRequest 和 transformResponse 的配置修改了默认配置，然后通过 instance 发送请求，效果和之前是一样的。\n\n至此我们实现了 axios.create 静态接口的扩展，整个 ts-axios 的配置化也告一段落。官方 axios 库还支持了对请求取消的能力，在发送请求前以及请求发送出去未响应前都可以取消该请求。下一章我们就来实现这个 feature。",normalizedContent:"# 扩展 axios.create 静态接口\n\n\n# 需求分析\n\n目前为止，我们的 axios 都是一个单例，一旦我们修改了 axios 的默认配置，会影响所有的请求。我们希望提供了一个 axios.create 的静态接口允许我们创建一个新的 axios 实例，同时允许我们传入新的配置和默认配置合并，并做为新的默认配置。\n\n举个例子：\n\nconst instance = axios.create({\n  transformrequest: [(function(data) {\n    return qs.stringify(data)\n  }), ...(axios.defaults.transformrequest as axiostransformer[])],\n  transformresponse: [...(axios.defaults.transformresponse as axiostransformer[]), function(data) {\n    if (typeof data === 'object') {\n      data.b = 2\n    }\n    return data\n  }]\n})\n\ninstance({\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 静态方法扩展\n\n由于 axios 扩展了一个静态接口，因此我们先来修改接口类型定义。\n\ntypes/index.ts：\n\nexport interface axiosstatic extends axiosinstance{\n  create(config?: axiosrequestconfig): axiosinstance\n}\n\n\n1\n2\n3\n\n\ncreate 函数可以接受一个 axiosrequestconfig 类型的配置，作为默认配置的扩展，也可以接受不传参数。\n\n接着我们来实现 axios.create 静态方法。\n\naxios.ts：\n\nfunction createinstance(config: axiosrequestconfig): axiosstatic {\n  const context = new axios(config)\n  const instance = axios.prototype.request.bind(context)\n\n  extend(instance, context)\n\n  return instance as axiosstatic\n}\naxios.create = function create(config) {\n  return createinstance(mergeconfig(defaults, config))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n内部调用了 createinstance 函数，并且把参数 config 与 defaults 合并，作为新的默认配置。注意这里我们需要 createinstance 函数的返回值类型为 axiosstatic。\n\n\n# demo 编写\n\nconst instance = axios.create({\n  transformrequest: [(function(data) {\n    return qs.stringify(data)\n  }), ...(axios.defaults.transformrequest as axiostransformer[])],\n  transformresponse: [...(axios.defaults.transformresponse as axiostransformer[]), function(data) {\n    if (typeof data === 'object') {\n      data.b = 2\n    }\n    return data\n  }]\n})\n\ninstance({\n  url: '/config/post',\n  method: 'post',\n  data: {\n    a: 1\n  }\n}).then((res) => {\n  console.log(res.data)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n我们对上节课的示例做了小小的修改，通过 axios.create 方法创建一个新的实例 instance，并传入了 transformrequest 和 transformresponse 的配置修改了默认配置，然后通过 instance 发送请求，效果和之前是一样的。\n\n至此我们实现了 axios.create 静态接口的扩展，整个 ts-axios 的配置化也告一段落。官方 axios 库还支持了对请求取消的能力，在发送请求前以及请求发送出去未响应前都可以取消该请求。下一章我们就来实现这个 feature。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"取消功能的设计与实现",frontmatter:{title:"取消功能的设计与实现",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/fdc6da5372397430",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 取消功能实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/09.ts-axios%20%E5%8F%96%E6%B6%88%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/01.%E5%8F%96%E6%B6%88%E5%8A%9F%E8%83%BD%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.html",relativePath:"《TypeScript 从零实现 axios》/09.ts-axios 取消功能实现/01.取消功能的设计与实现.md",key:"v-195fc2cb",path:"/pages/fdc6da5372397430/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:17},{level:2,title:"异步分离的设计方案",slug:"异步分离的设计方案",normalizedTitle:"异步分离的设计方案",charIndex:1455},{level:2,title:"CancelToken 类实现",slug:"canceltoken-类实现",normalizedTitle:"canceltoken 类实现",charIndex:2052},{level:3,title:"接口定义",slug:"接口定义",normalizedTitle:"接口定义",charIndex:2101},{level:3,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:2555},{level:2,title:"CancelToken 扩展静态接口",slug:"canceltoken-扩展静态接口",normalizedTitle:"canceltoken 扩展静态接口",charIndex:3625},{level:3,title:"接口定义",slug:"接口定义-2",normalizedTitle:"接口定义",charIndex:2101},{level:3,title:"代码实现",slug:"代码实现-2",normalizedTitle:"代码实现",charIndex:2555},{level:2,title:"Cancel 类实现及 axios 的扩展",slug:"cancel-类实现及-axios-的扩展",normalizedTitle:"cancel 类实现及 axios 的扩展",charIndex:4535},{level:3,title:"接口定义",slug:"接口定义-3",normalizedTitle:"接口定义",charIndex:2101},{level:3,title:"代码实现",slug:"代码实现-3",normalizedTitle:"代码实现",charIndex:2555},{level:2,title:"额外逻辑实现",slug:"额外逻辑实现",normalizedTitle:"额外逻辑实现",charIndex:6342},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:7325}],headersStr:"需求分析 异步分离的设计方案 CancelToken 类实现 接口定义 代码实现 CancelToken 扩展静态接口 接口定义 代码实现 Cancel 类实现及 axios 的扩展 接口定义 代码实现 额外逻辑实现 demo 编写",content:"# 取消功能的设计与实现\n\n\n# 需求分析\n\n有些场景下，我们希望能主动取消请求，比如常见的搜索框案例，在用户输入过程中，搜索框的内容也在不断变化，正常情况每次变化我们都应该向服务端发送一次请求。但是当用户输入过快的时候，我们不希望每次变化请求都发出去，通常一个解决方案是前端用 debounce 的方案，比如延时 200ms 发送请求。这样当用户连续输入的字符，只要输入间隔小于 200ms，前面输入的字符都不会发请求。\n\n但是还有一种极端情况是后端接口很慢，比如超过 1s 才能响应，这个时候即使做了 200ms 的 debounce，但是在我慢慢输入（每个输入间隔超过 200ms）的情况下，在前面的请求没有响应前，也有可能发出去多个请求。因为接口的响应时长是不定的，如果先发出去的请求响应时长比后发出去的请求要久一些，后请求的响应先回来，先请求的响应后回来，就会出现前面请求响应结果覆盖后面请求响应结果的情况，那么就乱了。因此在这个场景下，我们除了做 debounce，还希望后面的请求发出去的时候，如果前面的请求还没有响应，我们可以把前面的请求取消。\n\n从 axios 的取消接口设计层面，我们希望做如下的设计：\n\nconst CancelToken = axios.CancelToken;\nconst source = CancelToken.source();\n\naxios.get('/user/12345', {\n  cancelToken: source.token\n}).catch(function (e) {\n  if (axios.isCancel(e)) {\n    console.log('Request canceled', e.message);\n  } else {\n    // 处理错误\n  }\n});\n\n// 取消请求 (请求原因是可选的)\nsource.cancel('Operation canceled by the user.');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n我们给 axios 添加一个 CancelToken 的对象，它有一个 source 方法可以返回一个 source 对象，source.token 是在每次请求的时候传给配置对象中的 cancelToken 属性，然后在请求发出去之后，我们可以通过 source.cancel 方法取消请求。\n\n我们还支持另一种方式的调用：\n\nconst CancelToken = axios.CancelToken;\nlet cancel;\n\naxios.get('/user/12345', {\n  cancelToken: new CancelToken(function executor(c) {\n    cancel = c;\n  })\n});\n\n// 取消请求\ncancel();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\naxios.CancelToken 是一个类，我们直接把它实例化的对象传给请求配置中的 cancelToken 属性，CancelToken 的构造函数参数支持传入一个 executor 方法，该方法的参数是一个取消函数 c，我们可以在 executor 方法执行的内部拿到这个取消函数 c，赋值给我们外部定义的 cancel 变量，之后我们可以通过调用这个 cancel 方法来取消请求。\n\n\n# 异步分离的设计方案\n\n通过需求分析，我们知道想要实现取消某次请求，我们需要为该请求配置一个 cancelToken，然后在外部调用一个 cancel 方法。\n\n请求的发送是一个异步过程，最终会执行 xhr.send 方法，xhr 对象提供了 abort 方法，可以把请求取消。因为我们在外部是碰不到 xhr 对象的，所以我们想在执行 cancel 的时候，去执行 xhr.abort 方法。\n\n现在就相当于我们在 xhr 异步请求过程中，插入一段代码，当我们在外部执行 cancel 函数的时候，会驱动这段代码的执行，然后执行 xhr.abort 方法取消请求。\n\n我们可以利用 Promise 实现异步分离，也就是在 cancelToken 中保存一个 pending 状态的 Promise 对象，然后当我们执行 cancel 方法的时候，能够访问到这个 Promise 对象，把它从 pending 状态变成 resolved 状态，这样我们就可以在 then 函数中去实现取消请求的逻辑，类似如下的代码：\n\n\nif (cancelToken) {\n  cancelToken.promise\n    .then(reason => {\n      request.abort()\n      reject(reason)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# CancelToken 类实现\n\n接下来，我们就来实现这个 CancelToken 类，先来看一下接口定义：\n\n\n# 接口定义\n\ntypes/index.ts：\n\nexport interface AxiosRequestConfig {\n  // ...\n  cancelToken?: CancelToken\n}\n\nexport interface CancelToken {\n  promise: Promise<string>\n  reason?: string\n}\n\nexport interface Canceler {\n  (message?: string): void\n}\n\nexport interface CancelExecutor {\n  (cancel: Canceler): void\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n其中 CancelToken 是实例类型的接口定义，Canceler 是取消方法的接口定义，CancelExecutor 是 CancelToken 类构造函数参数的接口定义。\n\n\n# 代码实现\n\n我们单独创建 cancel 目录来管理取消相关的代码，在 cancel 目录下创建 CancelToken.ts 文件：\n\nimport { CancelExecutor } from '../types'\n\ninterface ResolvePromise {\n  (reason?: string): void\n}\n\nexport default class CancelToken {\n  promise: Promise<string>\n  reason?: string\n\n  constructor(executor: CancelExecutor) {\n    let resolvePromise: ResolvePromise\n    this.promise = new Promise<string>(resolve => {\n      resolvePromise = resolve\n    })\n\n    executor(message => {\n      if (this.reason) {\n        return\n      }\n      this.reason = message\n      resolvePromise(this.reason)\n    })\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n在 CancelToken 构造函数内部，实例化一个 pending 状态的 Promise 对象，然后用一个 resolvePromise 变量指向 resolve 函数。接着执行 executor 函数，传入一个 cancel 函数，在 cancel 函数内部，会调用 resolvePromise 把 Promise 对象从 pending 状态变为 resolved 状态。\n\n接着我们在 xhr.ts 中插入一段取消请求的逻辑。\n\ncore/xhr.ts：\n\nconst { /*....*/ cancelToken } = config\n\nif (cancelToken) {\n  cancelToken.promise.then(reason => {\n    request.abort()\n    reject(reason)\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这样就满足了第二种使用方式，接着我们要实现第一种使用方式，给 CancelToken 扩展静态接口。\n\n\n# CancelToken 扩展静态接口\n\n\n# 接口定义\n\ntypes/index.ts：\n\nexport interface CancelTokenSource {\n  token: CancelToken\n  cancel: Canceler\n}\n\nexport interface CancelTokenStatic {\n  new(executor: CancelExecutor): CancelToken\n\n  source(): CancelTokenSource\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n其中 CancelTokenSource 作为 CancelToken 类静态方法 source 函数的返回值类型，CancelTokenStatic 则作为 CancelToken 类的类类型。\n\n\n# 代码实现\n\ncancel/CancelToken.ts：\n\nexport default class CancelToken {\n  // ...\n\n  static source(): CancelTokenSource {\n    let cancel!: Canceler\n    const token = new CancelToken(c => {\n      cancel = c\n    })\n    return {\n      cancel,\n      token\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nsource 的静态方法很简单，定义一个 cancel 变量实例化一个 CancelToken 类型的对象，然后在 executor 函数中，把 cancel 指向参数 c 这个取消函数。\n\n这样就满足了我们第一种使用方式，但是在第一种使用方式的例子中，我们在捕获请求的时候，通过 axios.isCancel 来判断这个错误参数 e 是不是一次取消请求导致的错误，接下来我们对取消错误的原因做一层包装，并且把给 axios 扩展静态方法\n\n\n# Cancel 类实现及 axios 的扩展\n\n\n# 接口定义\n\nexport interface Cancel {\n  message?: string\n}\n\nexport interface CancelStatic {\n  new(message?: string): Cancel\n}\n\nexport interface AxiosStatic extends AxiosInstance {\n  create(config?: AxiosRequestConfig): AxiosInstance\n\n  CancelToken: CancelTokenStatic\n  Cancel: CancelStatic\n  isCancel: (value: any) => boolean\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n其中 Cancel 是实例类型的接口定义，CancelStatic 是类类型的接口定义，并且我们给 axios 扩展了多个静态方法。\n\n\n# 代码实现\n\n我在 cancel 目录下创建 Cancel.ts 文件。\n\nexport default class Cancel {\n  message?: string\n\n  constructor(message?: string) {\n    this.message = message\n  }\n}\n\nexport function isCancel(value: any): boolean {\n  return value instanceof Cancel\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nCancel 类非常简单，拥有一个 message 的公共属性。isCancel 方法也非常简单，通过 instanceof 来判断传入的值是不是一个 Cancel 对象。\n\n接着我们对 CancelToken 类中的 reason 类型做修改，把它变成一个 Cancel 类型的实例。\n\n先修改定义部分。\n\ntypes/index.ts：\n\nexport interface CancelToken {\n  promise: Promise<Cancel>\n  reason?: Cancel\n}\n\n\n1\n2\n3\n4\n\n\n再修改实现部分：\n\nimport Cancel from './Cancel'\n\ninterface ResolvePromise {\n  (reason?: Cancel): void\n}\n\nexport default class CancelToken {\n  promise: Promise<Cancel>\n  reason?: Cancel\n\n  constructor(executor: CancelExecutor) {\n    let resolvePromise: ResolvePromise\n    this.promise = new Promise<Cancel>(resolve => {\n      resolvePromise = resolve\n    })\n\n    executor(message => {\n      if (this.reason) {\n        return\n      }\n      this.reason = new Cancel(message)\n      resolvePromise(this.reason)\n    })\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n接下来我们给 axios 扩展一些静态方法，供用户使用。\n\naxios.ts：\n\nimport CancelToken from './cancel/CancelToken'\nimport Cancel, { isCancel } from './cancel/Cancel'\n\naxios.CancelToken = CancelToken\naxios.Cancel = Cancel\naxios.isCancel = isCancel\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 额外逻辑实现\n\n除此之外，我们还需要实现一些额外逻辑，比如当一个请求携带的 cancelToken 已经被使用过，那么我们甚至都可以不发送这个请求，只需要抛一个异常即可，并且抛异常的信息就是我们取消的原因，所以我们需要给 CancelToken 扩展一个方法。\n\n先修改定义部分。\n\ntypes/index.ts：\n\nexport interface CancelToken {\n  promise: Promise<Cancel>\n  reason?: Cancel\n\n  throwIfRequested(): void\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n添加一个 throwIfRequested 方法，接下来实现它：\n\ncancel/CancelToken.ts：\n\nexport default class CancelToken {\n  // ...\n\n  throwIfRequested(): void {\n    if (this.reason) {\n      throw this.reason\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n判断如果存在 this.reason，说明这个 token 已经被使用过了，直接抛错。\n\n接下来在发送请求前增加一段逻辑。\n\ncore/dispatchRequest.ts：\n\nexport default function dispatchRequest(config: AxiosRequestConfig): AxiosPromise {\n  throwIfCancellationRequested(config)\n  processConfig(config)\n\n  // ...\n}\n\nfunction throwIfCancellationRequested(config: AxiosRequestConfig): void {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested()\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n发送请求前检查一下配置的 cancelToken 是否已经使用过了，如果已经被用过则不用法请求，直接抛异常。\n\n\n# demo 编写\n\n在 examples 目录下创建 cancel 目录，在 cancel 目录下创建 index.html:\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Cancel example</title>\n  </head>\n  <body>\n    <script src=\"/__build__/cancel.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n接着创建 app.ts 作为入口文件：\n\nimport axios, { Canceler } from '../../src/index'\n\nconst CancelToken = axios.CancelToken\nconst source = CancelToken.source()\n\naxios.get('/cancel/get', {\n  cancelToken: source.token\n}).catch(function(e) {\n  if (axios.isCancel(e)) {\n    console.log('Request canceled', e.message)\n  }\n})\n\nsetTimeout(() => {\n  source.cancel('Operation canceled by the user.')\n\n  axios.post('/cancel/post', { a: 1 }, { cancelToken: source.token }).catch(function(e) {\n    if (axios.isCancel(e)) {\n      console.log(e.message)\n    }\n  })\n}, 100)\n\nlet cancel: Canceler\n\naxios.get('/cancel/get', {\n  cancelToken: new CancelToken(c => {\n    cancel = c\n  })\n}).catch(function(e) {\n  if (axios.isCancel(e)) {\n    console.log('Request canceled')\n  }\n})\n\nsetTimeout(() => {\n  cancel()\n}, 200)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n我们的 demo 展示了 2 种使用方式，也演示了如果一个 token 已经被使用过，则再次携带该 token 的请求并不会发送。\n\n至此，我们完成了 ts-axios 的请求取消功能，我们巧妙地利用了 Promise 实现了异步分离。目前官方 axios 库的一些大的 feature 我们都已经实现了，下面的章节我们就开始补充完善 ts-axios 的其它功能。",normalizedContent:"# 取消功能的设计与实现\n\n\n# 需求分析\n\n有些场景下，我们希望能主动取消请求，比如常见的搜索框案例，在用户输入过程中，搜索框的内容也在不断变化，正常情况每次变化我们都应该向服务端发送一次请求。但是当用户输入过快的时候，我们不希望每次变化请求都发出去，通常一个解决方案是前端用 debounce 的方案，比如延时 200ms 发送请求。这样当用户连续输入的字符，只要输入间隔小于 200ms，前面输入的字符都不会发请求。\n\n但是还有一种极端情况是后端接口很慢，比如超过 1s 才能响应，这个时候即使做了 200ms 的 debounce，但是在我慢慢输入（每个输入间隔超过 200ms）的情况下，在前面的请求没有响应前，也有可能发出去多个请求。因为接口的响应时长是不定的，如果先发出去的请求响应时长比后发出去的请求要久一些，后请求的响应先回来，先请求的响应后回来，就会出现前面请求响应结果覆盖后面请求响应结果的情况，那么就乱了。因此在这个场景下，我们除了做 debounce，还希望后面的请求发出去的时候，如果前面的请求还没有响应，我们可以把前面的请求取消。\n\n从 axios 的取消接口设计层面，我们希望做如下的设计：\n\nconst canceltoken = axios.canceltoken;\nconst source = canceltoken.source();\n\naxios.get('/user/12345', {\n  canceltoken: source.token\n}).catch(function (e) {\n  if (axios.iscancel(e)) {\n    console.log('request canceled', e.message);\n  } else {\n    // 处理错误\n  }\n});\n\n// 取消请求 (请求原因是可选的)\nsource.cancel('operation canceled by the user.');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n我们给 axios 添加一个 canceltoken 的对象，它有一个 source 方法可以返回一个 source 对象，source.token 是在每次请求的时候传给配置对象中的 canceltoken 属性，然后在请求发出去之后，我们可以通过 source.cancel 方法取消请求。\n\n我们还支持另一种方式的调用：\n\nconst canceltoken = axios.canceltoken;\nlet cancel;\n\naxios.get('/user/12345', {\n  canceltoken: new canceltoken(function executor(c) {\n    cancel = c;\n  })\n});\n\n// 取消请求\ncancel();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\naxios.canceltoken 是一个类，我们直接把它实例化的对象传给请求配置中的 canceltoken 属性，canceltoken 的构造函数参数支持传入一个 executor 方法，该方法的参数是一个取消函数 c，我们可以在 executor 方法执行的内部拿到这个取消函数 c，赋值给我们外部定义的 cancel 变量，之后我们可以通过调用这个 cancel 方法来取消请求。\n\n\n# 异步分离的设计方案\n\n通过需求分析，我们知道想要实现取消某次请求，我们需要为该请求配置一个 canceltoken，然后在外部调用一个 cancel 方法。\n\n请求的发送是一个异步过程，最终会执行 xhr.send 方法，xhr 对象提供了 abort 方法，可以把请求取消。因为我们在外部是碰不到 xhr 对象的，所以我们想在执行 cancel 的时候，去执行 xhr.abort 方法。\n\n现在就相当于我们在 xhr 异步请求过程中，插入一段代码，当我们在外部执行 cancel 函数的时候，会驱动这段代码的执行，然后执行 xhr.abort 方法取消请求。\n\n我们可以利用 promise 实现异步分离，也就是在 canceltoken 中保存一个 pending 状态的 promise 对象，然后当我们执行 cancel 方法的时候，能够访问到这个 promise 对象，把它从 pending 状态变成 resolved 状态，这样我们就可以在 then 函数中去实现取消请求的逻辑，类似如下的代码：\n\n\nif (canceltoken) {\n  canceltoken.promise\n    .then(reason => {\n      request.abort()\n      reject(reason)\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# canceltoken 类实现\n\n接下来，我们就来实现这个 canceltoken 类，先来看一下接口定义：\n\n\n# 接口定义\n\ntypes/index.ts：\n\nexport interface axiosrequestconfig {\n  // ...\n  canceltoken?: canceltoken\n}\n\nexport interface canceltoken {\n  promise: promise<string>\n  reason?: string\n}\n\nexport interface canceler {\n  (message?: string): void\n}\n\nexport interface cancelexecutor {\n  (cancel: canceler): void\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n其中 canceltoken 是实例类型的接口定义，canceler 是取消方法的接口定义，cancelexecutor 是 canceltoken 类构造函数参数的接口定义。\n\n\n# 代码实现\n\n我们单独创建 cancel 目录来管理取消相关的代码，在 cancel 目录下创建 canceltoken.ts 文件：\n\nimport { cancelexecutor } from '../types'\n\ninterface resolvepromise {\n  (reason?: string): void\n}\n\nexport default class canceltoken {\n  promise: promise<string>\n  reason?: string\n\n  constructor(executor: cancelexecutor) {\n    let resolvepromise: resolvepromise\n    this.promise = new promise<string>(resolve => {\n      resolvepromise = resolve\n    })\n\n    executor(message => {\n      if (this.reason) {\n        return\n      }\n      this.reason = message\n      resolvepromise(this.reason)\n    })\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n在 canceltoken 构造函数内部，实例化一个 pending 状态的 promise 对象，然后用一个 resolvepromise 变量指向 resolve 函数。接着执行 executor 函数，传入一个 cancel 函数，在 cancel 函数内部，会调用 resolvepromise 把 promise 对象从 pending 状态变为 resolved 状态。\n\n接着我们在 xhr.ts 中插入一段取消请求的逻辑。\n\ncore/xhr.ts：\n\nconst { /*....*/ canceltoken } = config\n\nif (canceltoken) {\n  canceltoken.promise.then(reason => {\n    request.abort()\n    reject(reason)\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这样就满足了第二种使用方式，接着我们要实现第一种使用方式，给 canceltoken 扩展静态接口。\n\n\n# canceltoken 扩展静态接口\n\n\n# 接口定义\n\ntypes/index.ts：\n\nexport interface canceltokensource {\n  token: canceltoken\n  cancel: canceler\n}\n\nexport interface canceltokenstatic {\n  new(executor: cancelexecutor): canceltoken\n\n  source(): canceltokensource\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n其中 canceltokensource 作为 canceltoken 类静态方法 source 函数的返回值类型，canceltokenstatic 则作为 canceltoken 类的类类型。\n\n\n# 代码实现\n\ncancel/canceltoken.ts：\n\nexport default class canceltoken {\n  // ...\n\n  static source(): canceltokensource {\n    let cancel!: canceler\n    const token = new canceltoken(c => {\n      cancel = c\n    })\n    return {\n      cancel,\n      token\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nsource 的静态方法很简单，定义一个 cancel 变量实例化一个 canceltoken 类型的对象，然后在 executor 函数中，把 cancel 指向参数 c 这个取消函数。\n\n这样就满足了我们第一种使用方式，但是在第一种使用方式的例子中，我们在捕获请求的时候，通过 axios.iscancel 来判断这个错误参数 e 是不是一次取消请求导致的错误，接下来我们对取消错误的原因做一层包装，并且把给 axios 扩展静态方法\n\n\n# cancel 类实现及 axios 的扩展\n\n\n# 接口定义\n\nexport interface cancel {\n  message?: string\n}\n\nexport interface cancelstatic {\n  new(message?: string): cancel\n}\n\nexport interface axiosstatic extends axiosinstance {\n  create(config?: axiosrequestconfig): axiosinstance\n\n  canceltoken: canceltokenstatic\n  cancel: cancelstatic\n  iscancel: (value: any) => boolean\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n其中 cancel 是实例类型的接口定义，cancelstatic 是类类型的接口定义，并且我们给 axios 扩展了多个静态方法。\n\n\n# 代码实现\n\n我在 cancel 目录下创建 cancel.ts 文件。\n\nexport default class cancel {\n  message?: string\n\n  constructor(message?: string) {\n    this.message = message\n  }\n}\n\nexport function iscancel(value: any): boolean {\n  return value instanceof cancel\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ncancel 类非常简单，拥有一个 message 的公共属性。iscancel 方法也非常简单，通过 instanceof 来判断传入的值是不是一个 cancel 对象。\n\n接着我们对 canceltoken 类中的 reason 类型做修改，把它变成一个 cancel 类型的实例。\n\n先修改定义部分。\n\ntypes/index.ts：\n\nexport interface canceltoken {\n  promise: promise<cancel>\n  reason?: cancel\n}\n\n\n1\n2\n3\n4\n\n\n再修改实现部分：\n\nimport cancel from './cancel'\n\ninterface resolvepromise {\n  (reason?: cancel): void\n}\n\nexport default class canceltoken {\n  promise: promise<cancel>\n  reason?: cancel\n\n  constructor(executor: cancelexecutor) {\n    let resolvepromise: resolvepromise\n    this.promise = new promise<cancel>(resolve => {\n      resolvepromise = resolve\n    })\n\n    executor(message => {\n      if (this.reason) {\n        return\n      }\n      this.reason = new cancel(message)\n      resolvepromise(this.reason)\n    })\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n接下来我们给 axios 扩展一些静态方法，供用户使用。\n\naxios.ts：\n\nimport canceltoken from './cancel/canceltoken'\nimport cancel, { iscancel } from './cancel/cancel'\n\naxios.canceltoken = canceltoken\naxios.cancel = cancel\naxios.iscancel = iscancel\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 额外逻辑实现\n\n除此之外，我们还需要实现一些额外逻辑，比如当一个请求携带的 canceltoken 已经被使用过，那么我们甚至都可以不发送这个请求，只需要抛一个异常即可，并且抛异常的信息就是我们取消的原因，所以我们需要给 canceltoken 扩展一个方法。\n\n先修改定义部分。\n\ntypes/index.ts：\n\nexport interface canceltoken {\n  promise: promise<cancel>\n  reason?: cancel\n\n  throwifrequested(): void\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n添加一个 throwifrequested 方法，接下来实现它：\n\ncancel/canceltoken.ts：\n\nexport default class canceltoken {\n  // ...\n\n  throwifrequested(): void {\n    if (this.reason) {\n      throw this.reason\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n判断如果存在 this.reason，说明这个 token 已经被使用过了，直接抛错。\n\n接下来在发送请求前增加一段逻辑。\n\ncore/dispatchrequest.ts：\n\nexport default function dispatchrequest(config: axiosrequestconfig): axiospromise {\n  throwifcancellationrequested(config)\n  processconfig(config)\n\n  // ...\n}\n\nfunction throwifcancellationrequested(config: axiosrequestconfig): void {\n  if (config.canceltoken) {\n    config.canceltoken.throwifrequested()\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n发送请求前检查一下配置的 canceltoken 是否已经使用过了，如果已经被用过则不用法请求，直接抛异常。\n\n\n# demo 编写\n\n在 examples 目录下创建 cancel 目录，在 cancel 目录下创建 index.html:\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>cancel example</title>\n  </head>\n  <body>\n    <script src=\"/__build__/cancel.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n接着创建 app.ts 作为入口文件：\n\nimport axios, { canceler } from '../../src/index'\n\nconst canceltoken = axios.canceltoken\nconst source = canceltoken.source()\n\naxios.get('/cancel/get', {\n  canceltoken: source.token\n}).catch(function(e) {\n  if (axios.iscancel(e)) {\n    console.log('request canceled', e.message)\n  }\n})\n\nsettimeout(() => {\n  source.cancel('operation canceled by the user.')\n\n  axios.post('/cancel/post', { a: 1 }, { canceltoken: source.token }).catch(function(e) {\n    if (axios.iscancel(e)) {\n      console.log(e.message)\n    }\n  })\n}, 100)\n\nlet cancel: canceler\n\naxios.get('/cancel/get', {\n  canceltoken: new canceltoken(c => {\n    cancel = c\n  })\n}).catch(function(e) {\n  if (axios.iscancel(e)) {\n    console.log('request canceled')\n  }\n})\n\nsettimeout(() => {\n  cancel()\n}, 200)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n我们的 demo 展示了 2 种使用方式，也演示了如果一个 token 已经被使用过，则再次携带该 token 的请求并不会发送。\n\n至此，我们完成了 ts-axios 的请求取消功能，我们巧妙地利用了 promise 实现了异步分离。目前官方 axios 库的一些大的 feature 我们都已经实现了，下面的章节我们就开始补充完善 ts-axios 的其它功能。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"withCredentials",frontmatter:{title:"withCredentials",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/5dce43eba796a2ab",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 更多功能实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/10.ts-axios%20%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/01.withCredentials.html",relativePath:"《TypeScript 从零实现 axios》/10.ts-axios 更多功能实现/01.withCredentials.md",key:"v-4555a0c3",path:"/pages/5dce43eba796a2ab/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:22},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:382},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:673}],headersStr:"需求分析 代码实现 demo 编写",content:"# withCredentials\n\n\n# 需求分析\n\n有些时候我们会发一些跨域请求，比如 http://domain-a.com 站点发送一个 http://api.domain-b.com/get 的请求，默认情况下，浏览器会根据同源策略限制这种跨域请求，但是可以通过 CORS 技术解决跨域问题。\n\n在同域的情况下，我们发送请求会默认携带当前域下的 cookie，但是在跨域的情况下，默认是不会携带请求域下的 cookie 的，比如 http://domain-a.com 站点发送一个 http://api.domain-b.com/get 的请求，默认是不会携带 api.domain-b.com 域下的 cookie，如果我们想携带（很多情况下是需要的），只需要设置请求的 xhr 对象的 withCredentials 为 true 即可。\n\n\n# 代码实现\n\n先修改 AxiosRequestConfig 的类型定义。\n\ntypes/index.ts：\n\nexport interface AxiosRequestConfig {\n  // ...\n  withCredentials?: boolean\n}\n\n\n1\n2\n3\n4\n\n\n然后修改请求发送前的逻辑。\n\ncore/xhr.ts：\n\nconst { /*...*/ withCredentials } = config\n\nif (withCredentials) {\n  request.withCredentials = true\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# demo 编写\n\n在 examples 目录下创建 more 目录，在 cancel 目录下创建 index.html:\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>More example</title>\n  </head>\n  <body>\n    <script src=\"/__build__/more.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n接着创建 app.ts 作为入口文件：\n\nimport axios from '../../src/index'\n\ndocument.cookie = 'a=b'\n\naxios.get('/more/get').then(res => {\n  console.log(res)\n})\n\naxios.post('http://127.0.0.1:8088/more/server2', { }, {\n  withCredentials: true\n}).then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这次我们除了给 server.js 去配置了接口路由，还创建了 server2.js，起了一个跨域的服务。\n\nconst express = require('express')\nconst bodyParser = require('body-parser')\nconst cookieParser = require('cookie-parser')\n\nconst app = express()\n\napp.use(bodyParser.json())\napp.use(bodyParser.urlencoded({ extended: true }))\napp.use(cookieParser())\n\nconst router = express.Router()\n\nconst cors = {\n  'Access-Control-Allow-Origin': 'http://localhost:8080',\n  'Access-Control-Allow-Credentials': true,\n  'Access-Control-Allow-Methods': 'POST, GET, PUT, DELETE, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type'\n}\n\nrouter.post('/more/server2', function(req, res) {\n  res.set(cors)\n  res.json(req.cookies)\n})\n\nrouter.options('/more/server2', function(req, res) {\n  res.set(cors)\n  res.end()\n})\n\napp.use(router)\n\nconst port = 8088\nmodule.exports = app.listen(port)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n这里需要安装一下 cookie-parser 插件，用于请求发送的 cookie。\n\n通过 demo 演示我们可以发现，对于同域请求，会携带 cookie，而对于跨域请求，只有我们配置了 withCredentials 为 true，才会携带 cookie。\n\n至此我们的 withCredentials feature 开发完毕，下一节课我们来实现 axios 对 XSRF 的防御功能。",normalizedContent:"# withcredentials\n\n\n# 需求分析\n\n有些时候我们会发一些跨域请求，比如 http://domain-a.com 站点发送一个 http://api.domain-b.com/get 的请求，默认情况下，浏览器会根据同源策略限制这种跨域请求，但是可以通过 cors 技术解决跨域问题。\n\n在同域的情况下，我们发送请求会默认携带当前域下的 cookie，但是在跨域的情况下，默认是不会携带请求域下的 cookie 的，比如 http://domain-a.com 站点发送一个 http://api.domain-b.com/get 的请求，默认是不会携带 api.domain-b.com 域下的 cookie，如果我们想携带（很多情况下是需要的），只需要设置请求的 xhr 对象的 withcredentials 为 true 即可。\n\n\n# 代码实现\n\n先修改 axiosrequestconfig 的类型定义。\n\ntypes/index.ts：\n\nexport interface axiosrequestconfig {\n  // ...\n  withcredentials?: boolean\n}\n\n\n1\n2\n3\n4\n\n\n然后修改请求发送前的逻辑。\n\ncore/xhr.ts：\n\nconst { /*...*/ withcredentials } = config\n\nif (withcredentials) {\n  request.withcredentials = true\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# demo 编写\n\n在 examples 目录下创建 more 目录，在 cancel 目录下创建 index.html:\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>more example</title>\n  </head>\n  <body>\n    <script src=\"/__build__/more.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n接着创建 app.ts 作为入口文件：\n\nimport axios from '../../src/index'\n\ndocument.cookie = 'a=b'\n\naxios.get('/more/get').then(res => {\n  console.log(res)\n})\n\naxios.post('http://127.0.0.1:8088/more/server2', { }, {\n  withcredentials: true\n}).then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这次我们除了给 server.js 去配置了接口路由，还创建了 server2.js，起了一个跨域的服务。\n\nconst express = require('express')\nconst bodyparser = require('body-parser')\nconst cookieparser = require('cookie-parser')\n\nconst app = express()\n\napp.use(bodyparser.json())\napp.use(bodyparser.urlencoded({ extended: true }))\napp.use(cookieparser())\n\nconst router = express.router()\n\nconst cors = {\n  'access-control-allow-origin': 'http://localhost:8080',\n  'access-control-allow-credentials': true,\n  'access-control-allow-methods': 'post, get, put, delete, options',\n  'access-control-allow-headers': 'content-type'\n}\n\nrouter.post('/more/server2', function(req, res) {\n  res.set(cors)\n  res.json(req.cookies)\n})\n\nrouter.options('/more/server2', function(req, res) {\n  res.set(cors)\n  res.end()\n})\n\napp.use(router)\n\nconst port = 8088\nmodule.exports = app.listen(port)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n这里需要安装一下 cookie-parser 插件，用于请求发送的 cookie。\n\n通过 demo 演示我们可以发现，对于同域请求，会携带 cookie，而对于跨域请求，只有我们配置了 withcredentials 为 true，才会携带 cookie。\n\n至此我们的 withcredentials feature 开发完毕，下一节课我们来实现 axios 对 xsrf 的防御功能。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"XSRF 防御",frontmatter:{title:"XSRF 防御",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/390cb70e2b619449",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 更多功能实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/10.ts-axios%20%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/02.XSRF%20%E9%98%B2%E5%BE%A1.html",relativePath:"《TypeScript 从零实现 axios》/10.ts-axios 更多功能实现/02.XSRF 防御.md",key:"v-6e015157",path:"/pages/390cb70e2b619449/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:14},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:833},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:2775}],headersStr:"需求分析 代码实现 demo 编写",content:"# XSRF 防御\n\n\n# 需求分析\n\nXSRF 又名 CSRF，跨站请求伪造，它是前端常见的一种攻击方式，我们先通过一张图来认识它的攻击手段。\n\n\n\nCSRF 的防御手段有很多，比如验证请求的 referer，但是 referer 也是可以伪造的，所以杜绝此类攻击的一种方式是服务器端要求每次请求都包含一个 token，这个 token 不在前端生成，而是在我们每次访问站点的时候生成，并通过 set-cookie 的方式种到客户端，然后客户端发送请求的时候，从 cookie 中对应的字段读取出 token，然后添加到请求 headers 中。这样服务端就可以从请求 headers 中读取这个 token 并验证，由于这个 token 是很难伪造的，所以就能区分这个请求是否是用户正常发起的。\n\n对于我们的 ts-axios 库，我们要自动把这几件事做了，每次发送请求的时候，从 cookie 中读取对应的 token 值，然后添加到请求 headers中。我们允许用户配置 xsrfCookieName 和 xsrfHeaderName，其中 xsrfCookieName 表示存储 token 的 cookie 名称，xsrfHeaderName 表示请求 headers 中 token 对应的 header 名称。\n\naxios.get('/more/get',{\n  xsrfCookieName: 'XSRF-TOKEN', // default\n  xsrfHeaderName: 'X-XSRF-TOKEN' // default\n}).then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n我们提供 xsrfCookieName 和 xsrfHeaderName 的默认值，当然用户也可以根据自己的需求在请求中去配置 xsrfCookieName 和 xsrfHeaderName。\n\n\n# 代码实现\n\n先修改 AxiosRequestConfig 的类型定义。\n\ntypes/index.ts：\n\nexport interface AxiosRequestConfig {\n  // ...\n  xsrfCookieName?: string\n  xsrfHeaderName?: string\n}\n\n\n1\n2\n3\n4\n5\n\n\n然后修改默认配置。\n\ndefaults.ts：\n\nconst defaults: AxiosRequestConfig = {\n  // ...\n  xsrfCookieName: 'XSRF-TOKEN',\n\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n接下来我们要做三件事：\n\n * 首先判断如果是配置 withCredentials 为 true 或者是同域请求，我们才会请求 headers 添加 xsrf 相关的字段。\n\n * 如果判断成功，尝试从 cookie 中读取 xsrf 的 token 值。\n\n * 如果能读到，则把它添加到请求 headers 的 xsrf 相关字段中。\n\n我们先来实现同域请求的判断。\n\nhelpers/url.ts：\n\ninterface URLOrigin {\n  protocol: string\n  host: string\n}\n\n\nexport function isURLSameOrigin(requestURL: string): boolean {\n  const parsedOrigin = resolveURL(requestURL)\n  return (\n    parsedOrigin.protocol === currentOrigin.protocol && parsedOrigin.host === currentOrigin.host\n  )\n}\n\nconst urlParsingNode = document.createElement('a')\nconst currentOrigin = resolveURL(window.location.href)\n\nfunction resolveURL(url: string): URLOrigin {\n  urlParsingNode.setAttribute('href', url)\n  const { protocol, host } = urlParsingNode\n\n  return {\n    protocol,\n    host\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n同域名的判断主要利用了一个技巧，创建一个 a 标签的 DOM，然后设置 href 属性为我们传入的 url，然后可以获取该 DOM 的 protocol、host。当前页面的 url 和请求的 url 都通过这种方式获取，然后对比它们的 protocol 和 host 是否相同即可。\n\n接着实现 cookie 的读取。\n\nhelpers/cookie.ts：\n\nconst cookie = {\n  read(name: string): string | null {\n    const match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'))\n    return match ? decodeURIComponent(match[3]) : null\n  }\n}\n\nexport default cookie\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ncookie 的读取逻辑很简单，利用了正则表达式可以解析到 name 对应的值。\n\n最后实现完整的逻辑。\n\ncore/xhr.ts：\n\nconst {\n  /*...*/\n  xsrfCookieName,\n  xsrfHeaderName\n} = config\n\nif ((withCredentials || isURLSameOrigin(url!)) && xsrfCookieName){\n  const xsrfValue = cookie.read(xsrfCookieName)\n  if (xsrfValue) {\n    headers[xsrfHeaderName!] = xsrfValue\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# demo 编写\n\nconst instance = axios.create({\n  xsrfCookieName: 'XSRF-TOKEN-D',\n  xsrfHeaderName: 'X-XSRF-TOKEN-D'\n})\n\ninstance.get('/more/get').then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nexamples/server.js：\n\napp.use(express.static(__dirname, {\n  setHeaders (res) {\n    res.cookie('XSRF-TOKEN-D', '1234abc')\n  }\n}))\n\n\n1\n2\n3\n4\n5\n\n\n在访问页面的时候，服务端通过 set-cookie 往客户端种了 key 为 XSRF-TOKEN，值为 1234abc 的 cookie，作为 xsrf 的 token 值。\n\n然后我们在前端发送请求的时候，就能从 cookie 中读出 key 为 XSRF-TOKEN 的值，然后把它添加到 key 为 X-XSRF-TOKEN 的请求 headers 中。\n\n至此，我们实现了 XSRF 的自动防御的能力，下节课我们来实现 ts-axios 对上传和下载请求的支持。",normalizedContent:"# xsrf 防御\n\n\n# 需求分析\n\nxsrf 又名 csrf，跨站请求伪造，它是前端常见的一种攻击方式，我们先通过一张图来认识它的攻击手段。\n\n\n\ncsrf 的防御手段有很多，比如验证请求的 referer，但是 referer 也是可以伪造的，所以杜绝此类攻击的一种方式是服务器端要求每次请求都包含一个 token，这个 token 不在前端生成，而是在我们每次访问站点的时候生成，并通过 set-cookie 的方式种到客户端，然后客户端发送请求的时候，从 cookie 中对应的字段读取出 token，然后添加到请求 headers 中。这样服务端就可以从请求 headers 中读取这个 token 并验证，由于这个 token 是很难伪造的，所以就能区分这个请求是否是用户正常发起的。\n\n对于我们的 ts-axios 库，我们要自动把这几件事做了，每次发送请求的时候，从 cookie 中读取对应的 token 值，然后添加到请求 headers中。我们允许用户配置 xsrfcookiename 和 xsrfheadername，其中 xsrfcookiename 表示存储 token 的 cookie 名称，xsrfheadername 表示请求 headers 中 token 对应的 header 名称。\n\naxios.get('/more/get',{\n  xsrfcookiename: 'xsrf-token', // default\n  xsrfheadername: 'x-xsrf-token' // default\n}).then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n我们提供 xsrfcookiename 和 xsrfheadername 的默认值，当然用户也可以根据自己的需求在请求中去配置 xsrfcookiename 和 xsrfheadername。\n\n\n# 代码实现\n\n先修改 axiosrequestconfig 的类型定义。\n\ntypes/index.ts：\n\nexport interface axiosrequestconfig {\n  // ...\n  xsrfcookiename?: string\n  xsrfheadername?: string\n}\n\n\n1\n2\n3\n4\n5\n\n\n然后修改默认配置。\n\ndefaults.ts：\n\nconst defaults: axiosrequestconfig = {\n  // ...\n  xsrfcookiename: 'xsrf-token',\n\n  xsrfheadername: 'x-xsrf-token',\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n接下来我们要做三件事：\n\n * 首先判断如果是配置 withcredentials 为 true 或者是同域请求，我们才会请求 headers 添加 xsrf 相关的字段。\n\n * 如果判断成功，尝试从 cookie 中读取 xsrf 的 token 值。\n\n * 如果能读到，则把它添加到请求 headers 的 xsrf 相关字段中。\n\n我们先来实现同域请求的判断。\n\nhelpers/url.ts：\n\ninterface urlorigin {\n  protocol: string\n  host: string\n}\n\n\nexport function isurlsameorigin(requesturl: string): boolean {\n  const parsedorigin = resolveurl(requesturl)\n  return (\n    parsedorigin.protocol === currentorigin.protocol && parsedorigin.host === currentorigin.host\n  )\n}\n\nconst urlparsingnode = document.createelement('a')\nconst currentorigin = resolveurl(window.location.href)\n\nfunction resolveurl(url: string): urlorigin {\n  urlparsingnode.setattribute('href', url)\n  const { protocol, host } = urlparsingnode\n\n  return {\n    protocol,\n    host\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n同域名的判断主要利用了一个技巧，创建一个 a 标签的 dom，然后设置 href 属性为我们传入的 url，然后可以获取该 dom 的 protocol、host。当前页面的 url 和请求的 url 都通过这种方式获取，然后对比它们的 protocol 和 host 是否相同即可。\n\n接着实现 cookie 的读取。\n\nhelpers/cookie.ts：\n\nconst cookie = {\n  read(name: string): string | null {\n    const match = document.cookie.match(new regexp('(^|;\\\\s*)(' + name + ')=([^;]*)'))\n    return match ? decodeuricomponent(match[3]) : null\n  }\n}\n\nexport default cookie\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ncookie 的读取逻辑很简单，利用了正则表达式可以解析到 name 对应的值。\n\n最后实现完整的逻辑。\n\ncore/xhr.ts：\n\nconst {\n  /*...*/\n  xsrfcookiename,\n  xsrfheadername\n} = config\n\nif ((withcredentials || isurlsameorigin(url!)) && xsrfcookiename){\n  const xsrfvalue = cookie.read(xsrfcookiename)\n  if (xsrfvalue) {\n    headers[xsrfheadername!] = xsrfvalue\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# demo 编写\n\nconst instance = axios.create({\n  xsrfcookiename: 'xsrf-token-d',\n  xsrfheadername: 'x-xsrf-token-d'\n})\n\ninstance.get('/more/get').then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nexamples/server.js：\n\napp.use(express.static(__dirname, {\n  setheaders (res) {\n    res.cookie('xsrf-token-d', '1234abc')\n  }\n}))\n\n\n1\n2\n3\n4\n5\n\n\n在访问页面的时候，服务端通过 set-cookie 往客户端种了 key 为 xsrf-token，值为 1234abc 的 cookie，作为 xsrf 的 token 值。\n\n然后我们在前端发送请求的时候，就能从 cookie 中读出 key 为 xsrf-token 的值，然后把它添加到 key 为 x-xsrf-token 的请求 headers 中。\n\n至此，我们实现了 xsrf 的自动防御的能力，下节课我们来实现 ts-axios 对上传和下载请求的支持。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"上传和下载的进度监控",frontmatter:{title:"上传和下载的进度监控",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/1376fd897809036e",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 更多功能实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/10.ts-axios%20%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/03.%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%E7%9A%84%E8%BF%9B%E5%BA%A6%E7%9B%91%E6%8E%A7.html",relativePath:"《TypeScript 从零实现 axios》/10.ts-axios 更多功能实现/03.上传和下载的进度监控.md",key:"v-2721eb0a",path:"/pages/1376fd897809036e/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:17},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:468},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:5368}],headersStr:"需求分析 代码实现 demo 编写",content:"# 上传和下载的进度监控\n\n\n# 需求分析\n\n有些时候，当我们上传文件或者是请求一个大体积数据的时候，希望知道实时的进度，甚至可以基于此做一个进度条的展示。\n\n我们希望给 axios 的请求配置提供 onDownloadProgress 和 onUploadProgress 2 个函数属性，用户可以通过这俩函数实现对下载进度和上传进度的监控。\n\naxios.get('/more/get',{\n  onDownloadProgress(progressEvent) {\n    // 监听下载进度\n  }\n})\n\naxios.post('/more/post',{\n  onUploadProgress(progressEvent) {\n    // 监听上传进度\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nxhr 对象提供了一个 progress 事件，我们可以监听此事件对数据的下载进度做监控；另外，xhr.uplaod 对象也提供了 progress 事件，我们可以基于此对上传进度做监控。\n\n\n# 代码实现\n\n首先修改一下类型定义。\n\ntypes/index.ts：\n\nexport interface AxiosRequestConfig {\n  // ...\n  onDownloadProgress?: (e: ProgressEvent) => void\n  onUploadProgress?: (e: ProgressEvent) => void\n}\n\n\n1\n2\n3\n4\n5\n\n\n接着在发送请求前，给 xhr 对象添加属性。\n\ncore/xhr.ts：\n\nconst {\n  /*...*/\n  onDownloadProgress,\n  onUploadProgress\n} = config\n\nif (onDownloadProgress) {\n  request.onprogress = onDownloadProgress\n}\n\nif (onUploadProgress) {\n  request.upload.onprogress = onUploadProgress\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n另外，如果请求的数据是 FormData 类型，我们应该主动删除请求 headers 中的 Content-Type 字段，让浏览器自动根据请求数据设置 Content-Type。比如当我们通过 FormData 上传文件的时候，浏览器会把请求 headers 中的 Content-Type 设置为 multipart/form-data。\n\n我们先添加一个判断 FormData 的方法。\n\nhelpers/util.ts：\n\nexport function isFormData(val: any): boolean {\n  return typeof val !== 'undefined' && val instanceof FormData\n}\n\n\n1\n2\n3\n\n\n然后再添加相关逻辑。\n\ncore/xhr.ts：\n\nif (isFormData(data)) {\n  delete headers['Content-Type']\n}\n\n\n1\n2\n3\n\n\n我们发现，xhr 函数内部随着需求越来越多，代码也越来越臃肿，我们可以把逻辑梳理一下，把内部代码做一层封装优化。\n\nexport default function xhr(config: AxiosRequestConfig): AxiosPromise {\n  return new Promise((resolve, reject) => {\n    const {\n      data = null,\n      url,\n      method = 'get',\n      headers,\n      responseType,\n      timeout,\n      cancelToken,\n      withCredentials,\n      xsrfCookieName,\n      xsrfHeaderName,\n      onDownloadProgress,\n      onUploadProgress\n    } = config\n\n    const request = new XMLHttpRequest()\n\n    request.open(method.toUpperCase(), url!, true)\n\n    configureRequest()\n\n    addEvents()\n\n    processHeaders()\n\n    processCancel()\n\n    request.send(data)\n\n    function configureRequest(): void {\n      if (responseType) {\n        request.responseType = responseType\n      }\n\n      if (timeout) {\n        request.timeout = timeout\n      }\n\n      if (withCredentials) {\n        request.withCredentials = withCredentials\n      }\n    }\n\n    function addEvents(): void {\n      request.onreadystatechange = function handleLoad() {\n        if (request.readyState !== 4) {\n          return\n        }\n\n        if (request.status === 0) {\n          return\n        }\n\n        const responseHeaders = parseHeaders(request.getAllResponseHeaders())\n        const responseData =\n          responseType && responseType !== 'text' ? request.response : request.responseText\n        const response: AxiosResponse = {\n          data: responseData,\n          status: request.status,\n          statusText: request.statusText,\n          headers: responseHeaders,\n          config,\n          request\n        }\n        handleResponse(response)\n      }\n\n      request.onerror = function handleError() {\n        reject(createError('Network Error', config, null, request))\n      }\n\n      request.ontimeout = function handleTimeout() {\n        reject(\n          createError(`Timeout of ${config.timeout} ms exceeded`, config, 'ECONNABORTED', request)\n        )\n      }\n\n      if (onDownloadProgress) {\n        request.onprogress = onDownloadProgress\n      }\n\n      if (onUploadProgress) {\n        request.upload.onprogress = onUploadProgress\n      }\n    }\n\n    function processHeaders(): void {\n      if (isFormData(data)) {\n        delete headers['Content-Type']\n      }\n\n      if ((withCredentials || isURLSameOrigin(url!)) && xsrfCookieName) {\n        const xsrfValue = cookie.read(xsrfCookieName)\n        if (xsrfValue) {\n          headers[xsrfHeaderName!] = xsrfValue\n        }\n      }\n\n      Object.keys(headers).forEach(name => {\n        if (data === null && name.toLowerCase() === 'content-type') {\n          delete headers[name]\n        } else {\n          request.setRequestHeader(name, headers[name])\n        }\n      })\n    }\n\n    function processCancel(): void {\n      if (cancelToken) {\n        cancelToken.promise.then(reason => {\n          request.abort()\n          reject(reason)\n        })\n      }\n    }\n\n    function handleResponse(response: AxiosResponse): void {\n      if (response.status >= 200 && response.status < 300) {\n        resolve(response)\n      } else {\n        reject(\n          createError(\n            `Request failed with status code ${response.status}`,\n            config,\n            null,\n            request,\n            response\n          )\n        )\n      }\n    }\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n\n\n我们把整个流程分为 7 步：\n\n * 创建一个 request 实例。\n * 执行 request.open 方法初始化。\n * 执行 configureRequest 配置 request 对象。\n * 执行 addEvents 给 request 添加事件处理函数。\n * 执行 processHeaders 处理请求 headers。\n * 执行 processCancel 处理请求取消逻辑。\n * 执行 request.send 方法发送请求。\n\n这样拆分后整个流程就会显得非常清晰，未来我们再去新增需求的时候代码也不会显得越来越臃肿。\n\n\n# demo 编写\n\n这节课的 demo 非常有意思，我们第一次给界面上增加了一些交互的按钮。\n\nexamples/more/index.html\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>More example</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css\"/>\n</head>\n<body>\n<h1>file download</h1>\n<div>\n  <button id=\"download\" class=\"btn btn-primary\">Download</button>\n</div>\n<h1>file upload</h1>\n<form role=\"form\" class=\"form\" onsubmit=\"return false;\">\n  <input id=\"file\" type=\"file\" class=\"form-control\"/>\n  <button id=\"upload\" type=\"button\" class=\"btn btn-primary\">Upload</button>\n</form>\n\n<script src=\"/__build__/more.js\"><\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n另外，我们为了友好地展示上传和下载进度，我们引入了一个开源库 nprogress，它可以在页面的顶部展示进度条。\n\nexamples/more/app.ts：\n\nconst instance = axios.create()\n\nfunction calculatePercentage(loaded: number, total: number) {\n  return Math.floor(loaded * 1.0) / total\n}\n\nfunction loadProgressBar() {\n  const setupStartProgress = () => {\n    instance.interceptors.request.use(config => {\n      NProgress.start()\n      return config\n    })\n  }\n\n  const setupUpdateProgress = () => {\n    const update = (e: ProgressEvent) => {\n      console.log(e)\n      NProgress.set(calculatePercentage(e.loaded, e.total))\n    }\n    instance.defaults.onDownloadProgress = update\n    instance.defaults.onUploadProgress = update\n  }\n\n  const setupStopProgress = () => {\n    instance.interceptors.response.use(response => {\n      NProgress.done()\n      return response\n    }, error => {\n      NProgress.done()\n      return Promise.reject(error)\n    })\n  }\n\n  setupStartProgress()\n  setupUpdateProgress()\n  setupStopProgress()\n}\n\nloadProgressBar()\n\nconst downloadEl = document.getElementById('download')\n\ndownloadEl!.addEventListener('click', e => {\n  instance.get('https://img.mukewang.com/5cc01a7b0001a33718720632.jpg')\n})\n\nconst uploadEl = document.getElementById('upload')\n\nuploadEl!.addEventListener('click', e => {\n  const data = new FormData()\n  const fileEl = document.getElementById('file') as HTMLInputElement\n  if (fileEl.files) {\n    data.append('file', fileEl.files[0])\n\n    instance.post('/more/upload', data)\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n对于 progress 事件参数 e，会有 e.total 和 e.loaded 属性，表示进程总体的工作量和已经执行的工作量，我们可以根据这 2 个值算出当前进度，然后通过 Nprogess.set 设置。另外，我们通过配置请求拦截器和响应拦截器执行 NProgress.start() 和 NProgress.done()。\n\n我们给下载按钮绑定了一个 click 事件，请求一张图片，我们可以看到实时的进度；另外我们也给上传按钮绑定了一个 click 事件，上传我们选择的文件，同样也能看到实时进度。\n\n在服务端，我们为了处理上传请求，需要下载安装一个 express 的中间件 connect-multiparty，然后使用它。\n\nexample/server.js：\n\nconst multipart = require('connect-multiparty')\napp.use(multipart({\n  uploadDir: path.resolve(__dirname, 'upload-file')\n}))\n\nrouter.post('/more/upload', function(req, res) {\n  console.log(req.body, req.files)\n  res.end('upload success!')\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这里我们需要在 examples 目录下创建一个 upload-file 的空目录，用于存放上传的文件。\n\n通过这个中间件，我们就可以处理上传请求并且可以把上传的文件存储在 upload-file 目录下。\n\n为了保证代码正常运行，我们还需要在 examples/webpack.config.js 中添加 css-loader 和 css-loader，不要忘记先安装它们。\n\n至此，ts-axios 支持了上传下载进度事件的回调函数的配置，用户可以通过配置这俩函数实现对下载进度和上传进度的监控。下一节课我们来实现 http 的认证授权功能。",normalizedContent:"# 上传和下载的进度监控\n\n\n# 需求分析\n\n有些时候，当我们上传文件或者是请求一个大体积数据的时候，希望知道实时的进度，甚至可以基于此做一个进度条的展示。\n\n我们希望给 axios 的请求配置提供 ondownloadprogress 和 onuploadprogress 2 个函数属性，用户可以通过这俩函数实现对下载进度和上传进度的监控。\n\naxios.get('/more/get',{\n  ondownloadprogress(progressevent) {\n    // 监听下载进度\n  }\n})\n\naxios.post('/more/post',{\n  onuploadprogress(progressevent) {\n    // 监听上传进度\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nxhr 对象提供了一个 progress 事件，我们可以监听此事件对数据的下载进度做监控；另外，xhr.uplaod 对象也提供了 progress 事件，我们可以基于此对上传进度做监控。\n\n\n# 代码实现\n\n首先修改一下类型定义。\n\ntypes/index.ts：\n\nexport interface axiosrequestconfig {\n  // ...\n  ondownloadprogress?: (e: progressevent) => void\n  onuploadprogress?: (e: progressevent) => void\n}\n\n\n1\n2\n3\n4\n5\n\n\n接着在发送请求前，给 xhr 对象添加属性。\n\ncore/xhr.ts：\n\nconst {\n  /*...*/\n  ondownloadprogress,\n  onuploadprogress\n} = config\n\nif (ondownloadprogress) {\n  request.onprogress = ondownloadprogress\n}\n\nif (onuploadprogress) {\n  request.upload.onprogress = onuploadprogress\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n另外，如果请求的数据是 formdata 类型，我们应该主动删除请求 headers 中的 content-type 字段，让浏览器自动根据请求数据设置 content-type。比如当我们通过 formdata 上传文件的时候，浏览器会把请求 headers 中的 content-type 设置为 multipart/form-data。\n\n我们先添加一个判断 formdata 的方法。\n\nhelpers/util.ts：\n\nexport function isformdata(val: any): boolean {\n  return typeof val !== 'undefined' && val instanceof formdata\n}\n\n\n1\n2\n3\n\n\n然后再添加相关逻辑。\n\ncore/xhr.ts：\n\nif (isformdata(data)) {\n  delete headers['content-type']\n}\n\n\n1\n2\n3\n\n\n我们发现，xhr 函数内部随着需求越来越多，代码也越来越臃肿，我们可以把逻辑梳理一下，把内部代码做一层封装优化。\n\nexport default function xhr(config: axiosrequestconfig): axiospromise {\n  return new promise((resolve, reject) => {\n    const {\n      data = null,\n      url,\n      method = 'get',\n      headers,\n      responsetype,\n      timeout,\n      canceltoken,\n      withcredentials,\n      xsrfcookiename,\n      xsrfheadername,\n      ondownloadprogress,\n      onuploadprogress\n    } = config\n\n    const request = new xmlhttprequest()\n\n    request.open(method.touppercase(), url!, true)\n\n    configurerequest()\n\n    addevents()\n\n    processheaders()\n\n    processcancel()\n\n    request.send(data)\n\n    function configurerequest(): void {\n      if (responsetype) {\n        request.responsetype = responsetype\n      }\n\n      if (timeout) {\n        request.timeout = timeout\n      }\n\n      if (withcredentials) {\n        request.withcredentials = withcredentials\n      }\n    }\n\n    function addevents(): void {\n      request.onreadystatechange = function handleload() {\n        if (request.readystate !== 4) {\n          return\n        }\n\n        if (request.status === 0) {\n          return\n        }\n\n        const responseheaders = parseheaders(request.getallresponseheaders())\n        const responsedata =\n          responsetype && responsetype !== 'text' ? request.response : request.responsetext\n        const response: axiosresponse = {\n          data: responsedata,\n          status: request.status,\n          statustext: request.statustext,\n          headers: responseheaders,\n          config,\n          request\n        }\n        handleresponse(response)\n      }\n\n      request.onerror = function handleerror() {\n        reject(createerror('network error', config, null, request))\n      }\n\n      request.ontimeout = function handletimeout() {\n        reject(\n          createerror(`timeout of ${config.timeout} ms exceeded`, config, 'econnaborted', request)\n        )\n      }\n\n      if (ondownloadprogress) {\n        request.onprogress = ondownloadprogress\n      }\n\n      if (onuploadprogress) {\n        request.upload.onprogress = onuploadprogress\n      }\n    }\n\n    function processheaders(): void {\n      if (isformdata(data)) {\n        delete headers['content-type']\n      }\n\n      if ((withcredentials || isurlsameorigin(url!)) && xsrfcookiename) {\n        const xsrfvalue = cookie.read(xsrfcookiename)\n        if (xsrfvalue) {\n          headers[xsrfheadername!] = xsrfvalue\n        }\n      }\n\n      object.keys(headers).foreach(name => {\n        if (data === null && name.tolowercase() === 'content-type') {\n          delete headers[name]\n        } else {\n          request.setrequestheader(name, headers[name])\n        }\n      })\n    }\n\n    function processcancel(): void {\n      if (canceltoken) {\n        canceltoken.promise.then(reason => {\n          request.abort()\n          reject(reason)\n        })\n      }\n    }\n\n    function handleresponse(response: axiosresponse): void {\n      if (response.status >= 200 && response.status < 300) {\n        resolve(response)\n      } else {\n        reject(\n          createerror(\n            `request failed with status code ${response.status}`,\n            config,\n            null,\n            request,\n            response\n          )\n        )\n      }\n    }\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n\n\n我们把整个流程分为 7 步：\n\n * 创建一个 request 实例。\n * 执行 request.open 方法初始化。\n * 执行 configurerequest 配置 request 对象。\n * 执行 addevents 给 request 添加事件处理函数。\n * 执行 processheaders 处理请求 headers。\n * 执行 processcancel 处理请求取消逻辑。\n * 执行 request.send 方法发送请求。\n\n这样拆分后整个流程就会显得非常清晰，未来我们再去新增需求的时候代码也不会显得越来越臃肿。\n\n\n# demo 编写\n\n这节课的 demo 非常有意思，我们第一次给界面上增加了一些交互的按钮。\n\nexamples/more/index.html\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>more example</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css\"/>\n</head>\n<body>\n<h1>file download</h1>\n<div>\n  <button id=\"download\" class=\"btn btn-primary\">download</button>\n</div>\n<h1>file upload</h1>\n<form role=\"form\" class=\"form\" onsubmit=\"return false;\">\n  <input id=\"file\" type=\"file\" class=\"form-control\"/>\n  <button id=\"upload\" type=\"button\" class=\"btn btn-primary\">upload</button>\n</form>\n\n<script src=\"/__build__/more.js\"><\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n另外，我们为了友好地展示上传和下载进度，我们引入了一个开源库 nprogress，它可以在页面的顶部展示进度条。\n\nexamples/more/app.ts：\n\nconst instance = axios.create()\n\nfunction calculatepercentage(loaded: number, total: number) {\n  return math.floor(loaded * 1.0) / total\n}\n\nfunction loadprogressbar() {\n  const setupstartprogress = () => {\n    instance.interceptors.request.use(config => {\n      nprogress.start()\n      return config\n    })\n  }\n\n  const setupupdateprogress = () => {\n    const update = (e: progressevent) => {\n      console.log(e)\n      nprogress.set(calculatepercentage(e.loaded, e.total))\n    }\n    instance.defaults.ondownloadprogress = update\n    instance.defaults.onuploadprogress = update\n  }\n\n  const setupstopprogress = () => {\n    instance.interceptors.response.use(response => {\n      nprogress.done()\n      return response\n    }, error => {\n      nprogress.done()\n      return promise.reject(error)\n    })\n  }\n\n  setupstartprogress()\n  setupupdateprogress()\n  setupstopprogress()\n}\n\nloadprogressbar()\n\nconst downloadel = document.getelementbyid('download')\n\ndownloadel!.addeventlistener('click', e => {\n  instance.get('https://img.mukewang.com/5cc01a7b0001a33718720632.jpg')\n})\n\nconst uploadel = document.getelementbyid('upload')\n\nuploadel!.addeventlistener('click', e => {\n  const data = new formdata()\n  const fileel = document.getelementbyid('file') as htmlinputelement\n  if (fileel.files) {\n    data.append('file', fileel.files[0])\n\n    instance.post('/more/upload', data)\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n对于 progress 事件参数 e，会有 e.total 和 e.loaded 属性，表示进程总体的工作量和已经执行的工作量，我们可以根据这 2 个值算出当前进度，然后通过 nprogess.set 设置。另外，我们通过配置请求拦截器和响应拦截器执行 nprogress.start() 和 nprogress.done()。\n\n我们给下载按钮绑定了一个 click 事件，请求一张图片，我们可以看到实时的进度；另外我们也给上传按钮绑定了一个 click 事件，上传我们选择的文件，同样也能看到实时进度。\n\n在服务端，我们为了处理上传请求，需要下载安装一个 express 的中间件 connect-multiparty，然后使用它。\n\nexample/server.js：\n\nconst multipart = require('connect-multiparty')\napp.use(multipart({\n  uploaddir: path.resolve(__dirname, 'upload-file')\n}))\n\nrouter.post('/more/upload', function(req, res) {\n  console.log(req.body, req.files)\n  res.end('upload success!')\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这里我们需要在 examples 目录下创建一个 upload-file 的空目录，用于存放上传的文件。\n\n通过这个中间件，我们就可以处理上传请求并且可以把上传的文件存储在 upload-file 目录下。\n\n为了保证代码正常运行，我们还需要在 examples/webpack.config.js 中添加 css-loader 和 css-loader，不要忘记先安装它们。\n\n至此，ts-axios 支持了上传下载进度事件的回调函数的配置，用户可以通过配置这俩函数实现对下载进度和上传进度的监控。下一节课我们来实现 http 的认证授权功能。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"HTTP 授权",frontmatter:{title:"HTTP 授权",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/89cd6496c23159ae",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 更多功能实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/10.ts-axios%20%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/04.HTTP%20%E6%8E%88%E6%9D%83.html",relativePath:"《TypeScript 从零实现 axios》/10.ts-axios 更多功能实现/04.HTTP 授权.md",key:"v-a3689244",path:"/pages/89cd6496c23159ae/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:14},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:499},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:1032}],headersStr:"需求分析 代码实现 demo 编写",content:"# HTTP 授权\n\n\n# 需求分析\n\nHTTP 协议中的 Authorization 请求 header 会包含服务器用于验证用户代理身份的凭证，通常会在服务器返回 401 Unauthorized 状态码以及 WWW-Authenticate 消息头之后在后续请求中发送此消息头。\n\naxios 库也允许你在请求配置中配置 auth 属性，auth 是一个对象结构，包含 username 和 password 2 个属性。一旦用户在请求的时候配置这俩属性，我们就会自动往 HTTP 的 请求 header 中添加 Authorization 属性，它的值为 Basic 加密串。 这里的加密串是 username:password base64 加密后的结果。\n\naxios.post('/more/post', {\n  a: 1\n}, {\n  auth: {\n    username: 'Yee',\n    password: '123456'\n  }\n}).then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 代码实现\n\n首先修改一下类型定义。\n\ntypes/index.ts：\n\nexport interface AxiosRequestConfig {\n  // ...\n  auth?: AxiosBasicCredentials\n}\n\nexport interface AxiosBasicCredentials {\n  username: string\n  password: string\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n接着修改合并规则，因为 auth 也是一个对象格式，所以它的合并规则是 deepMergeStrat。\n\ncore/mergeConfig.ts：\n\nconst stratKeysDeepMerge = ['headers', 'auth']\n\n\n1\n\n\n然后修改发送请求前的逻辑。\n\ncore/xhr.ts：\n\nconst {\n  /*...*/\n  auth\n} = config\n\nif (auth) {\n  headers['Authorization'] = 'Basic ' + btoa(auth.username + ':' + auth.password)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# demo 编写\n\naxios.post('/more/post', {\n  a: 1\n}, {\n  auth: {\n    username: 'Yee',\n    password: '123456'\n  }\n}).then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n另外，我们在 server.js 中对于这个路由接口写了一段小逻辑：\n\nrouter.post('/more/post', function(req, res) {\n  const auth = req.headers.authorization\n  const [type, credentials] = auth.split(' ')\n  console.log(atob(credentials))\n  const [username, password] = atob(credentials).split(':')\n  if (type === 'Basic' && username === 'Yee' && password === '123456') {\n    res.json(req.body)\n  } else {\n    res.end('UnAuthorization')\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n注意，这里我们需要安装第三方库 atob 实现 base64 串的解码。\n\n至此，ts-axios 支持了 HTTP 授权功能，用户可以通过配置 auth 对象实现自动在请求 header 中添加 Authorization 属性。下一节课我们来实现自定义合法状态码功能。",normalizedContent:"# http 授权\n\n\n# 需求分析\n\nhttp 协议中的 authorization 请求 header 会包含服务器用于验证用户代理身份的凭证，通常会在服务器返回 401 unauthorized 状态码以及 www-authenticate 消息头之后在后续请求中发送此消息头。\n\naxios 库也允许你在请求配置中配置 auth 属性，auth 是一个对象结构，包含 username 和 password 2 个属性。一旦用户在请求的时候配置这俩属性，我们就会自动往 http 的 请求 header 中添加 authorization 属性，它的值为 basic 加密串。 这里的加密串是 username:password base64 加密后的结果。\n\naxios.post('/more/post', {\n  a: 1\n}, {\n  auth: {\n    username: 'yee',\n    password: '123456'\n  }\n}).then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 代码实现\n\n首先修改一下类型定义。\n\ntypes/index.ts：\n\nexport interface axiosrequestconfig {\n  // ...\n  auth?: axiosbasiccredentials\n}\n\nexport interface axiosbasiccredentials {\n  username: string\n  password: string\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n接着修改合并规则，因为 auth 也是一个对象格式，所以它的合并规则是 deepmergestrat。\n\ncore/mergeconfig.ts：\n\nconst stratkeysdeepmerge = ['headers', 'auth']\n\n\n1\n\n\n然后修改发送请求前的逻辑。\n\ncore/xhr.ts：\n\nconst {\n  /*...*/\n  auth\n} = config\n\nif (auth) {\n  headers['authorization'] = 'basic ' + btoa(auth.username + ':' + auth.password)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# demo 编写\n\naxios.post('/more/post', {\n  a: 1\n}, {\n  auth: {\n    username: 'yee',\n    password: '123456'\n  }\n}).then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n另外，我们在 server.js 中对于这个路由接口写了一段小逻辑：\n\nrouter.post('/more/post', function(req, res) {\n  const auth = req.headers.authorization\n  const [type, credentials] = auth.split(' ')\n  console.log(atob(credentials))\n  const [username, password] = atob(credentials).split(':')\n  if (type === 'basic' && username === 'yee' && password === '123456') {\n    res.json(req.body)\n  } else {\n    res.end('unauthorization')\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n注意，这里我们需要安装第三方库 atob 实现 base64 串的解码。\n\n至此，ts-axios 支持了 http 授权功能，用户可以通过配置 auth 对象实现自动在请求 header 中添加 authorization 属性。下一节课我们来实现自定义合法状态码功能。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"自定义合法状态码",frontmatter:{title:"自定义合法状态码",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/40b41ce8e8159567",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 更多功能实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/10.ts-axios%20%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/05.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%88%E6%B3%95%E7%8A%B6%E6%80%81%E7%A0%81.html",relativePath:"《TypeScript 从零实现 axios》/10.ts-axios 更多功能实现/05.自定义合法状态码.md",key:"v-d68294b4",path:"/pages/40b41ce8e8159567/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:15},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:451},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:1296}],headersStr:"需求分析 代码实现 demo 编写",content:"# 自定义合法状态码\n\n\n# 需求分析\n\n之前 ts-axios 在处理响应结果的时候，认为 HTTP status 在 200 和 300 之间是一个合法值，在这个区间之外则创建一个错误。有些时候我们想自定义这个规则，比如认为 304 也是一个合法的状态码，所以我们希望 ts-axios 能提供一个配置，允许我们自定义合法状态码规则。如下：\n\naxios.get('/more/304', {\n  validateStatus(status) {\n    return status >= 200 && status < 400\n  }\n}).then(res => {\n  console.log(res)\n}).catch((e: AxiosError) => {\n  console.log(e.message)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n通过在请求配置中配置一个 validateStatus 函数，它可以根据参数 status 来自定义合法状态码的规则。\n\n\n# 代码实现\n\n首先修改一下类型定义。\n\ntypes/index.ts：\n\nexport interface AxiosRequestConfig {\n  // ...\n  validateStatus?: (status: number) => boolean\n}\n\n\n1\n2\n3\n4\n\n\n然后我们来修改默认配置规则。\n\ndefaults.ts：\n\nvalidateStatus(status: number): boolean {\n  return status >= 200 && status < 300\n}\n\n\n1\n2\n3\n\n\n添加默认合法状态码的校验规则。然后再请求后对响应数据的处理逻辑。\n\ncore/xhr.ts：\n\nconst {\n  /*...*/\n  validateStatus\n} = config\n\nfunction handleResponse(response: AxiosResponse): void {\n  if (!validateStatus || validateStatus(response.status)) {\n    resolve(response)\n  } else {\n    reject(\n      createError(\n        `Request failed with status code ${response.status}`,\n        config,\n        null,\n        request,\n        response\n      )\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n如果没有配置 validateStatus 以及 validateStatus 函数返回的值为 true 的时候，都认为是合法的，正常 resolve(response)，否则都创建一个错误。\n\n\n# demo 编写\n\naxios.get('/more/304').then(res => {\n  console.log(res)\n}).catch((e: AxiosError) => {\n  console.log(e.message)\n})\n\naxios.get('/more/304', {\n  validateStatus(status) {\n    return status >= 200 && status < 400\n  }\n}).then(res => {\n  console.log(res)\n}).catch((e: AxiosError) => {\n  console.log(e.message)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nserver.js 中我们编写了这个路由接口\n\n\nrouter.get('/more/304', function(req, res) {\n  res.status(304)\n  res.end()\n})\n\n\n1\n2\n3\n4\n5\n\n\n接口返回 304 状态码，对于默认的请求我们会输出一条错误信息。第二个请求中我们配置了自定义合法状态码规则，区间在 200 和 400 之间，这样就不会报错，而是可以正常输出响应对象。\n\n至此 ts-axios 实现了自定义合法状态码功能，用户可以配置 validateStatus 自定义合法状态码规则。之前有同学会质疑 ts-axios 对于请求 url 参数的序列化处理规则，下一节课我们来实现自定义参数序列化规则功能。",normalizedContent:"# 自定义合法状态码\n\n\n# 需求分析\n\n之前 ts-axios 在处理响应结果的时候，认为 http status 在 200 和 300 之间是一个合法值，在这个区间之外则创建一个错误。有些时候我们想自定义这个规则，比如认为 304 也是一个合法的状态码，所以我们希望 ts-axios 能提供一个配置，允许我们自定义合法状态码规则。如下：\n\naxios.get('/more/304', {\n  validatestatus(status) {\n    return status >= 200 && status < 400\n  }\n}).then(res => {\n  console.log(res)\n}).catch((e: axioserror) => {\n  console.log(e.message)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n通过在请求配置中配置一个 validatestatus 函数，它可以根据参数 status 来自定义合法状态码的规则。\n\n\n# 代码实现\n\n首先修改一下类型定义。\n\ntypes/index.ts：\n\nexport interface axiosrequestconfig {\n  // ...\n  validatestatus?: (status: number) => boolean\n}\n\n\n1\n2\n3\n4\n\n\n然后我们来修改默认配置规则。\n\ndefaults.ts：\n\nvalidatestatus(status: number): boolean {\n  return status >= 200 && status < 300\n}\n\n\n1\n2\n3\n\n\n添加默认合法状态码的校验规则。然后再请求后对响应数据的处理逻辑。\n\ncore/xhr.ts：\n\nconst {\n  /*...*/\n  validatestatus\n} = config\n\nfunction handleresponse(response: axiosresponse): void {\n  if (!validatestatus || validatestatus(response.status)) {\n    resolve(response)\n  } else {\n    reject(\n      createerror(\n        `request failed with status code ${response.status}`,\n        config,\n        null,\n        request,\n        response\n      )\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n如果没有配置 validatestatus 以及 validatestatus 函数返回的值为 true 的时候，都认为是合法的，正常 resolve(response)，否则都创建一个错误。\n\n\n# demo 编写\n\naxios.get('/more/304').then(res => {\n  console.log(res)\n}).catch((e: axioserror) => {\n  console.log(e.message)\n})\n\naxios.get('/more/304', {\n  validatestatus(status) {\n    return status >= 200 && status < 400\n  }\n}).then(res => {\n  console.log(res)\n}).catch((e: axioserror) => {\n  console.log(e.message)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nserver.js 中我们编写了这个路由接口\n\n\nrouter.get('/more/304', function(req, res) {\n  res.status(304)\n  res.end()\n})\n\n\n1\n2\n3\n4\n5\n\n\n接口返回 304 状态码，对于默认的请求我们会输出一条错误信息。第二个请求中我们配置了自定义合法状态码规则，区间在 200 和 400 之间，这样就不会报错，而是可以正常输出响应对象。\n\n至此 ts-axios 实现了自定义合法状态码功能，用户可以配置 validatestatus 自定义合法状态码规则。之前有同学会质疑 ts-axios 对于请求 url 参数的序列化处理规则，下一节课我们来实现自定义参数序列化规则功能。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"自定义参数序列化",frontmatter:{title:"自定义参数序列化",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/7753b8141663e54a",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 更多功能实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/10.ts-axios%20%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/06.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E5%BA%8F%E5%88%97%E5%8C%96.html",relativePath:"《TypeScript 从零实现 axios》/10.ts-axios 更多功能实现/06.自定义参数序列化.md",key:"v-1308a3c9",path:"/pages/7753b8141663e54a/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:15},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:523},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:2560}],headersStr:"需求分析 代码实现 demo 编写",content:"# 自定义参数序列化\n\n\n# 需求分析\n\n在之前的章节，我们对请求的 url 参数做了处理，我们会解析传入的 params 对象，根据一定的规则把它解析成字符串，然后添加在 url 后面。在解析的过程中，我们会对字符串 encode，但是对于一些特殊字符比如 @、+ 等却不转义，这是 axios 库的默认解析规则。当然，我们也希望自己定义解析规则，于是我们希望 ts-axios 能在请求配置中允许我们配置一个 paramsSerializer 函数来自定义参数的解析规则，该函数接受 params 参数，返回值作为解析后的结果，如下：\n\naxios.get('/more/get', {\n  params: {\n    a: 1,\n    b: 2,\n    c: ['a', 'b', 'c']\n  },\n  paramsSerializer(params) {\n    return qs.stringify(params, { arrayFormat: 'brackets' })\n  }\n}).then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 代码实现\n\n首先修改一下类型定义。\n\ntypes/index.ts：\n\nexport interface AxiosRequestConfig {\n  // ...\n  paramsSerializer?: (params: any) => string\n}\n\n\n1\n2\n3\n4\n\n\n然后修改 buildURL 函数的实现。\n\nhelpers/url.ts：\n\nexport function buildURL(\n  url: string,\n  params?: any,\n  paramsSerializer?: (params: any) => string\n): string {\n  if (!params) {\n    return url\n  }\n\n  let serializedParams\n\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params)\n  } else if (isURLSearchParams(params)) {\n    serializedParams = params.toString()\n  } else {\n    const parts: string[] = []\n\n    Object.keys(params).forEach(key => {\n      const val = params[key]\n      if (val === null || typeof val === 'undefined') {\n        return\n      }\n      let values = []\n      if (Array.isArray(val)) {\n        values = val\n        key += '[]'\n      } else {\n        values = [val]\n      }\n      values.forEach(val => {\n        if (isDate(val)) {\n          val = val.toISOString()\n        } else if (isPlainObject(val)) {\n          val = JSON.stringify(val)\n        }\n        parts.push(`${encode(key)}=${encode(val)}`)\n      })\n    })\n\n    serializedParams = parts.join('&')\n  }\n\n  if (serializedParams) {\n    const markIndex = url.indexOf('#')\n    if (markIndex !== -1) {\n      url = url.slice(0, markIndex)\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams\n  }\n\n  return url\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n这里我们给 buildURL 函数新增了 paramsSerializer 可选参数，另外我们还新增了对 params 类型判断，如果它是一个 URLSearchParams 对象实例的话，我们直接返回它 toString 后的结果。\n\nhelpers/util.ts：\n\nexport function isURLSearchParams(val: any): val is URLSearchParams {\n  return typeof val !== 'undefined' && val instanceof URLSearchParams\n}\n\n\n1\n2\n3\n\n\n最后我们要修改 buildURL 调用的逻辑。\n\ncore/dispatchRequest.ts：\n\nfunction transformURL(config: AxiosRequestConfig): string {\n  const { url, params, paramsSerializer } = config\n  return buildURL(url!, params, paramsSerializer)\n}\n\n\n1\n2\n3\n4\n\n\n\n# demo 编写\n\naxios.get('/more/get', {\n  params: new URLSearchParams('a=b&c=d')\n}).then(res => {\n  console.log(res)\n})\n\naxios.get('/more/get', {\n  params: {\n    a: 1,\n    b: 2,\n    c: ['a', 'b', 'c']\n  }\n}).then(res => {\n  console.log(res)\n})\n\nconst instance = axios.create({\n  paramsSerializer(params) {\n    return qs.stringify(params, { arrayFormat: 'brackets' })\n  }\n})\n\ninstance.get('/more/get', {\n  params: {\n    a: 1,\n    b: 2,\n    c: ['a', 'b', 'c']\n  }\n}).then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n我们编写了 3 种情况的请求，第一种满足请求的 params 参数是 URLSearchParams 对象类型的。后两种请求的结果主要区别在于前者并没有对 [] 转义，而后者会转义。\n\n至此，ts-axios 实现了自定义参数序列化功能，用户可以配置 paramsSerializer 自定义参数序列化规则。下一节课我们来实现 ts-axios 对 baseURL 的支持。",normalizedContent:"# 自定义参数序列化\n\n\n# 需求分析\n\n在之前的章节，我们对请求的 url 参数做了处理，我们会解析传入的 params 对象，根据一定的规则把它解析成字符串，然后添加在 url 后面。在解析的过程中，我们会对字符串 encode，但是对于一些特殊字符比如 @、+ 等却不转义，这是 axios 库的默认解析规则。当然，我们也希望自己定义解析规则，于是我们希望 ts-axios 能在请求配置中允许我们配置一个 paramsserializer 函数来自定义参数的解析规则，该函数接受 params 参数，返回值作为解析后的结果，如下：\n\naxios.get('/more/get', {\n  params: {\n    a: 1,\n    b: 2,\n    c: ['a', 'b', 'c']\n  },\n  paramsserializer(params) {\n    return qs.stringify(params, { arrayformat: 'brackets' })\n  }\n}).then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 代码实现\n\n首先修改一下类型定义。\n\ntypes/index.ts：\n\nexport interface axiosrequestconfig {\n  // ...\n  paramsserializer?: (params: any) => string\n}\n\n\n1\n2\n3\n4\n\n\n然后修改 buildurl 函数的实现。\n\nhelpers/url.ts：\n\nexport function buildurl(\n  url: string,\n  params?: any,\n  paramsserializer?: (params: any) => string\n): string {\n  if (!params) {\n    return url\n  }\n\n  let serializedparams\n\n  if (paramsserializer) {\n    serializedparams = paramsserializer(params)\n  } else if (isurlsearchparams(params)) {\n    serializedparams = params.tostring()\n  } else {\n    const parts: string[] = []\n\n    object.keys(params).foreach(key => {\n      const val = params[key]\n      if (val === null || typeof val === 'undefined') {\n        return\n      }\n      let values = []\n      if (array.isarray(val)) {\n        values = val\n        key += '[]'\n      } else {\n        values = [val]\n      }\n      values.foreach(val => {\n        if (isdate(val)) {\n          val = val.toisostring()\n        } else if (isplainobject(val)) {\n          val = json.stringify(val)\n        }\n        parts.push(`${encode(key)}=${encode(val)}`)\n      })\n    })\n\n    serializedparams = parts.join('&')\n  }\n\n  if (serializedparams) {\n    const markindex = url.indexof('#')\n    if (markindex !== -1) {\n      url = url.slice(0, markindex)\n    }\n\n    url += (url.indexof('?') === -1 ? '?' : '&') + serializedparams\n  }\n\n  return url\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n这里我们给 buildurl 函数新增了 paramsserializer 可选参数，另外我们还新增了对 params 类型判断，如果它是一个 urlsearchparams 对象实例的话，我们直接返回它 tostring 后的结果。\n\nhelpers/util.ts：\n\nexport function isurlsearchparams(val: any): val is urlsearchparams {\n  return typeof val !== 'undefined' && val instanceof urlsearchparams\n}\n\n\n1\n2\n3\n\n\n最后我们要修改 buildurl 调用的逻辑。\n\ncore/dispatchrequest.ts：\n\nfunction transformurl(config: axiosrequestconfig): string {\n  const { url, params, paramsserializer } = config\n  return buildurl(url!, params, paramsserializer)\n}\n\n\n1\n2\n3\n4\n\n\n\n# demo 编写\n\naxios.get('/more/get', {\n  params: new urlsearchparams('a=b&c=d')\n}).then(res => {\n  console.log(res)\n})\n\naxios.get('/more/get', {\n  params: {\n    a: 1,\n    b: 2,\n    c: ['a', 'b', 'c']\n  }\n}).then(res => {\n  console.log(res)\n})\n\nconst instance = axios.create({\n  paramsserializer(params) {\n    return qs.stringify(params, { arrayformat: 'brackets' })\n  }\n})\n\ninstance.get('/more/get', {\n  params: {\n    a: 1,\n    b: 2,\n    c: ['a', 'b', 'c']\n  }\n}).then(res => {\n  console.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n我们编写了 3 种情况的请求，第一种满足请求的 params 参数是 urlsearchparams 对象类型的。后两种请求的结果主要区别在于前者并没有对 [] 转义，而后者会转义。\n\n至此，ts-axios 实现了自定义参数序列化功能，用户可以配置 paramsserializer 自定义参数序列化规则。下一节课我们来实现 ts-axios 对 baseurl 的支持。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"baseURL",frontmatter:{title:"baseURL",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/0b9f2ee2b4dbb728",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 更多功能实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/10.ts-axios%20%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/07.baseURL.html",relativePath:"《TypeScript 从零实现 axios》/10.ts-axios 更多功能实现/07.baseURL.md",key:"v-20a6df83",path:"/pages/0b9f2ee2b4dbb728/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:14},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:315},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:1083}],headersStr:"需求分析 代码实现 demo 编写",content:"# baseURL\n\n\n# 需求分析\n\n有些时候，我们会请求某个域名下的多个接口，我们不希望每次发送请求都填写完整的 url，希望可以配置一个 baseURL，之后都可以传相对路径。如下：\n\nconst instance = axios.create({\n  baseURL: 'https://some-domain.com/api'\n})\n\ninstance.get('/get')\n\ninstance.post('/post')\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n我们一旦配置了 baseURL，之后请求传入的 url 都会和我们的 baseURL 拼接成完整的绝对地址，除非请求传入的 url 已经是绝对地址。\n\n\n# 代码实现\n\n首先修改一下类型定义。\n\ntypes/index.ts：\n\nexport interface AxiosRequestConfig {\n  // ...\n  baseURL?: string\n}\n\n\n1\n2\n3\n4\n\n\n接下来实现 2 个辅助函数。\n\nhelpers/url.ts：\n\nexport function isAbsoluteURL(url: string): boolean {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url)\n}\n\nexport function combineURL(baseURL: string, relativeURL?: string): string {\n  return relativeURL ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '') : baseURL\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n最后我们来调用这俩个辅助函数。\n\ncore/dispatchRequest.ts：\n\nfunction transformURL(config: AxiosRequestConfig): string {\n  let { url, params, paramsSerializer, baseURL } = config\n  if (baseURL && !isAbsoluteURL(url!)) {\n    url = combineURL(baseURL, url)\n  }\n  return buildURL(url!, params, paramsSerializer)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# demo 编写\n\nconst instance = axios.create({\n  baseURL: 'https://img.mukewang.com/'\n})\n\ninstance.get('5cc01a7b0001a33718720632.jpg')\n\ninstance.get('https://img.mukewang.com/szimg/5becd5ad0001b89306000338-360-202.jpg')\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这个 demo 非常简单，我们请求了慕课网的 2 张图片，注意当第二个请求 url 已经是绝对地址的时候，我们并不会再去拼接 baseURL。\n\n至此，ts-axios 就实现了 baseURL 的配置功能，接下来我们来实现 ts-axios 的静态方法扩展。",normalizedContent:"# baseurl\n\n\n# 需求分析\n\n有些时候，我们会请求某个域名下的多个接口，我们不希望每次发送请求都填写完整的 url，希望可以配置一个 baseurl，之后都可以传相对路径。如下：\n\nconst instance = axios.create({\n  baseurl: 'https://some-domain.com/api'\n})\n\ninstance.get('/get')\n\ninstance.post('/post')\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n我们一旦配置了 baseurl，之后请求传入的 url 都会和我们的 baseurl 拼接成完整的绝对地址，除非请求传入的 url 已经是绝对地址。\n\n\n# 代码实现\n\n首先修改一下类型定义。\n\ntypes/index.ts：\n\nexport interface axiosrequestconfig {\n  // ...\n  baseurl?: string\n}\n\n\n1\n2\n3\n4\n\n\n接下来实现 2 个辅助函数。\n\nhelpers/url.ts：\n\nexport function isabsoluteurl(url: string): boolean {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url)\n}\n\nexport function combineurl(baseurl: string, relativeurl?: string): string {\n  return relativeurl ? baseurl.replace(/\\/+$/, '') + '/' + relativeurl.replace(/^\\/+/, '') : baseurl\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n最后我们来调用这俩个辅助函数。\n\ncore/dispatchrequest.ts：\n\nfunction transformurl(config: axiosrequestconfig): string {\n  let { url, params, paramsserializer, baseurl } = config\n  if (baseurl && !isabsoluteurl(url!)) {\n    url = combineurl(baseurl, url)\n  }\n  return buildurl(url!, params, paramsserializer)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# demo 编写\n\nconst instance = axios.create({\n  baseurl: 'https://img.mukewang.com/'\n})\n\ninstance.get('5cc01a7b0001a33718720632.jpg')\n\ninstance.get('https://img.mukewang.com/szimg/5becd5ad0001b89306000338-360-202.jpg')\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这个 demo 非常简单，我们请求了慕课网的 2 张图片，注意当第二个请求 url 已经是绝对地址的时候，我们并不会再去拼接 baseurl。\n\n至此，ts-axios 就实现了 baseurl 的配置功能，接下来我们来实现 ts-axios 的静态方法扩展。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"静态方法扩展",frontmatter:{title:"静态方法扩展",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/c26b053540a7dafa",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 更多功能实现"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/10.ts-axios%20%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/08.%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%89%A9%E5%B1%95.html",relativePath:"《TypeScript 从零实现 axios》/10.ts-axios 更多功能实现/08.静态方法扩展.md",key:"v-58d3d128",path:"/pages/c26b053540a7dafa/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:13},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:1467},{level:2,title:"demo 编写",slug:"demo-编写",normalizedTitle:"demo 编写",charIndex:2440}],headersStr:"需求分析 代码实现 demo 编写",content:"# 静态方法扩展\n\n\n# 需求分析\n\n官方 axios 库实现了 axios.all、axios.spread 等方法，它们的用法如下：\n\nfunction getUserAccount() {\n  return axios.get('/user/12345');\n}\n\nfunction getUserPermissions() {\n  return axios.get('/user/12345/permissions');\n}\n\naxios.all([getUserAccount(), getUserPermissions()])\n  .then(axios.spread(function (acct, perms) {\n    // Both requests are now complete\n  }));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n实际上，axios.all 就是 Promise.all 的封装，它返回的是一个 Promise 数组，then 函数的参数本应是一个参数为 Promise resolves（数组）的函数，在这里使用了 axios.spread 方法。所以 axios.spread 方法是接收一个函数，返回一个新的函数，新函数的结构满足 then 函数的参数结构。\n\n个人认为 axios 这俩静态方法在目前看来很鸡肋，因为使用 Promise 一样可以完成这俩需求。\n\nfunction getUserAccount() {\n  return axios.get('/user/12345');\n}\n\nfunction getUserPermissions() {\n  return axios.get('/user/12345/permissions');\n}\n\nPromise.all([getUserAccount(), getUserPermissions()])\n  .then(([acct,perms]) {\n    // Both requests are now complete\n  }));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在 Promise.all 的 resolve 函数中，我们可以直接通过数组的解构拿到每个请求对应的响应对象。\n\n但是为了保持与官网 axios API 一致，我们也在 ts-axios 库中实现这俩方法。\n\n官方 axios 库也通过 axios.Axios 对外暴露了 Axios 类(感觉也没有啥使用场景，但为了保持一致，我们也会实现)。\n\n另外对于 axios 实例，官网还提供了 getUri 方法在不发送请求的前提下根据传入的配置返回一个 url，如下：\n\nconst fakeConfig = {\n  baseURL: 'https://www.baidu.com/',\n  url: '/user/12345',\n  params: {\n    idClient: 1,\n    idTest: 2,\n    testString: 'thisIsATest'\n  }\n}\nconsole.log(axios.getUri(fakeConfig))\n// https://www.baidu.com/user/12345?idClient=1&idTest=2&testString=thisIsATest\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 代码实现\n\n首先修改类型定义。\n\ntypes/index.ts：\n\nexport interface AxiosClassStatic {\n  new (config: AxiosRequestConfig): Axios\n}\n\nexport interface AxiosStatic extends AxiosInstance {\n  // ...\n\n  all<T>(promises: Array<T | Promise<T>>): Promise<T[]>\n\n  spread<T, R>(callback: (...args: T[]) => R): (arr: T[]) => R\n\n  Axios: AxiosClassStatic\n}\n\nexport interface Axios {\n  // ...\n\n  getUri(config?: AxiosRequestConfig): string\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n然后我们去实现这几个静态方法。\n\naxios.ts：\n\naxios.all = function all(promises) {\n  return Promise.all(promises)\n}\n\naxios.spread = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr)\n  }\n}\n\naxios.Axios = Axios\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n最后我们去给 Axios 添加实例方法 getUri。\n\ncore/Axios.ts：\n\ngetUri(config?: AxiosRequestConfig): string {\n  config = mergeConfig(this.defaults, config)\n  return transformURL(config)\n}\n\n\n1\n2\n3\n4\n\n\n先和默认配置合并，然后再通过 dispatchRequest 中实现的 transformURL 返回一个新的 url。\n\n\n# demo 编写\n\nfunction getA() {\n  return axios.get('/more/A')\n}\n\nfunction getB() {\n  return axios.get('/more/B')\n}\n\naxios.all([getA(), getB()])\n  .then(axios.spread(function(resA, resB) {\n    console.log(resA.data)\n    console.log(resB.data)\n  }))\n\n\naxios.all([getA(), getB()])\n  .then(([resA, resB]) => {\n    console.log(resA.data)\n    console.log(resB.data)\n  })\n\nconst fakeConfig = {\n  baseURL: 'https://www.baidu.com/',\n  url: '/user/12345',\n  params: {\n    idClient: 1,\n    idTest: 2,\n    testString: 'thisIsATest'\n  }\n}\nconsole.log(axios.getUri(fakeConfig))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n这里我们通过 axios.all 同时发出了 2 个请求，返回了 Promise 数组，，我们可以在 axios.spread 的参数函数中拿到结果，也可以直接在 then 函数的参数函数中拿到结果。另外，我们可以根据 axios.getUri 方法在不发送请求的情况下根据配置得到最终请求的 url 结果。\n\n至此，ts-axios 就实现了官网 axios 库在浏览器端的所有需求。如果你学到了这里，先为自己鼓个掌吧，因为我们已经获得了阶段性的学习成果了。\n\n目前为止，我们对于所写代码的验证都是通过 demo 的方式，但是 demo 毕竟难以覆盖所有场景和代码分支，为了保证代码的正确性，我们还需要更科学的方式。从下一章开始，我们会学习编写单元测试，通过单元测试的方式来保证我们的代码正确性。",normalizedContent:"# 静态方法扩展\n\n\n# 需求分析\n\n官方 axios 库实现了 axios.all、axios.spread 等方法，它们的用法如下：\n\nfunction getuseraccount() {\n  return axios.get('/user/12345');\n}\n\nfunction getuserpermissions() {\n  return axios.get('/user/12345/permissions');\n}\n\naxios.all([getuseraccount(), getuserpermissions()])\n  .then(axios.spread(function (acct, perms) {\n    // both requests are now complete\n  }));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n实际上，axios.all 就是 promise.all 的封装，它返回的是一个 promise 数组，then 函数的参数本应是一个参数为 promise resolves（数组）的函数，在这里使用了 axios.spread 方法。所以 axios.spread 方法是接收一个函数，返回一个新的函数，新函数的结构满足 then 函数的参数结构。\n\n个人认为 axios 这俩静态方法在目前看来很鸡肋，因为使用 promise 一样可以完成这俩需求。\n\nfunction getuseraccount() {\n  return axios.get('/user/12345');\n}\n\nfunction getuserpermissions() {\n  return axios.get('/user/12345/permissions');\n}\n\npromise.all([getuseraccount(), getuserpermissions()])\n  .then(([acct,perms]) {\n    // both requests are now complete\n  }));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在 promise.all 的 resolve 函数中，我们可以直接通过数组的解构拿到每个请求对应的响应对象。\n\n但是为了保持与官网 axios api 一致，我们也在 ts-axios 库中实现这俩方法。\n\n官方 axios 库也通过 axios.axios 对外暴露了 axios 类(感觉也没有啥使用场景，但为了保持一致，我们也会实现)。\n\n另外对于 axios 实例，官网还提供了 geturi 方法在不发送请求的前提下根据传入的配置返回一个 url，如下：\n\nconst fakeconfig = {\n  baseurl: 'https://www.baidu.com/',\n  url: '/user/12345',\n  params: {\n    idclient: 1,\n    idtest: 2,\n    teststring: 'thisisatest'\n  }\n}\nconsole.log(axios.geturi(fakeconfig))\n// https://www.baidu.com/user/12345?idclient=1&idtest=2&teststring=thisisatest\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 代码实现\n\n首先修改类型定义。\n\ntypes/index.ts：\n\nexport interface axiosclassstatic {\n  new (config: axiosrequestconfig): axios\n}\n\nexport interface axiosstatic extends axiosinstance {\n  // ...\n\n  all<t>(promises: array<t | promise<t>>): promise<t[]>\n\n  spread<t, r>(callback: (...args: t[]) => r): (arr: t[]) => r\n\n  axios: axiosclassstatic\n}\n\nexport interface axios {\n  // ...\n\n  geturi(config?: axiosrequestconfig): string\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n然后我们去实现这几个静态方法。\n\naxios.ts：\n\naxios.all = function all(promises) {\n  return promise.all(promises)\n}\n\naxios.spread = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr)\n  }\n}\n\naxios.axios = axios\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n最后我们去给 axios 添加实例方法 geturi。\n\ncore/axios.ts：\n\ngeturi(config?: axiosrequestconfig): string {\n  config = mergeconfig(this.defaults, config)\n  return transformurl(config)\n}\n\n\n1\n2\n3\n4\n\n\n先和默认配置合并，然后再通过 dispatchrequest 中实现的 transformurl 返回一个新的 url。\n\n\n# demo 编写\n\nfunction geta() {\n  return axios.get('/more/a')\n}\n\nfunction getb() {\n  return axios.get('/more/b')\n}\n\naxios.all([geta(), getb()])\n  .then(axios.spread(function(resa, resb) {\n    console.log(resa.data)\n    console.log(resb.data)\n  }))\n\n\naxios.all([geta(), getb()])\n  .then(([resa, resb]) => {\n    console.log(resa.data)\n    console.log(resb.data)\n  })\n\nconst fakeconfig = {\n  baseurl: 'https://www.baidu.com/',\n  url: '/user/12345',\n  params: {\n    idclient: 1,\n    idtest: 2,\n    teststring: 'thisisatest'\n  }\n}\nconsole.log(axios.geturi(fakeconfig))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n这里我们通过 axios.all 同时发出了 2 个请求，返回了 promise 数组，，我们可以在 axios.spread 的参数函数中拿到结果，也可以直接在 then 函数的参数函数中拿到结果。另外，我们可以根据 axios.geturi 方法在不发送请求的情况下根据配置得到最终请求的 url 结果。\n\n至此，ts-axios 就实现了官网 axios 库在浏览器端的所有需求。如果你学到了这里，先为自己鼓个掌吧，因为我们已经获得了阶段性的学习成果了。\n\n目前为止，我们对于所写代码的验证都是通过 demo 的方式，但是 demo 毕竟难以覆盖所有场景和代码分支，为了保证代码的正确性，我们还需要更科学的方式。从下一章开始，我们会学习编写单元测试，通过单元测试的方式来保证我们的代码正确性。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"前言",frontmatter:{title:"前言",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/df36888424843793",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 单元测试"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/11.ts-axios%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/01.%E5%89%8D%E8%A8%80.html",relativePath:"《TypeScript 从零实现 axios》/11.ts-axios 单元测试/01.前言.md",key:"v-fb3dd6b6",path:"/pages/df36888424843793/",headersStr:null,content:"# 前言\n\n单元测试是前端一个很重要的方向，鉴别一个开源库是否靠谱的一个标准是它的单元测试是否完善。有了完整的单元测试，未来你去重构现有代码或者是增加新的需求都会有十足的把握不出现 regression bug。\n\n在前面的章节，我们已经编写完成 ts-axios 库的代码，并通过 demo 的形式简单地对一些功能做了验证，但是 demo 可以走到的代码分支，覆盖的场景都是极其有限的。为了用更科学的手段保证我们代码的可靠性，我们需要去编写单元测试，并尽可能达到 99% 以上的测试覆盖率。\n\n这门课我们会使用开源测试框架 Jest，它是 Facebook 出品的一个测试框架，相对其他测试框架，它的一大特点就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。\n\n由于时间有限，我不会带大家一行行手敲测试代码，但我会把所有的知识点和测试代码都带大家过一遍，确保大家都能够学会。但是我希望你们在学习的过程中，能自己手敲这些测试代码，这样有助于你们学习和巩固。\n\n通过这一章节的学习，我希望你们能够学会使用 Jest 去对 JS 库或者是 TS 库编写单元测试，并能把所学应用到你们的实际项目中。给自己的代码添加完整的测试代码也是一个非常好的开发习惯，虽然枯燥但十分实用，如果养成这些好习惯会有助于提升你的行业竞争力，所以希望大家虽然把代码实现了，也不要太骄傲，耐心把单元测试写好。\n\n那么接下来就让我们开启单元测试之旅。",normalizedContent:"# 前言\n\n单元测试是前端一个很重要的方向，鉴别一个开源库是否靠谱的一个标准是它的单元测试是否完善。有了完整的单元测试，未来你去重构现有代码或者是增加新的需求都会有十足的把握不出现 regression bug。\n\n在前面的章节，我们已经编写完成 ts-axios 库的代码，并通过 demo 的形式简单地对一些功能做了验证，但是 demo 可以走到的代码分支，覆盖的场景都是极其有限的。为了用更科学的手段保证我们代码的可靠性，我们需要去编写单元测试，并尽可能达到 99% 以上的测试覆盖率。\n\n这门课我们会使用开源测试框架 jest，它是 facebook 出品的一个测试框架，相对其他测试框架，它的一大特点就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。\n\n由于时间有限，我不会带大家一行行手敲测试代码，但我会把所有的知识点和测试代码都带大家过一遍，确保大家都能够学会。但是我希望你们在学习的过程中，能自己手敲这些测试代码，这样有助于你们学习和巩固。\n\n通过这一章节的学习，我希望你们能够学会使用 jest 去对 js 库或者是 ts 库编写单元测试，并能把所学应用到你们的实际项目中。给自己的代码添加完整的测试代码也是一个非常好的开发习惯，虽然枯燥但十分实用，如果养成这些好习惯会有助于提升你的行业竞争力，所以希望大家虽然把代码实现了，也不要太骄傲，耐心把单元测试写好。\n\n那么接下来就让我们开启单元测试之旅。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"Jest 安装和配置",frontmatter:{title:"Jest 安装和配置",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/bf5c625a35757b37",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 单元测试"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/11.ts-axios%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/02.Jest%20%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE.html",relativePath:"《TypeScript 从零实现 axios》/11.ts-axios 单元测试/02.Jest 安装和配置.md",key:"v-81321e74",path:"/pages/bf5c625a35757b37/",headers:[{level:2,title:"Jest 安装",slug:"jest-安装",normalizedTitle:"jest 安装",charIndex:2},{level:2,title:"Jest 配置",slug:"jest-配置",normalizedTitle:"jest 配置",charIndex:370}],headersStr:"Jest 安装 Jest 配置",content:'# Jest 安装和配置\n\n\n# Jest 安装\n\n由于我们的项目是使用 typescript-library-starter 初始化的，已经内置了 Jest 的安装，但是安装的版本却不是最新的，我们可以对 package.json 中的相关依赖版本做修改，重新安装。\n\n{\n  "@types/jest": "^24.0.13",\n  "jest": "^24.8.0",\n  "jest-config": "^24.8.0",\n  "ts-jest": "^24.0.2",\n  "typescript": "^3.4.5"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 注意，这里都是目前最新的版本，未来如果有版本升级的话，可以自行更新到最新版本。\n\n更改版本后，在命令行再次执行 npm install 即可安装到相应版本。\n\n\n# Jest 配置\n\n在 package.json 文件中有 jest 字段，对应 Jest 配置：\n\n"jest": {\n  "transform": {\n    ".(ts|tsx)": "ts-jest"\n  },\n  "testEnvironment": "jsdom",\n  "testRegex": "/test/.*\\\\.(test|spec)\\\\.(ts)$",\n  "moduleFileExtensions": [\n    "ts",\n    "tsx",\n    "js"\n  ],\n  "coverageThreshold": {\n    "global": {\n      "branches": 90,\n      "functions": 95,\n      "lines": 95,\n      "statements": 95\n    }\n  },\n  "collectCoverageFrom": [\n    "src/*.{js,ts}",\n    "src/**/*.{js,ts}"\n  ],\n  "setupFilesAfterEnv": [\n    "<rootDir>/test/boot.ts"\n  ]\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n接下来，我们就分别来看这几个配置的含义。\n\n * transform\n\n简单地说就是一种转换器配置，比如我们这里的\n\n"transform": {\n  ".(ts|tsx)": "ts-jest"\n},\n\n\n1\n2\n3\n\n\n表示的就是使用 ts-jest 工具把 .ts 和 .tsx 文件内容转换成 JavaScript，因为我们也是使用 TypeScript 编写测试代码，而 Node.js 是不能直接支持 TypeScript 的，所以需要配置转换器。\n\n * testEnvironment\n\n测试环境。\n\n"testEnvironment": "jsdom"\n\n\n1\n\n\n表示它是一个类浏览器的测试环境，我们可以使用浏览器环境中的一些 API。\n\n * testRegex\n\n要测试文件的正则表达式。\n\n"testRegex": "/test/.*\\\\.(test|spec)\\\\.(ts)$"\n\n\n1\n\n\n表示 test 目录下所有以 .test.ts 和 .spec.ts 的文件都需要跑测试。\n\n * moduleFileExtensions\n\n模块文件扩展名，当你去引入一个模块并没有指定扩展名的时候，它会依次尝试去添加这些扩展名去找你引入的模块文件。\n\n"moduleFileExtensions": [\n  "ts",\n  "tsx",\n  "js"\n]\n\n\n1\n2\n3\n4\n5\n\n\n表示优先找 .ts 的模块、然后是 .tsx，最后是 .js。\n\n * coverageThreshold\n\n测试覆盖率的阈值设定，当我们的测试覆盖率达不到阈值的时候，测试会失败。\n\n"coverageThreshold": {\n  "global": {\n    "branches": 90,\n    "functions": 95,\n    "lines": 95,\n    "statements": 95\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n表示全局的代码分支覆盖率要达到 90%，方法覆盖率要达到 95%，代码行数覆盖率达到 95%，声明覆盖率达到 95%。\n\n * collectCoverageFrom\n\n收集指定文件的测试覆盖率(即使你没为这些文件编写测试)，它的值为 glob patterns 类型。\n\n"collectCoverageFrom": [\n  "src/*.{js,ts}",\n  "src/**/*.{js,ts}"\n]\n\n\n1\n2\n3\n4\n\n\n表示收集 src 目录以及它的所有子目录中的 js 和 ts 文件的测试覆盖率。\n\n * setupFilesAfterEnv\n\n测试框架安装后立即执行的代码文件列表。\n\n"setupFilesAfterEnv": [\n  "<rootDir>/test/boot.ts"\n]\n\n\n1\n2\n3\n\n\n表示每次跑具体测试代码之前会先运行 <rootDir>/test/boot.ts 中的代码，<rootDir> 表示当前项目的根目录。这个配置在之后的章节我们会具体介绍。\n\n其他关于 Jest 的配置，感兴趣的同学可以去官网做扩展学习。\n\n至此，我们学习了 Jest 的安装和配置，下节课我们就开始编写 ts-axios 库的单元测试。',normalizedContent:'# jest 安装和配置\n\n\n# jest 安装\n\n由于我们的项目是使用 typescript-library-starter 初始化的，已经内置了 jest 的安装，但是安装的版本却不是最新的，我们可以对 package.json 中的相关依赖版本做修改，重新安装。\n\n{\n  "@types/jest": "^24.0.13",\n  "jest": "^24.8.0",\n  "jest-config": "^24.8.0",\n  "ts-jest": "^24.0.2",\n  "typescript": "^3.4.5"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 注意，这里都是目前最新的版本，未来如果有版本升级的话，可以自行更新到最新版本。\n\n更改版本后，在命令行再次执行 npm install 即可安装到相应版本。\n\n\n# jest 配置\n\n在 package.json 文件中有 jest 字段，对应 jest 配置：\n\n"jest": {\n  "transform": {\n    ".(ts|tsx)": "ts-jest"\n  },\n  "testenvironment": "jsdom",\n  "testregex": "/test/.*\\\\.(test|spec)\\\\.(ts)$",\n  "modulefileextensions": [\n    "ts",\n    "tsx",\n    "js"\n  ],\n  "coveragethreshold": {\n    "global": {\n      "branches": 90,\n      "functions": 95,\n      "lines": 95,\n      "statements": 95\n    }\n  },\n  "collectcoveragefrom": [\n    "src/*.{js,ts}",\n    "src/**/*.{js,ts}"\n  ],\n  "setupfilesafterenv": [\n    "<rootdir>/test/boot.ts"\n  ]\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n接下来，我们就分别来看这几个配置的含义。\n\n * transform\n\n简单地说就是一种转换器配置，比如我们这里的\n\n"transform": {\n  ".(ts|tsx)": "ts-jest"\n},\n\n\n1\n2\n3\n\n\n表示的就是使用 ts-jest 工具把 .ts 和 .tsx 文件内容转换成 javascript，因为我们也是使用 typescript 编写测试代码，而 node.js 是不能直接支持 typescript 的，所以需要配置转换器。\n\n * testenvironment\n\n测试环境。\n\n"testenvironment": "jsdom"\n\n\n1\n\n\n表示它是一个类浏览器的测试环境，我们可以使用浏览器环境中的一些 api。\n\n * testregex\n\n要测试文件的正则表达式。\n\n"testregex": "/test/.*\\\\.(test|spec)\\\\.(ts)$"\n\n\n1\n\n\n表示 test 目录下所有以 .test.ts 和 .spec.ts 的文件都需要跑测试。\n\n * modulefileextensions\n\n模块文件扩展名，当你去引入一个模块并没有指定扩展名的时候，它会依次尝试去添加这些扩展名去找你引入的模块文件。\n\n"modulefileextensions": [\n  "ts",\n  "tsx",\n  "js"\n]\n\n\n1\n2\n3\n4\n5\n\n\n表示优先找 .ts 的模块、然后是 .tsx，最后是 .js。\n\n * coveragethreshold\n\n测试覆盖率的阈值设定，当我们的测试覆盖率达不到阈值的时候，测试会失败。\n\n"coveragethreshold": {\n  "global": {\n    "branches": 90,\n    "functions": 95,\n    "lines": 95,\n    "statements": 95\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n表示全局的代码分支覆盖率要达到 90%，方法覆盖率要达到 95%，代码行数覆盖率达到 95%，声明覆盖率达到 95%。\n\n * collectcoveragefrom\n\n收集指定文件的测试覆盖率(即使你没为这些文件编写测试)，它的值为 glob patterns 类型。\n\n"collectcoveragefrom": [\n  "src/*.{js,ts}",\n  "src/**/*.{js,ts}"\n]\n\n\n1\n2\n3\n4\n\n\n表示收集 src 目录以及它的所有子目录中的 js 和 ts 文件的测试覆盖率。\n\n * setupfilesafterenv\n\n测试框架安装后立即执行的代码文件列表。\n\n"setupfilesafterenv": [\n  "<rootdir>/test/boot.ts"\n]\n\n\n1\n2\n3\n\n\n表示每次跑具体测试代码之前会先运行 <rootdir>/test/boot.ts 中的代码，<rootdir> 表示当前项目的根目录。这个配置在之后的章节我们会具体介绍。\n\n其他关于 jest 的配置，感兴趣的同学可以去官网做扩展学习。\n\n至此，我们学习了 jest 的安装和配置，下节课我们就开始编写 ts-axios 库的单元测试。',charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"辅助模块单元测试",frontmatter:{title:"辅助模块单元测试",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/13f147a9b355c4c1",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 单元测试"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/11.ts-axios%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/03.%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",relativePath:"《TypeScript 从零实现 axios》/11.ts-axios 单元测试/03.辅助模块单元测试.md",key:"v-21911570",path:"/pages/13f147a9b355c4c1/",headers:[{level:2,title:"准备工作",slug:"准备工作",normalizedTitle:"准备工作",charIndex:15},{level:2,title:"util 模块测试",slug:"util-模块测试",normalizedTitle:"util 模块测试",charIndex:334},{level:2,title:"cookie 模块测试",slug:"cookie-模块测试",normalizedTitle:"cookie 模块测试",charIndex:3864},{level:2,title:"data 模块测试",slug:"data-模块测试",normalizedTitle:"data 模块测试",charIndex:4342},{level:2,title:"error 模块测试",slug:"error-模块测试",normalizedTitle:"error 模块测试",charIndex:5480},{level:2,title:"headers 模块测试",slug:"headers-模块测试",normalizedTitle:"headers 模块测试",charIndex:6600},{level:2,title:"url 模块测试",slug:"url-模块测试",normalizedTitle:"url 模块测试",charIndex:10764}],headersStr:"准备工作 util 模块测试 cookie 模块测试 data 模块测试 error 模块测试 headers 模块测试 url 模块测试",content:"# 辅助模块单元测试\n\n\n# 准备工作\n\n通常我们会优先为一个库的辅助方法编写测试，我们会优先为 ts-axios 库的 helpers 目录下的模块编写测试。我们在 test 目录下创建一个 helpers 目录，创建一个 boot.ts 空文件，这个是因为我们上节课给 Jest 配置了 setupFilesAfterEnv 指向了这个文件，后面的章节我们会编写这个文件。\n\n然后我们可以在控制台运行 npm test，它实际上是执行了 jest --coverage 来跑单元测试，我们会发现它会报错，没有匹配的测试文件，那是因为我们还没有在 test 目录下编写任何一个 .spec.ts 结尾的测试文件。接下来我们就来为这些辅助模块编写相应的测试。\n\n\n# util 模块测试\n\ntest/helpers/util.spec.ts：\n\nimport {\n  isDate,\n  isPlainObject,\n  isFormData,\n  isURLSearchParams,\n  extend,\n  deepMerge\n} from '../../src/helpers/util'\n\ndescribe('helpers:util', () => {\n  describe('isXX', () => {\n    test('should validate Date', () => {\n      expect(isDate(new Date())).toBeTruthy()\n      expect(isDate(Date.now())).toBeFalsy()\n    })\n\n    test('should validate PlainObject', () => {\n      expect(isPlainObject({})).toBeTruthy()\n      expect(isPlainObject(new Date())).toBeFalsy()\n    })\n\n    test('should validate FormData', () => {\n      expect(isFormData(new FormData())).toBeTruthy()\n      expect(isFormData({})).toBeFalsy()\n    })\n\n    test('should validate URLSearchParams', () => {\n      expect(isURLSearchParams(new URLSearchParams())).toBeTruthy()\n      expect(isURLSearchParams('foo=1&bar=2')).toBeFalsy()\n    })\n  })\n\n  describe('extend', () => {\n    test('should be mutable', () => {\n      const a = Object.create(null)\n      const b = { foo: 123 }\n\n      extend(a, b)\n\n      expect(a.foo).toBe(123)\n    })\n\n    test('should extend properties', function() {\n      const a = { foo: 123, bar: 456 }\n      const b = { bar: 789 }\n      const c = extend(a, b)\n\n      expect(c.foo).toBe(123)\n      expect(c.bar).toBe(789)\n    })\n  })\n\n  describe('deepMerge', () => {\n    test('should be immutable', () => {\n      const a = Object.create(null)\n      const b: any = { foo: 123 }\n      const c: any = { bar: 456 }\n\n      deepMerge(a, b, c)\n\n      expect(typeof a.foo).toBe('undefined')\n      expect(typeof a.bar).toBe('undefined')\n      expect(typeof b.bar).toBe('undefined')\n      expect(typeof c.foo).toBe('undefined')\n    })\n\n    test('should deepMerge properties', () => {\n      const a = { foo: 123 }\n      const b = { bar: 456 }\n      const c = { foo: 789 }\n      const d = deepMerge(a, b, c)\n\n      expect(d.foo).toBe(789)\n      expect(d.bar).toBe(456)\n    })\n\n    test('should deepMerge recursively', function() {\n      const a = { foo: { bar: 123 } }\n      const b = { foo: { baz: 456 }, bar: { qux: 789 } }\n      const c = deepMerge(a, b)\n\n      expect(c).toEqual({\n        foo: {\n          bar: 123,\n          baz: 456\n        },\n        bar: {\n          qux: 789\n        }\n      })\n    })\n\n    test('should remove all references from nested objects', () => {\n      const a = { foo: { bar: 123 } }\n      const b = {}\n      const c = deepMerge(a, b)\n\n      expect(c).toEqual({\n        foo: {\n          bar: 123\n        }\n      })\n\n      expect(c.foo).not.toBe(a.foo)\n    })\n\n    test('should handle null and undefined arguments', () => {\n      expect(deepMerge(undefined, undefined)).toEqual({})\n      expect(deepMerge(undefined, { foo: 123 })).toEqual({ foo: 123 })\n      expect(deepMerge({ foo: 123 }, undefined)).toEqual({ foo: 123 })\n\n      expect(deepMerge(null, null)).toEqual({})\n      expect(deepMerge(null, { foo: 123 })).toEqual({ foo: 123 })\n      expect(deepMerge({ foo: 123 }, null)).toEqual({ foo: 123 })\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n\n\n其中 describe 方法用来定义一组测试，它可以支持嵌套，test 函数是用来定义单个测试用例，它是测试的最小单元。expect 是断言函数，所谓\"断言\"，就是判断代码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。\n\n测试文件编写好后，我们可以去控制台运行一次 npm test，看一下测试结果，我们可以看跑了几个测试文件，测试是否通过，测试覆盖率等。\n\n\n# cookie 模块测试\n\ntest/helpers/cookie.spec.ts：\n\nimport cookie from '../../src/helpers/cookie'\n\ndescribe('helpers:cookie', () => {\n  test('should read cookies', () => {\n    document.cookie = 'foo=baz'\n    expect(cookie.read('foo')).toBe('baz')\n  })\n\n  test('should return null if cookie name is not exist', () => {\n    document.cookie = 'foo=baz'\n    expect(cookie.read('bar')).toBeNull()\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这里我们可以通过 document.cookie 去设置 cookie，就像在浏览器里一样操作。\n\n\n# data 模块测试\n\ntest/helpers/data.spec.ts：\n\nimport { transformRequest, transformResponse } from '../../src/helpers/data'\n\ndescribe('helpers:data', () => {\n  describe('transformRequest', () => {\n    test('should transform request data to string if data is a PlainObject', () => {\n      const a = { a: 1 }\n      expect(transformRequest(a)).toBe('{\"a\":1}')\n    })\n\n    test('should do nothing if data is not a PlainObject', () => {\n      const a = new URLSearchParams('a=b')\n      expect(transformRequest(a)).toBe(a)\n    })\n  })\n\n  describe('transformResponse', () => {\n    test('should transform response data to Object if data is a JSON string', () => {\n      const a = '{\"a\": 2}'\n      expect(transformResponse(a)).toEqual({ a: 2 })\n    })\n\n    test('should do nothing if data is a string but not a JSON string', () => {\n      const a = '{a: 2}'\n      expect(transformResponse(a)).toBe('{a: 2}')\n    })\n\n    test('should do nothing if data is not a string', () => {\n      const a = { a: 2 }\n      expect(transformResponse(a)).toBe(a)\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# error 模块测试\n\ntest/helpers/error.spec.ts：\n\nimport { createError } from '../../src/helpers/error'\nimport { AxiosRequestConfig, AxiosResponse } from '../../src/types'\n\ndescribe('helpers::error', function() {\n  test('should create an Error with message, config, code, request, response and isAxiosError', () => {\n    const request = new XMLHttpRequest()\n    const config: AxiosRequestConfig = { method: 'post' }\n    const response: AxiosResponse = {\n      status: 200,\n      statusText: 'OK',\n      headers: null,\n      request,\n      config,\n      data: { foo: 'bar' }\n    }\n    const error = createError('Boom!', config, 'SOMETHING', request, response)\n    expect(error instanceof Error).toBeTruthy()\n    expect(error.message).toBe('Boom!')\n    expect(error.config).toBe(config)\n    expect(error.code).toBe('SOMETHING')\n    expect(error.request).toBe(request)\n    expect(error.response).toBe(response)\n    expect(error.isAxiosError).toBeTruthy()\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n该模块跑完我们会发现，分支覆盖率是在 50%，因为第十七行代码\n\nsuper(message)\n\n\n1\n\n\n这个是 super 继承对测试覆盖率支持的坑，目前没有好的解决方案，可以先忽略。\n\n\n# headers 模块测试\n\ntest/helpers/headers.spec.ts：\n\nimport { parseHeaders, processHeaders, flattenHeaders } from '../../src/helpers/headers'\n\ndescribe('helpers:header', () => {\n  describe('parseHeaders', () => {\n    test('should parse headers', () => {\n      const parsed = parseHeaders(\n        'Content-Type: application/json\\r\\n' +\n          'Connection: keep-alive\\r\\n' +\n          'Transfer-Encoding: chunked\\r\\n' +\n          'Date: Tue, 21 May 2019 09:23:44 GMT\\r\\n' +\n          ':aa\\r\\n' +\n          'key:'\n      )\n\n      expect(parsed['content-type']).toBe('application/json')\n      expect(parsed['connection']).toBe('keep-alive')\n      expect(parsed['transfer-encoding']).toBe('chunked')\n      expect(parsed['date']).toBe('Tue, 21 May 2019 09:23:44 GMT')\n      expect(parsed['key']).toBe('')\n    })\n\n    test('should return empty object if headers is empty string', () => {\n      expect(parseHeaders('')).toEqual({})\n    })\n  })\n\n  describe('processHeaders', () => {\n    test('should normalize Content-Type header name', () => {\n      const headers: any = {\n        'conTenT-Type': 'foo/bar',\n        'Content-length': 1024\n      }\n      processHeaders(headers, {})\n      expect(headers['Content-Type']).toBe('foo/bar')\n      expect(headers['conTenT-Type']).toBeUndefined()\n      expect(headers['Content-length']).toBe(1024)\n    })\n\n    test('should set Content-Type if not set and data is PlainObject', () => {\n      const headers: any = {}\n      processHeaders(headers, { a: 1 })\n      expect(headers['Content-Type']).toBe('application/json;charset=utf-8')\n    })\n\n    test('should set not Content-Type if not set and data is not PlainObject', () => {\n      const headers: any = {}\n      processHeaders(headers, new URLSearchParams('a=b'))\n      expect(headers['Content-Type']).toBeUndefined()\n    })\n\n    test('should do nothing if headers is undefined or null', () => {\n      expect(processHeaders(undefined, {})).toBeUndefined()\n      expect(processHeaders(null, {})).toBeNull()\n    })\n  })\n\n  describe('flattenHeaders', () => {\n    test('should flatten the headers and include common headers', () => {\n      const headers = {\n        Accept: 'application/json',\n        common: {\n          'X-COMMON-HEADER': 'commonHeaderValue'\n        },\n        get: {\n          'X-GET-HEADER': 'getHeaderValue'\n        },\n        post: {\n          'X-POST-HEADER': 'postHeaderValue'\n        }\n      }\n\n      expect(flattenHeaders(headers, 'get')).toEqual({\n        Accept: 'application/json',\n        'X-COMMON-HEADER': 'commonHeaderValue',\n        'X-GET-HEADER': 'getHeaderValue'\n      })\n    })\n\n    test('should flatten the headers without common headers', () => {\n      const headers = {\n        Accept: 'application/json',\n        get: {\n          'X-GET-HEADER': 'getHeaderValue'\n        }\n      }\n\n      expect(flattenHeaders(headers, 'patch')).toEqual({\n        Accept: 'application/json'\n      })\n    })\n\n    test('should do nothing if headers is undefined or null', () => {\n      expect(flattenHeaders(undefined, 'get')).toBeUndefined()\n      expect(flattenHeaders(null, 'post')).toBeNull()\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n\n\n运行后，我们会发现 parseHeaders 测试组的 should parse headers 测试没通过，expect(parsed['date']).toBe('Tue, 21 May 2019 09:23:44 GMT') 我们期望解析后的 date 字段是 Tue, 21 May 2019 09:23:44 GMT，而实际的值是 Tue, 21 May 2019 09。\n\n测试没通过，我们检查一下代码，发现我们 parseHeaders 的代码逻辑漏洞，我们只考虑了第一个 \":\" 号，没考虑后半部分的字符串内部也可能有 \":\"，按我们现有的逻辑就会把字符串中 \":\" 后面部分都截断了。\n\n因此我们修改 parseHeaders 的实现逻辑。\n\nexport function parseHeaders(headers: string): any {\n  let parsed = Object.create(null)\n  if (!headers) {\n    return parsed\n  }\n\n  headers.split('\\r\\n').forEach(line => {\n    let [key, ...vals] = line.split(':')\n    key = key.trim().toLowerCase()\n    if (!key) {\n      return\n    }\n    let val = vals.join(':').trim()\n    parsed[key] = val\n  })\n\n  return parsed\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这样我们再重新跑测试，就会通过了。\n\n\n# url 模块测试\n\ntest/helpers/url.spec.ts：\n\nimport { buildURL, isAbsoluteURL, combineURL, isURLSameOrigin } from '../../src/helpers/url'\n\ndescribe('helpers:url', () => {\n  describe('buildURL', () => {\n    test('should support null params', () => {\n      expect(buildURL('/foo')).toBe('/foo')\n    })\n\n    test('should support params', () => {\n      expect(\n        buildURL('/foo', {\n          foo: 'bar'\n        })\n      ).toBe('/foo?foo=bar')\n    })\n\n    test('should ignore if some param value is null', () => {\n      expect(\n        buildURL('/foo', {\n          foo: 'bar',\n          baz: null\n        })\n      ).toBe('/foo?foo=bar')\n    })\n\n    test('should ignore if the only param value is null', () => {\n      expect(\n        buildURL('/foo', {\n          baz: null\n        })\n      ).toBe('/foo')\n    })\n\n    test('should support object params', () => {\n      expect(\n        buildURL('/foo', {\n          foo: {\n            bar: 'baz'\n          }\n        })\n      ).toBe('/foo?foo=' + encodeURI('{\"bar\":\"baz\"}'))\n    })\n\n    test('should support date params', () => {\n      const date = new Date()\n\n      expect(\n        buildURL('/foo', {\n          date: date\n        })\n      ).toBe('/foo?date=' + date.toISOString())\n    })\n\n    test('should support array params', () => {\n      expect(\n        buildURL('/foo', {\n          foo: ['bar', 'baz']\n        })\n      ).toBe('/foo?foo[]=bar&foo[]=baz')\n    })\n\n    test('should support special char params', () => {\n      expect(\n        buildURL('/foo', {\n          foo: '@:$, '\n        })\n      ).toBe('/foo?foo=@:$,+')\n    })\n\n    test('should support existing params', () => {\n      expect(\n        buildURL('/foo?foo=bar', {\n          bar: 'baz'\n        })\n      ).toBe('/foo?foo=bar&bar=baz')\n    })\n\n    test('should correct discard url hash mark', () => {\n      expect(\n        buildURL('/foo?foo=bar#hash', {\n          query: 'baz'\n        })\n      ).toBe('/foo?foo=bar&query=baz')\n    })\n\n    test('should use serializer if provided', () => {\n      const serializer = jest.fn(() => {\n        return 'foo=bar'\n      })\n      const params = { foo: 'bar' }\n      expect(buildURL('/foo', params, serializer)).toBe('/foo?foo=bar')\n      expect(serializer).toHaveBeenCalled()\n      expect(serializer).toHaveBeenCalledWith(params)\n    })\n\n    test('should support URLSearchParams', () => {\n      expect(buildURL('/foo', new URLSearchParams('bar=baz'))).toBe('/foo?bar=baz')\n    })\n  })\n\n  describe('isAbsoluteURL', () => {\n    test('should return true if URL begins with valid scheme name', () => {\n      expect(isAbsoluteURL('https://api.github.com/users')).toBeTruthy()\n      expect(isAbsoluteURL('custom-scheme-v1.0://example.com/')).toBeTruthy()\n      expect(isAbsoluteURL('HTTP://example.com/')).toBeTruthy()\n    })\n\n    test('should return false if URL begins with invalid scheme name', () => {\n      expect(isAbsoluteURL('123://example.com/')).toBeFalsy()\n      expect(isAbsoluteURL('!valid://example.com/')).toBeFalsy()\n    })\n\n    test('should return true if URL is protocol-relative', () => {\n      expect(isAbsoluteURL('//example.com/')).toBeTruthy()\n    })\n\n    test('should return false if URL is relative', () => {\n      expect(isAbsoluteURL('/foo')).toBeFalsy()\n      expect(isAbsoluteURL('foo')).toBeFalsy()\n    })\n  })\n\n  describe('combineURL', () => {\n    test('should combine URL', () => {\n      expect(combineURL('https://api.github.com', '/users')).toBe('https://api.github.com/users')\n    })\n\n    test('should remove duplicate slashes', () => {\n      expect(combineURL('https://api.github.com/', '/users')).toBe('https://api.github.com/users')\n    })\n\n    test('should insert missing slash', () => {\n      expect(combineURL('https://api.github.com', 'users')).toBe('https://api.github.com/users')\n    })\n\n    test('should not insert slash when relative url missing/empty', () => {\n      expect(combineURL('https://api.github.com/users', '')).toBe('https://api.github.com/users')\n    })\n\n    test('should allow a single slash for relative url', () => {\n      expect(combineURL('https://api.github.com/users', '/')).toBe('https://api.github.com/users/')\n    })\n  })\n\n  describe('isURLSameOrigin', () => {\n    test('should detect same origin', () => {\n      expect(isURLSameOrigin(window.location.href)).toBeTruthy()\n    })\n\n    test('should detect different origin', () => {\n      expect(isURLSameOrigin('https://github.com/axios/axios')).toBeFalsy()\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n\n\n这里要注意的是，我们使用了 jest.fn 去模拟了一个函数，这个也是在编写 Jest 测试中非常常用的一个 API。\n\n至此，我们就实现了 ts-axios 库 helpers 目录下所有模块的测试，并把该目录下的测试覆盖率达到了近乎 100% 的覆盖率。下面的章节我们就开始测试 ts-axios 的核心流程，针对不同的 feature 去编写单元测试了。",normalizedContent:"# 辅助模块单元测试\n\n\n# 准备工作\n\n通常我们会优先为一个库的辅助方法编写测试，我们会优先为 ts-axios 库的 helpers 目录下的模块编写测试。我们在 test 目录下创建一个 helpers 目录，创建一个 boot.ts 空文件，这个是因为我们上节课给 jest 配置了 setupfilesafterenv 指向了这个文件，后面的章节我们会编写这个文件。\n\n然后我们可以在控制台运行 npm test，它实际上是执行了 jest --coverage 来跑单元测试，我们会发现它会报错，没有匹配的测试文件，那是因为我们还没有在 test 目录下编写任何一个 .spec.ts 结尾的测试文件。接下来我们就来为这些辅助模块编写相应的测试。\n\n\n# util 模块测试\n\ntest/helpers/util.spec.ts：\n\nimport {\n  isdate,\n  isplainobject,\n  isformdata,\n  isurlsearchparams,\n  extend,\n  deepmerge\n} from '../../src/helpers/util'\n\ndescribe('helpers:util', () => {\n  describe('isxx', () => {\n    test('should validate date', () => {\n      expect(isdate(new date())).tobetruthy()\n      expect(isdate(date.now())).tobefalsy()\n    })\n\n    test('should validate plainobject', () => {\n      expect(isplainobject({})).tobetruthy()\n      expect(isplainobject(new date())).tobefalsy()\n    })\n\n    test('should validate formdata', () => {\n      expect(isformdata(new formdata())).tobetruthy()\n      expect(isformdata({})).tobefalsy()\n    })\n\n    test('should validate urlsearchparams', () => {\n      expect(isurlsearchparams(new urlsearchparams())).tobetruthy()\n      expect(isurlsearchparams('foo=1&bar=2')).tobefalsy()\n    })\n  })\n\n  describe('extend', () => {\n    test('should be mutable', () => {\n      const a = object.create(null)\n      const b = { foo: 123 }\n\n      extend(a, b)\n\n      expect(a.foo).tobe(123)\n    })\n\n    test('should extend properties', function() {\n      const a = { foo: 123, bar: 456 }\n      const b = { bar: 789 }\n      const c = extend(a, b)\n\n      expect(c.foo).tobe(123)\n      expect(c.bar).tobe(789)\n    })\n  })\n\n  describe('deepmerge', () => {\n    test('should be immutable', () => {\n      const a = object.create(null)\n      const b: any = { foo: 123 }\n      const c: any = { bar: 456 }\n\n      deepmerge(a, b, c)\n\n      expect(typeof a.foo).tobe('undefined')\n      expect(typeof a.bar).tobe('undefined')\n      expect(typeof b.bar).tobe('undefined')\n      expect(typeof c.foo).tobe('undefined')\n    })\n\n    test('should deepmerge properties', () => {\n      const a = { foo: 123 }\n      const b = { bar: 456 }\n      const c = { foo: 789 }\n      const d = deepmerge(a, b, c)\n\n      expect(d.foo).tobe(789)\n      expect(d.bar).tobe(456)\n    })\n\n    test('should deepmerge recursively', function() {\n      const a = { foo: { bar: 123 } }\n      const b = { foo: { baz: 456 }, bar: { qux: 789 } }\n      const c = deepmerge(a, b)\n\n      expect(c).toequal({\n        foo: {\n          bar: 123,\n          baz: 456\n        },\n        bar: {\n          qux: 789\n        }\n      })\n    })\n\n    test('should remove all references from nested objects', () => {\n      const a = { foo: { bar: 123 } }\n      const b = {}\n      const c = deepmerge(a, b)\n\n      expect(c).toequal({\n        foo: {\n          bar: 123\n        }\n      })\n\n      expect(c.foo).not.tobe(a.foo)\n    })\n\n    test('should handle null and undefined arguments', () => {\n      expect(deepmerge(undefined, undefined)).toequal({})\n      expect(deepmerge(undefined, { foo: 123 })).toequal({ foo: 123 })\n      expect(deepmerge({ foo: 123 }, undefined)).toequal({ foo: 123 })\n\n      expect(deepmerge(null, null)).toequal({})\n      expect(deepmerge(null, { foo: 123 })).toequal({ foo: 123 })\n      expect(deepmerge({ foo: 123 }, null)).toequal({ foo: 123 })\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n\n\n其中 describe 方法用来定义一组测试，它可以支持嵌套，test 函数是用来定义单个测试用例，它是测试的最小单元。expect 是断言函数，所谓\"断言\"，就是判断代码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。\n\n测试文件编写好后，我们可以去控制台运行一次 npm test，看一下测试结果，我们可以看跑了几个测试文件，测试是否通过，测试覆盖率等。\n\n\n# cookie 模块测试\n\ntest/helpers/cookie.spec.ts：\n\nimport cookie from '../../src/helpers/cookie'\n\ndescribe('helpers:cookie', () => {\n  test('should read cookies', () => {\n    document.cookie = 'foo=baz'\n    expect(cookie.read('foo')).tobe('baz')\n  })\n\n  test('should return null if cookie name is not exist', () => {\n    document.cookie = 'foo=baz'\n    expect(cookie.read('bar')).tobenull()\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这里我们可以通过 document.cookie 去设置 cookie，就像在浏览器里一样操作。\n\n\n# data 模块测试\n\ntest/helpers/data.spec.ts：\n\nimport { transformrequest, transformresponse } from '../../src/helpers/data'\n\ndescribe('helpers:data', () => {\n  describe('transformrequest', () => {\n    test('should transform request data to string if data is a plainobject', () => {\n      const a = { a: 1 }\n      expect(transformrequest(a)).tobe('{\"a\":1}')\n    })\n\n    test('should do nothing if data is not a plainobject', () => {\n      const a = new urlsearchparams('a=b')\n      expect(transformrequest(a)).tobe(a)\n    })\n  })\n\n  describe('transformresponse', () => {\n    test('should transform response data to object if data is a json string', () => {\n      const a = '{\"a\": 2}'\n      expect(transformresponse(a)).toequal({ a: 2 })\n    })\n\n    test('should do nothing if data is a string but not a json string', () => {\n      const a = '{a: 2}'\n      expect(transformresponse(a)).tobe('{a: 2}')\n    })\n\n    test('should do nothing if data is not a string', () => {\n      const a = { a: 2 }\n      expect(transformresponse(a)).tobe(a)\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# error 模块测试\n\ntest/helpers/error.spec.ts：\n\nimport { createerror } from '../../src/helpers/error'\nimport { axiosrequestconfig, axiosresponse } from '../../src/types'\n\ndescribe('helpers::error', function() {\n  test('should create an error with message, config, code, request, response and isaxioserror', () => {\n    const request = new xmlhttprequest()\n    const config: axiosrequestconfig = { method: 'post' }\n    const response: axiosresponse = {\n      status: 200,\n      statustext: 'ok',\n      headers: null,\n      request,\n      config,\n      data: { foo: 'bar' }\n    }\n    const error = createerror('boom!', config, 'something', request, response)\n    expect(error instanceof error).tobetruthy()\n    expect(error.message).tobe('boom!')\n    expect(error.config).tobe(config)\n    expect(error.code).tobe('something')\n    expect(error.request).tobe(request)\n    expect(error.response).tobe(response)\n    expect(error.isaxioserror).tobetruthy()\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n该模块跑完我们会发现，分支覆盖率是在 50%，因为第十七行代码\n\nsuper(message)\n\n\n1\n\n\n这个是 super 继承对测试覆盖率支持的坑，目前没有好的解决方案，可以先忽略。\n\n\n# headers 模块测试\n\ntest/helpers/headers.spec.ts：\n\nimport { parseheaders, processheaders, flattenheaders } from '../../src/helpers/headers'\n\ndescribe('helpers:header', () => {\n  describe('parseheaders', () => {\n    test('should parse headers', () => {\n      const parsed = parseheaders(\n        'content-type: application/json\\r\\n' +\n          'connection: keep-alive\\r\\n' +\n          'transfer-encoding: chunked\\r\\n' +\n          'date: tue, 21 may 2019 09:23:44 gmt\\r\\n' +\n          ':aa\\r\\n' +\n          'key:'\n      )\n\n      expect(parsed['content-type']).tobe('application/json')\n      expect(parsed['connection']).tobe('keep-alive')\n      expect(parsed['transfer-encoding']).tobe('chunked')\n      expect(parsed['date']).tobe('tue, 21 may 2019 09:23:44 gmt')\n      expect(parsed['key']).tobe('')\n    })\n\n    test('should return empty object if headers is empty string', () => {\n      expect(parseheaders('')).toequal({})\n    })\n  })\n\n  describe('processheaders', () => {\n    test('should normalize content-type header name', () => {\n      const headers: any = {\n        'content-type': 'foo/bar',\n        'content-length': 1024\n      }\n      processheaders(headers, {})\n      expect(headers['content-type']).tobe('foo/bar')\n      expect(headers['content-type']).tobeundefined()\n      expect(headers['content-length']).tobe(1024)\n    })\n\n    test('should set content-type if not set and data is plainobject', () => {\n      const headers: any = {}\n      processheaders(headers, { a: 1 })\n      expect(headers['content-type']).tobe('application/json;charset=utf-8')\n    })\n\n    test('should set not content-type if not set and data is not plainobject', () => {\n      const headers: any = {}\n      processheaders(headers, new urlsearchparams('a=b'))\n      expect(headers['content-type']).tobeundefined()\n    })\n\n    test('should do nothing if headers is undefined or null', () => {\n      expect(processheaders(undefined, {})).tobeundefined()\n      expect(processheaders(null, {})).tobenull()\n    })\n  })\n\n  describe('flattenheaders', () => {\n    test('should flatten the headers and include common headers', () => {\n      const headers = {\n        accept: 'application/json',\n        common: {\n          'x-common-header': 'commonheadervalue'\n        },\n        get: {\n          'x-get-header': 'getheadervalue'\n        },\n        post: {\n          'x-post-header': 'postheadervalue'\n        }\n      }\n\n      expect(flattenheaders(headers, 'get')).toequal({\n        accept: 'application/json',\n        'x-common-header': 'commonheadervalue',\n        'x-get-header': 'getheadervalue'\n      })\n    })\n\n    test('should flatten the headers without common headers', () => {\n      const headers = {\n        accept: 'application/json',\n        get: {\n          'x-get-header': 'getheadervalue'\n        }\n      }\n\n      expect(flattenheaders(headers, 'patch')).toequal({\n        accept: 'application/json'\n      })\n    })\n\n    test('should do nothing if headers is undefined or null', () => {\n      expect(flattenheaders(undefined, 'get')).tobeundefined()\n      expect(flattenheaders(null, 'post')).tobenull()\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n\n\n运行后，我们会发现 parseheaders 测试组的 should parse headers 测试没通过，expect(parsed['date']).tobe('tue, 21 may 2019 09:23:44 gmt') 我们期望解析后的 date 字段是 tue, 21 may 2019 09:23:44 gmt，而实际的值是 tue, 21 may 2019 09。\n\n测试没通过，我们检查一下代码，发现我们 parseheaders 的代码逻辑漏洞，我们只考虑了第一个 \":\" 号，没考虑后半部分的字符串内部也可能有 \":\"，按我们现有的逻辑就会把字符串中 \":\" 后面部分都截断了。\n\n因此我们修改 parseheaders 的实现逻辑。\n\nexport function parseheaders(headers: string): any {\n  let parsed = object.create(null)\n  if (!headers) {\n    return parsed\n  }\n\n  headers.split('\\r\\n').foreach(line => {\n    let [key, ...vals] = line.split(':')\n    key = key.trim().tolowercase()\n    if (!key) {\n      return\n    }\n    let val = vals.join(':').trim()\n    parsed[key] = val\n  })\n\n  return parsed\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这样我们再重新跑测试，就会通过了。\n\n\n# url 模块测试\n\ntest/helpers/url.spec.ts：\n\nimport { buildurl, isabsoluteurl, combineurl, isurlsameorigin } from '../../src/helpers/url'\n\ndescribe('helpers:url', () => {\n  describe('buildurl', () => {\n    test('should support null params', () => {\n      expect(buildurl('/foo')).tobe('/foo')\n    })\n\n    test('should support params', () => {\n      expect(\n        buildurl('/foo', {\n          foo: 'bar'\n        })\n      ).tobe('/foo?foo=bar')\n    })\n\n    test('should ignore if some param value is null', () => {\n      expect(\n        buildurl('/foo', {\n          foo: 'bar',\n          baz: null\n        })\n      ).tobe('/foo?foo=bar')\n    })\n\n    test('should ignore if the only param value is null', () => {\n      expect(\n        buildurl('/foo', {\n          baz: null\n        })\n      ).tobe('/foo')\n    })\n\n    test('should support object params', () => {\n      expect(\n        buildurl('/foo', {\n          foo: {\n            bar: 'baz'\n          }\n        })\n      ).tobe('/foo?foo=' + encodeuri('{\"bar\":\"baz\"}'))\n    })\n\n    test('should support date params', () => {\n      const date = new date()\n\n      expect(\n        buildurl('/foo', {\n          date: date\n        })\n      ).tobe('/foo?date=' + date.toisostring())\n    })\n\n    test('should support array params', () => {\n      expect(\n        buildurl('/foo', {\n          foo: ['bar', 'baz']\n        })\n      ).tobe('/foo?foo[]=bar&foo[]=baz')\n    })\n\n    test('should support special char params', () => {\n      expect(\n        buildurl('/foo', {\n          foo: '@:$, '\n        })\n      ).tobe('/foo?foo=@:$,+')\n    })\n\n    test('should support existing params', () => {\n      expect(\n        buildurl('/foo?foo=bar', {\n          bar: 'baz'\n        })\n      ).tobe('/foo?foo=bar&bar=baz')\n    })\n\n    test('should correct discard url hash mark', () => {\n      expect(\n        buildurl('/foo?foo=bar#hash', {\n          query: 'baz'\n        })\n      ).tobe('/foo?foo=bar&query=baz')\n    })\n\n    test('should use serializer if provided', () => {\n      const serializer = jest.fn(() => {\n        return 'foo=bar'\n      })\n      const params = { foo: 'bar' }\n      expect(buildurl('/foo', params, serializer)).tobe('/foo?foo=bar')\n      expect(serializer).tohavebeencalled()\n      expect(serializer).tohavebeencalledwith(params)\n    })\n\n    test('should support urlsearchparams', () => {\n      expect(buildurl('/foo', new urlsearchparams('bar=baz'))).tobe('/foo?bar=baz')\n    })\n  })\n\n  describe('isabsoluteurl', () => {\n    test('should return true if url begins with valid scheme name', () => {\n      expect(isabsoluteurl('https://api.github.com/users')).tobetruthy()\n      expect(isabsoluteurl('custom-scheme-v1.0://example.com/')).tobetruthy()\n      expect(isabsoluteurl('http://example.com/')).tobetruthy()\n    })\n\n    test('should return false if url begins with invalid scheme name', () => {\n      expect(isabsoluteurl('123://example.com/')).tobefalsy()\n      expect(isabsoluteurl('!valid://example.com/')).tobefalsy()\n    })\n\n    test('should return true if url is protocol-relative', () => {\n      expect(isabsoluteurl('//example.com/')).tobetruthy()\n    })\n\n    test('should return false if url is relative', () => {\n      expect(isabsoluteurl('/foo')).tobefalsy()\n      expect(isabsoluteurl('foo')).tobefalsy()\n    })\n  })\n\n  describe('combineurl', () => {\n    test('should combine url', () => {\n      expect(combineurl('https://api.github.com', '/users')).tobe('https://api.github.com/users')\n    })\n\n    test('should remove duplicate slashes', () => {\n      expect(combineurl('https://api.github.com/', '/users')).tobe('https://api.github.com/users')\n    })\n\n    test('should insert missing slash', () => {\n      expect(combineurl('https://api.github.com', 'users')).tobe('https://api.github.com/users')\n    })\n\n    test('should not insert slash when relative url missing/empty', () => {\n      expect(combineurl('https://api.github.com/users', '')).tobe('https://api.github.com/users')\n    })\n\n    test('should allow a single slash for relative url', () => {\n      expect(combineurl('https://api.github.com/users', '/')).tobe('https://api.github.com/users/')\n    })\n  })\n\n  describe('isurlsameorigin', () => {\n    test('should detect same origin', () => {\n      expect(isurlsameorigin(window.location.href)).tobetruthy()\n    })\n\n    test('should detect different origin', () => {\n      expect(isurlsameorigin('https://github.com/axios/axios')).tobefalsy()\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n\n\n这里要注意的是，我们使用了 jest.fn 去模拟了一个函数，这个也是在编写 jest 测试中非常常用的一个 api。\n\n至此，我们就实现了 ts-axios 库 helpers 目录下所有模块的测试，并把该目录下的测试覆盖率达到了近乎 100% 的覆盖率。下面的章节我们就开始测试 ts-axios 的核心流程，针对不同的 feature 去编写单元测试了。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"请求模块单元测试",frontmatter:{title:"请求模块单元测试",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/e1d15dec8634e6b5",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 单元测试"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/11.ts-axios%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/04.%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",relativePath:"《TypeScript 从零实现 axios》/11.ts-axios 单元测试/04.请求模块单元测试.md",key:"v-2f72dc3c",path:"/pages/e1d15dec8634e6b5/",headers:[{level:2,title:"jasmine-ajax",slug:"jasmine-ajax",normalizedTitle:"jasmine-ajax",charIndex:60},{level:2,title:"测试代码编写",slug:"测试代码编写",normalizedTitle:"测试代码编写",charIndex:787}],headersStr:"jasmine-ajax 测试代码编写",content:"# 请求模块单元测试\n\n请求模块是 axios 最基础的模块，通过一个 axios 方法发送 Ajax 请求。\n\n\n# jasmine-ajax\n\nJasmine 是一个 BDD(行为驱动开发)的测试框架，它有很多成熟的插件，比如我们要用到的 jasmine-ajax，它会为我们发出的 Ajax 请求根据规范定义一组假的响应，并跟踪我们发出的Ajax请求，可以让我们方便的为结果做断言。\n\n其实 Jest 也可以去写插件，但并没有现成的 Ajax 相关的 Jest 插件，但是 Jest 测试中我们仍然可以使用 Jasmine 相关的插件，只需要做一些小小的配置即可。\n\n当然，未来我也会考虑去编写一个 Ajax 相关的 Jest 插件，目前我们仍然使用 jasmine-ajax 去配合我们编写测试。\n\njasmine-ajax 依赖 jasmine-core，因此首先我们要安装几个依赖包，jasmine-ajax、jasmine-core 和 @types/jasmine-ajax。\n\n这个时候我们需要去修改 test/boot.ts 文件，因为每次跑具体测试代码之前会先运行该文件，我们可以在这里去初始化 jasmine-ajax。\n\nconst JasmineCore = require('jasmine-core')\n// @ts-ignore\nglobal.getJasmineRequireObj = function() {\n  return JasmineCore\n}\nrequire('jasmine-ajax')\n\n\n1\n2\n3\n4\n5\n6\n\n\n这里为了让 jasmine-ajax 插件运行成功，我们需要手动添加全局的 getJasmineRequireObj 方法，参考 issue。\n\n接下来，我们就开始编写请求模块的单元测试。\n\n\n# 测试代码编写\n\ntest/requests.spec.ts：\n\nimport axios, { AxiosResponse, AxiosError } from '../src/index'\nimport { getAjaxRequest } from './helper'\n\ndescribe('requests', () => {\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n  })\n\n  test('should treat single string arg as url', () => {\n    axios('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.url).toBe('/foo')\n      expect(request.method).toBe('GET')\n    })\n  })\n\n  test('should treat method value as lowercase string', done => {\n    axios({\n      url: '/foo',\n      method: 'POST'\n    }).then(response => {\n      expect(response.config.method).toBe('post')\n      done()\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200\n      })\n    })\n  })\n\n  test('should reject on network errors', done => {\n    const resolveSpy = jest.fn((res: AxiosResponse) => {\n      return res\n    })\n\n    const rejectSpy = jest.fn((e: AxiosError) => {\n      return e\n    })\n\n    jasmine.Ajax.uninstall()\n\n    axios('/foo')\n      .then(resolveSpy)\n      .catch(rejectSpy)\n      .then(next)\n\n    function next(reason: AxiosResponse | AxiosError) {\n      expect(resolveSpy).not.toHaveBeenCalled()\n      expect(rejectSpy).toHaveBeenCalled()\n      expect(reason instanceof Error).toBeTruthy()\n      expect((reason as AxiosError).message).toBe('Network Error')\n      expect(reason.request).toEqual(expect.any(XMLHttpRequest))\n\n      jasmine.Ajax.install()\n\n      done()\n    }\n  })\n\n  test('should reject when request timeout', done => {\n    let err: AxiosError\n\n    axios('/foo', {\n      timeout: 2000,\n      method: 'post'\n    }).catch(error => {\n      err = error\n    })\n\n    getAjaxRequest().then(request => {\n      // @ts-ignore\n      request.eventBus.trigger('timeout')\n\n      setTimeout(() => {\n        expect(err instanceof Error).toBeTruthy()\n        expect(err.message).toBe('Timeout of 2000 ms exceeded')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should reject when validateStatus returns false', done => {\n    const resolveSpy = jest.fn((res: AxiosResponse) => {\n      return res\n    })\n\n    const rejectSpy = jest.fn((e: AxiosError) => {\n      return e\n    })\n\n    axios('/foo', {\n      validateStatus(status) {\n        return status !== 500\n      }\n    })\n      .then(resolveSpy)\n      .catch(rejectSpy)\n      .then(next)\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 500\n      })\n    })\n\n    function next(reason: AxiosError | AxiosResponse) {\n      expect(resolveSpy).not.toHaveBeenCalled()\n      expect(rejectSpy).toHaveBeenCalled()\n      expect(reason instanceof Error).toBeTruthy()\n      expect((reason as AxiosError).message).toBe('Request failed with status code 500')\n      expect((reason as AxiosError).response!.status).toBe(500)\n\n      done()\n    }\n  })\n\n  test('should resolve when validateStatus returns true', done => {\n    const resolveSpy = jest.fn((res: AxiosResponse) => {\n      return res\n    })\n\n    const rejectSpy = jest.fn((e: AxiosError) => {\n      return e\n    })\n\n    axios('/foo', {\n      validateStatus(status) {\n        return status === 500\n      }\n    })\n      .then(resolveSpy)\n      .catch(rejectSpy)\n      .then(next)\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 500\n      })\n    })\n\n    function next(res: AxiosResponse | AxiosError) {\n      expect(resolveSpy).toHaveBeenCalled()\n      expect(rejectSpy).not.toHaveBeenCalled()\n      expect(res.config.url).toBe('/foo')\n\n      done()\n    }\n  })\n\n  test('should return JSON when resolved', done => {\n    let response: AxiosResponse\n\n    axios('/api/account/signup', {\n      auth: {\n        username: '',\n        password: ''\n      },\n      method: 'post',\n      headers: {\n        Accept: 'application/json'\n      }\n    }).then(res => {\n      response = res\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200,\n        statusText: 'OK',\n        responseText: '{\"a\": 1}'\n      })\n\n      setTimeout(() => {\n        expect(response.data).toEqual({ a: 1 })\n        done()\n      }, 100)\n    })\n  })\n\n  test('should return JSON when rejecting', done => {\n    let response: AxiosResponse\n\n    axios('/api/account/signup', {\n      auth: {\n        username: '',\n        password: ''\n      },\n      method: 'post',\n      headers: {\n        Accept: 'application/json'\n      }\n    }).catch(error => {\n      response = error.response\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 400,\n        statusText: 'Bad Request',\n        responseText: '{\"error\": \"BAD USERNAME\", \"code\": 1}'\n      })\n\n      setTimeout(() => {\n        expect(typeof response.data).toBe('object')\n        expect(response.data.error).toBe('BAD USERNAME')\n        expect(response.data.code).toBe(1)\n        done()\n      }, 100)\n    })\n  })\n\n  test('should supply correct response', done => {\n    let response: AxiosResponse\n\n    axios.post('/foo').then(res => {\n      response = res\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200,\n        statusText: 'OK',\n        responseText: '{\"foo\": \"bar\"}',\n        responseHeaders: {\n          'Content-Type': 'application/json'\n        }\n      })\n\n      setTimeout(() => {\n        expect(response.data.foo).toBe('bar')\n        expect(response.status).toBe(200)\n        expect(response.statusText).toBe('OK')\n        expect(response.headers['content-type']).toBe('application/json')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should allow overriding Content-Type header case-insensitive', () => {\n    let response: AxiosResponse\n\n    axios\n      .post(\n        '/foo',\n        { prop: 'value' },\n        {\n          headers: {\n            'content-type': 'application/json'\n          }\n        }\n      )\n      .then(res => {\n        response = res\n      })\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders['Content-Type']).toBe('application/json')\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n\n\n我们要注意的一些点，在这里列出：\n\n * beforeEach & afterEach\n\nbeforeEach表示每个测试用例运行前的钩子函数，在这里我们执行 jasmine.Ajax.install() 安装 jasmine.Ajax。\n\nafterEach表示每个测试用例运行后的钩子函数，在这里我们执行 jasmine.Ajax.uninstall() 卸载 jasmine.Ajax。\n\n * getAjaxRequest\n\ngetAjaxRequest 是我们在 test/helper.ts 定义的一个辅助方法，通过 jasmine.Ajax.requests.mostRecent() 拿到最近一次请求的 request 对象，这个 request 对象是 jasmine-ajax 库伪造的 xhr 对象，它模拟了 xhr 对象上的方法，并且提供一些 api 让我们使用，比如 request.respondWith 方法返回一个响应。\n\n * 异步测试\n\n注意到我们这里大部分的测试用例不再是同步的代码了，几乎都是一些异步逻辑，Jest 非常好地支持异步测试代码。通常有 2 种解决方案。\n\n第一种是利用 done 参数，每个测试用例函数有一个 done 参数，一旦我们使用了该参数，只有当 done 函数执行的时候表示这个测试用例结束。\n\n第二种是我们的测试函数返回一个 Promise 对象，一旦这个 Promise 对象 resolve 了，表示这个测试结束。\n\n * expect.any(constructor)\n\n它表示匹配任意由 constructor 创建的对象实例。\n\n * request.eventBus.trigger\n\n由于 request.responseTimeout 方法内部依赖了 jasmine.clock 方法会导致运行失败，这里我直接用了 request.eventBus.trigger('timeout') 方法触发了 timeout 事件。因为这个方法不在接口定义中，所以需要加 // @ts-ignore。\n\n另外，我们在测试中发现 2 个 case 没有通过。\n\n第一个是 should treat method value as lowercase string，这个测试用例是我们发送请求的 method 需要转换成小写字符串，这么做的目的也是为了之后 flattenHeaders 能正常处理这些 method，所以我们需要修改源码逻辑。\n\ncore/Axios.ts：\n\n  request(url: any, config?: any): AxiosPromise {\n    if (typeof url === 'string') {\n      if (!config) {\n        config = {}\n      }\n      config.url = url\n    } else {\n      config = url\n    }\n\n    config = mergeConfig(this.defaults, config)\n    config.method = config.method.toLowerCase()\n\n    // ...\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在合并配置后，我们需要把 config.method 转成小写字符串。\n\n另一个是 should return JSON when rejecting，这个测试用例是当我们发送请求失败后，也能把响应数据转换成 JSON 格式，所以也需要修改源码逻辑。\n\ncore/dispatchRequest.ts：\n\nexport default function dispatchRequest(config: AxiosRequestConfig): AxiosPromise {\n  throwIfCancellationRequested(config)\n  processConfig(config)\n  return xhr(config).then(\n    res => {\n      return transformResponseData(res)\n    },\n    e => {\n      if (e && e.response) {\n        e.response = transformResponseData(e.response)\n      }\n      return Promise.reject(e)\n    }\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n除了对正常情况的响应数据做转换，我们也需要对异常情况的响应数据做转换。\n\n至此我们完成了 ts-axios 库对请求模块的测试，下一节课我们会从业务的角度来测试 headers 模块。",normalizedContent:"# 请求模块单元测试\n\n请求模块是 axios 最基础的模块，通过一个 axios 方法发送 ajax 请求。\n\n\n# jasmine-ajax\n\njasmine 是一个 bdd(行为驱动开发)的测试框架，它有很多成熟的插件，比如我们要用到的 jasmine-ajax，它会为我们发出的 ajax 请求根据规范定义一组假的响应，并跟踪我们发出的ajax请求，可以让我们方便的为结果做断言。\n\n其实 jest 也可以去写插件，但并没有现成的 ajax 相关的 jest 插件，但是 jest 测试中我们仍然可以使用 jasmine 相关的插件，只需要做一些小小的配置即可。\n\n当然，未来我也会考虑去编写一个 ajax 相关的 jest 插件，目前我们仍然使用 jasmine-ajax 去配合我们编写测试。\n\njasmine-ajax 依赖 jasmine-core，因此首先我们要安装几个依赖包，jasmine-ajax、jasmine-core 和 @types/jasmine-ajax。\n\n这个时候我们需要去修改 test/boot.ts 文件，因为每次跑具体测试代码之前会先运行该文件，我们可以在这里去初始化 jasmine-ajax。\n\nconst jasminecore = require('jasmine-core')\n// @ts-ignore\nglobal.getjasminerequireobj = function() {\n  return jasminecore\n}\nrequire('jasmine-ajax')\n\n\n1\n2\n3\n4\n5\n6\n\n\n这里为了让 jasmine-ajax 插件运行成功，我们需要手动添加全局的 getjasminerequireobj 方法，参考 issue。\n\n接下来，我们就开始编写请求模块的单元测试。\n\n\n# 测试代码编写\n\ntest/requests.spec.ts：\n\nimport axios, { axiosresponse, axioserror } from '../src/index'\nimport { getajaxrequest } from './helper'\n\ndescribe('requests', () => {\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n  })\n\n  test('should treat single string arg as url', () => {\n    axios('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.url).tobe('/foo')\n      expect(request.method).tobe('get')\n    })\n  })\n\n  test('should treat method value as lowercase string', done => {\n    axios({\n      url: '/foo',\n      method: 'post'\n    }).then(response => {\n      expect(response.config.method).tobe('post')\n      done()\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200\n      })\n    })\n  })\n\n  test('should reject on network errors', done => {\n    const resolvespy = jest.fn((res: axiosresponse) => {\n      return res\n    })\n\n    const rejectspy = jest.fn((e: axioserror) => {\n      return e\n    })\n\n    jasmine.ajax.uninstall()\n\n    axios('/foo')\n      .then(resolvespy)\n      .catch(rejectspy)\n      .then(next)\n\n    function next(reason: axiosresponse | axioserror) {\n      expect(resolvespy).not.tohavebeencalled()\n      expect(rejectspy).tohavebeencalled()\n      expect(reason instanceof error).tobetruthy()\n      expect((reason as axioserror).message).tobe('network error')\n      expect(reason.request).toequal(expect.any(xmlhttprequest))\n\n      jasmine.ajax.install()\n\n      done()\n    }\n  })\n\n  test('should reject when request timeout', done => {\n    let err: axioserror\n\n    axios('/foo', {\n      timeout: 2000,\n      method: 'post'\n    }).catch(error => {\n      err = error\n    })\n\n    getajaxrequest().then(request => {\n      // @ts-ignore\n      request.eventbus.trigger('timeout')\n\n      settimeout(() => {\n        expect(err instanceof error).tobetruthy()\n        expect(err.message).tobe('timeout of 2000 ms exceeded')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should reject when validatestatus returns false', done => {\n    const resolvespy = jest.fn((res: axiosresponse) => {\n      return res\n    })\n\n    const rejectspy = jest.fn((e: axioserror) => {\n      return e\n    })\n\n    axios('/foo', {\n      validatestatus(status) {\n        return status !== 500\n      }\n    })\n      .then(resolvespy)\n      .catch(rejectspy)\n      .then(next)\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 500\n      })\n    })\n\n    function next(reason: axioserror | axiosresponse) {\n      expect(resolvespy).not.tohavebeencalled()\n      expect(rejectspy).tohavebeencalled()\n      expect(reason instanceof error).tobetruthy()\n      expect((reason as axioserror).message).tobe('request failed with status code 500')\n      expect((reason as axioserror).response!.status).tobe(500)\n\n      done()\n    }\n  })\n\n  test('should resolve when validatestatus returns true', done => {\n    const resolvespy = jest.fn((res: axiosresponse) => {\n      return res\n    })\n\n    const rejectspy = jest.fn((e: axioserror) => {\n      return e\n    })\n\n    axios('/foo', {\n      validatestatus(status) {\n        return status === 500\n      }\n    })\n      .then(resolvespy)\n      .catch(rejectspy)\n      .then(next)\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 500\n      })\n    })\n\n    function next(res: axiosresponse | axioserror) {\n      expect(resolvespy).tohavebeencalled()\n      expect(rejectspy).not.tohavebeencalled()\n      expect(res.config.url).tobe('/foo')\n\n      done()\n    }\n  })\n\n  test('should return json when resolved', done => {\n    let response: axiosresponse\n\n    axios('/api/account/signup', {\n      auth: {\n        username: '',\n        password: ''\n      },\n      method: 'post',\n      headers: {\n        accept: 'application/json'\n      }\n    }).then(res => {\n      response = res\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200,\n        statustext: 'ok',\n        responsetext: '{\"a\": 1}'\n      })\n\n      settimeout(() => {\n        expect(response.data).toequal({ a: 1 })\n        done()\n      }, 100)\n    })\n  })\n\n  test('should return json when rejecting', done => {\n    let response: axiosresponse\n\n    axios('/api/account/signup', {\n      auth: {\n        username: '',\n        password: ''\n      },\n      method: 'post',\n      headers: {\n        accept: 'application/json'\n      }\n    }).catch(error => {\n      response = error.response\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 400,\n        statustext: 'bad request',\n        responsetext: '{\"error\": \"bad username\", \"code\": 1}'\n      })\n\n      settimeout(() => {\n        expect(typeof response.data).tobe('object')\n        expect(response.data.error).tobe('bad username')\n        expect(response.data.code).tobe(1)\n        done()\n      }, 100)\n    })\n  })\n\n  test('should supply correct response', done => {\n    let response: axiosresponse\n\n    axios.post('/foo').then(res => {\n      response = res\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200,\n        statustext: 'ok',\n        responsetext: '{\"foo\": \"bar\"}',\n        responseheaders: {\n          'content-type': 'application/json'\n        }\n      })\n\n      settimeout(() => {\n        expect(response.data.foo).tobe('bar')\n        expect(response.status).tobe(200)\n        expect(response.statustext).tobe('ok')\n        expect(response.headers['content-type']).tobe('application/json')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should allow overriding content-type header case-insensitive', () => {\n    let response: axiosresponse\n\n    axios\n      .post(\n        '/foo',\n        { prop: 'value' },\n        {\n          headers: {\n            'content-type': 'application/json'\n          }\n        }\n      )\n      .then(res => {\n        response = res\n      })\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders['content-type']).tobe('application/json')\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n\n\n我们要注意的一些点，在这里列出：\n\n * beforeeach & aftereach\n\nbeforeeach表示每个测试用例运行前的钩子函数，在这里我们执行 jasmine.ajax.install() 安装 jasmine.ajax。\n\naftereach表示每个测试用例运行后的钩子函数，在这里我们执行 jasmine.ajax.uninstall() 卸载 jasmine.ajax。\n\n * getajaxrequest\n\ngetajaxrequest 是我们在 test/helper.ts 定义的一个辅助方法，通过 jasmine.ajax.requests.mostrecent() 拿到最近一次请求的 request 对象，这个 request 对象是 jasmine-ajax 库伪造的 xhr 对象，它模拟了 xhr 对象上的方法，并且提供一些 api 让我们使用，比如 request.respondwith 方法返回一个响应。\n\n * 异步测试\n\n注意到我们这里大部分的测试用例不再是同步的代码了，几乎都是一些异步逻辑，jest 非常好地支持异步测试代码。通常有 2 种解决方案。\n\n第一种是利用 done 参数，每个测试用例函数有一个 done 参数，一旦我们使用了该参数，只有当 done 函数执行的时候表示这个测试用例结束。\n\n第二种是我们的测试函数返回一个 promise 对象，一旦这个 promise 对象 resolve 了，表示这个测试结束。\n\n * expect.any(constructor)\n\n它表示匹配任意由 constructor 创建的对象实例。\n\n * request.eventbus.trigger\n\n由于 request.responsetimeout 方法内部依赖了 jasmine.clock 方法会导致运行失败，这里我直接用了 request.eventbus.trigger('timeout') 方法触发了 timeout 事件。因为这个方法不在接口定义中，所以需要加 // @ts-ignore。\n\n另外，我们在测试中发现 2 个 case 没有通过。\n\n第一个是 should treat method value as lowercase string，这个测试用例是我们发送请求的 method 需要转换成小写字符串，这么做的目的也是为了之后 flattenheaders 能正常处理这些 method，所以我们需要修改源码逻辑。\n\ncore/axios.ts：\n\n  request(url: any, config?: any): axiospromise {\n    if (typeof url === 'string') {\n      if (!config) {\n        config = {}\n      }\n      config.url = url\n    } else {\n      config = url\n    }\n\n    config = mergeconfig(this.defaults, config)\n    config.method = config.method.tolowercase()\n\n    // ...\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在合并配置后，我们需要把 config.method 转成小写字符串。\n\n另一个是 should return json when rejecting，这个测试用例是当我们发送请求失败后，也能把响应数据转换成 json 格式，所以也需要修改源码逻辑。\n\ncore/dispatchrequest.ts：\n\nexport default function dispatchrequest(config: axiosrequestconfig): axiospromise {\n  throwifcancellationrequested(config)\n  processconfig(config)\n  return xhr(config).then(\n    res => {\n      return transformresponsedata(res)\n    },\n    e => {\n      if (e && e.response) {\n        e.response = transformresponsedata(e.response)\n      }\n      return promise.reject(e)\n    }\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n除了对正常情况的响应数据做转换，我们也需要对异常情况的响应数据做转换。\n\n至此我们完成了 ts-axios 库对请求模块的测试，下一节课我们会从业务的角度来测试 headers 模块。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"Axios 实例模块单元测试",frontmatter:{title:"Axios 实例模块单元测试",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/2eac7a0a0d644c15",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 单元测试"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/11.ts-axios%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/06.Axios%20%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",relativePath:"《TypeScript 从零实现 axios》/11.ts-axios 单元测试/06.Axios 实例模块单元测试.md",key:"v-503841a2",path:"/pages/2eac7a0a0d644c15/",headers:[{level:2,title:"测试代码编写",slug:"测试代码编写",normalizedTitle:"测试代码编写",charIndex:84}],headersStr:"测试代码编写",content:"# Axios 实例模块单元测试\n\nts-axios 提供了 axios.create 静态方法，返回一个 instance 实例，我们需要对这个模块做测试。\n\n\n# 测试代码编写\n\ntest/instance.spec.ts：\n\nimport axios, { AxiosRequestConfig, AxiosResponse } from '../src/index'\nimport { getAjaxRequest } from './helper'\n\ndescribe('instance', () => {\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n  })\n\n  test('should make a http request without verb helper', () => {\n    const instance = axios.create()\n\n    instance('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.url).toBe('/foo')\n    })\n  })\n\n  test('should make a http request', () => {\n    const instance = axios.create()\n\n    instance.get('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.url).toBe('/foo')\n      expect(request.method).toBe('GET')\n    })\n  })\n\n  test('should make a post request', () => {\n    const instance = axios.create()\n\n    instance.post('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.method).toBe('POST')\n    })\n  })\n\n  test('should make a put request', () => {\n    const instance = axios.create()\n\n    instance.put('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.method).toBe('PUT')\n    })\n  })\n\n  test('should make a patch request', () => {\n    const instance = axios.create()\n\n    instance.patch('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.method).toBe('PATCH')\n    })\n  })\n\n  test('should make a options request', () => {\n    const instance = axios.create()\n\n    instance.options('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.method).toBe('OPTIONS')\n    })\n  })\n\n  test('should make a delete request', () => {\n    const instance = axios.create()\n\n    instance.delete('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.method).toBe('DELETE')\n    })\n  })\n\n  test('should make a head request', () => {\n    const instance = axios.create()\n\n    instance.head('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.method).toBe('HEAD')\n    })\n  })\n\n  test('should use instance options', () => {\n    const instance = axios.create({ timeout: 1000 })\n\n    instance.get('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.timeout).toBe(1000)\n    })\n  })\n\n  test('should have defaults.headers', () => {\n    const instance = axios.create({ baseURL: 'https://api.example.com' })\n\n    expect(typeof instance.defaults.headers).toBe('object')\n    expect(typeof instance.defaults.headers.common).toBe('object')\n  })\n\n  test('should have interceptors on the instance', done => {\n    axios.interceptors.request.use(config => {\n      config.timeout = 2000\n      return config\n    })\n\n    const instance = axios.create()\n\n    instance.interceptors.request.use(config => {\n      config.withCredentials = true\n      return config\n    })\n\n    let response: AxiosResponse\n    instance.get('/foo').then(res => {\n      response = res\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200\n      })\n\n      setTimeout(() => {\n        expect(response.config.timeout).toEqual(0)\n        expect(response.config.withCredentials).toEqual(true)\n        done()\n      }, 100)\n    })\n  })\n\n  test('should get the computed uri', () => {\n    const fakeConfig: AxiosRequestConfig = {\n      baseURL: 'https://www.baidu.com/',\n      url: '/user/12345',\n      params: {\n        idClient: 1,\n        idTest: 2,\n        testString: 'thisIsATest'\n      }\n    }\n    expect(axios.getUri(fakeConfig)).toBe(\n      'https://www.baidu.com/user/12345?idClient=1&idTest=2&testString=thisIsATest'\n    )\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n\n\n至此我们完成了 ts-axios 库 Axios 实例模块相关业务逻辑的测试，下一节课我们会对拦截器模块做测试。",normalizedContent:"# axios 实例模块单元测试\n\nts-axios 提供了 axios.create 静态方法，返回一个 instance 实例，我们需要对这个模块做测试。\n\n\n# 测试代码编写\n\ntest/instance.spec.ts：\n\nimport axios, { axiosrequestconfig, axiosresponse } from '../src/index'\nimport { getajaxrequest } from './helper'\n\ndescribe('instance', () => {\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n  })\n\n  test('should make a http request without verb helper', () => {\n    const instance = axios.create()\n\n    instance('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.url).tobe('/foo')\n    })\n  })\n\n  test('should make a http request', () => {\n    const instance = axios.create()\n\n    instance.get('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.url).tobe('/foo')\n      expect(request.method).tobe('get')\n    })\n  })\n\n  test('should make a post request', () => {\n    const instance = axios.create()\n\n    instance.post('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.method).tobe('post')\n    })\n  })\n\n  test('should make a put request', () => {\n    const instance = axios.create()\n\n    instance.put('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.method).tobe('put')\n    })\n  })\n\n  test('should make a patch request', () => {\n    const instance = axios.create()\n\n    instance.patch('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.method).tobe('patch')\n    })\n  })\n\n  test('should make a options request', () => {\n    const instance = axios.create()\n\n    instance.options('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.method).tobe('options')\n    })\n  })\n\n  test('should make a delete request', () => {\n    const instance = axios.create()\n\n    instance.delete('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.method).tobe('delete')\n    })\n  })\n\n  test('should make a head request', () => {\n    const instance = axios.create()\n\n    instance.head('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.method).tobe('head')\n    })\n  })\n\n  test('should use instance options', () => {\n    const instance = axios.create({ timeout: 1000 })\n\n    instance.get('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.timeout).tobe(1000)\n    })\n  })\n\n  test('should have defaults.headers', () => {\n    const instance = axios.create({ baseurl: 'https://api.example.com' })\n\n    expect(typeof instance.defaults.headers).tobe('object')\n    expect(typeof instance.defaults.headers.common).tobe('object')\n  })\n\n  test('should have interceptors on the instance', done => {\n    axios.interceptors.request.use(config => {\n      config.timeout = 2000\n      return config\n    })\n\n    const instance = axios.create()\n\n    instance.interceptors.request.use(config => {\n      config.withcredentials = true\n      return config\n    })\n\n    let response: axiosresponse\n    instance.get('/foo').then(res => {\n      response = res\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200\n      })\n\n      settimeout(() => {\n        expect(response.config.timeout).toequal(0)\n        expect(response.config.withcredentials).toequal(true)\n        done()\n      }, 100)\n    })\n  })\n\n  test('should get the computed uri', () => {\n    const fakeconfig: axiosrequestconfig = {\n      baseurl: 'https://www.baidu.com/',\n      url: '/user/12345',\n      params: {\n        idclient: 1,\n        idtest: 2,\n        teststring: 'thisisatest'\n      }\n    }\n    expect(axios.geturi(fakeconfig)).tobe(\n      'https://www.baidu.com/user/12345?idclient=1&idtest=2&teststring=thisisatest'\n    )\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n\n\n至此我们完成了 ts-axios 库 axios 实例模块相关业务逻辑的测试，下一节课我们会对拦截器模块做测试。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"拦截器模块单元测试",frontmatter:{title:"拦截器模块单元测试",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/97de6fd6293a2c6e",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 单元测试"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/11.ts-axios%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/07.%E6%8B%A6%E6%88%AA%E5%99%A8%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",relativePath:"《TypeScript 从零实现 axios》/11.ts-axios 单元测试/07.拦截器模块单元测试.md",key:"v-2f02c477",path:"/pages/97de6fd6293a2c6e/",headers:[{level:2,title:"测试代码编写",slug:"测试代码编写",normalizedTitle:"测试代码编写",charIndex:58}],headersStr:"测试代码编写",content:"# 拦截器模块单元测试\n\n拦截器是 ts-axios 库一个非常实用的功能，接下来我们来编写它的测试代码。\n\n\n# 测试代码编写\n\ntest/interceptor.spec.ts：\n\nimport axios, { AxiosRequestConfig, AxiosResponse } from '../src/index'\nimport { getAjaxRequest } from './helper'\n\ndescribe('interceptors', () => {\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n  })\n\n  test('should add a request interceptor', () => {\n    const instance = axios.create()\n\n    instance.interceptors.request.use((config: AxiosRequestConfig) => {\n      config.headers.test = 'added by interceptor'\n      return config\n    })\n\n    instance('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders.test).toBe('added by interceptor')\n    })\n  })\n\n  test('should add a request interceptor that returns a new config object', () => {\n    const instance = axios.create()\n\n    instance.interceptors.request.use(() => {\n      return {\n        url: '/bar',\n        method: 'post'\n      }\n    })\n\n    instance('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.method).toBe('POST')\n      expect(request.url).toBe('/bar')\n    })\n  })\n\n  test('should add a request interceptor that returns a promise', done => {\n    const instance = axios.create()\n\n    instance.interceptors.request.use((config: AxiosRequestConfig) => {\n      return new Promise(resolve => {\n        setTimeout(() => {\n          config.headers.async = 'promise'\n          resolve(config)\n        }, 10)\n      })\n    })\n\n    instance('/foo')\n\n    setTimeout(() => {\n      getAjaxRequest().then(request => {\n        expect(request.requestHeaders.async).toBe('promise')\n        done()\n      })\n    }, 100)\n  })\n\n  test('should add multiple request interceptors', () => {\n    const instance = axios.create()\n\n    instance.interceptors.request.use(config => {\n      config.headers.test1 = '1'\n      return config\n    })\n    instance.interceptors.request.use(config => {\n      config.headers.test2 = '2'\n      return config\n    })\n    instance.interceptors.request.use(config => {\n      config.headers.test3 = '3'\n      return config\n    })\n\n    instance('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders.test1).toBe('1')\n      expect(request.requestHeaders.test2).toBe('2')\n      expect(request.requestHeaders.test3).toBe('3')\n    })\n  })\n\n  test('should add a response interceptor', done => {\n    let response: AxiosResponse\n    const instance = axios.create()\n\n    instance.interceptors.response.use(data => {\n      data.data = data.data + ' - modified by interceptor'\n      return data\n    })\n\n    instance('/foo').then(data => {\n      response = data\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200,\n        responseText: 'OK'\n      })\n\n      setTimeout(() => {\n        expect(response.data).toBe('OK - modified by interceptor')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should add a response interceptor that returns a new data object', done => {\n    let response: AxiosResponse\n    const instance = axios.create()\n\n    instance.interceptors.response.use(() => {\n      return {\n        data: 'stuff',\n        headers: null,\n        status: 500,\n        statusText: 'ERR',\n        request: null,\n        config: {}\n      }\n    })\n\n    instance('/foo').then(res => {\n      response = res\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200,\n        responseText: 'OK'\n      })\n\n      setTimeout(() => {\n        expect(response.data).toBe('stuff')\n        expect(response.headers).toBeNull()\n        expect(response.status).toBe(500)\n        expect(response.statusText).toBe('ERR')\n        expect(response.request).toBeNull()\n        expect(response.config).toEqual({})\n        done()\n      }, 100)\n    })\n  })\n\n  test('should add a response interceptor that returns a promise', done => {\n    let response: AxiosResponse\n    const instance = axios.create()\n\n    instance.interceptors.response.use(data => {\n      return new Promise(resolve => {\n        // do something async\n        setTimeout(() => {\n          data.data = 'you have been promised!'\n          resolve(data)\n        }, 10)\n      })\n    })\n\n    instance('/foo').then(res => {\n      response = res\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200,\n        responseText: 'OK'\n      })\n\n      setTimeout(() => {\n        expect(response.data).toBe('you have been promised!')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should add multiple response interceptors', done => {\n    let response: AxiosResponse\n    const instance = axios.create()\n\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '1'\n      return data\n    })\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '2'\n      return data\n    })\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '3'\n      return data\n    })\n\n    instance('/foo').then(data => {\n      response = data\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200,\n        responseText: 'OK'\n      })\n\n      setTimeout(() => {\n        expect(response.data).toBe('OK123')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should allow removing interceptors', done => {\n    let response: AxiosResponse\n    let intercept\n    const instance = axios.create()\n\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '1'\n      return data\n    })\n    intercept = instance.interceptors.response.use(data => {\n      data.data = data.data + '2'\n      return data\n    })\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '3'\n      return data\n    })\n\n    instance.interceptors.response.eject(intercept)\n    instance.interceptors.response.eject(5)\n\n    instance('/foo').then(data => {\n      response = data\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200,\n        responseText: 'OK'\n      })\n\n      setTimeout(() => {\n        expect(response.data).toBe('OK13')\n        done()\n      }, 100)\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n\n\n运行测试后我们发现在测试用例 should add a request interceptor that returns a new config object 报错了，是代码运行的报错，而不是测试期望结果的报错，顺着报错信息，我们可以找到报错原因。\n\n在 core/xhr.ts 中，执行到 processHeaders 中的 Object.keys(headers).forEach 代码报错，因为我们在拦截器对请求配置做了修改，导致 headers 为空，所以报错。\n\n于是我们在解构赋值 headers 的时候，给它添加默认值即可。\n\nconst {\n  // ...\n  headers = {}\n} = config\n\n\n1\n2\n3\n4\n\n\n再次运行测试，发现全部测试通过。\n\n至此，我们完成了 ts-axios 库对拦截器模块的单元测试，下节课我们来测试 mergeConfig 模块的业务逻辑。",normalizedContent:"# 拦截器模块单元测试\n\n拦截器是 ts-axios 库一个非常实用的功能，接下来我们来编写它的测试代码。\n\n\n# 测试代码编写\n\ntest/interceptor.spec.ts：\n\nimport axios, { axiosrequestconfig, axiosresponse } from '../src/index'\nimport { getajaxrequest } from './helper'\n\ndescribe('interceptors', () => {\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n  })\n\n  test('should add a request interceptor', () => {\n    const instance = axios.create()\n\n    instance.interceptors.request.use((config: axiosrequestconfig) => {\n      config.headers.test = 'added by interceptor'\n      return config\n    })\n\n    instance('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders.test).tobe('added by interceptor')\n    })\n  })\n\n  test('should add a request interceptor that returns a new config object', () => {\n    const instance = axios.create()\n\n    instance.interceptors.request.use(() => {\n      return {\n        url: '/bar',\n        method: 'post'\n      }\n    })\n\n    instance('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.method).tobe('post')\n      expect(request.url).tobe('/bar')\n    })\n  })\n\n  test('should add a request interceptor that returns a promise', done => {\n    const instance = axios.create()\n\n    instance.interceptors.request.use((config: axiosrequestconfig) => {\n      return new promise(resolve => {\n        settimeout(() => {\n          config.headers.async = 'promise'\n          resolve(config)\n        }, 10)\n      })\n    })\n\n    instance('/foo')\n\n    settimeout(() => {\n      getajaxrequest().then(request => {\n        expect(request.requestheaders.async).tobe('promise')\n        done()\n      })\n    }, 100)\n  })\n\n  test('should add multiple request interceptors', () => {\n    const instance = axios.create()\n\n    instance.interceptors.request.use(config => {\n      config.headers.test1 = '1'\n      return config\n    })\n    instance.interceptors.request.use(config => {\n      config.headers.test2 = '2'\n      return config\n    })\n    instance.interceptors.request.use(config => {\n      config.headers.test3 = '3'\n      return config\n    })\n\n    instance('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders.test1).tobe('1')\n      expect(request.requestheaders.test2).tobe('2')\n      expect(request.requestheaders.test3).tobe('3')\n    })\n  })\n\n  test('should add a response interceptor', done => {\n    let response: axiosresponse\n    const instance = axios.create()\n\n    instance.interceptors.response.use(data => {\n      data.data = data.data + ' - modified by interceptor'\n      return data\n    })\n\n    instance('/foo').then(data => {\n      response = data\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200,\n        responsetext: 'ok'\n      })\n\n      settimeout(() => {\n        expect(response.data).tobe('ok - modified by interceptor')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should add a response interceptor that returns a new data object', done => {\n    let response: axiosresponse\n    const instance = axios.create()\n\n    instance.interceptors.response.use(() => {\n      return {\n        data: 'stuff',\n        headers: null,\n        status: 500,\n        statustext: 'err',\n        request: null,\n        config: {}\n      }\n    })\n\n    instance('/foo').then(res => {\n      response = res\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200,\n        responsetext: 'ok'\n      })\n\n      settimeout(() => {\n        expect(response.data).tobe('stuff')\n        expect(response.headers).tobenull()\n        expect(response.status).tobe(500)\n        expect(response.statustext).tobe('err')\n        expect(response.request).tobenull()\n        expect(response.config).toequal({})\n        done()\n      }, 100)\n    })\n  })\n\n  test('should add a response interceptor that returns a promise', done => {\n    let response: axiosresponse\n    const instance = axios.create()\n\n    instance.interceptors.response.use(data => {\n      return new promise(resolve => {\n        // do something async\n        settimeout(() => {\n          data.data = 'you have been promised!'\n          resolve(data)\n        }, 10)\n      })\n    })\n\n    instance('/foo').then(res => {\n      response = res\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200,\n        responsetext: 'ok'\n      })\n\n      settimeout(() => {\n        expect(response.data).tobe('you have been promised!')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should add multiple response interceptors', done => {\n    let response: axiosresponse\n    const instance = axios.create()\n\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '1'\n      return data\n    })\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '2'\n      return data\n    })\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '3'\n      return data\n    })\n\n    instance('/foo').then(data => {\n      response = data\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200,\n        responsetext: 'ok'\n      })\n\n      settimeout(() => {\n        expect(response.data).tobe('ok123')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should allow removing interceptors', done => {\n    let response: axiosresponse\n    let intercept\n    const instance = axios.create()\n\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '1'\n      return data\n    })\n    intercept = instance.interceptors.response.use(data => {\n      data.data = data.data + '2'\n      return data\n    })\n    instance.interceptors.response.use(data => {\n      data.data = data.data + '3'\n      return data\n    })\n\n    instance.interceptors.response.eject(intercept)\n    instance.interceptors.response.eject(5)\n\n    instance('/foo').then(data => {\n      response = data\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200,\n        responsetext: 'ok'\n      })\n\n      settimeout(() => {\n        expect(response.data).tobe('ok13')\n        done()\n      }, 100)\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n\n\n运行测试后我们发现在测试用例 should add a request interceptor that returns a new config object 报错了，是代码运行的报错，而不是测试期望结果的报错，顺着报错信息，我们可以找到报错原因。\n\n在 core/xhr.ts 中，执行到 processheaders 中的 object.keys(headers).foreach 代码报错，因为我们在拦截器对请求配置做了修改，导致 headers 为空，所以报错。\n\n于是我们在解构赋值 headers 的时候，给它添加默认值即可。\n\nconst {\n  // ...\n  headers = {}\n} = config\n\n\n1\n2\n3\n4\n\n\n再次运行测试，发现全部测试通过。\n\n至此，我们完成了 ts-axios 库对拦截器模块的单元测试，下节课我们来测试 mergeconfig 模块的业务逻辑。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"headers 模块单元测试",frontmatter:{title:"headers 模块单元测试",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/ddd86ec39b5dfe33",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 单元测试"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/11.ts-axios%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/05.headers%20%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",relativePath:"《TypeScript 从零实现 axios》/11.ts-axios 单元测试/05.headers 模块单元测试.md",key:"v-50f4f5cb",path:"/pages/ddd86ec39b5dfe33/",headers:[{level:2,title:"测试代码编写",slug:"测试代码编写",normalizedTitle:"测试代码编写",charIndex:77}],headersStr:"测试代码编写",content:"# headers 模块单元测试\n\n之前我们测试了 headers 的基础方法模块，接下来我们会从业务角度测试 headers 的相关业务逻辑。\n\n\n# 测试代码编写\n\ntest/headers.spec.ts：\n\nimport axios from '../src/index'\nimport { getAjaxRequest } from './helper'\n\nfunction testHeaderValue(headers: any, key: string, val?: string): void {\n  let found = false\n\n  for (let k in headers) {\n    if (k.toLowerCase() === key.toLowerCase()) {\n      found = true\n      expect(headers[k]).toBe(val)\n      break\n    }\n  }\n\n  if (!found) {\n    if (typeof val === 'undefined') {\n      expect(headers.hasOwnProperty(key)).toBeFalsy()\n    } else {\n      throw new Error(key + ' was not found in headers')\n    }\n  }\n}\n\ndescribe('headers', () => {\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n  })\n\n  test('should use default common headers', () => {\n    const headers = axios.defaults.headers.common\n\n    axios('/foo')\n\n    return getAjaxRequest().then(request => {\n      for (let key in headers) {\n        if (headers.hasOwnProperty(key)) {\n          expect(request.requestHeaders[key]).toEqual(headers[key])\n        }\n      }\n    })\n  })\n\n  test('should add extra headers for post', () => {\n    axios.post('/foo', 'fizz=buzz')\n\n    return getAjaxRequest().then(request => {\n      testHeaderValue(request.requestHeaders, 'Content-Type', 'application/x-www-form-urlencoded')\n    })\n  })\n\n  test('should use application/json when posting an object', () => {\n    axios.post('/foo/bar', {\n      firstName: 'foo',\n      lastName: 'bar'\n    })\n\n    return getAjaxRequest().then(request => {\n      testHeaderValue(request.requestHeaders, 'Content-Type', 'application/json;charset=utf-8')\n    })\n  })\n\n  test('should remove content-type if data is empty', () => {\n    axios.post('/foo')\n\n    return getAjaxRequest().then(request => {\n      testHeaderValue(request.requestHeaders, 'Content-Type', undefined)\n    })\n  })\n\n  it('should preserve content-type if data is false', () => {\n    axios.post('/foo', false)\n\n    return getAjaxRequest().then(request => {\n      testHeaderValue(request.requestHeaders, 'Content-Type', 'application/x-www-form-urlencoded')\n    })\n  })\n\n  test('should remove content-type if data is FormData', () => {\n    const data = new FormData()\n    data.append('foo', 'bar')\n\n    axios.post('/foo', data)\n\n    return getAjaxRequest().then(request => {\n      testHeaderValue(request.requestHeaders, 'Content-Type', undefined)\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n\n\n内部定义了 testHeaderValue 辅助函数，用于测试 headers 是否存在某个 header name 下的某个值。\n\n至此我们完成了 ts-axios 库 headers 模块相关业务逻辑的测试，下一节课我们会对 Axios 的实例做测试。",normalizedContent:"# headers 模块单元测试\n\n之前我们测试了 headers 的基础方法模块，接下来我们会从业务角度测试 headers 的相关业务逻辑。\n\n\n# 测试代码编写\n\ntest/headers.spec.ts：\n\nimport axios from '../src/index'\nimport { getajaxrequest } from './helper'\n\nfunction testheadervalue(headers: any, key: string, val?: string): void {\n  let found = false\n\n  for (let k in headers) {\n    if (k.tolowercase() === key.tolowercase()) {\n      found = true\n      expect(headers[k]).tobe(val)\n      break\n    }\n  }\n\n  if (!found) {\n    if (typeof val === 'undefined') {\n      expect(headers.hasownproperty(key)).tobefalsy()\n    } else {\n      throw new error(key + ' was not found in headers')\n    }\n  }\n}\n\ndescribe('headers', () => {\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n  })\n\n  test('should use default common headers', () => {\n    const headers = axios.defaults.headers.common\n\n    axios('/foo')\n\n    return getajaxrequest().then(request => {\n      for (let key in headers) {\n        if (headers.hasownproperty(key)) {\n          expect(request.requestheaders[key]).toequal(headers[key])\n        }\n      }\n    })\n  })\n\n  test('should add extra headers for post', () => {\n    axios.post('/foo', 'fizz=buzz')\n\n    return getajaxrequest().then(request => {\n      testheadervalue(request.requestheaders, 'content-type', 'application/x-www-form-urlencoded')\n    })\n  })\n\n  test('should use application/json when posting an object', () => {\n    axios.post('/foo/bar', {\n      firstname: 'foo',\n      lastname: 'bar'\n    })\n\n    return getajaxrequest().then(request => {\n      testheadervalue(request.requestheaders, 'content-type', 'application/json;charset=utf-8')\n    })\n  })\n\n  test('should remove content-type if data is empty', () => {\n    axios.post('/foo')\n\n    return getajaxrequest().then(request => {\n      testheadervalue(request.requestheaders, 'content-type', undefined)\n    })\n  })\n\n  it('should preserve content-type if data is false', () => {\n    axios.post('/foo', false)\n\n    return getajaxrequest().then(request => {\n      testheadervalue(request.requestheaders, 'content-type', 'application/x-www-form-urlencoded')\n    })\n  })\n\n  test('should remove content-type if data is formdata', () => {\n    const data = new formdata()\n    data.append('foo', 'bar')\n\n    axios.post('/foo', data)\n\n    return getajaxrequest().then(request => {\n      testheadervalue(request.requestheaders, 'content-type', undefined)\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n\n\n内部定义了 testheadervalue 辅助函数，用于测试 headers 是否存在某个 header name 下的某个值。\n\n至此我们完成了 ts-axios 库 headers 模块相关业务逻辑的测试，下一节课我们会对 axios 的实例做测试。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"mergeConfig 模块单元测试",frontmatter:{title:"mergeConfig 模块单元测试",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/cdf59840306f9e81",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 单元测试"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/11.ts-axios%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/08.mergeConfig%20%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",relativePath:"《TypeScript 从零实现 axios》/11.ts-axios 单元测试/08.mergeConfig 模块单元测试.md",key:"v-4ee9b879",path:"/pages/cdf59840306f9e81/",headers:[{level:2,title:"测试代码编写",slug:"测试代码编写",normalizedTitle:"测试代码编写",charIndex:74}],headersStr:"测试代码编写",content:"# mergeConfig 模块单元测试\n\n合并配置是 ts-axios 核心流程中非常重要的一个环节，我们需要为它的各种情况去编写测试。\n\n\n# 测试代码编写\n\ntest/mergeConfig.spec.ts：\n\nimport axios from '../src/index'\nimport mergeConfig from '../src/core/mergeConfig'\n\ndescribe('mergeConfig', () => {\n  const defaults = axios.defaults\n\n  test('should accept undefined for second argument', () => {\n    expect(mergeConfig(defaults, undefined)).toEqual(defaults)\n  })\n\n  test('should accept an object for second argument', () => {\n    expect(mergeConfig(defaults, {})).toEqual(defaults)\n  })\n\n  test('should not leave references', () => {\n    const merged = mergeConfig(defaults, {})\n    expect(merged).not.toBe(defaults)\n    expect(merged.headers).not.toBe(defaults.headers)\n  })\n\n  test('should allow setting request options', () => {\n    const config = {\n      url: '__sample url__',\n      params: '__sample params__',\n      data: { foo: true }\n    }\n    const merged = mergeConfig(defaults, config)\n    expect(merged.url).toBe(config.url)\n    expect(merged.params).toBe(config.params)\n    expect(merged.data).toEqual(config.data)\n  })\n\n  test('should not inherit request options', () => {\n    const localDefaults = {\n      url: '__sample url__',\n      params: '__sample params__',\n      data: { foo: true }\n    }\n    const merged = mergeConfig(localDefaults, {})\n    expect(merged.url).toBeUndefined()\n    expect(merged.params).toBeUndefined()\n    expect(merged.data).toBeUndefined()\n  })\n\n  test('should return default headers if pass config2 with undefined', () => {\n    expect(\n      mergeConfig(\n        {\n          headers: 'x-mock-header'\n        },\n        undefined\n      )\n    ).toEqual({\n      headers: 'x-mock-header'\n    })\n  })\n\n  test('should merge auth, headers with defaults', () => {\n    expect(\n      mergeConfig(\n        {\n          auth: undefined\n        },\n        {\n          auth: {\n            username: 'foo',\n            password: 'test'\n          }\n        }\n      )\n    ).toEqual({\n      auth: {\n        username: 'foo',\n        password: 'test'\n      }\n    })\n    expect(\n      mergeConfig(\n        {\n          auth: {\n            username: 'foo',\n            password: 'test'\n          }\n        },\n        {\n          auth: {\n            username: 'baz',\n            password: 'foobar'\n          }\n        }\n      )\n    ).toEqual({\n      auth: {\n        username: 'baz',\n        password: 'foobar'\n      }\n    })\n  })\n\n  test('should overwrite auth, headers with a non-object value', () => {\n    expect(\n      mergeConfig(\n        {\n          headers: {\n            common: {\n              Accept: 'application/json, text/plain, */*'\n            }\n          }\n        },\n        {\n          headers: null\n        }\n      )\n    ).toEqual({\n      headers: null\n    })\n  })\n\n  test('should allow setting other options', () => {\n    const merged = mergeConfig(defaults, {\n      timeout: 123\n    })\n    expect(merged.timeout).toBe(123)\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n\n\n运行测试后我们发现 mergeConfig.ts 文件的分支覆盖率并未达到 100%，提示是 23 行，打开文件后发现最后一个 else 逻辑并未走到，也就是 val1 为 undefined 的情况。但实际上即使 val1 为 undefined，我们也是返回 undefined，也就是返回 val1，所以这块代码的逻辑可以优化。\n\nfunction deepMergeStrat(val1: any, val2: any): any {\n  if (isPlainObject(val2)) {\n    return deepMerge(val1, val2)\n  } else if (typeof val2 !== 'undefined') {\n    return val2\n  } else if (isPlainObject(val1)) {\n    return deepMerge(val1)\n  } else {\n    return val1\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n2 个分支可以合并到一个分支，这样我们再次跑测试，分支覆盖率就可以达到 100% 了。\n\n至此我们完成了 ts-axios 库对 mergeConfig 模块的测试，下一节课我们来测试取消模块相关代码。",normalizedContent:"# mergeconfig 模块单元测试\n\n合并配置是 ts-axios 核心流程中非常重要的一个环节，我们需要为它的各种情况去编写测试。\n\n\n# 测试代码编写\n\ntest/mergeconfig.spec.ts：\n\nimport axios from '../src/index'\nimport mergeconfig from '../src/core/mergeconfig'\n\ndescribe('mergeconfig', () => {\n  const defaults = axios.defaults\n\n  test('should accept undefined for second argument', () => {\n    expect(mergeconfig(defaults, undefined)).toequal(defaults)\n  })\n\n  test('should accept an object for second argument', () => {\n    expect(mergeconfig(defaults, {})).toequal(defaults)\n  })\n\n  test('should not leave references', () => {\n    const merged = mergeconfig(defaults, {})\n    expect(merged).not.tobe(defaults)\n    expect(merged.headers).not.tobe(defaults.headers)\n  })\n\n  test('should allow setting request options', () => {\n    const config = {\n      url: '__sample url__',\n      params: '__sample params__',\n      data: { foo: true }\n    }\n    const merged = mergeconfig(defaults, config)\n    expect(merged.url).tobe(config.url)\n    expect(merged.params).tobe(config.params)\n    expect(merged.data).toequal(config.data)\n  })\n\n  test('should not inherit request options', () => {\n    const localdefaults = {\n      url: '__sample url__',\n      params: '__sample params__',\n      data: { foo: true }\n    }\n    const merged = mergeconfig(localdefaults, {})\n    expect(merged.url).tobeundefined()\n    expect(merged.params).tobeundefined()\n    expect(merged.data).tobeundefined()\n  })\n\n  test('should return default headers if pass config2 with undefined', () => {\n    expect(\n      mergeconfig(\n        {\n          headers: 'x-mock-header'\n        },\n        undefined\n      )\n    ).toequal({\n      headers: 'x-mock-header'\n    })\n  })\n\n  test('should merge auth, headers with defaults', () => {\n    expect(\n      mergeconfig(\n        {\n          auth: undefined\n        },\n        {\n          auth: {\n            username: 'foo',\n            password: 'test'\n          }\n        }\n      )\n    ).toequal({\n      auth: {\n        username: 'foo',\n        password: 'test'\n      }\n    })\n    expect(\n      mergeconfig(\n        {\n          auth: {\n            username: 'foo',\n            password: 'test'\n          }\n        },\n        {\n          auth: {\n            username: 'baz',\n            password: 'foobar'\n          }\n        }\n      )\n    ).toequal({\n      auth: {\n        username: 'baz',\n        password: 'foobar'\n      }\n    })\n  })\n\n  test('should overwrite auth, headers with a non-object value', () => {\n    expect(\n      mergeconfig(\n        {\n          headers: {\n            common: {\n              accept: 'application/json, text/plain, */*'\n            }\n          }\n        },\n        {\n          headers: null\n        }\n      )\n    ).toequal({\n      headers: null\n    })\n  })\n\n  test('should allow setting other options', () => {\n    const merged = mergeconfig(defaults, {\n      timeout: 123\n    })\n    expect(merged.timeout).tobe(123)\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n\n\n运行测试后我们发现 mergeconfig.ts 文件的分支覆盖率并未达到 100%，提示是 23 行，打开文件后发现最后一个 else 逻辑并未走到，也就是 val1 为 undefined 的情况。但实际上即使 val1 为 undefined，我们也是返回 undefined，也就是返回 val1，所以这块代码的逻辑可以优化。\n\nfunction deepmergestrat(val1: any, val2: any): any {\n  if (isplainobject(val2)) {\n    return deepmerge(val1, val2)\n  } else if (typeof val2 !== 'undefined') {\n    return val2\n  } else if (isplainobject(val1)) {\n    return deepmerge(val1)\n  } else {\n    return val1\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n2 个分支可以合并到一个分支，这样我们再次跑测试，分支覆盖率就可以达到 100% 了。\n\n至此我们完成了 ts-axios 库对 mergeconfig 模块的测试，下一节课我们来测试取消模块相关代码。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"请求取消模块单元测试",frontmatter:{title:"请求取消模块单元测试",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/6fa16aee29527032",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 单元测试"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/11.ts-axios%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/09.%E8%AF%B7%E6%B1%82%E5%8F%96%E6%B6%88%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",relativePath:"《TypeScript 从零实现 axios》/11.ts-axios 单元测试/09.请求取消模块单元测试.md",key:"v-43b8a596",path:"/pages/6fa16aee29527032/",headers:[{level:2,title:"Cancel 类单元测试",slug:"cancel-类单元测试",normalizedTitle:"cancel 类单元测试",charIndex:86},{level:2,title:"CancelToken 类单元测试",slug:"canceltoken-类单元测试",normalizedTitle:"canceltoken 类单元测试",charIndex:704},{level:2,title:"Cancel 业务逻辑单元测试",slug:"cancel-业务逻辑单元测试",normalizedTitle:"cancel 业务逻辑单元测试",charIndex:4050}],headersStr:"Cancel 类单元测试 CancelToken 类单元测试 Cancel 业务逻辑单元测试",content:"# 请求取消模块单元测试\n\n请求取消模块是 ts-axios 库核心流程其中一个分支，也是非常重要的模块，我们将从基础库和业务流程模块 2 个方面去编写单元测试。\n\n\n# Cancel 类单元测试\n\ncancel/Cancel.spec.ts：\n\nimport Cancel, { isCancel } from '../../src/cancel/Cancel'\n\ndescribe('cancel:Cancel', () => {\n  test('should returns correct result when message is specified', () => {\n    const cancel = new Cancel('Operation has been canceled.')\n    expect(cancel.message).toBe('Operation has been canceled.')\n  })\n\n  test('should returns true if value is a Cancel', () => {\n    expect(isCancel(new Cancel())).toBeTruthy()\n  })\n\n  test('should returns false if value is not a Cancel', () => {\n    expect(isCancel({ foo: 'bar' })).toBeFalsy()\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# CancelToken 类单元测试\n\ncancel/CancelToken.spec.ts：\n\nimport CancelToken from '../../src/cancel/CancelToken'\nimport Cancel from '../../src/cancel/Cancel'\nimport { Canceler } from '../../src/types'\n\ndescribe('CancelToken', () => {\n  describe('reason', () => {\n    test('should returns a Cancel if cancellation has been requested', () => {\n      let cancel: Canceler\n      let token = new CancelToken(c => {\n        cancel = c\n      })\n      cancel!('Operation has been canceled.')\n      expect(token.reason).toEqual(expect.any(Cancel))\n      expect(token.reason!.message).toBe('Operation has been canceled.')\n    })\n\n    test('should has no side effect if call cancellation for multi times', () => {\n      let cancel: Canceler\n      let token = new CancelToken(c => {\n        cancel = c\n      })\n      cancel!('Operation has been canceled.')\n      cancel!('Operation has been canceled.')\n      expect(token.reason).toEqual(expect.any(Cancel))\n      expect(token.reason!.message).toBe('Operation has been canceled.')\n    })\n\n    test('should returns undefined if cancellation has not been requested', () => {\n      const token = new CancelToken(() => {\n        // do nothing\n      })\n      expect(token.reason).toBeUndefined()\n    })\n  })\n\n  describe('promise', () => {\n    test('should returns a Promise that resolves when cancellation is requested', done => {\n      let cancel: Canceler\n      const token = new CancelToken(c => {\n        cancel = c\n      })\n      token.promise.then(value => {\n        expect(value).toEqual(expect.any(Cancel))\n        expect(value.message).toBe('Operation has been canceled.')\n        done()\n      })\n      cancel!('Operation has been canceled.')\n    })\n  })\n\n  describe('throwIfRequested', () => {\n    test('should throws if cancellation has been requested', () => {\n      let cancel: Canceler\n      const token = new CancelToken(c => {\n        cancel = c\n      })\n      cancel!('Operation has been canceled.')\n      try {\n        token.throwIfRequested()\n        fail('Expected throwIfRequested to throw.')\n      } catch (thrown) {\n        if (!(thrown instanceof Cancel)) {\n          fail('Expected throwIfRequested to throw a Cancel, but test threw ' + thrown + '.')\n        }\n        expect(thrown.message).toBe('Operation has been canceled.')\n      }\n    })\n\n    test('should does not throw if cancellation has not been requested', () => {\n      const token = new CancelToken(() => {\n        // do nothing\n      })\n      token.throwIfRequested()\n    })\n  })\n\n  describe('source', () => {\n    test('should returns an object containing token and cancel function', () => {\n      const source = CancelToken.source()\n      expect(source.token).toEqual(expect.any(CancelToken))\n      expect(source.cancel).toEqual(expect.any(Function))\n      expect(source.token.reason).toBeUndefined()\n      source.cancel('Operation has been canceled.')\n      expect(source.token.reason).toEqual(expect.any(Cancel))\n      expect(source.token.reason!.message).toBe('Operation has been canceled.')\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n注意，这里我们使用了 fail 函数表示一个测试的失败，这个并未在 Jest 文档中体现，但它是一个可以用的 API。\n\n\n# Cancel 业务逻辑单元测试\n\ncancel.spec.ts：\n\nimport axios from '../src/index'\nimport { getAjaxRequest } from './helper'\n\ndescribe('cancel', () => {\n  const CancelToken = axios.CancelToken\n  const Cancel = axios.Cancel\n\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n  })\n\n  describe('when called before sending request', () => {\n    test('should rejects Promise with a Cancel object', () => {\n      const source = CancelToken.source()\n      source.cancel('Operation has been canceled.')\n\n      return axios\n        .get('/foo', {\n          cancelToken: source.token\n        })\n        .catch(reason => {\n          expect(reason).toEqual(expect.any(Cancel))\n          expect(reason.message).toBe('Operation has been canceled.')\n        })\n    })\n  })\n\n  describe('when called after request has been sent', () => {\n    test('should rejects Promise with a Cancel object', done => {\n      const source = CancelToken.source()\n      axios\n        .get('/foo/bar', {\n          cancelToken: source.token\n        })\n        .catch(reason => {\n          expect(reason).toEqual(expect.any(Cancel))\n          expect(reason.message).toBe('Operation has been canceled.')\n          done()\n        })\n\n      getAjaxRequest().then(request => {\n        source.cancel('Operation has been canceled.')\n        setTimeout(() => {\n          request.respondWith({\n            status: 200,\n            responseText: 'OK'\n          })\n        }, 100)\n      })\n    })\n\n    test('calls abort on request object', done => {\n      const source = CancelToken.source()\n      let request: any\n      axios\n        .get('/foo/bar', {\n          cancelToken: source.token\n        })\n        .catch(() => {\n          expect(request.statusText).toBe('abort')\n          done()\n        })\n\n      getAjaxRequest().then(req => {\n        source.cancel()\n        request = req\n      })\n    })\n  })\n\n  describe('when called after response has been received', () => {\n    test('should not cause unhandled rejection', done => {\n      const source = CancelToken.source()\n      axios\n        .get('/foo', {\n          cancelToken: source.token\n        })\n        .then(() => {\n          window.addEventListener('unhandledrejection', () => {\n            done.fail('Unhandled rejection.')\n          })\n          source.cancel()\n          setTimeout(done, 100)\n        })\n\n      getAjaxRequest().then(request => {\n        request.respondWith({\n          status: 200,\n          responseText: 'OK'\n        })\n      })\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n注意这里我们使用了 done.fail 表示了一个异常的结束，这个并未在 Jest 文档中体现，但它是一个可以用的 API。\n\n至此，我们完成了取消模块相关业务逻辑的单元测试，我们测试覆盖率达到了阈值，测试已经通过了。但是扔未达到我们的目标，还有很多 feature 是没有覆盖到的。接下来我们就完成剩余 feature 的编写单元测试。",normalizedContent:"# 请求取消模块单元测试\n\n请求取消模块是 ts-axios 库核心流程其中一个分支，也是非常重要的模块，我们将从基础库和业务流程模块 2 个方面去编写单元测试。\n\n\n# cancel 类单元测试\n\ncancel/cancel.spec.ts：\n\nimport cancel, { iscancel } from '../../src/cancel/cancel'\n\ndescribe('cancel:cancel', () => {\n  test('should returns correct result when message is specified', () => {\n    const cancel = new cancel('operation has been canceled.')\n    expect(cancel.message).tobe('operation has been canceled.')\n  })\n\n  test('should returns true if value is a cancel', () => {\n    expect(iscancel(new cancel())).tobetruthy()\n  })\n\n  test('should returns false if value is not a cancel', () => {\n    expect(iscancel({ foo: 'bar' })).tobefalsy()\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# canceltoken 类单元测试\n\ncancel/canceltoken.spec.ts：\n\nimport canceltoken from '../../src/cancel/canceltoken'\nimport cancel from '../../src/cancel/cancel'\nimport { canceler } from '../../src/types'\n\ndescribe('canceltoken', () => {\n  describe('reason', () => {\n    test('should returns a cancel if cancellation has been requested', () => {\n      let cancel: canceler\n      let token = new canceltoken(c => {\n        cancel = c\n      })\n      cancel!('operation has been canceled.')\n      expect(token.reason).toequal(expect.any(cancel))\n      expect(token.reason!.message).tobe('operation has been canceled.')\n    })\n\n    test('should has no side effect if call cancellation for multi times', () => {\n      let cancel: canceler\n      let token = new canceltoken(c => {\n        cancel = c\n      })\n      cancel!('operation has been canceled.')\n      cancel!('operation has been canceled.')\n      expect(token.reason).toequal(expect.any(cancel))\n      expect(token.reason!.message).tobe('operation has been canceled.')\n    })\n\n    test('should returns undefined if cancellation has not been requested', () => {\n      const token = new canceltoken(() => {\n        // do nothing\n      })\n      expect(token.reason).tobeundefined()\n    })\n  })\n\n  describe('promise', () => {\n    test('should returns a promise that resolves when cancellation is requested', done => {\n      let cancel: canceler\n      const token = new canceltoken(c => {\n        cancel = c\n      })\n      token.promise.then(value => {\n        expect(value).toequal(expect.any(cancel))\n        expect(value.message).tobe('operation has been canceled.')\n        done()\n      })\n      cancel!('operation has been canceled.')\n    })\n  })\n\n  describe('throwifrequested', () => {\n    test('should throws if cancellation has been requested', () => {\n      let cancel: canceler\n      const token = new canceltoken(c => {\n        cancel = c\n      })\n      cancel!('operation has been canceled.')\n      try {\n        token.throwifrequested()\n        fail('expected throwifrequested to throw.')\n      } catch (thrown) {\n        if (!(thrown instanceof cancel)) {\n          fail('expected throwifrequested to throw a cancel, but test threw ' + thrown + '.')\n        }\n        expect(thrown.message).tobe('operation has been canceled.')\n      }\n    })\n\n    test('should does not throw if cancellation has not been requested', () => {\n      const token = new canceltoken(() => {\n        // do nothing\n      })\n      token.throwifrequested()\n    })\n  })\n\n  describe('source', () => {\n    test('should returns an object containing token and cancel function', () => {\n      const source = canceltoken.source()\n      expect(source.token).toequal(expect.any(canceltoken))\n      expect(source.cancel).toequal(expect.any(function))\n      expect(source.token.reason).tobeundefined()\n      source.cancel('operation has been canceled.')\n      expect(source.token.reason).toequal(expect.any(cancel))\n      expect(source.token.reason!.message).tobe('operation has been canceled.')\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n注意，这里我们使用了 fail 函数表示一个测试的失败，这个并未在 jest 文档中体现，但它是一个可以用的 api。\n\n\n# cancel 业务逻辑单元测试\n\ncancel.spec.ts：\n\nimport axios from '../src/index'\nimport { getajaxrequest } from './helper'\n\ndescribe('cancel', () => {\n  const canceltoken = axios.canceltoken\n  const cancel = axios.cancel\n\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n  })\n\n  describe('when called before sending request', () => {\n    test('should rejects promise with a cancel object', () => {\n      const source = canceltoken.source()\n      source.cancel('operation has been canceled.')\n\n      return axios\n        .get('/foo', {\n          canceltoken: source.token\n        })\n        .catch(reason => {\n          expect(reason).toequal(expect.any(cancel))\n          expect(reason.message).tobe('operation has been canceled.')\n        })\n    })\n  })\n\n  describe('when called after request has been sent', () => {\n    test('should rejects promise with a cancel object', done => {\n      const source = canceltoken.source()\n      axios\n        .get('/foo/bar', {\n          canceltoken: source.token\n        })\n        .catch(reason => {\n          expect(reason).toequal(expect.any(cancel))\n          expect(reason.message).tobe('operation has been canceled.')\n          done()\n        })\n\n      getajaxrequest().then(request => {\n        source.cancel('operation has been canceled.')\n        settimeout(() => {\n          request.respondwith({\n            status: 200,\n            responsetext: 'ok'\n          })\n        }, 100)\n      })\n    })\n\n    test('calls abort on request object', done => {\n      const source = canceltoken.source()\n      let request: any\n      axios\n        .get('/foo/bar', {\n          canceltoken: source.token\n        })\n        .catch(() => {\n          expect(request.statustext).tobe('abort')\n          done()\n        })\n\n      getajaxrequest().then(req => {\n        source.cancel()\n        request = req\n      })\n    })\n  })\n\n  describe('when called after response has been received', () => {\n    test('should not cause unhandled rejection', done => {\n      const source = canceltoken.source()\n      axios\n        .get('/foo', {\n          canceltoken: source.token\n        })\n        .then(() => {\n          window.addeventlistener('unhandledrejection', () => {\n            done.fail('unhandled rejection.')\n          })\n          source.cancel()\n          settimeout(done, 100)\n        })\n\n      getajaxrequest().then(request => {\n        request.respondwith({\n          status: 200,\n          responsetext: 'ok'\n        })\n      })\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n注意这里我们使用了 done.fail 表示了一个异常的结束，这个并未在 jest 文档中体现，但它是一个可以用的 api。\n\n至此，我们完成了取消模块相关业务逻辑的单元测试，我们测试覆盖率达到了阈值，测试已经通过了。但是扔未达到我们的目标，还有很多 feature 是没有覆盖到的。接下来我们就完成剩余 feature 的编写单元测试。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"剩余模块单元测试",frontmatter:{title:"剩余模块单元测试",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/9572134781ba6a25",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 单元测试"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/11.ts-axios%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/10.%E5%89%A9%E4%BD%99%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",relativePath:"《TypeScript 从零实现 axios》/11.ts-axios 单元测试/10.剩余模块单元测试.md",key:"v-6f7a53e0",path:"/pages/9572134781ba6a25/",headers:[{level:2,title:"defaults 模块单元测试",slug:"defaults-模块单元测试",normalizedTitle:"defaults 模块单元测试",charIndex:15},{level:2,title:"transform 模块单元测试",slug:"transform-模块单元测试",normalizedTitle:"transform 模块单元测试",charIndex:5003},{level:2,title:"xsrf 模块单元测试",slug:"xsrf-模块单元测试",normalizedTitle:"xsrf 模块单元测试",charIndex:7403},{level:2,title:"上传下载模块单元测试",slug:"上传下载模块单元测试",normalizedTitle:"上传下载模块单元测试",charIndex:9188},{level:2,title:"HTTP 授权模块单元测试",slug:"http-授权模块单元测试",normalizedTitle:"http 授权模块单元测试",charIndex:10349},{level:2,title:"静态方法模块单元测试",slug:"静态方法模块单元测试",normalizedTitle:"静态方法模块单元测试",charIndex:11594},{level:2,title:"补充未覆盖的代码测试",slug:"补充未覆盖的代码测试",normalizedTitle:"补充未覆盖的代码测试",charIndex:12593}],headersStr:"defaults 模块单元测试 transform 模块单元测试 xsrf 模块单元测试 上传下载模块单元测试 HTTP 授权模块单元测试 静态方法模块单元测试 补充未覆盖的代码测试",content:"# 剩余模块单元测试\n\n\n# defaults 模块单元测试\n\ndefaults 模块为请求配置提供了一些默认的属性和方法，我们需要为其编写单元测试。\n\ntest/defaults.spec.ts：\n\nimport axios, { AxiosTransformer } from '../src/index'\nimport { getAjaxRequest } from './helper'\nimport { deepMerge } from '../src/helpers/util'\n\ndescribe('defaults', () => {\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n  })\n\n  test('should transform request json', () => {\n    expect((axios.defaults.transformRequest as AxiosTransformer[])[0]({ foo: 'bar' })).toBe('{\"foo\":\"bar\"}')\n  })\n\n  test('should do nothing to request string', () => {\n    expect((axios.defaults.transformRequest as AxiosTransformer[])[0]('foo=bar')).toBe('foo=bar')\n  })\n\n  test('should transform response json', () => {\n    const data = (axios.defaults.transformResponse as AxiosTransformer[])[0]('{\"foo\":\"bar\"}')\n\n    expect(typeof data).toBe('object')\n    expect(data.foo).toBe('bar')\n  })\n\n  test('should do nothing to response string', () => {\n    expect((axios.defaults.transformResponse as AxiosTransformer[])[0]('foo=bar')).toBe('foo=bar')\n  })\n\n  test('should use global defaults config', () => {\n    axios('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.url).toBe('/foo')\n    })\n  })\n\n  test('should use modified defaults config', () => {\n    axios.defaults.baseURL = 'http://example.com/'\n\n    axios('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.url).toBe('http://example.com/foo')\n      delete axios.defaults.baseURL\n    })\n  })\n\n  test('should use request config', () => {\n    axios('/foo', {\n      baseURL: 'http://www.example.com'\n    })\n\n    return getAjaxRequest().then(request => {\n      expect(request.url).toBe('http://www.example.com/foo')\n    })\n  })\n\n  test('should use default config for custom instance', () => {\n    const instance = axios.create({\n      xsrfCookieName: 'CUSTOM-XSRF-TOKEN',\n      xsrfHeaderName: 'X-CUSTOM-XSRF-TOKEN'\n    })\n    document.cookie = instance.defaults.xsrfCookieName + '=foobarbaz'\n\n    instance.get('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders[instance.defaults.xsrfHeaderName!]).toBe('foobarbaz')\n      document.cookie =\n        instance.defaults.xsrfCookieName +\n        '=;expires=' +\n        new Date(Date.now() - 86400000).toUTCString()\n    })\n  })\n\n  test('should use GET headers', () => {\n    axios.defaults.headers.get['X-CUSTOM-HEADER'] = 'foo'\n    axios.get('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders['X-CUSTOM-HEADER']).toBe('foo')\n      delete axios.defaults.headers.get['X-CUSTOM-HEADER']\n    })\n  })\n\n  test('should use POST headers', () => {\n    axios.defaults.headers.post['X-CUSTOM-HEADER'] = 'foo'\n    axios.post('/foo', {})\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders['X-CUSTOM-HEADER']).toBe('foo')\n      delete axios.defaults.headers.post['X-CUSTOM-HEADER']\n    })\n  })\n\n  test('should use header config', () => {\n    const instance = axios.create({\n      headers: {\n        common: {\n          'X-COMMON-HEADER': 'commonHeaderValue'\n        },\n        get: {\n          'X-GET-HEADER': 'getHeaderValue'\n        },\n        post: {\n          'X-POST-HEADER': 'postHeaderValue'\n        }\n      }\n    })\n\n    instance.get('/foo', {\n      headers: {\n        'X-FOO-HEADER': 'fooHeaderValue',\n        'X-BAR-HEADER': 'barHeaderValue'\n      }\n    })\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders).toEqual(\n        deepMerge(axios.defaults.headers.common, axios.defaults.headers.get, {\n          'X-COMMON-HEADER': 'commonHeaderValue',\n          'X-GET-HEADER': 'getHeaderValue',\n          'X-FOO-HEADER': 'fooHeaderValue',\n          'X-BAR-HEADER': 'barHeaderValue'\n        })\n      )\n    })\n  })\n\n  test('should be used by custom instance if set before instance created', () => {\n    axios.defaults.baseURL = 'http://example.org/'\n    const instance = axios.create()\n\n    instance.get('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.url).toBe('http://example.org/foo')\n      delete axios.defaults.baseURL\n    })\n  })\n\n  test('should not be used by custom instance if set after instance created', () => {\n    const instance = axios.create()\n    axios.defaults.baseURL = 'http://example.org/'\n\n    instance.get('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.url).toBe('/foo')\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n\n\n\n# transform 模块单元测试\n\ntransform 模块用来定义请求和响应的转换方法，我们需要为其编写单元测试。\n\nimport axios, { AxiosResponse, AxiosTransformer } from '../src/index'\nimport { getAjaxRequest } from './helper'\n\ndescribe('transform', () => {\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n  })\n\n  test('should transform JSON to string', () => {\n    const data = {\n      foo: 'bar'\n    }\n\n    axios.post('/foo', data)\n\n    return getAjaxRequest().then(request => {\n      expect(request.params).toBe('{\"foo\":\"bar\"}')\n    })\n  })\n\n  test('should transform string to JSON', done => {\n    let response: AxiosResponse\n\n    axios('/foo').then(res => {\n      response = res\n    })\n\n    getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200,\n        responseText: '{\"foo\": \"bar\"}'\n      })\n\n      setTimeout(() => {\n        expect(typeof response.data).toBe('object')\n        expect(response.data.foo).toBe('bar')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should override default transform', () => {\n    const data = {\n      foo: 'bar'\n    }\n\n    axios.post('/foo', data, {\n      transformRequest(data) {\n        return data\n      }\n    })\n\n    return getAjaxRequest().then(request => {\n      expect(request.params).toEqual({ foo: 'bar' })\n    })\n  })\n\n  test('should allow an Array of transformers', () => {\n    const data = {\n      foo: 'bar'\n    }\n\n    axios.post('/foo', data, {\n      transformRequest: (axios.defaults.transformRequest as AxiosTransformer[]).concat(function(\n        data\n      ) {\n        return data.replace('bar', 'baz')\n      })\n    })\n\n    return getAjaxRequest().then(request => {\n      expect(request.params).toBe('{\"foo\":\"baz\"}')\n    })\n  })\n\n  test('should allowing mutating headers', () => {\n    const token = Math.floor(Math.random() * Math.pow(2, 64)).toString(36)\n\n    axios('/foo', {\n      transformRequest: (data, headers) => {\n        headers['X-Authorization'] = token\n        return data\n      }\n    })\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders['X-Authorization']).toEqual(token)\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n\n\n# xsrf 模块单元测试\n\nxsrf 模块提供了一套防御 xsrf 攻击的解决方案，我们需要为其编写单元测试。\n\ntest/xsrf.spec.ts：\n\nimport axios from '../src/index'\nimport { getAjaxRequest } from './helper'\n\ndescribe('xsrf', () => {\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n    document.cookie =\n      axios.defaults.xsrfCookieName + '=;expires=' + new Date(Date.now() - 86400000).toUTCString()\n  })\n\n  test('should not set xsrf header if cookie is null', () => {\n    axios('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders[axios.defaults.xsrfHeaderName!]).toBeUndefined()\n    })\n  })\n\n  test('should set xsrf header if cookie is set', () => {\n    document.cookie = axios.defaults.xsrfCookieName + '=12345'\n\n    axios('/foo')\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders[axios.defaults.xsrfHeaderName!]).toBe('12345')\n    })\n  })\n\n  test('should not set xsrf header for cross origin', () => {\n    document.cookie = axios.defaults.xsrfCookieName + '=12345'\n\n    axios('http://example.com/')\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders[axios.defaults.xsrfHeaderName!]).toBeUndefined()\n    })\n  })\n\n  test('should set xsrf header for cross origin when using withCredentials', () => {\n    document.cookie = axios.defaults.xsrfCookieName + '=12345'\n\n    axios('http://example.com/', {\n      withCredentials: true\n    })\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders[axios.defaults.xsrfHeaderName!]).toBe('12345')\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n注意在 afterEach 函数中我们清空了 xsrf 相关的 cookie。\n\n\n# 上传下载模块单元测试\n\n上传下载模块允许我们监听上传和下载的进度，我们需要为其编写单元测试。\n\ntest/progress.spec.ts：\n\nimport axios from '../src/index'\nimport { getAjaxRequest } from './helper'\n\ndescribe('progress', () => {\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n  })\n\n  test('should add a download progress handler', () => {\n    const progressSpy = jest.fn()\n\n    axios('/foo', { onDownloadProgress: progressSpy })\n\n    return getAjaxRequest().then(request => {\n      request.respondWith({\n        status: 200,\n        responseText: '{\"foo\": \"bar\"}'\n      })\n      expect(progressSpy).toHaveBeenCalled()\n    })\n  })\n\n  test('should add a upload progress handler', () => {\n    const progressSpy = jest.fn()\n\n    axios('/foo', { onUploadProgress: progressSpy })\n\n    return getAjaxRequest().then(request => {\n      // Jasmine AJAX doesn't trigger upload events.Waiting for jest-ajax fix\n      // expect(progressSpy).toHaveBeenCalled()\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n注意，由于 jasmine-ajax 插件不会派发 upload 事件，这个未来可以通过我们自己编写的 jest-ajax 插件来解决，目前不写断言的情况它会直接通过。\n\n\n# HTTP 授权模块单元测试\n\nHTTP 授权模块为我们在请求头中添加 Authorization 字段，我们需要为其编写单元测试。\n\ntest/auth.spec.ts：\n\nimport axios from '../src/index'\nimport { getAjaxRequest } from './helper'\n\ndescribe('auth', () => {\n  beforeEach(() => {\n    jasmine.Ajax.install()\n  })\n\n  afterEach(() => {\n    jasmine.Ajax.uninstall()\n  })\n\n  test('should accept HTTP Basic auth with username/password', () => {\n    axios('/foo', {\n      auth: {\n        username: 'Aladdin',\n        password: 'open sesame'\n      }\n    })\n\n    return getAjaxRequest().then(request => {\n      expect(request.requestHeaders['Authorization']).toBe('Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==')\n    })\n  })\n\n  test('should fail to encode HTTP Basic auth credentials with non-Latin1 characters', () => {\n    return axios('/foo', {\n      auth: {\n        username: 'Aladßç£☃din',\n        password: 'open sesame'\n      }\n    })\n      .then(() => {\n        throw new Error(\n          'Should not succeed to make a HTTP Basic auth request with non-latin1 chars in credentials.'\n        )\n      })\n      .catch(error => {\n        expect(/character/i.test(error.message)).toBeTruthy()\n      })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 静态方法模块单元测试\n\n静态方法模块为 axios 对象添加了 2 个静态方法，我们需要为其编写单元测试。\n\ntest/static.spec.ts：\n\nimport axios from '../src/index'\n\ndescribe('promise', () => {\n  test('should support all', done => {\n    let fulfilled = false\n\n    axios.all([true, false]).then(arg => {\n      fulfilled = arg[0]\n    })\n\n    setTimeout(() => {\n      expect(fulfilled).toBeTruthy()\n      done()\n    }, 100)\n  })\n\n  test('should support spread', done => {\n    let sum = 0\n    let fulfilled = false\n    let result: any\n\n    axios\n      .all([123, 456])\n      .then(\n        axios.spread((a, b) => {\n          sum = a + b\n          fulfilled = true\n          return 'hello world'\n        })\n      )\n      .then(res => {\n        result = res\n      })\n\n    setTimeout(() => {\n      expect(fulfilled).toBeTruthy()\n      expect(sum).toBe(123 + 456)\n      expect(result).toBe('hello world')\n      done()\n    }, 100)\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 补充未覆盖的代码测试\n\n我们发现，跑完测试后，仍有一些代码没有覆盖到测试，其中 core/xhr.ts 文件的第 43 行：\n\nif (responseType) {\n  request.responseType = responseType\n}\n\n\n1\n2\n3\n\n\n我们并未在测试中设置过 responseType，因此我们在 test/requests.spect.ts 文件中补充相关测试：\n\ntest('should support array buffer response', done => {\n  let response: AxiosResponse\n\n  function str2ab(str: string) {\n    const buff = new ArrayBuffer(str.length * 2)\n    const view = new Uint16Array(buff)\n    for (let i = 0; i < str.length; i++) {\n      view[i] = str.charCodeAt(i)\n    }\n    return buff\n  }\n\n  axios('/foo', {\n    responseType: 'arraybuffer'\n  }).then(data => {\n    response = data\n  })\n\n  getAjaxRequest().then(request => {\n    request.respondWith({\n      status: 200,\n      // @ts-ignore\n      response: str2ab('Hello world')\n    })\n\n    setTimeout(() => {\n      expect(response.data.byteLength).toBe(22)\n      done()\n    }, 100)\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n另外我们发现 core/xhr.ts 文件的第 13 行：\n\nmethod = 'get'\n\n\n1\n\n\n分支没有测试完全。因为实际上代码执行到这的时候 method 是一定会有的，所以我们不必为其指定默认值，另外还需要在 method!.toUpperCase() 的时候使用非空断言。\n\n同时core/xhr.ts 文件的第 66 行：\n\nconst responseData = responseType !== 'text' ? request.response : request.responseText\n\n\n1\n\n\n分支也没有测试完全。这里我们应该先判断存在 responseType 存在的情况下再去和 text 做对比，需要修改逻辑：\n\nconst responseData = responseType && responseType !== 'text' ? request.response : request.responseText\n\n\n1\n\n\n这样再次跑测试，就覆盖了所有的分支。\n\n到此为止，除了我们之前说的 helpers/error.ts 模块中对于 super 的测试的分支覆盖率没达到 100%，其它模块均达到 100% 的测试覆盖率。\n\n有些有强迫症的同学可能会觉得，能不能通过某种手段让它的覆盖率达到 100% 呢，这里其实有一个奇技淫巧，在 helpers/error.ts 文件的 constructor 函数上方加一个 /* istanbul ignore next */ 注释，这样其实相当于忽略了整个构造函数的测试，这样我们就可以达到 100% 的覆盖率了。\n\n/* istanbul ignore next */ 在我们去阅读一些开源代码的时候经常会遇到，主要用途就是用来忽略测试用的，这个技巧不可滥用，除非你明确的知道这段代码不需要测试，否则你不应该使用它。滥用就失去了单元测试的意义了。\n\n至此，我们就完成了整个 ts-axios 库的测试了，我们也成功地让测试覆盖率达到目标 99% 以上。下一章我会教大家如果打包构建和发布我们的 ts-axios 库。",normalizedContent:"# 剩余模块单元测试\n\n\n# defaults 模块单元测试\n\ndefaults 模块为请求配置提供了一些默认的属性和方法，我们需要为其编写单元测试。\n\ntest/defaults.spec.ts：\n\nimport axios, { axiostransformer } from '../src/index'\nimport { getajaxrequest } from './helper'\nimport { deepmerge } from '../src/helpers/util'\n\ndescribe('defaults', () => {\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n  })\n\n  test('should transform request json', () => {\n    expect((axios.defaults.transformrequest as axiostransformer[])[0]({ foo: 'bar' })).tobe('{\"foo\":\"bar\"}')\n  })\n\n  test('should do nothing to request string', () => {\n    expect((axios.defaults.transformrequest as axiostransformer[])[0]('foo=bar')).tobe('foo=bar')\n  })\n\n  test('should transform response json', () => {\n    const data = (axios.defaults.transformresponse as axiostransformer[])[0]('{\"foo\":\"bar\"}')\n\n    expect(typeof data).tobe('object')\n    expect(data.foo).tobe('bar')\n  })\n\n  test('should do nothing to response string', () => {\n    expect((axios.defaults.transformresponse as axiostransformer[])[0]('foo=bar')).tobe('foo=bar')\n  })\n\n  test('should use global defaults config', () => {\n    axios('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.url).tobe('/foo')\n    })\n  })\n\n  test('should use modified defaults config', () => {\n    axios.defaults.baseurl = 'http://example.com/'\n\n    axios('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.url).tobe('http://example.com/foo')\n      delete axios.defaults.baseurl\n    })\n  })\n\n  test('should use request config', () => {\n    axios('/foo', {\n      baseurl: 'http://www.example.com'\n    })\n\n    return getajaxrequest().then(request => {\n      expect(request.url).tobe('http://www.example.com/foo')\n    })\n  })\n\n  test('should use default config for custom instance', () => {\n    const instance = axios.create({\n      xsrfcookiename: 'custom-xsrf-token',\n      xsrfheadername: 'x-custom-xsrf-token'\n    })\n    document.cookie = instance.defaults.xsrfcookiename + '=foobarbaz'\n\n    instance.get('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders[instance.defaults.xsrfheadername!]).tobe('foobarbaz')\n      document.cookie =\n        instance.defaults.xsrfcookiename +\n        '=;expires=' +\n        new date(date.now() - 86400000).toutcstring()\n    })\n  })\n\n  test('should use get headers', () => {\n    axios.defaults.headers.get['x-custom-header'] = 'foo'\n    axios.get('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders['x-custom-header']).tobe('foo')\n      delete axios.defaults.headers.get['x-custom-header']\n    })\n  })\n\n  test('should use post headers', () => {\n    axios.defaults.headers.post['x-custom-header'] = 'foo'\n    axios.post('/foo', {})\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders['x-custom-header']).tobe('foo')\n      delete axios.defaults.headers.post['x-custom-header']\n    })\n  })\n\n  test('should use header config', () => {\n    const instance = axios.create({\n      headers: {\n        common: {\n          'x-common-header': 'commonheadervalue'\n        },\n        get: {\n          'x-get-header': 'getheadervalue'\n        },\n        post: {\n          'x-post-header': 'postheadervalue'\n        }\n      }\n    })\n\n    instance.get('/foo', {\n      headers: {\n        'x-foo-header': 'fooheadervalue',\n        'x-bar-header': 'barheadervalue'\n      }\n    })\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders).toequal(\n        deepmerge(axios.defaults.headers.common, axios.defaults.headers.get, {\n          'x-common-header': 'commonheadervalue',\n          'x-get-header': 'getheadervalue',\n          'x-foo-header': 'fooheadervalue',\n          'x-bar-header': 'barheadervalue'\n        })\n      )\n    })\n  })\n\n  test('should be used by custom instance if set before instance created', () => {\n    axios.defaults.baseurl = 'http://example.org/'\n    const instance = axios.create()\n\n    instance.get('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.url).tobe('http://example.org/foo')\n      delete axios.defaults.baseurl\n    })\n  })\n\n  test('should not be used by custom instance if set after instance created', () => {\n    const instance = axios.create()\n    axios.defaults.baseurl = 'http://example.org/'\n\n    instance.get('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.url).tobe('/foo')\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n\n\n\n# transform 模块单元测试\n\ntransform 模块用来定义请求和响应的转换方法，我们需要为其编写单元测试。\n\nimport axios, { axiosresponse, axiostransformer } from '../src/index'\nimport { getajaxrequest } from './helper'\n\ndescribe('transform', () => {\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n  })\n\n  test('should transform json to string', () => {\n    const data = {\n      foo: 'bar'\n    }\n\n    axios.post('/foo', data)\n\n    return getajaxrequest().then(request => {\n      expect(request.params).tobe('{\"foo\":\"bar\"}')\n    })\n  })\n\n  test('should transform string to json', done => {\n    let response: axiosresponse\n\n    axios('/foo').then(res => {\n      response = res\n    })\n\n    getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200,\n        responsetext: '{\"foo\": \"bar\"}'\n      })\n\n      settimeout(() => {\n        expect(typeof response.data).tobe('object')\n        expect(response.data.foo).tobe('bar')\n        done()\n      }, 100)\n    })\n  })\n\n  test('should override default transform', () => {\n    const data = {\n      foo: 'bar'\n    }\n\n    axios.post('/foo', data, {\n      transformrequest(data) {\n        return data\n      }\n    })\n\n    return getajaxrequest().then(request => {\n      expect(request.params).toequal({ foo: 'bar' })\n    })\n  })\n\n  test('should allow an array of transformers', () => {\n    const data = {\n      foo: 'bar'\n    }\n\n    axios.post('/foo', data, {\n      transformrequest: (axios.defaults.transformrequest as axiostransformer[]).concat(function(\n        data\n      ) {\n        return data.replace('bar', 'baz')\n      })\n    })\n\n    return getajaxrequest().then(request => {\n      expect(request.params).tobe('{\"foo\":\"baz\"}')\n    })\n  })\n\n  test('should allowing mutating headers', () => {\n    const token = math.floor(math.random() * math.pow(2, 64)).tostring(36)\n\n    axios('/foo', {\n      transformrequest: (data, headers) => {\n        headers['x-authorization'] = token\n        return data\n      }\n    })\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders['x-authorization']).toequal(token)\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n\n\n# xsrf 模块单元测试\n\nxsrf 模块提供了一套防御 xsrf 攻击的解决方案，我们需要为其编写单元测试。\n\ntest/xsrf.spec.ts：\n\nimport axios from '../src/index'\nimport { getajaxrequest } from './helper'\n\ndescribe('xsrf', () => {\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n    document.cookie =\n      axios.defaults.xsrfcookiename + '=;expires=' + new date(date.now() - 86400000).toutcstring()\n  })\n\n  test('should not set xsrf header if cookie is null', () => {\n    axios('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders[axios.defaults.xsrfheadername!]).tobeundefined()\n    })\n  })\n\n  test('should set xsrf header if cookie is set', () => {\n    document.cookie = axios.defaults.xsrfcookiename + '=12345'\n\n    axios('/foo')\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders[axios.defaults.xsrfheadername!]).tobe('12345')\n    })\n  })\n\n  test('should not set xsrf header for cross origin', () => {\n    document.cookie = axios.defaults.xsrfcookiename + '=12345'\n\n    axios('http://example.com/')\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders[axios.defaults.xsrfheadername!]).tobeundefined()\n    })\n  })\n\n  test('should set xsrf header for cross origin when using withcredentials', () => {\n    document.cookie = axios.defaults.xsrfcookiename + '=12345'\n\n    axios('http://example.com/', {\n      withcredentials: true\n    })\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders[axios.defaults.xsrfheadername!]).tobe('12345')\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n注意在 aftereach 函数中我们清空了 xsrf 相关的 cookie。\n\n\n# 上传下载模块单元测试\n\n上传下载模块允许我们监听上传和下载的进度，我们需要为其编写单元测试。\n\ntest/progress.spec.ts：\n\nimport axios from '../src/index'\nimport { getajaxrequest } from './helper'\n\ndescribe('progress', () => {\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n  })\n\n  test('should add a download progress handler', () => {\n    const progressspy = jest.fn()\n\n    axios('/foo', { ondownloadprogress: progressspy })\n\n    return getajaxrequest().then(request => {\n      request.respondwith({\n        status: 200,\n        responsetext: '{\"foo\": \"bar\"}'\n      })\n      expect(progressspy).tohavebeencalled()\n    })\n  })\n\n  test('should add a upload progress handler', () => {\n    const progressspy = jest.fn()\n\n    axios('/foo', { onuploadprogress: progressspy })\n\n    return getajaxrequest().then(request => {\n      // jasmine ajax doesn't trigger upload events.waiting for jest-ajax fix\n      // expect(progressspy).tohavebeencalled()\n    })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n注意，由于 jasmine-ajax 插件不会派发 upload 事件，这个未来可以通过我们自己编写的 jest-ajax 插件来解决，目前不写断言的情况它会直接通过。\n\n\n# http 授权模块单元测试\n\nhttp 授权模块为我们在请求头中添加 authorization 字段，我们需要为其编写单元测试。\n\ntest/auth.spec.ts：\n\nimport axios from '../src/index'\nimport { getajaxrequest } from './helper'\n\ndescribe('auth', () => {\n  beforeeach(() => {\n    jasmine.ajax.install()\n  })\n\n  aftereach(() => {\n    jasmine.ajax.uninstall()\n  })\n\n  test('should accept http basic auth with username/password', () => {\n    axios('/foo', {\n      auth: {\n        username: 'aladdin',\n        password: 'open sesame'\n      }\n    })\n\n    return getajaxrequest().then(request => {\n      expect(request.requestheaders['authorization']).tobe('basic qwxhzgrpbjpvcgvuihnlc2ftzq==')\n    })\n  })\n\n  test('should fail to encode http basic auth credentials with non-latin1 characters', () => {\n    return axios('/foo', {\n      auth: {\n        username: 'aladßc£☃din',\n        password: 'open sesame'\n      }\n    })\n      .then(() => {\n        throw new error(\n          'should not succeed to make a http basic auth request with non-latin1 chars in credentials.'\n        )\n      })\n      .catch(error => {\n        expect(/character/i.test(error.message)).tobetruthy()\n      })\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 静态方法模块单元测试\n\n静态方法模块为 axios 对象添加了 2 个静态方法，我们需要为其编写单元测试。\n\ntest/static.spec.ts：\n\nimport axios from '../src/index'\n\ndescribe('promise', () => {\n  test('should support all', done => {\n    let fulfilled = false\n\n    axios.all([true, false]).then(arg => {\n      fulfilled = arg[0]\n    })\n\n    settimeout(() => {\n      expect(fulfilled).tobetruthy()\n      done()\n    }, 100)\n  })\n\n  test('should support spread', done => {\n    let sum = 0\n    let fulfilled = false\n    let result: any\n\n    axios\n      .all([123, 456])\n      .then(\n        axios.spread((a, b) => {\n          sum = a + b\n          fulfilled = true\n          return 'hello world'\n        })\n      )\n      .then(res => {\n        result = res\n      })\n\n    settimeout(() => {\n      expect(fulfilled).tobetruthy()\n      expect(sum).tobe(123 + 456)\n      expect(result).tobe('hello world')\n      done()\n    }, 100)\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 补充未覆盖的代码测试\n\n我们发现，跑完测试后，仍有一些代码没有覆盖到测试，其中 core/xhr.ts 文件的第 43 行：\n\nif (responsetype) {\n  request.responsetype = responsetype\n}\n\n\n1\n2\n3\n\n\n我们并未在测试中设置过 responsetype，因此我们在 test/requests.spect.ts 文件中补充相关测试：\n\ntest('should support array buffer response', done => {\n  let response: axiosresponse\n\n  function str2ab(str: string) {\n    const buff = new arraybuffer(str.length * 2)\n    const view = new uint16array(buff)\n    for (let i = 0; i < str.length; i++) {\n      view[i] = str.charcodeat(i)\n    }\n    return buff\n  }\n\n  axios('/foo', {\n    responsetype: 'arraybuffer'\n  }).then(data => {\n    response = data\n  })\n\n  getajaxrequest().then(request => {\n    request.respondwith({\n      status: 200,\n      // @ts-ignore\n      response: str2ab('hello world')\n    })\n\n    settimeout(() => {\n      expect(response.data.bytelength).tobe(22)\n      done()\n    }, 100)\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n另外我们发现 core/xhr.ts 文件的第 13 行：\n\nmethod = 'get'\n\n\n1\n\n\n分支没有测试完全。因为实际上代码执行到这的时候 method 是一定会有的，所以我们不必为其指定默认值，另外还需要在 method!.touppercase() 的时候使用非空断言。\n\n同时core/xhr.ts 文件的第 66 行：\n\nconst responsedata = responsetype !== 'text' ? request.response : request.responsetext\n\n\n1\n\n\n分支也没有测试完全。这里我们应该先判断存在 responsetype 存在的情况下再去和 text 做对比，需要修改逻辑：\n\nconst responsedata = responsetype && responsetype !== 'text' ? request.response : request.responsetext\n\n\n1\n\n\n这样再次跑测试，就覆盖了所有的分支。\n\n到此为止，除了我们之前说的 helpers/error.ts 模块中对于 super 的测试的分支覆盖率没达到 100%，其它模块均达到 100% 的测试覆盖率。\n\n有些有强迫症的同学可能会觉得，能不能通过某种手段让它的覆盖率达到 100% 呢，这里其实有一个奇技淫巧，在 helpers/error.ts 文件的 constructor 函数上方加一个 /* istanbul ignore next */ 注释，这样其实相当于忽略了整个构造函数的测试，这样我们就可以达到 100% 的覆盖率了。\n\n/* istanbul ignore next */ 在我们去阅读一些开源代码的时候经常会遇到，主要用途就是用来忽略测试用的，这个技巧不可滥用，除非你明确的知道这段代码不需要测试，否则你不应该使用它。滥用就失去了单元测试的意义了。\n\n至此，我们就完成了整个 ts-axios 库的测试了，我们也成功地让测试覆盖率达到目标 99% 以上。下一章我会教大家如果打包构建和发布我们的 ts-axios 库。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"ts-axios 编译与发布",frontmatter:{title:"ts-axios 编译与发布",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/3e5d5a45ad50f198",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 部署与发布"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/12.ts-axios%20%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%8F%91%E5%B8%83/01.ts-axios%20%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%91%E5%B8%83.html",relativePath:"《TypeScript 从零实现 axios》/12.ts-axios 部署与发布/01.ts-axios 编译与发布.md",key:"v-3a04ede6",path:"/pages/3e5d5a45ad50f198/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:21},{level:2,title:"编译和打包",slug:"编译和打包",normalizedTitle:"编译和打包",charIndex:174},{level:3,title:"修改 rollup.config.ts",slug:"修改-rollup-config-ts",normalizedTitle:"修改 rollup.config.ts",charIndex:510},{level:3,title:"修改 package.json",slug:"修改-package-json",normalizedTitle:"修改 package.json",charIndex:2264},{level:2,title:"自动化部署",slug:"自动化部署",normalizedTitle:"自动化部署",charIndex:2715},{level:3,title:"修改 package.json",slug:"修改-package-json-2",normalizedTitle:"修改 package.json",charIndex:2264},{level:3,title:"编写部署脚本",slug:"编写部署脚本",normalizedTitle:"编写部署脚本",charIndex:3812},{level:2,title:"运行部署脚本",slug:"运行部署脚本",normalizedTitle:"运行部署脚本",charIndex:5301}],headersStr:"需求分析 编译和打包 修改 rollup.config.ts 修改 package.json 自动化部署 修改 package.json 编写部署脚本 运行部署脚本",content:'# ts-axios 编译与发布\n\n\n# 需求分析\n\n前面的章节我们完成 ts-axios 库的代码编写和单元测试。这一章我们希望把代码部署发布到公共 npm 上，供别人下载使用。但是并不是所有人都会使用 TypeScript 开发，仍然有大量的 JavaScript 用户，它们是不能直接引用 TypeScript 代码的，因此我们需要先对源码做编译和打包，然后再发布。\n\n由于我们会把包发布到公共的 npm 源，如果你还没有 npm 账号，那么需要先去官网注册。注册完成后，可以去终端执行 npm login 登录。这个步骤非常重要，决定你最终能否发布成功。\n\n\n# 编译和打包\n\n我们会利用 rollup 来打包我们的 ts-axios 库，它是一个非常著名的编译打包工具，Vue.js 也是利用 rollup 编译打包的。相比 webpack，它非常适合去编译和打包一些 JS 库。\n\n由于使用 typescript-library-starter 初始化我们的项目，我们已经拥有了 rollup 打包的相关配置和相关插件的安装，接下来我们就来对生成的 rollup.config.ts 做小小的修改。\n\n\n# 修改 rollup.config.ts\n\nimport resolve from \'rollup-plugin-node-resolve\'\nimport commonjs from \'rollup-plugin-commonjs\'\nimport sourceMaps from \'rollup-plugin-sourcemaps\'\nimport camelCase from \'lodash.camelcase\'\nimport typescript from \'rollup-plugin-typescript2\'\nimport json from \'rollup-plugin-json\'\n\nconst pkg = require(\'./package.json\')\n\nconst libraryName = \'axios\'\n\nexport default {\n  input: `src/index.ts`,\n  output: [\n    { file: pkg.main, name: camelCase(libraryName), format: \'umd\', sourcemap: true },\n    { file: pkg.module, format: \'es\', sourcemap: true }\n  ],\n  // Indicate here external modules you don\'t wanna include in your bundle (i.e.: \'lodash\')\n  external: [],\n  watch: {\n    include: \'src/**\'\n  },\n  plugins: [\n    // Allow json resolution\n    json(),\n    // Compile TypeScript files\n    typescript({ useTsconfigDeclarationDir: true }),\n    // Allow bundling cjs modules (unlike webpack, rollup doesn\'t understand cjs)\n    commonjs(),\n    // Allow node_modules resolution, so you can use \'external\' to control\n    // which external modules to include in the bundle\n    // https://github.com/rollup/rollup-plugin-node-resolve#usage\n    resolve(),\n\n    // Resolve source maps to the original source\n    sourceMaps()\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n注意要修改的地方，把 libraryName 修改为 axios，input 修改为 src/index.ts。\n\nrollup 的配置很简单，我们简单地过一下。\n\n * input\n\n表示打包入口文件。\n\n * output\n\n表示输出的目标文件，它是一个对象数组，我们可以指定输出的格式，比如 umd 格式、es 模式等。\n\n * external\n\n声明它的外部依赖，可以不被打包进去。\n\n * watch\n\n监听文件的变化，重新编译，只有在编译的时候开启 --watch 才生效。\n\n * plugins\n\n编译过程中使用的插件，其中 rollup-plugin-typescript2 就是用来编译 TypeScript 文件，useTsconfigDeclarationDir 表示使用 tsconfig.json 文件中定义的 declarationDir。其它插件感兴趣的同学可以自己去查阅文档。\n\n\n# 修改 package.json\n\n由于我们已经在 rollup.config.ts 中修改了 libraryName 为 axios， 那么在 package.json 文件中你需要做相关的修改：\n\n{\n  "main": "dist/axios.umd.js",\n  "module": "dist/axios.es5.js",\n  "typings": "dist/types/index.d.ts"\n}\n\n\n1\n2\n3\n4\n5\n\n\n然后我们在控制台执行 npm run build，会编译输出 dist 目录，其中 lib 目录是单个 .ts 文件编译后的 .js 文件。types 目录是所有 .ts 文件编译后生产的 .d.ts 声明文件。axios.es5.js 是编译后生成的 es 模式的入口文件，用在 package.json 的 module 字段，axios.umd.js 文件是编译后生成的 umd 模式的入口文件，用在 package.json 的 main 字段。\n\n\n# 自动化部署\n\n由于 semantic-release 插件过于黑盒也略微重量，我还是决定教同学们自己编写自动化部署脚本，这样更灵活，意义也更大，因为大部分场景是用不到那么多 feature 的。\n\n\n# 修改 package.json\n\n发布到 npm 之前你需要为你的包命名，由于 ts-axios 这个名字已经被占用了，我使用了 ts-axios-new 这个名称，当然你学到这里，就需要起一个新名字了。可以使用 npm view [<@scope>/]<pkg>[@<version>] 的方式去搜索一个包名是否已经存在，比如你搜索 npm view ts-axios-new 会发现这个包已经存在，返回这个包相关信息。如果你搜索 npm view xxxx 返回错误 404 的话，那么你就可以使用 xxxx 这个包名了。\n\n如果你想让你发布的包关联你的仓库地址，可以配置 repository 的 url 字段。\n\n另外我们增加 2 个 npm scripts：\n\n{\n  "prepub": "npm run test:prod && npm run build",\n  "pub": "sh release.sh"\n}\n\n\n1\n2\n3\n4\n\n\n当我们运行 npm run pub 的时候，会优先执行 prepub 脚本，在 prepub 中我们运行了 test:prod 和 build 2 个脚本。&& 符号表示前面一个命令执行成功后才会执行后面的任务。\n\nnpm run test:prod 实际上运行了 npm run lint && npm run test -- --no-cache。 先运行 lint 去校验我们的源码和测试文件是否遵循 tslint 规范，再运行 test 去跑测试。\n\nnpm run build 实际上运行了 tsc --module commonjs、rollup -c rollup.config.ts 和 typedoc --out docs --target es6 --theme minimal --mode file src。先运行 tsc 去编译我们的 TypeScript 文件，dist/lib 和 dist/types 下的文件就是该命令产生的，然后运行 rollup 去构建 axios.umd.js 及 axios.es.js，最后运行 typedoc 去构建项目的文档。\n\n运行完 prepub 后就会再运行 pub 命令，实际上执行了 sh release.sh 命令，但是目前我们没有这个脚本，接下来我们就需要来编写部署脚本 release.sh。\n\n\n# 编写部署脚本\n\nrelease.sh：\n\n#!/usr/bin/env sh\nset -e\necho "Enter release version: "\nread VERSION\nread -p "Releasing $VERSION - are you sure? (y/n)" -n 1 -r\necho  # (optional) move to a new line\nif [[ $REPLY =~ ^[Yy]$ ]]\nthen\n  echo "Releasing $VERSION ..."\n\n  # commit\n  git add -A\n  git commit -m "[build] $VERSION"\n  npm version $VERSION --message "[release] $VERSION"\n  git push origin master\n\n  # publish\n  npm publish\nfi\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n部署脚本是 shell 脚本，shell 脚本就是封装了多行控制台命令，来逐行解释他们的含义。\n\n#!/usr/bin/env sh 用来表示它是一个 shell 脚本。\n\nset -e 告诉脚本如果执行结果不为 true 则退出。\n\necho "Enter release version: " 在控制台输出 Enter release version:。\n\nread VERSION 表示从标准输入读取值，并赋值给 $VERSION 变量。\n\nread -p "Releasing $VERSION - are you sure? (y/n)" -n 1 -r，其中 read -p 表示给出提示符，后面接着 Releasing $VERSION - are you sure? (y/n) 提示符；-n 1 表示限定最多可以有 1 个字符可以作为有效读入；-r 表示禁止反斜线的转义功能。因为我们的 read 并没有指定变量名，那么默认这个输入读取值会赋值给 $REPLY 变量。\n\necho 输出空值表示跳到一个新行，# 在 shell 脚本中表示注释。\n\nif [[ $REPLY =~ ^[Yy]$ ]] 表示 shell 脚本中的流程控制语句，判断 $REPLY 是不是大小写的 y，如果满足，则走到后面的 then 逻辑。\n\necho "Releasing $VERSION ..." 在控制台输出 Releasing $VERSION ...。\n\ngit add -A 表示把代码所有变化提交到暂存区。\n\ngit commit -m "[build] $VERSION" 表示提交代码，提交注释是 [build] $VERSION。\n\nnpm version $VERSION --message "[release] $VERSION" 是修改 package.json 中的 version 字段到 $VERSION，并且提交一条修改记录，提交注释是 [release] $VERSION。\n\ngit push origin master 是把代码发布到主干分支。\n\nnpm publish 是把仓库发布到 npm 上，我们会把 dist 目录下的代码都发布到 npm 上，因为我们在 package.json 中配置的是 files 是 ["dist"]。\n\n\n# 运行部署脚本\n\n接下来我们就运行 npm run pub 脚本部署，我们会发现在 npm run prepub 阶段，在执行 tslint --project tsconfig.json -t codeFrame \'src/**/*.ts\' \'test/**/*.ts\' 的时候失败了，原因是我们有代码不符合 lint 规范。原来是 core/xhr.ts 文件中 processCancel 函数中对 promise 的处理，我们没有对异常情况处理，所以我们要给它加上 catch 的逻辑：\n\nfunction processCancel(): void {\n  if (cancelToken) {\n    cancelToken.promise\n      .then(reason => {\n        request.abort()\n        reject(reason)\n      })\n      .catch(\n        /* istanbul ignore next */\n        () => {\n        // do nothing\n      })\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n由于我们不会走到 catch 逻辑，所以我们给它添加一个注释 /* istanbul ignore next */ 忽略该代码分支的测试。\n\n然后我们再重新运行 npm run pub 逻辑，它会先执行 test，然后运行 build 编译代码，再执行 release.sh 脚本。我们输入了要发布的版本，它就可以完成了整个代码的发布流程。\n\n通过编写部署脚本的一行命令发布的方式，不仅可以用在这种 JS 库，也可以用于我们平时项目开发中，可以大大帮助我们提高生产率，也是前端工程化中必不可少的一个环节，希望同学们都能学会并掌握它。\n\n至此我们完成了项目的部署和发布，我们也可以在 npm 官网上看到我们发布的包，下一节课我们来创建一个实际项目，来引用我们开发的 ts-axios 库。',normalizedContent:'# ts-axios 编译与发布\n\n\n# 需求分析\n\n前面的章节我们完成 ts-axios 库的代码编写和单元测试。这一章我们希望把代码部署发布到公共 npm 上，供别人下载使用。但是并不是所有人都会使用 typescript 开发，仍然有大量的 javascript 用户，它们是不能直接引用 typescript 代码的，因此我们需要先对源码做编译和打包，然后再发布。\n\n由于我们会把包发布到公共的 npm 源，如果你还没有 npm 账号，那么需要先去官网注册。注册完成后，可以去终端执行 npm login 登录。这个步骤非常重要，决定你最终能否发布成功。\n\n\n# 编译和打包\n\n我们会利用 rollup 来打包我们的 ts-axios 库，它是一个非常著名的编译打包工具，vue.js 也是利用 rollup 编译打包的。相比 webpack，它非常适合去编译和打包一些 js 库。\n\n由于使用 typescript-library-starter 初始化我们的项目，我们已经拥有了 rollup 打包的相关配置和相关插件的安装，接下来我们就来对生成的 rollup.config.ts 做小小的修改。\n\n\n# 修改 rollup.config.ts\n\nimport resolve from \'rollup-plugin-node-resolve\'\nimport commonjs from \'rollup-plugin-commonjs\'\nimport sourcemaps from \'rollup-plugin-sourcemaps\'\nimport camelcase from \'lodash.camelcase\'\nimport typescript from \'rollup-plugin-typescript2\'\nimport json from \'rollup-plugin-json\'\n\nconst pkg = require(\'./package.json\')\n\nconst libraryname = \'axios\'\n\nexport default {\n  input: `src/index.ts`,\n  output: [\n    { file: pkg.main, name: camelcase(libraryname), format: \'umd\', sourcemap: true },\n    { file: pkg.module, format: \'es\', sourcemap: true }\n  ],\n  // indicate here external modules you don\'t wanna include in your bundle (i.e.: \'lodash\')\n  external: [],\n  watch: {\n    include: \'src/**\'\n  },\n  plugins: [\n    // allow json resolution\n    json(),\n    // compile typescript files\n    typescript({ usetsconfigdeclarationdir: true }),\n    // allow bundling cjs modules (unlike webpack, rollup doesn\'t understand cjs)\n    commonjs(),\n    // allow node_modules resolution, so you can use \'external\' to control\n    // which external modules to include in the bundle\n    // https://github.com/rollup/rollup-plugin-node-resolve#usage\n    resolve(),\n\n    // resolve source maps to the original source\n    sourcemaps()\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n注意要修改的地方，把 libraryname 修改为 axios，input 修改为 src/index.ts。\n\nrollup 的配置很简单，我们简单地过一下。\n\n * input\n\n表示打包入口文件。\n\n * output\n\n表示输出的目标文件，它是一个对象数组，我们可以指定输出的格式，比如 umd 格式、es 模式等。\n\n * external\n\n声明它的外部依赖，可以不被打包进去。\n\n * watch\n\n监听文件的变化，重新编译，只有在编译的时候开启 --watch 才生效。\n\n * plugins\n\n编译过程中使用的插件，其中 rollup-plugin-typescript2 就是用来编译 typescript 文件，usetsconfigdeclarationdir 表示使用 tsconfig.json 文件中定义的 declarationdir。其它插件感兴趣的同学可以自己去查阅文档。\n\n\n# 修改 package.json\n\n由于我们已经在 rollup.config.ts 中修改了 libraryname 为 axios， 那么在 package.json 文件中你需要做相关的修改：\n\n{\n  "main": "dist/axios.umd.js",\n  "module": "dist/axios.es5.js",\n  "typings": "dist/types/index.d.ts"\n}\n\n\n1\n2\n3\n4\n5\n\n\n然后我们在控制台执行 npm run build，会编译输出 dist 目录，其中 lib 目录是单个 .ts 文件编译后的 .js 文件。types 目录是所有 .ts 文件编译后生产的 .d.ts 声明文件。axios.es5.js 是编译后生成的 es 模式的入口文件，用在 package.json 的 module 字段，axios.umd.js 文件是编译后生成的 umd 模式的入口文件，用在 package.json 的 main 字段。\n\n\n# 自动化部署\n\n由于 semantic-release 插件过于黑盒也略微重量，我还是决定教同学们自己编写自动化部署脚本，这样更灵活，意义也更大，因为大部分场景是用不到那么多 feature 的。\n\n\n# 修改 package.json\n\n发布到 npm 之前你需要为你的包命名，由于 ts-axios 这个名字已经被占用了，我使用了 ts-axios-new 这个名称，当然你学到这里，就需要起一个新名字了。可以使用 npm view [<@scope>/]<pkg>[@<version>] 的方式去搜索一个包名是否已经存在，比如你搜索 npm view ts-axios-new 会发现这个包已经存在，返回这个包相关信息。如果你搜索 npm view xxxx 返回错误 404 的话，那么你就可以使用 xxxx 这个包名了。\n\n如果你想让你发布的包关联你的仓库地址，可以配置 repository 的 url 字段。\n\n另外我们增加 2 个 npm scripts：\n\n{\n  "prepub": "npm run test:prod && npm run build",\n  "pub": "sh release.sh"\n}\n\n\n1\n2\n3\n4\n\n\n当我们运行 npm run pub 的时候，会优先执行 prepub 脚本，在 prepub 中我们运行了 test:prod 和 build 2 个脚本。&& 符号表示前面一个命令执行成功后才会执行后面的任务。\n\nnpm run test:prod 实际上运行了 npm run lint && npm run test -- --no-cache。 先运行 lint 去校验我们的源码和测试文件是否遵循 tslint 规范，再运行 test 去跑测试。\n\nnpm run build 实际上运行了 tsc --module commonjs、rollup -c rollup.config.ts 和 typedoc --out docs --target es6 --theme minimal --mode file src。先运行 tsc 去编译我们的 typescript 文件，dist/lib 和 dist/types 下的文件就是该命令产生的，然后运行 rollup 去构建 axios.umd.js 及 axios.es.js，最后运行 typedoc 去构建项目的文档。\n\n运行完 prepub 后就会再运行 pub 命令，实际上执行了 sh release.sh 命令，但是目前我们没有这个脚本，接下来我们就需要来编写部署脚本 release.sh。\n\n\n# 编写部署脚本\n\nrelease.sh：\n\n#!/usr/bin/env sh\nset -e\necho "enter release version: "\nread version\nread -p "releasing $version - are you sure? (y/n)" -n 1 -r\necho  # (optional) move to a new line\nif [[ $reply =~ ^[yy]$ ]]\nthen\n  echo "releasing $version ..."\n\n  # commit\n  git add -a\n  git commit -m "[build] $version"\n  npm version $version --message "[release] $version"\n  git push origin master\n\n  # publish\n  npm publish\nfi\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n部署脚本是 shell 脚本，shell 脚本就是封装了多行控制台命令，来逐行解释他们的含义。\n\n#!/usr/bin/env sh 用来表示它是一个 shell 脚本。\n\nset -e 告诉脚本如果执行结果不为 true 则退出。\n\necho "enter release version: " 在控制台输出 enter release version:。\n\nread version 表示从标准输入读取值，并赋值给 $version 变量。\n\nread -p "releasing $version - are you sure? (y/n)" -n 1 -r，其中 read -p 表示给出提示符，后面接着 releasing $version - are you sure? (y/n) 提示符；-n 1 表示限定最多可以有 1 个字符可以作为有效读入；-r 表示禁止反斜线的转义功能。因为我们的 read 并没有指定变量名，那么默认这个输入读取值会赋值给 $reply 变量。\n\necho 输出空值表示跳到一个新行，# 在 shell 脚本中表示注释。\n\nif [[ $reply =~ ^[yy]$ ]] 表示 shell 脚本中的流程控制语句，判断 $reply 是不是大小写的 y，如果满足，则走到后面的 then 逻辑。\n\necho "releasing $version ..." 在控制台输出 releasing $version ...。\n\ngit add -a 表示把代码所有变化提交到暂存区。\n\ngit commit -m "[build] $version" 表示提交代码，提交注释是 [build] $version。\n\nnpm version $version --message "[release] $version" 是修改 package.json 中的 version 字段到 $version，并且提交一条修改记录，提交注释是 [release] $version。\n\ngit push origin master 是把代码发布到主干分支。\n\nnpm publish 是把仓库发布到 npm 上，我们会把 dist 目录下的代码都发布到 npm 上，因为我们在 package.json 中配置的是 files 是 ["dist"]。\n\n\n# 运行部署脚本\n\n接下来我们就运行 npm run pub 脚本部署，我们会发现在 npm run prepub 阶段，在执行 tslint --project tsconfig.json -t codeframe \'src/**/*.ts\' \'test/**/*.ts\' 的时候失败了，原因是我们有代码不符合 lint 规范。原来是 core/xhr.ts 文件中 processcancel 函数中对 promise 的处理，我们没有对异常情况处理，所以我们要给它加上 catch 的逻辑：\n\nfunction processcancel(): void {\n  if (canceltoken) {\n    canceltoken.promise\n      .then(reason => {\n        request.abort()\n        reject(reason)\n      })\n      .catch(\n        /* istanbul ignore next */\n        () => {\n        // do nothing\n      })\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n由于我们不会走到 catch 逻辑，所以我们给它添加一个注释 /* istanbul ignore next */ 忽略该代码分支的测试。\n\n然后我们再重新运行 npm run pub 逻辑，它会先执行 test，然后运行 build 编译代码，再执行 release.sh 脚本。我们输入了要发布的版本，它就可以完成了整个代码的发布流程。\n\n通过编写部署脚本的一行命令发布的方式，不仅可以用在这种 js 库，也可以用于我们平时项目开发中，可以大大帮助我们提高生产率，也是前端工程化中必不可少的一个环节，希望同学们都能学会并掌握它。\n\n至此我们完成了项目的部署和发布，我们也可以在 npm 官网上看到我们发布的包，下一节课我们来创建一个实际项目，来引用我们开发的 ts-axios 库。',charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"引用 ts-axios 库",frontmatter:{title:"引用 ts-axios 库",date:"2020-01-05T10:56:02.000Z",permalink:"/pages/c6bdbd5bd60adf5a",author:"HuangYi",categories:["《TypeScript 从零实现 axios》","ts-axios 部署与发布"],tags:["TypeScript"]},regularPath:"/%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B/12.ts-axios%20%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%8F%91%E5%B8%83/02.%E5%BC%95%E7%94%A8%20ts-axios%20%E5%BA%93.html",relativePath:"《TypeScript 从零实现 axios》/12.ts-axios 部署与发布/02.引用 ts-axios 库.md",key:"v-31791362",path:"/pages/c6bdbd5bd60adf5a/",headers:[{level:2,title:"在 TS 项目中引用",slug:"在-ts-项目中引用",normalizedTitle:"在 ts 项目中引用",charIndex:20},{level:2,title:"在 JS 项目中引用",slug:"在-js-项目中引用",normalizedTitle:"在 js 项目中引用",charIndex:2815}],headersStr:"在 TS 项目中引用 在 JS 项目中引用",content:"# 引用 ts-axios 库\n\n\n# 在 TS 项目中引用\n\n我们借助于 vue-cli 脚手架创建一个 TypeScript 的 Vue 项目，然后我们把 Vue 官网上一段使用 axios 发请求的 demo 代码抄过来。\n\n我们需要先执行 npm install ts-axios-new 安装 ts-axios 库。\n\nHelloWorld.vue\n\n<template>\n  <div class=\"hello\">\n    <p>\n      Ask a yes/no question:\n      <input v-model=\"question\">\n    </p>\n    <p>{{ answer }}</p>\n  </div>\n</template>\n\n<script lang=\"ts\">\n  import Vue from 'vue'\n  import _ from 'lodash'\n  import axios from 'ts-axios-new'\n\n  export default Vue.extend({\n    name: 'HelloWorld',\n    data () {\n      return {\n        question: '',\n        answer: 'I cannot give you an answer until you ask a question!'\n      }\n    },\n    created () {\n      this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)\n    },\n    methods: {\n      debouncedGetAnswer () {\n        // do nothing\n      },\n      getAnswer () {\n        if (this.question.indexOf('?') === -1) {\n          this.answer = 'Questions usually contain a question mark. -)'\n          return\n        }\n        this.answer = 'Thinking...'\n        const instance = axios.create()\n        instance.interceptors.request.use((config) => {\n          config.params = {\n            _t: +new Date()\n          }\n          return config\n        })\n\n        instance.get('https://yesno.wtf/api')\n          .then((response) => {\n            this.answer = _.capitalize(response.data.answer)\n          })\n          .catch((error) => {\n            this.answer = 'Error! Could not reach the API. ' + error\n          })\n      }\n    },\n    watch: {\n      question: function (newQuestion: string, oldQuestion: string) {\n        this.answer = 'Waiting for you to stop typing...'\n        this.debouncedGetAnswer()\n      }\n    }\n  })\n<\/script>\n\n\x3c!-- Add \"scoped\" attribute to limit CSS to this component only --\x3e\n<style scoped>\n  h3 {\n    margin: 40px 0 0;\n  }\n\n  ul {\n    list-style-type: none;\n    padding: 0;\n  }\n\n  li {\n    display: inline-block;\n    margin: 0 10px;\n  }\n\n  a {\n    color: #42b983;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n\n\n这段代码主要是提供了一个 input 输入框，绑定了 question 变量，当我们输入的时候，会触发 question 的变化，执行 watch question 中的逻辑，执行 this.debouncedGetAnswer 方法，实际上就是 debounce 执行了 getAnswer 方法，发送请求。\n\n我们通过 import axios from 'ts-axios-new' 去加载 ts-axios 库，实际上就是引入了 node_modules/ts-axios-new/dist/axios.es5.js，因为 ts-axios-new 的 package.json 文件中配置的 module 字段是 dist/axios.es5.js，在 webpack 中优先 import 优先会找 module 字段，其次是 main 字段。\n\n> 小技巧：当我们引入某个库运行时出现问题时候，我们就可以调试 node_modules 中对应引入的代码。\n\n注意我们这里先使用了 axios.create() 方法创建了一个 instance，然后添加了一个请求拦截器，会在每次发送请求前，添加了一个 _t 参数，值为时间戳。然后执行 instance.get 发送一个请求。\n\n我们可以看到整个 demo 是可以正常运行的，并且没有任何类型相关的问题，说明我们的库打包后的代码和类型声明文件都是没有问题的。\n\n\n# 在 JS 项目中引用\n\n我们编写的 TS 库仍然可以被纯 JS 的项目引用，这次我们来修改《Vue.js2.5+cube-ui重构饿了么App》课程的代码，把之前对 axios 的引用改成对 ts-axios-new 的引用。课程源码是开源的，所以没购买课程的小伙伴也可以去 GitHub 下载。\n\n我们需要先执行 npm install ts-axios-new 安装 ts-axios 库，然后修改代码。\n\napi/helpers.js：\n\nimport axios from 'ts-axios-new'\n\nconst urlMap = {\n  development: '/',\n  production: 'http://ustbhuangyi.com/sell/'\n}\nconst baseUrl = urlMap[process.env.NODE_ENV]\nconst ERR_OK = 0\n\nexport function get(url) {\n  return function(params = {}) {\n    return axios.get(baseUrl + url, {\n      params\n    }).then((res) => {\n      const {errno, data} = res.data\n      if (errno === ERR_OK) {\n        return data\n      }\n    }).catch((e) => {\n    })\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n只需要把 import axios from 'axios' 修改为 import axios from 'ts-axios-new' 即可。\n\n接着运行项目，我们发现项目可以成功运行，因为我们实现了axios 在浏览器端的所有功能，所以可以放心的做替换。\n\n至此，我们就完成了 ts-axios 库的开发、测试、编译、发布和引用。课程到这里也就告一段落了，下一章我们会对整个课程做总结与展望。",normalizedContent:"# 引用 ts-axios 库\n\n\n# 在 ts 项目中引用\n\n我们借助于 vue-cli 脚手架创建一个 typescript 的 vue 项目，然后我们把 vue 官网上一段使用 axios 发请求的 demo 代码抄过来。\n\n我们需要先执行 npm install ts-axios-new 安装 ts-axios 库。\n\nhelloworld.vue\n\n<template>\n  <div class=\"hello\">\n    <p>\n      ask a yes/no question:\n      <input v-model=\"question\">\n    </p>\n    <p>{{ answer }}</p>\n  </div>\n</template>\n\n<script lang=\"ts\">\n  import vue from 'vue'\n  import _ from 'lodash'\n  import axios from 'ts-axios-new'\n\n  export default vue.extend({\n    name: 'helloworld',\n    data () {\n      return {\n        question: '',\n        answer: 'i cannot give you an answer until you ask a question!'\n      }\n    },\n    created () {\n      this.debouncedgetanswer = _.debounce(this.getanswer, 500)\n    },\n    methods: {\n      debouncedgetanswer () {\n        // do nothing\n      },\n      getanswer () {\n        if (this.question.indexof('?') === -1) {\n          this.answer = 'questions usually contain a question mark. -)'\n          return\n        }\n        this.answer = 'thinking...'\n        const instance = axios.create()\n        instance.interceptors.request.use((config) => {\n          config.params = {\n            _t: +new date()\n          }\n          return config\n        })\n\n        instance.get('https://yesno.wtf/api')\n          .then((response) => {\n            this.answer = _.capitalize(response.data.answer)\n          })\n          .catch((error) => {\n            this.answer = 'error! could not reach the api. ' + error\n          })\n      }\n    },\n    watch: {\n      question: function (newquestion: string, oldquestion: string) {\n        this.answer = 'waiting for you to stop typing...'\n        this.debouncedgetanswer()\n      }\n    }\n  })\n<\/script>\n\n\x3c!-- add \"scoped\" attribute to limit css to this component only --\x3e\n<style scoped>\n  h3 {\n    margin: 40px 0 0;\n  }\n\n  ul {\n    list-style-type: none;\n    padding: 0;\n  }\n\n  li {\n    display: inline-block;\n    margin: 0 10px;\n  }\n\n  a {\n    color: #42b983;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n\n\n这段代码主要是提供了一个 input 输入框，绑定了 question 变量，当我们输入的时候，会触发 question 的变化，执行 watch question 中的逻辑，执行 this.debouncedgetanswer 方法，实际上就是 debounce 执行了 getanswer 方法，发送请求。\n\n我们通过 import axios from 'ts-axios-new' 去加载 ts-axios 库，实际上就是引入了 node_modules/ts-axios-new/dist/axios.es5.js，因为 ts-axios-new 的 package.json 文件中配置的 module 字段是 dist/axios.es5.js，在 webpack 中优先 import 优先会找 module 字段，其次是 main 字段。\n\n> 小技巧：当我们引入某个库运行时出现问题时候，我们就可以调试 node_modules 中对应引入的代码。\n\n注意我们这里先使用了 axios.create() 方法创建了一个 instance，然后添加了一个请求拦截器，会在每次发送请求前，添加了一个 _t 参数，值为时间戳。然后执行 instance.get 发送一个请求。\n\n我们可以看到整个 demo 是可以正常运行的，并且没有任何类型相关的问题，说明我们的库打包后的代码和类型声明文件都是没有问题的。\n\n\n# 在 js 项目中引用\n\n我们编写的 ts 库仍然可以被纯 js 的项目引用，这次我们来修改《vue.js2.5+cube-ui重构饿了么app》课程的代码，把之前对 axios 的引用改成对 ts-axios-new 的引用。课程源码是开源的，所以没购买课程的小伙伴也可以去 github 下载。\n\n我们需要先执行 npm install ts-axios-new 安装 ts-axios 库，然后修改代码。\n\napi/helpers.js：\n\nimport axios from 'ts-axios-new'\n\nconst urlmap = {\n  development: '/',\n  production: 'http://ustbhuangyi.com/sell/'\n}\nconst baseurl = urlmap[process.env.node_env]\nconst err_ok = 0\n\nexport function get(url) {\n  return function(params = {}) {\n    return axios.get(baseurl + url, {\n      params\n    }).then((res) => {\n      const {errno, data} = res.data\n      if (errno === err_ok) {\n        return data\n      }\n    }).catch((e) => {\n    })\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n只需要把 import axios from 'axios' 修改为 import axios from 'ts-axios-new' 即可。\n\n接着运行项目，我们发现项目可以成功运行，因为我们实现了axios 在浏览器端的所有功能，所以可以放心的做替换。\n\n至此，我们就完成了 ts-axios 库的开发、测试、编译、发布和引用。课程到这里也就告一段落了，下一章我们会对整个课程做总结与展望。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"Vue概念原理",frontmatter:{title:"Vue概念原理",date:"2022-04-10T20:49:03.000Z",permalink:"/pages/81066a/",categories:["《Vue》"],tags:["Vue"],author:{name:"年华惊风雨",link:"https://github.com/wsy425"}},regularPath:"/%E3%80%8AVue%E3%80%8B/00.%20Vue%E6%A6%82%E5%BF%B5%E5%8E%9F%E7%90%86.html",relativePath:"《Vue》/00. Vue概念原理.md",key:"v-22aa0bf8",path:"/pages/81066a/",headers:[{level:2,title:"1.1 Vue介绍与描述",slug:"_1-1-vue介绍与描述",normalizedTitle:"1.1 vue介绍与描述",charIndex:2},{level:2,title:"1.2 Vue特点",slug:"_1-2-vue特点",normalizedTitle:"1.2 vue特点",charIndex:139},{level:2,title:"1.3 与其他JS框架对比",slug:"_1-3-与其他js框架对比",normalizedTitle:"1.3 与其他js框架对比",charIndex:316},{level:2,title:"1.4 MVVM模型",slug:"_1-4-mvvm模型",normalizedTitle:"1.4 mvvm模型",charIndex:383},{level:2,title:"1.5 Vue基础使用",slug:"_1-5-vue基础使用",normalizedTitle:"1.5 vue基础使用",charIndex:540},{level:3,title:"1.5.1 Vue实例挂载",slug:"_1-5-1-vue实例挂载",normalizedTitle:"1.5.1 vue实例挂载",charIndex:1140},{level:3,title:"1.5.2 Vue实例data",slug:"_1-5-2-vue实例data",normalizedTitle:"1.5.2 vue实例data",charIndex:1220},{level:2,title:"1.6 数据监视",slug:"_1-6-数据监视",normalizedTitle:"1.6 数据监视",charIndex:1334},{level:3,title:"1.6.1 Vue2数据监视",slug:"_1-6-1-vue2数据监视",normalizedTitle:"1.6.1 vue2数据监视",charIndex:1347},{level:2,title:"1.7 生命周期",slug:"_1-7-生命周期",normalizedTitle:"1.7 生命周期",charIndex:1948},{level:3,title:"1.7.1 VUE2生命周期",slug:"_1-7-1-vue2生命周期",normalizedTitle:"1.7.1 vue2生命周期",charIndex:2095},{level:3,title:"1.7.2 VUE3生命周期",slug:"_1-7-2-vue3生命周期",normalizedTitle:"1.7.2 vue3生命周期",charIndex:2731}],headersStr:"1.1 Vue介绍与描述 1.2 Vue特点 1.3 与其他JS框架对比 1.4 MVVM模型 1.5 Vue基础使用 1.5.1 Vue实例挂载 1.5.2 Vue实例data 1.6 数据监视 1.6.1 Vue2数据监视 1.7 生命周期 1.7.1 VUE2生命周期 1.7.2 VUE3生命周期",content:"# 1.1 Vue介绍与描述\n\nVue是一套用来动态构建用户界面的渐进式JavaScript框架\n\n * 构建用户界面：把数据通过某种办法变成用户界面\n * 渐进式：Vue可以自底向上逐层的应用，简单应用只需要一个轻量小巧的核心库，复杂应用可以引入各式各样的Vue插件\n\n\n# 1.2 Vue特点\n\n 1. 遵循MVVM模式\n 2. 编码简洁，体积小，运行效率高，适合移动/PC端开发\n 3. 它本身只关注 UI，可以引入其它第三方库开发项目\n 4. 采用组件化模式，提高代码复用率、且让代码更好维护\n 5. 声明式编码，让编码人员无需直接操作DOM，提高开发效率\n 6. 使用虚拟DOM和Diff算法，尽量复用DOM节点\n\n\n# 1.3 与其他JS框架对比\n\n 1. 借鉴angular的模板和数据绑定技术\n 2. 借鉴react的组件化和虚拟DOM技术\n\n\n# 1.4 MVVM模型\n\n\n\n 1. M：模型Model，data中的数据\n 2. V：视图View，模板代码\n 3. VM：视图模型ViewModel，Vue实例\n 4. data中所有的属性，最后都出现在了vm身上\n 5. vm身上所有的属性 及Vue原型身上所有的属性，在 Vue模板中都可以直接使用\n\n\n# 1.5 Vue基础使用\n\n 1. 需要一个root容器，root容器里的代码被称为Vue模板\n 2. 就必须创建一个Vue实例，且要传入一个配置对象\n 3. Vue 实例与容器是一一对应的\n 4. {{xxx}}中的 xxx 要写js表达式，且 xxx 可以自动读取到data中的所有属性\n 5. 一旦data中的数据发生变化，那么模板中用到该数据的地方也会自动更新\n\n<body>\n    \x3c!-- root容器 --\x3e\n    <div id=\"demo\">\n        <h1>Hello，{{ name.toUpperCase() }}，{{ address }}</h1>\n    </div>\n</body>\n\n<script>\n    // 创建Vue实例\n    new Vue ({\n        el:'#demo' //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串\n        data: {       // data中用于存储数据，数据供el所指定的容器去使用，值暂时先写成一个对象\n            name: 'cess',\n            address: '成都'\n        }\n    })\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 1.5.1 Vue实例挂载\n\n 1. 创建Vue实例对象的时候配置el属性\n 2. 先创建Vue实例，随后再通过vm.$mount('#XXX')挂载\n\n\n# 1.5.2 Vue实例data\n\n 1. 对象式：data:{ }\n 2. 函数式：data(){return {}}\n 3. 使用组件的时候必须使用函数形式\n 4. 不能使用箭头函数，会导致this不再是Vue实例了\n\n\n# 1.6 数据监视\n\n\n# 1.6.1 Vue2数据监视\n\n 1. vue会监视data中所有层次的数据\n 2. 如何监测对象中的数据？\n    1. 通过setter实现监视，且要在new Vue()时就传入要监测的数据\n    2. 对象创建后追加的属性，Vue默认不做响应式处理\n    3. 如需给后添加的属性做响应式，请使用如下API\n       1. Vue.set(target,propertyName/index,value)\n       2. vm.$set(target,propertyName/index,value)\n 3. 如何监测数组中的数据？\n    1. 通过包裹数组更新元素的方法实现，本质就是做了两件事\n       1. 调用原生对应的方法对数组进行更新\n       2. 重新解析模板，进而更新页面\n 4. 在Vue修改数组中的某个元素一定要用如下方法\n    1. push()pop()unshift()shift()splice()sort()reverse()这几个方法被Vue重写了\n    2. Vue.set()或vm.$set()\n 5. Vue.set() 和 vm.$set() 不能给vm或vm的根数据对象（data等）添加属性\n 6. 数据劫持：将写的data加工后添加getter和setter的过程，将数据劫持在getter和setter里了\n\n\n# 1.7 生命周期\n\n 1. 又名生命周期回调函数、生命周期函数、生命周期钩子\n 2. 生命周期函数是Vue在关键时刻帮我们调用的一些特殊名称的函数\n 3. 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的\n 4. 生命周期函数中的 this 指向是vm或组件实例对象\n\n\n# 1.7.1 VUE2生命周期\n\n\n\nbeforeCreate() {console.log('初始化但没有数据代理')},\ncreated() {console.log('初始化且完成数据监测和数据代理')},\nbeforeMount() {console.log('虚拟DOM已经生成，但还没有转换为真实DOM')},\nmounted() {console.log('VUE解析并把真实DOM挂载到页面上')},\nbeforeUpdate() {console.log('数据已经更新，但页面还未更新')},\nupdated() {console.log('页面和数据都更新完毕')},\nbeforeDestroy() {console.log('马上要销毁VUE实例')},\ndestroyed() {console.log('destroyed')},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 1. 常用的生命周期钩子\n    1. mounted发送ajax请求、启动定时器、绑定自定义事件、订阅消息等初始化操作\n    2. beforeDestroy清除定时器、解绑自定义事件、取消订阅消息等收尾工作\n 2. 关于销毁Vue实例\n    1. 销毁后借助Vue开发者工具看不到任何信息\n    2. 销毁后自定义事件会失效，但原生DOM事件依然有效\n    3. 一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了\n\n\n# 1.7.2 VUE3生命周期\n\n\n\n 1. Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名\n    1. beforeDestroy改名为 beforeUnmount\n    2. destroyed改名为 unmounted\n 2. Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下\n    1. beforeCreate===>setup()\n    2. created=======>setup()\n    3. beforeMount ===>onBeforeMount\n    4. mounted=======>onMounted\n    5. beforeUpdate===>onBeforeUpdate\n    6. updated =======>onUpdated\n    7. beforeUnmount ==>onBeforeUnmount\n    8. unmounted =====>onUnmounted",normalizedContent:"# 1.1 vue介绍与描述\n\nvue是一套用来动态构建用户界面的渐进式javascript框架\n\n * 构建用户界面：把数据通过某种办法变成用户界面\n * 渐进式：vue可以自底向上逐层的应用，简单应用只需要一个轻量小巧的核心库，复杂应用可以引入各式各样的vue插件\n\n\n# 1.2 vue特点\n\n 1. 遵循mvvm模式\n 2. 编码简洁，体积小，运行效率高，适合移动/pc端开发\n 3. 它本身只关注 ui，可以引入其它第三方库开发项目\n 4. 采用组件化模式，提高代码复用率、且让代码更好维护\n 5. 声明式编码，让编码人员无需直接操作dom，提高开发效率\n 6. 使用虚拟dom和diff算法，尽量复用dom节点\n\n\n# 1.3 与其他js框架对比\n\n 1. 借鉴angular的模板和数据绑定技术\n 2. 借鉴react的组件化和虚拟dom技术\n\n\n# 1.4 mvvm模型\n\n\n\n 1. m：模型model，data中的数据\n 2. v：视图view，模板代码\n 3. vm：视图模型viewmodel，vue实例\n 4. data中所有的属性，最后都出现在了vm身上\n 5. vm身上所有的属性 及vue原型身上所有的属性，在 vue模板中都可以直接使用\n\n\n# 1.5 vue基础使用\n\n 1. 需要一个root容器，root容器里的代码被称为vue模板\n 2. 就必须创建一个vue实例，且要传入一个配置对象\n 3. vue 实例与容器是一一对应的\n 4. {{xxx}}中的 xxx 要写js表达式，且 xxx 可以自动读取到data中的所有属性\n 5. 一旦data中的数据发生变化，那么模板中用到该数据的地方也会自动更新\n\n<body>\n    \x3c!-- root容器 --\x3e\n    <div id=\"demo\">\n        <h1>hello，{{ name.touppercase() }}，{{ address }}</h1>\n    </div>\n</body>\n\n<script>\n    // 创建vue实例\n    new vue ({\n        el:'#demo' //el用于指定当前vue实例为哪个容器服务，值通常为css选择器字符串\n        data: {       // data中用于存储数据，数据供el所指定的容器去使用，值暂时先写成一个对象\n            name: 'cess',\n            address: '成都'\n        }\n    })\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 1.5.1 vue实例挂载\n\n 1. 创建vue实例对象的时候配置el属性\n 2. 先创建vue实例，随后再通过vm.$mount('#xxx')挂载\n\n\n# 1.5.2 vue实例data\n\n 1. 对象式：data:{ }\n 2. 函数式：data(){return {}}\n 3. 使用组件的时候必须使用函数形式\n 4. 不能使用箭头函数，会导致this不再是vue实例了\n\n\n# 1.6 数据监视\n\n\n# 1.6.1 vue2数据监视\n\n 1. vue会监视data中所有层次的数据\n 2. 如何监测对象中的数据？\n    1. 通过setter实现监视，且要在new vue()时就传入要监测的数据\n    2. 对象创建后追加的属性，vue默认不做响应式处理\n    3. 如需给后添加的属性做响应式，请使用如下api\n       1. vue.set(target,propertyname/index,value)\n       2. vm.$set(target,propertyname/index,value)\n 3. 如何监测数组中的数据？\n    1. 通过包裹数组更新元素的方法实现，本质就是做了两件事\n       1. 调用原生对应的方法对数组进行更新\n       2. 重新解析模板，进而更新页面\n 4. 在vue修改数组中的某个元素一定要用如下方法\n    1. push()pop()unshift()shift()splice()sort()reverse()这几个方法被vue重写了\n    2. vue.set()或vm.$set()\n 5. vue.set() 和 vm.$set() 不能给vm或vm的根数据对象（data等）添加属性\n 6. 数据劫持：将写的data加工后添加getter和setter的过程，将数据劫持在getter和setter里了\n\n\n# 1.7 生命周期\n\n 1. 又名生命周期回调函数、生命周期函数、生命周期钩子\n 2. 生命周期函数是vue在关键时刻帮我们调用的一些特殊名称的函数\n 3. 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的\n 4. 生命周期函数中的 this 指向是vm或组件实例对象\n\n\n# 1.7.1 vue2生命周期\n\n\n\nbeforecreate() {console.log('初始化但没有数据代理')},\ncreated() {console.log('初始化且完成数据监测和数据代理')},\nbeforemount() {console.log('虚拟dom已经生成，但还没有转换为真实dom')},\nmounted() {console.log('vue解析并把真实dom挂载到页面上')},\nbeforeupdate() {console.log('数据已经更新，但页面还未更新')},\nupdated() {console.log('页面和数据都更新完毕')},\nbeforedestroy() {console.log('马上要销毁vue实例')},\ndestroyed() {console.log('destroyed')},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 1. 常用的生命周期钩子\n    1. mounted发送ajax请求、启动定时器、绑定自定义事件、订阅消息等初始化操作\n    2. beforedestroy清除定时器、解绑自定义事件、取消订阅消息等收尾工作\n 2. 关于销毁vue实例\n    1. 销毁后借助vue开发者工具看不到任何信息\n    2. 销毁后自定义事件会失效，但原生dom事件依然有效\n    3. 一般不会在beforedestroy操作数据，因为即便操作数据，也不会再触发更新流程了\n\n\n# 1.7.2 vue3生命周期\n\n\n\n 1. vue3.0中可以继续使用vue2.x中的生命周期钩子，但有有两个被更名\n    1. beforedestroy改名为 beforeunmount\n    2. destroyed改名为 unmounted\n 2. vue3.0也提供了 composition api 形式的生命周期钩子，与vue2.x中钩子对应关系如下\n    1. beforecreate===>setup()\n    2. created=======>setup()\n    3. beforemount ===>onbeforemount\n    4. mounted=======>onmounted\n    5. beforeupdate===>onbeforeupdate\n    6. updated =======>onupdated\n    7. beforeunmount ==>onbeforeunmount\n    8. unmounted =====>onunmounted",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"Vue核心",frontmatter:{title:"Vue核心",date:"2022-04-10T20:50:19.000Z",permalink:"/pages/4e0a77/",categories:["《Vue》"],tags:["Vue"],author:{name:"年华惊风雨",link:"https://github.com/wsy425"}},regularPath:"/%E3%80%8AVue%E3%80%8B/05.%20%20Vue%E6%A0%B8%E5%BF%83.html",relativePath:"《Vue》/05.  Vue核心.md",key:"v-eee07e4e",path:"/pages/4e0a77/",headers:[{level:2,title:"2.1 模板语法",slug:"_2-1-模板语法",normalizedTitle:"2.1 模板语法",charIndex:2},{level:3,title:"2.1.1 插值语法",slug:"_2-1-1-插值语法",normalizedTitle:"2.1.1 插值语法",charIndex:29},{level:3,title:"2.1.2 指令语法",slug:"_2-1-2-指令语法",normalizedTitle:"2.1.2 指令语法",charIndex:113},{level:2,title:"2.2 数据绑定",slug:"_2-2-数据绑定",normalizedTitle:"2.2 数据绑定",charIndex:212},{level:3,title:"2.2.1 单向数据绑定",slug:"_2-2-1-单向数据绑定",normalizedTitle:"2.2.1 单向数据绑定",charIndex:240},{level:3,title:"2.2.2 双向数据绑定",slug:"_2-2-2-双向数据绑定",normalizedTitle:"2.2.2 双向数据绑定",charIndex:293},{level:3,title:"2.2.3 收集表单数据",slug:"_2-2-3-收集表单数据",normalizedTitle:"2.2.3 收集表单数据",charIndex:458},{level:2,title:"2.3 数据代理",slug:"_2-3-数据代理",normalizedTitle:"2.3 数据代理",charIndex:882},{level:3,title:"2.3.1 Vue数据代理原理",slug:"_2-3-1-vue数据代理原理",normalizedTitle:"2.3.1 vue数据代理原理",charIndex:926},{level:3,title:"2.3.2 数据代理原理",slug:"_2-3-2-数据代理原理",normalizedTitle:"2.3.2 数据代理原理",charIndex:1237},{level:3,title:"2.3.3 Object.defineProperty()",slug:"_2-3-3-object-defineproperty",normalizedTitle:"2.3.3 object.defineproperty()",charIndex:1573},{level:2,title:"2.4 事件处理",slug:"_2-4-事件处理",normalizedTitle:"2.4 事件处理",charIndex:2148},{level:3,title:"2.4.1 事件的基本用法",slug:"_2-4-1-事件的基本用法",normalizedTitle:"2.4.1 事件的基本用法",charIndex:2161},{level:3,title:"2.4.2 事件修饰符",slug:"_2-4-2-事件修饰符",normalizedTitle:"2.4.2 事件修饰符",charIndex:2392},{level:3,title:"2.4.3 键盘事件",slug:"_2-4-3-键盘事件",normalizedTitle:"2.4.3 键盘事件",charIndex:2655},{level:2,title:"2.5 计算属性computed",slug:"_2-5-计算属性computed",normalizedTitle:"2.5 计算属性computed",charIndex:3195},{level:2,title:"2.6监视属性watch",slug:"_2-6监视属性watch",normalizedTitle:"2.6监视属性watch",charIndex:3991},{level:3,title:"2.6.1侦听属性基本用法",slug:"_2-6-1侦听属性基本用法",normalizedTitle:"2.6.1侦听属性基本用法",charIndex:4008},{level:3,title:"2.6.2 深度监视",slug:"_2-6-2-深度监视",normalizedTitle:"2.6.2 深度监视",charIndex:4916},{level:3,title:"2.6.3 监视属性简写",slug:"_2-6-3-监视属性简写",normalizedTitle:"2.6.3 监视属性简写",charIndex:5135},{level:3,title:"2.6.4 computed与watch的区别",slug:"_2-6-4-computed与watch的区别",normalizedTitle:"2.6.4 computed与watch的区别",charIndex:5346},{level:2,title:"2.7 样式绑定",slug:"_2-7-样式绑定",normalizedTitle:"2.7 样式绑定",charIndex:5586},{level:3,title:"2.7.1 绑定class样式",slug:"_2-7-1-绑定class样式",normalizedTitle:"2.7.1 绑定class样式",charIndex:5599},{level:3,title:"2.7.2 绑定style样式",slug:"_2-7-2-绑定style样式",normalizedTitle:"2.7.2 绑定style样式",charIndex:5774},{level:2,title:"2.8 条件渲染",slug:"_2-8-条件渲染",normalizedTitle:"2.8 条件渲染",charIndex:5864},{level:3,title:"2.8.1 v-if",slug:"_2-8-1-v-if",normalizedTitle:"2.8.1 v-if",charIndex:5877},{level:3,title:"2.8.2 v-show",slug:"_2-8-2-v-show",normalizedTitle:"2.8.2 v-show",charIndex:6052},{level:2,title:"2.9 列表渲染",slug:"_2-9-列表渲染",normalizedTitle:"2.9 列表渲染",charIndex:6242},{level:3,title:"2.9.1 v-for指令",slug:"_2-9-1-v-for指令",normalizedTitle:"2.9.1 v-for指令",charIndex:6255},{level:3,title:"2.9.2 key的作用与原理",slug:"_2-9-2-key的作用与原理",normalizedTitle:"2.9.2 key的作用与原理",charIndex:6404},{level:3,title:"2.9.2 列表过滤",slug:"_2-9-2-列表过滤",normalizedTitle:"2.9.2 列表过滤",charIndex:6983},{level:3,title:"2.9.3 列表排序",slug:"_2-9-3-列表排序",normalizedTitle:"2.9.3 列表排序",charIndex:7391},{level:2,title:"2.10 内置指令",slug:"_2-10-内置指令",normalizedTitle:"2.10 内置指令",charIndex:7810},{level:3,title:"2.10.1之前用过的",slug:"_2-10-1之前用过的",normalizedTitle:"2.10.1之前用过的",charIndex:7824},{level:3,title:"2.10.2 v-text",slug:"_2-10-2-v-text",normalizedTitle:"2.10.2 v-text",charIndex:8052},{level:3,title:"2.10.3 v-html",slug:"_2-10-3-v-html",normalizedTitle:"2.10.3 v-html",charIndex:8153},{level:3,title:"2.10.4 v-cloak",slug:"_2-10-4-v-cloak",normalizedTitle:"2.10.4 v-cloak",charIndex:8382},{level:3,title:"2.10.5 v-once",slug:"_2-10-5-v-once",normalizedTitle:"2.10.5 v-once",charIndex:8495},{level:3,title:"2.10.6 v-pre",slug:"_2-10-6-v-pre",normalizedTitle:"2.10.6 v-pre",charIndex:8584},{level:2,title:"2.11 自定义指令",slug:"_2-11-自定义指令",normalizedTitle:"2.11 自定义指令",charIndex:8661},{level:2,title:"2.12 ~~过滤器~~（Vue3已移除）",slug:"_2-12-过滤器-vue3已移除",normalizedTitle:"2.12 <s>过滤器</s>（vue3已移除）",charIndex:null}],headersStr:"2.1 模板语法 2.1.1 插值语法 2.1.2 指令语法 2.2 数据绑定 2.2.1 单向数据绑定 2.2.2 双向数据绑定 2.2.3 收集表单数据 2.3 数据代理 2.3.1 Vue数据代理原理 2.3.2 数据代理原理 2.3.3 Object.defineProperty() 2.4 事件处理 2.4.1 事件的基本用法 2.4.2 事件修饰符 2.4.3 键盘事件 2.5 计算属性computed 2.6监视属性watch 2.6.1侦听属性基本用法 2.6.2 深度监视 2.6.3 监视属性简写 2.6.4 computed与watch的区别 2.7 样式绑定 2.7.1 绑定class样式 2.7.2 绑定style样式 2.8 条件渲染 2.8.1 v-if 2.8.2 v-show 2.9 列表渲染 2.9.1 v-for指令 2.9.2 key的作用与原理 2.9.2 列表过滤 2.9.3 列表排序 2.10 内置指令 2.10.1之前用过的 2.10.2 v-text 2.10.3 v-html 2.10.4 v-cloak 2.10.5 v-once 2.10.6 v-pre 2.11 自定义指令 2.12 ~~过滤器~~（Vue3已移除）",content:"# 2.1 模板语法\n\nVue模板语法包括两大类\n\n\n# 2.1.1 插值语法\n\n 1. 功能：用于解析标签体内容\n 2. 写法：`{ {xxx}}`，xxx 是 js 表达式，可以直接读取到 data 中的所有区域\n\n\n# 2.1.2 指令语法\n\n 1. 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…）\n 2. 写法：通过vue的指令将数据绑定到模板上，例如v-bind:可以给标签里的属性绑定数据\n\n\n# 2.2 数据绑定\n\nVue中有2种数据绑定方法\n\n\n# 2.2.1 单向数据绑定\n\n 1. v-bind数据只能从data流入页面\n 2. 可以简化为:\n\n\n# 2.2.2 双向数据绑定\n\n 1. v-model数据不仅能从 data 流向页面，还可以从页面流向 data\n 2. v-model:value可以简写为v-model，因为v-model默认收集的就是value值\n 3. 双向绑定一般都应用在表单类元素上，如< input>< select>< textarea>等\n\n\n# 2.2.3 收集表单数据\n\n 1. 若<input type=\"text\"/>，则v-model收集的是value值，用户输入的内容就是value值\n 2. 若<input type=\"radio\"/>，则v-model收集的是value值，且要给标签配置value属性\n 3. 若<input type=\"checkbox\"/>\n    1. 没有配置value属性，那么收集的是checked属性（勾选 or 未勾选，是布尔值）\n    2. 配置了value属性\n       1. v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）\n       2. v-model的初始值是数组，那么收集的就是value组成的数组\n 4. v-model修饰符\n    1. lazy 失去焦点后再收集数据\n    2. number输入字符串转为有效的数字\n    3. trim 输入首尾空格过滤\n\n\n# 2.3 数据代理\n\n数据代理：通过一个对象代理对另一个对象中属性的操作（读写）\n\n\n# 2.3.1 Vue数据代理原理\n\n\n\n 1. Vue中的数据代理通过vm对象来代理data对象中属性的操作（读/写）\n 2. Vue中数据代理的好处：更加方便的操作data中的数据\n 3. 基本原理\n    * 通过Object.defineProperty()把data对象中所有属性添加到vm上\n    * 为每一个添加到vm上的属性，都指定一个 getter setter\n    * 在getter setter内部去操作（读/写）data中对应属性的值\n    * 其中涉及到Vue将model里的data拷贝到vm的_data属性中，这是为了通过_data对data进行数据劫持，实现页面的响应式展示\n\n\n# 2.3.2 数据代理原理\n\n使用Object.defineProperty()方法在代理的对象中添加被代理对象需要被代理的属性\n\nlet obj = {x:100} //被代理的对象\nlet propertyObj = {} //代理的对象\nObject.defineProperty(propertyObj, 'x', {\n    //读取propertyObj的x属性时触发\n    get(){\n        return obj.x\n    }\n    //修改propertyObj的x属性时触发\n    set(value){\n        obj.x = value\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.3.3 Object.defineProperty()\n\nlet person = {\n    name:'张三',\n    sex:'男',\n}\nlet age = 18\n// 为person对象添加属性,可以对添加的属性进行高级操作\nObject.defineProperty(person, 'age', {\n    value:18,  //属性赋值\n    enumerable:true,   // 控制属性是否可以枚举，默认值是false\n    writable:true,     // 控制属性是否可以被修改，默认值是false\n    configurable:true  // 控制属性是否可以被删除，默认值是false\n    //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值\n    get(){\n        return age\n    }\n    //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值\n    set(value){\n        age = value\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 2.4 事件处理\n\n\n# 2.4.1 事件的基本用法\n\n 1. 使用v-on:XXX或@XXX绑定事件，其中XXX是事件名\n 2. 事件的回调需要配置到在methods对象中，最终会在vm上\n 3. methods中配置的函数，不要用箭头函数，否则 this 就不是vm了\n 4. methods中配置的函数，都是被 Vue所管理的函数，this 的指向是vm或组件实例对象\n 5. @click=\"demo\"和@click=\"demo($event)\"效果一致，但后者可以传参\n\n\n# 2.4.2 事件修饰符\n\n 1. Vue中的事件修饰符\n    1. prevent 阻止默认事件（常用）\n    2. stop 阻止事件冒泡（常用）\n    3. once 事件只触发一次（常用）\n    4. capture 使用事件的捕获模式\n    5. self 只有event.target是当前操作的元素时才触发事件\n    6. passive 事件的默认行为立即执行，无需等待事件回调执行完毕\n 2. 修饰符可以连续写，比如可以这么用：@click.prevent.stop=\"showInfo\"\n\n\n# 2.4.3 键盘事件\n\n 1. 键盘上的每个按键都有自己的名称和编码，例如：Enter（13）。而Vue还对一些常用按键起了别名方便使用\n 2. Vue别名使用@keyup.enter=\"XXX\"\n 3. . Vue中常用的按键别名\n    1. 回车enter\n    2. 删除delete捕获“删除”和“退格”键\n    3. 退出esc\n    4. 空格space\n    5. 换行tab特殊，必须配合keydown去使用\n    6. 上up；下down ；左left；右right\n 4. Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（多单词小写短横线写法）\n 5. 系统修饰键（用法特殊）ctrlaltshiftmeta（meta就是win键）\n    1. 配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发\n    2. 指定 ctr+y 使用 @keyup.ctr.y\n    3. 配合keydown使用：正常触发事件\n 6. 也可以使用keyCode去指定具体的按键（不推荐）\n 7. Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名\n\n\n# 2.5 计算属性computed\n\n 1. 定义：要用的属性不存在，需要通过已有属性计算得来\n 2. 原理：底层借助了Objcet.defineproperty()方法提供的getter和setter\n 3. get函数什么时候执行？\n    1. 初次读取时会执行一次\n    2. 当依赖的数据发生改变时会被再次调用\n 4. 优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便\n 5. 计算属性最终会出现在vm上，直接读取使用即可\n 6. 如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变\n 7. 如果计算属性确定不考虑修改，可以使用计算属性的简写形式\n\nconst vm = new Vue({\n  el: '#root',\n  data: {\n    firstName:'张',\n    lastName:'三',\n  },\n  computed: {\n  //   完整写法\n    fullName: {\n    \tget() {\n    \t\treturn this.firstName + '-' + this.lastName\n    \t},\n    \tset(value) {\n    \t\tconst arr = value.split('-')\n    \t\tthis.firstName = arr[0]\n    \t\tthis.lastName = arr[1]\n    \t}\n    }\n    // 简写\n    Name() {\n      return this.firstName + '-' + this.lastName\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 2.6监视属性watch\n\n\n# 2.6.1侦听属性基本用法\n\n 1. 当被监视的属性变化时，回调函数自动调用，进行相关操作\n 2. 监视的属性必须存在，才能进行监视，既可以监视data，也可以监视计算属性\n 3. 配置项属性immediate:false，改为 true，则初始化时调用一次handler(newValue,oldValue)\n 4. 监视有两种写法\n    1. 创建Vue时传入watch: {}配置\n    2. 通过vm.$watch()监视\n\nconst vm = new Vue({\n    el: '#root',\n    data: {\n      isHot: true,\n    },\n    // 方式一\n    watch:{\n        isHot:{\n            immediate:true,\n            handler(newValue,oldValue){\n                console.log('isHot被修改了',newValue,oldValue)\n            }\n        }\n    },\n    methods:{\n        changeWeather(){\n            this.isHot = !isHot\n        }\n    },\n    computed: {\n        info(){\n            return this.isHot ? '炎热' : '凉爽'\n        }\n    }\n})\n// 方式二\nvm.$watch('isHot',{\n    immediate:true,\n    handler(newValue,oldValue){\n        console.log('isHot被修改了',newValue,oldValue)\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 2.6.2 深度监视\n\n 1. Vue中的watch默认不监测对象内部值的改变（一层）\n 2. 在watch中配置deep:true可以监测对象内部值的改变（多层）\n 3. Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以\n 4. 使用watch时根据监视数据的具体结构，决定是否采用深度监视\n 5. 只监视多级结构中某个属性的变化watch(){'numbers.a':{}'}，key需要手动加''包裹\n\n\n# 2.6.3 监视属性简写\n\n如果监视属性除了handler没有其他配置项的话，可以进行简写\n\nwatch:{\n    isHot(newValue,oldValue){\n    }\n}\nvm.$watch('isHot',(newValue,oldValue){\n    console.log('isHot被修改了', newValue, oldValue, this)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2.6.4 computed与watch的区别\n\n 1. computed能完成的功能，watch都可以完成\n 2. watch能完成的功能，computed不一定能完成，例如watch可以进行异步操作\n 3. 所有被Vue管理的函数，最好写成普通函数，这样 this 的指向才是vm或组件实例对象\n 4. 所有不被Vue所管理的函数（定时器的回调函数、ajax 的回调函数等、Promise 的回调函数），最好写成箭头函数，这样 this 的指向才是vm或组件实例对象\n\n\n# 2.7 样式绑定\n\n\n# 2.7.1 绑定class样式\n\n 1. 写法：:class=\"xxx\"，xxx 可以是字符串、数组、对象\n 2. 三种写法区别\n    1. 字符串写法适用于：类名不确定，要动态获取\n    2. 数组写法适用于：要绑定多个样式，个数不确定，名字也不确定\n    3. 对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用\n\n\n# 2.7.2 绑定style样式\n\n 1. :style=\"[a,b]\"其中a、b是样式对象\n 2. :style=\"{fontSize: xxx}\"其中 xxx 是动态值\n\n\n# 2.8 条件渲染\n\n\n# 2.8.1 v-if\n\n 1. 写法 跟 if else 语法类似\n    1. v-if=\"表达式\"\n    2. v-else-if=\"表达式\"\n    3. `v-else\n 2. 适用于：切换频率较低的场景，因为不展示的DOM元素直接被移除\n 3. 注意：v-if可以和v-else-if v-else一起使用，但要求结构不能被打断\n\n\n# 2.8.2 v-show\n\n 1. 写法：v-show=\"表达式\"\n 2. 适用于：切换频率较高的场景\n 3. 特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉display: none\n 4. 使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到template标签不影响结构，页面html中不会有此标签，但只能配合v-if，不能配合v-sho\n\n\n# 2.9 列表渲染\n\n\n# 2.9.1 v-for指令\n\n 1. 用于展示列表数据\n 2. 语法：<li v-for=\"(item, index) of items\" :key=\"index\">，这里key可以是index，更好的是遍历对象的唯一标识\n 3. 可遍历：数组、对象、字符串（用的少）、指定次数（用的少）\n\n\n# 2.9.2 key的作用与原理\n\n\n\n 1. 虚拟DOM中key的作用：key是虚拟DOM中对象的标识，当数据发生变化时，Vue会根据新数据生成新的虚拟DOM，随后Vue进行新虚拟DOM与旧虚拟DOM的差异比较\n 2. 对比规则\n    1. 旧虚拟DOM中找到了与新虚拟DOM相同的key\n       1. 若虚拟DOM中内容没变, 直接使用之前的真实DOM\n       2. 若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM\n    2. 旧虚拟DOM中未找到与新虚拟DOM相同的key 创建新的真实DOM，随后渲染到到页面\n 3. 用index作为key可能会引发的问题\n    1. 若对数据进行逆序添加、逆序删除等破坏顺序操作，会产生没有必要的真实DOM更新 ==> 界面效果没问题，但效率低\n    2. 若结构中还包含输入类的DOM：会产生错误DOM更新 ==> 界面有问题\n 4. 开发中如何选择key\n    1. 最好使用每条数据的唯一标识作为key，比如 id、手机号、身份证号、学号等唯一值\n    2. 如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表，使用index作为key是没有问题的\n 5. 如果代码没写key，vue就会自动把遍历的index作为key输入\n\n\n# 2.9.2 列表过滤\n\n 1. v-model来双向绑定用户过滤的信息\n 2. watch实现\n    1. 需要一个新的数组存储过滤后的内容，否则数据越来越少\n    2. immediate: true上来就执行一次，这样过滤后的数组不需要初始给值。其核心原理是任意字符串.indexOf(空字符串) = 0\n    3. Array.filter((p)=>{ return p.indexOf(val)})filter返回一个数组不改变原数组\n 3. computed实现\n\ncomputed:{\n    filPersons(){\n        return this.persons.filter((p)=>{\n            return p.name.indexOf(this.keyword) !== -1\n        })\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2.9.3 列表排序\n\n 1. 先过滤再排序，在同时存在过滤和排序需求的时候，排序还是维护过滤后的数据\n\ncomputed:{\n    filPersons(){\n        const arr =  this.persons.filter((p)=>{\n            return p.name.indexOf(this.keyword) !== -1\n        })\n        if(this.sortType){\n            arr.sort((p1,p2)=>{\n                return this.sortType === 1 ? p2.age-p1.age : p1.age-p2.age\n            })\n        }\n        return arr\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 2.10 内置指令\n\n\n# 2.10.1之前用过的\n\n 1. v-bind：单向绑定解析表达式，可简写为:\n 2. v-model:双向数据绑定\n 3. v-for:遍历数组 / 对象 / 字符串\n 4. v-on:绑定事件监听，可简写为@\n 5. v-show:条件渲染 (动态控制节点是否展示)\n 6. v-if:条件渲染（动态控制节点是否存存在）\n 7. v-else-if:条件渲染（动态控制节点是否存存在）\n 8. v-else:条件渲染（动态控制节点是否存存在）\n\n\n# 2.10.2 v-text\n\n 1. 作用：向其所在的节点中渲染文本内容\n 2. 与插值语法的区别：v-text会替换掉节点中的内容，{{xxx}}则不会\n 3. 不会解析数据里的html标签\n\n\n# 2.10.3 v-html\n\n 1. 作用：向指定节点中渲染包含html结构的内容\n 2. 与插值语法的区别：\n    1. v-html会替换掉节点中所有的内容，{{xxx}}则不会\n    2. v-html可以识别html结构\n 3. 严重注意v-html有安全性问题！！！\n    1. 在网站上动态渲染任意html是非常危险的，容易导致 XSS 攻击\n    2. 一定要在可信的内容上使用v-html，永远不要用在用户提交的内容上！！！\n\n\n# 2.10.4 v-cloak\n\n 1. 没有值\n 2. 本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性\n 3. 使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题\n\n\n# 2.10.5 v-once\n\n 1. v-once所在节点在初次动态渲染后，就视为静态内容了\n 2. 以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能\n\n\n# 2.10.6 v-pre\n\n 1. 跳过v-pre所在节点的编译过程\n 2. 可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译\n\n\n# 2.11 自定义指令\n\n 1. directives配置项\n\n// 局部指令\nnew Vue({\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n  directives:{ \n    指令名:配置对象 \n  }   \n})\nnew Vue({\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n  directives:{ \n    指令名:(element,binding){} \n  }   \n})\n// 全局指令\nVue.directive(指令名, 配置对象)\nVue.directive(指令名, 回调函数)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n 2. element就是DOM元素\n 3. binding就是要绑定的对象，它包含以下属性：name、value、oldValue、expression、arg、modifiers\n 4. 用函数的形式定义时指令执行时间\n    1. 指令与元素成功绑定时\n    2. 指令所在的模板被重新解析时\n 5. 配置对象中常用的三个回调函数\n    1. bind(element, binding)指令与元素成功绑定时调用\n    2. inserted(element, binding)指令所在元素被插入页面时调用\n    3. update(element, binding)指令所在模板结构被重新解析时调用\n 6. 指令定义时不加v-，但使用时要加v-\n 7. 指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名\n 8. 指令回调函数里的this都是window\n\n\n# 2.12 过滤器（Vue3已移除）\n\n 1. 定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）\n 2. 注册过滤器：\n    1. Vue.filter(name, callback)全局过滤器\n    2. new Vue {filters: {}} 局部过滤器\n 3. 使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = \"xxx | 过滤器名\"\n 4. 过滤器可以接收额外参数，多个过滤器也可以串联\n 5. 并没有改变原本的数据，而是产生新的对应的数据",normalizedContent:"# 2.1 模板语法\n\nvue模板语法包括两大类\n\n\n# 2.1.1 插值语法\n\n 1. 功能：用于解析标签体内容\n 2. 写法：`{ {xxx}}`，xxx 是 js 表达式，可以直接读取到 data 中的所有区域\n\n\n# 2.1.2 指令语法\n\n 1. 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…）\n 2. 写法：通过vue的指令将数据绑定到模板上，例如v-bind:可以给标签里的属性绑定数据\n\n\n# 2.2 数据绑定\n\nvue中有2种数据绑定方法\n\n\n# 2.2.1 单向数据绑定\n\n 1. v-bind数据只能从data流入页面\n 2. 可以简化为:\n\n\n# 2.2.2 双向数据绑定\n\n 1. v-model数据不仅能从 data 流向页面，还可以从页面流向 data\n 2. v-model:value可以简写为v-model，因为v-model默认收集的就是value值\n 3. 双向绑定一般都应用在表单类元素上，如< input>< select>< textarea>等\n\n\n# 2.2.3 收集表单数据\n\n 1. 若<input type=\"text\"/>，则v-model收集的是value值，用户输入的内容就是value值\n 2. 若<input type=\"radio\"/>，则v-model收集的是value值，且要给标签配置value属性\n 3. 若<input type=\"checkbox\"/>\n    1. 没有配置value属性，那么收集的是checked属性（勾选 or 未勾选，是布尔值）\n    2. 配置了value属性\n       1. v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）\n       2. v-model的初始值是数组，那么收集的就是value组成的数组\n 4. v-model修饰符\n    1. lazy 失去焦点后再收集数据\n    2. number输入字符串转为有效的数字\n    3. trim 输入首尾空格过滤\n\n\n# 2.3 数据代理\n\n数据代理：通过一个对象代理对另一个对象中属性的操作（读写）\n\n\n# 2.3.1 vue数据代理原理\n\n\n\n 1. vue中的数据代理通过vm对象来代理data对象中属性的操作（读/写）\n 2. vue中数据代理的好处：更加方便的操作data中的数据\n 3. 基本原理\n    * 通过object.defineproperty()把data对象中所有属性添加到vm上\n    * 为每一个添加到vm上的属性，都指定一个 getter setter\n    * 在getter setter内部去操作（读/写）data中对应属性的值\n    * 其中涉及到vue将model里的data拷贝到vm的_data属性中，这是为了通过_data对data进行数据劫持，实现页面的响应式展示\n\n\n# 2.3.2 数据代理原理\n\n使用object.defineproperty()方法在代理的对象中添加被代理对象需要被代理的属性\n\nlet obj = {x:100} //被代理的对象\nlet propertyobj = {} //代理的对象\nobject.defineproperty(propertyobj, 'x', {\n    //读取propertyobj的x属性时触发\n    get(){\n        return obj.x\n    }\n    //修改propertyobj的x属性时触发\n    set(value){\n        obj.x = value\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.3.3 object.defineproperty()\n\nlet person = {\n    name:'张三',\n    sex:'男',\n}\nlet age = 18\n// 为person对象添加属性,可以对添加的属性进行高级操作\nobject.defineproperty(person, 'age', {\n    value:18,  //属性赋值\n    enumerable:true,   // 控制属性是否可以枚举，默认值是false\n    writable:true,     // 控制属性是否可以被修改，默认值是false\n    configurable:true  // 控制属性是否可以被删除，默认值是false\n    //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值\n    get(){\n        return age\n    }\n    //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值\n    set(value){\n        age = value\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 2.4 事件处理\n\n\n# 2.4.1 事件的基本用法\n\n 1. 使用v-on:xxx或@xxx绑定事件，其中xxx是事件名\n 2. 事件的回调需要配置到在methods对象中，最终会在vm上\n 3. methods中配置的函数，不要用箭头函数，否则 this 就不是vm了\n 4. methods中配置的函数，都是被 vue所管理的函数，this 的指向是vm或组件实例对象\n 5. @click=\"demo\"和@click=\"demo($event)\"效果一致，但后者可以传参\n\n\n# 2.4.2 事件修饰符\n\n 1. vue中的事件修饰符\n    1. prevent 阻止默认事件（常用）\n    2. stop 阻止事件冒泡（常用）\n    3. once 事件只触发一次（常用）\n    4. capture 使用事件的捕获模式\n    5. self 只有event.target是当前操作的元素时才触发事件\n    6. passive 事件的默认行为立即执行，无需等待事件回调执行完毕\n 2. 修饰符可以连续写，比如可以这么用：@click.prevent.stop=\"showinfo\"\n\n\n# 2.4.3 键盘事件\n\n 1. 键盘上的每个按键都有自己的名称和编码，例如：enter（13）。而vue还对一些常用按键起了别名方便使用\n 2. vue别名使用@keyup.enter=\"xxx\"\n 3. . vue中常用的按键别名\n    1. 回车enter\n    2. 删除delete捕获“删除”和“退格”键\n    3. 退出esc\n    4. 空格space\n    5. 换行tab特殊，必须配合keydown去使用\n    6. 上up；下down ；左left；右right\n 4. vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（多单词小写短横线写法）\n 5. 系统修饰键（用法特殊）ctrlaltshiftmeta（meta就是win键）\n    1. 配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发\n    2. 指定 ctr+y 使用 @keyup.ctr.y\n    3. 配合keydown使用：正常触发事件\n 6. 也可以使用keycode去指定具体的按键（不推荐）\n 7. vue.config.keycodes.自定义键名 = 键码，可以去定制按键别名\n\n\n# 2.5 计算属性computed\n\n 1. 定义：要用的属性不存在，需要通过已有属性计算得来\n 2. 原理：底层借助了objcet.defineproperty()方法提供的getter和setter\n 3. get函数什么时候执行？\n    1. 初次读取时会执行一次\n    2. 当依赖的数据发生改变时会被再次调用\n 4. 优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便\n 5. 计算属性最终会出现在vm上，直接读取使用即可\n 6. 如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变\n 7. 如果计算属性确定不考虑修改，可以使用计算属性的简写形式\n\nconst vm = new vue({\n  el: '#root',\n  data: {\n    firstname:'张',\n    lastname:'三',\n  },\n  computed: {\n  //   完整写法\n    fullname: {\n    \tget() {\n    \t\treturn this.firstname + '-' + this.lastname\n    \t},\n    \tset(value) {\n    \t\tconst arr = value.split('-')\n    \t\tthis.firstname = arr[0]\n    \t\tthis.lastname = arr[1]\n    \t}\n    }\n    // 简写\n    name() {\n      return this.firstname + '-' + this.lastname\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 2.6监视属性watch\n\n\n# 2.6.1侦听属性基本用法\n\n 1. 当被监视的属性变化时，回调函数自动调用，进行相关操作\n 2. 监视的属性必须存在，才能进行监视，既可以监视data，也可以监视计算属性\n 3. 配置项属性immediate:false，改为 true，则初始化时调用一次handler(newvalue,oldvalue)\n 4. 监视有两种写法\n    1. 创建vue时传入watch: {}配置\n    2. 通过vm.$watch()监视\n\nconst vm = new vue({\n    el: '#root',\n    data: {\n      ishot: true,\n    },\n    // 方式一\n    watch:{\n        ishot:{\n            immediate:true,\n            handler(newvalue,oldvalue){\n                console.log('ishot被修改了',newvalue,oldvalue)\n            }\n        }\n    },\n    methods:{\n        changeweather(){\n            this.ishot = !ishot\n        }\n    },\n    computed: {\n        info(){\n            return this.ishot ? '炎热' : '凉爽'\n        }\n    }\n})\n// 方式二\nvm.$watch('ishot',{\n    immediate:true,\n    handler(newvalue,oldvalue){\n        console.log('ishot被修改了',newvalue,oldvalue)\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 2.6.2 深度监视\n\n 1. vue中的watch默认不监测对象内部值的改变（一层）\n 2. 在watch中配置deep:true可以监测对象内部值的改变（多层）\n 3. vue自身可以监测对象内部值的改变，但vue提供的watch默认不可以\n 4. 使用watch时根据监视数据的具体结构，决定是否采用深度监视\n 5. 只监视多级结构中某个属性的变化watch(){'numbers.a':{}'}，key需要手动加''包裹\n\n\n# 2.6.3 监视属性简写\n\n如果监视属性除了handler没有其他配置项的话，可以进行简写\n\nwatch:{\n    ishot(newvalue,oldvalue){\n    }\n}\nvm.$watch('ishot',(newvalue,oldvalue){\n    console.log('ishot被修改了', newvalue, oldvalue, this)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2.6.4 computed与watch的区别\n\n 1. computed能完成的功能，watch都可以完成\n 2. watch能完成的功能，computed不一定能完成，例如watch可以进行异步操作\n 3. 所有被vue管理的函数，最好写成普通函数，这样 this 的指向才是vm或组件实例对象\n 4. 所有不被vue所管理的函数（定时器的回调函数、ajax 的回调函数等、promise 的回调函数），最好写成箭头函数，这样 this 的指向才是vm或组件实例对象\n\n\n# 2.7 样式绑定\n\n\n# 2.7.1 绑定class样式\n\n 1. 写法：:class=\"xxx\"，xxx 可以是字符串、数组、对象\n 2. 三种写法区别\n    1. 字符串写法适用于：类名不确定，要动态获取\n    2. 数组写法适用于：要绑定多个样式，个数不确定，名字也不确定\n    3. 对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用\n\n\n# 2.7.2 绑定style样式\n\n 1. :style=\"[a,b]\"其中a、b是样式对象\n 2. :style=\"{fontsize: xxx}\"其中 xxx 是动态值\n\n\n# 2.8 条件渲染\n\n\n# 2.8.1 v-if\n\n 1. 写法 跟 if else 语法类似\n    1. v-if=\"表达式\"\n    2. v-else-if=\"表达式\"\n    3. `v-else\n 2. 适用于：切换频率较低的场景，因为不展示的dom元素直接被移除\n 3. 注意：v-if可以和v-else-if v-else一起使用，但要求结构不能被打断\n\n\n# 2.8.2 v-show\n\n 1. 写法：v-show=\"表达式\"\n 2. 适用于：切换频率较高的场景\n 3. 特点：不展示的dom元素未被移除，仅仅是使用样式隐藏掉display: none\n 4. 使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到template标签不影响结构，页面html中不会有此标签，但只能配合v-if，不能配合v-sho\n\n\n# 2.9 列表渲染\n\n\n# 2.9.1 v-for指令\n\n 1. 用于展示列表数据\n 2. 语法：<li v-for=\"(item, index) of items\" :key=\"index\">，这里key可以是index，更好的是遍历对象的唯一标识\n 3. 可遍历：数组、对象、字符串（用的少）、指定次数（用的少）\n\n\n# 2.9.2 key的作用与原理\n\n\n\n 1. 虚拟dom中key的作用：key是虚拟dom中对象的标识，当数据发生变化时，vue会根据新数据生成新的虚拟dom，随后vue进行新虚拟dom与旧虚拟dom的差异比较\n 2. 对比规则\n    1. 旧虚拟dom中找到了与新虚拟dom相同的key\n       1. 若虚拟dom中内容没变, 直接使用之前的真实dom\n       2. 若虚拟dom中内容变了, 则生成新的真实dom，随后替换掉页面中之前的真实dom\n    2. 旧虚拟dom中未找到与新虚拟dom相同的key 创建新的真实dom，随后渲染到到页面\n 3. 用index作为key可能会引发的问题\n    1. 若对数据进行逆序添加、逆序删除等破坏顺序操作，会产生没有必要的真实dom更新 ==> 界面效果没问题，但效率低\n    2. 若结构中还包含输入类的dom：会产生错误dom更新 ==> 界面有问题\n 4. 开发中如何选择key\n    1. 最好使用每条数据的唯一标识作为key，比如 id、手机号、身份证号、学号等唯一值\n    2. 如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表，使用index作为key是没有问题的\n 5. 如果代码没写key，vue就会自动把遍历的index作为key输入\n\n\n# 2.9.2 列表过滤\n\n 1. v-model来双向绑定用户过滤的信息\n 2. watch实现\n    1. 需要一个新的数组存储过滤后的内容，否则数据越来越少\n    2. immediate: true上来就执行一次，这样过滤后的数组不需要初始给值。其核心原理是任意字符串.indexof(空字符串) = 0\n    3. array.filter((p)=>{ return p.indexof(val)})filter返回一个数组不改变原数组\n 3. computed实现\n\ncomputed:{\n    filpersons(){\n        return this.persons.filter((p)=>{\n            return p.name.indexof(this.keyword) !== -1\n        })\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2.9.3 列表排序\n\n 1. 先过滤再排序，在同时存在过滤和排序需求的时候，排序还是维护过滤后的数据\n\ncomputed:{\n    filpersons(){\n        const arr =  this.persons.filter((p)=>{\n            return p.name.indexof(this.keyword) !== -1\n        })\n        if(this.sorttype){\n            arr.sort((p1,p2)=>{\n                return this.sorttype === 1 ? p2.age-p1.age : p1.age-p2.age\n            })\n        }\n        return arr\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 2.10 内置指令\n\n\n# 2.10.1之前用过的\n\n 1. v-bind：单向绑定解析表达式，可简写为:\n 2. v-model:双向数据绑定\n 3. v-for:遍历数组 / 对象 / 字符串\n 4. v-on:绑定事件监听，可简写为@\n 5. v-show:条件渲染 (动态控制节点是否展示)\n 6. v-if:条件渲染（动态控制节点是否存存在）\n 7. v-else-if:条件渲染（动态控制节点是否存存在）\n 8. v-else:条件渲染（动态控制节点是否存存在）\n\n\n# 2.10.2 v-text\n\n 1. 作用：向其所在的节点中渲染文本内容\n 2. 与插值语法的区别：v-text会替换掉节点中的内容，{{xxx}}则不会\n 3. 不会解析数据里的html标签\n\n\n# 2.10.3 v-html\n\n 1. 作用：向指定节点中渲染包含html结构的内容\n 2. 与插值语法的区别：\n    1. v-html会替换掉节点中所有的内容，{{xxx}}则不会\n    2. v-html可以识别html结构\n 3. 严重注意v-html有安全性问题！！！\n    1. 在网站上动态渲染任意html是非常危险的，容易导致 xss 攻击\n    2. 一定要在可信的内容上使用v-html，永远不要用在用户提交的内容上！！！\n\n\n# 2.10.4 v-cloak\n\n 1. 没有值\n 2. 本质是一个特殊属性，vue实例创建完毕并接管容器后，会删掉v-cloak属性\n 3. 使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题\n\n\n# 2.10.5 v-once\n\n 1. v-once所在节点在初次动态渲染后，就视为静态内容了\n 2. 以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能\n\n\n# 2.10.6 v-pre\n\n 1. 跳过v-pre所在节点的编译过程\n 2. 可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译\n\n\n# 2.11 自定义指令\n\n 1. directives配置项\n\n// 局部指令\nnew vue({\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n  directives:{ \n    指令名:配置对象 \n  }   \n})\nnew vue({\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n  directives:{ \n    指令名:(element,binding){} \n  }   \n})\n// 全局指令\nvue.directive(指令名, 配置对象)\nvue.directive(指令名, 回调函数)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n 2. element就是dom元素\n 3. binding就是要绑定的对象，它包含以下属性：name、value、oldvalue、expression、arg、modifiers\n 4. 用函数的形式定义时指令执行时间\n    1. 指令与元素成功绑定时\n    2. 指令所在的模板被重新解析时\n 5. 配置对象中常用的三个回调函数\n    1. bind(element, binding)指令与元素成功绑定时调用\n    2. inserted(element, binding)指令所在元素被插入页面时调用\n    3. update(element, binding)指令所在模板结构被重新解析时调用\n 6. 指令定义时不加v-，但使用时要加v-\n 7. 指令名如果是多个单词，要使用kebab-case命名方式，不要用camelcase命名\n 8. 指令回调函数里的this都是window\n\n\n# 2.12 过滤器（vue3已移除）\n\n 1. 定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）\n 2. 注册过滤器：\n    1. vue.filter(name, callback)全局过滤器\n    2. new vue {filters: {}} 局部过滤器\n 3. 使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = \"xxx | 过滤器名\"\n 4. 过滤器可以接收额外参数，多个过滤器也可以串联\n 5. 并没有改变原本的数据，而是产生新的对应的数据",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"Vue组件化",frontmatter:{title:"Vue组件化",date:"2022-04-10T20:51:44.000Z",permalink:"/pages/ecec85/",categories:["《Vue》"],tags:["Vue"],author:{name:"年华惊风雨",link:"https://github.com/wsy425"}},regularPath:"/%E3%80%8AVue%E3%80%8B/10.%20Vue%E7%BB%84%E4%BB%B6%E5%8C%96.html",relativePath:"《Vue》/10. Vue组件化.md",key:"v-40aa029e",path:"/pages/ecec85/",headers:[{level:2,title:"3.1 组件化编程原理",slug:"_3-1-组件化编程原理",normalizedTitle:"3.1 组件化编程原理",charIndex:2},{level:3,title:"3.1.1 模块",slug:"_3-1-1-模块",normalizedTitle:"3.1.1 模块",charIndex:18},{level:3,title:"3.1.2 组件",slug:"_3-1-2-组件",normalizedTitle:"3.1.2 组件",charIndex:160},{level:2,title:"3.2 非单文件组件",slug:"_3-2-非单文件组件",normalizedTitle:"3.2 非单文件组件",charIndex:308},{level:3,title:"3.2.1 基本使用",slug:"_3-2-1-基本使用",normalizedTitle:"3.2.1 基本使用",charIndex:346},{level:3,title:"3.2.3 组件注意事项",slug:"_3-2-3-组件注意事项",normalizedTitle:"3.2.3 组件注意事项",charIndex:656},{level:4,title:"关于组件名",slug:"关于组件名",normalizedTitle:"关于组件名",charIndex:672},{level:4,title:"关于组件标签",slug:"关于组件标签",normalizedTitle:"关于组件标签",charIndex:926},{level:3,title:"3.2.4 VueComponent",slug:"_3-2-4-vuecomponent",normalizedTitle:"3.2.4 vuecomponent",charIndex:1132},{level:2,title:"3.3 单文件组件",slug:"_3-3-单文件组件",normalizedTitle:"3.3 单文件组件",charIndex:1711},{level:3,title:"3.3.1 vue文件组成",slug:"_3-3-1-vue文件组成",normalizedTitle:"3.3.1 vue文件组成",charIndex:1725},{level:3,title:"3.3.2 基本使用",slug:"_3-3-2-基本使用",normalizedTitle:"3.3.2 基本使用",charIndex:2379},{level:2,title:"3.4 ref属性",slug:"_3-4-ref属性",normalizedTitle:"3.4 ref属性",charIndex:2852},{level:2,title:"3.5 props 配置项",slug:"_3-5-props-配置项",normalizedTitle:"3.5 props 配置项",charIndex:3039},{level:2,title:"3.6 mixin 混入",slug:"_3-6-mixin-混入",normalizedTitle:"3.6 mixin 混入",charIndex:3503},{level:2,title:"3.7 plugin 插件",slug:"_3-7-plugin-插件",normalizedTitle:"3.7 plugin 插件",charIndex:3780}],headersStr:"3.1 组件化编程原理 3.1.1 模块 3.1.2 组件 3.2 非单文件组件 3.2.1 基本使用 3.2.3 组件注意事项 关于组件名 关于组件标签 3.2.4 VueComponent 3.3 单文件组件 3.3.1 vue文件组成 3.3.2 基本使用 3.4 ref属性 3.5 props 配置项 3.6 mixin 混入 3.7 plugin 插件",content:"# 3.1 组件化编程原理\n\n\n# 3.1.1 模块\n\n 1. 理解：向外提供特定功能的 js 程序，一般就是一个 js 文件\n 2. 为什么：js 文件很多很复杂\n 3. 作用：复用、简化 js 的编写，提高 js 运行效率\n 4. 模块化：当应用中的 js 都以模块来编写的，那这个应用就是一个模块化的应用\n\n\n# 3.1.2 组件\n\n 1. 定义：用来实现局部功能的代码和资源的集合（html/css/js/image…）\n 2. 为什么：一个界面的功能很复杂\n 3. 作用：复用编码，简化项目编码，提高运行效率\n 4. 组件化：当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用\n\n\n# 3.2 非单文件组件\n\n非单文件组件：一个文件中包含有 n 个组件\n\n\n# 3.2.1 基本使用\n\n 1. 定义组件 使用Vue.extend(options)创建，其中options和new Vue(options)时传入的options几乎一样，但也有点区别\n    1. el不要写，因为最终所有的组件都要经过一个vm的管理，由vm中的el才决定服务哪个容器\n    2. data必须写成函数，避免组件被复用时，数据存在引用关系\n 2. 注册组件\n    1. 局部注册：new Vue()的时候options传入components选项\n    2. 全局注册：Vue.component('组件名',组件)\n 3. 使用组件：编写组件标签如<school></school>\n\n\n# 3.2.3 组件注意事项\n\n# 关于组件名\n\n 1. 一个单词组成\n    1. 第一种写法（首字母小写）：school\n    2. 第二种写法（首字母大写）：School\n 2. 多个单词组成\n    1. 第一种写法（kebab-case 命名）：my-school\n    2. 第二种写法（CamelCase 命名）：MySchool（需要Vue脚手架支持）\n 3. 其他\n    1. 组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行\n    2. 可以使用name配置项指定组件在开发者工具中呈现的名字\n\n# 关于组件标签\n\n 1. 第一种写法：<school></school>\n 2. 第二种写法：<school/>（需要Vue脚手架支持）\n 3. 备注：不使用脚手架时，<school/>会导致后续组件不能渲染\n 4. 一个简写方式：const school = Vue.extend(options)可简写为const school = options，因为父组件components引入的时候会自动创建\n\n\n# 3.2.4 VueComponent\n\n 1. school 组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，而是Vue.extend()生成的\n 2. 我们只需要写<school/>或<school></school>，Vue 解析时会帮我们创建 school 组件的实例对象，即Vue帮我们执行的new VueComponent(options)\n 3. 每次调用Vue.extend，返回的都是一个全新的VueComponent，即不同组件是不同的对象\n 4. 关于 this 指向\n    1. 组件配置中data函数、methods中的函数、watch中的函数、computed中的函数 它们的 this 均是 VueComponent实例对象\n    2. new Vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的 this 均是 Vue实例对象\n 5. VueComponent的实例对象，以后简称vc（组件实例对象）Vue的实例对象，以后简称vm\n 6. 一个重要的内置关系：VueComponent.prototype.__proto__ === Vue.prototype,让组件实例对象vc可以访问到 Vue原型上的属性、方法\n\n\n# 3.3 单文件组件\n\n\n# 3.3.1 vue文件组成\n\n// 模板页面\n<template>\n    <div id='Demo'>\n        <h2>学校名称：{{name}}</h2>\n        <h2>学校地址：{{address}}</h2>\n        <button @click=\"showName\">点我提示学校名</button>\n    </div>\n</template>\n// JS模块对象\n<script>\n    export default {\n        name:'School',\n        data() {\n            return {\n                name:'UESTC',\n                address:'成都'\n            }\n        },\n        methods: {\n            showName(){\n                alert(this.name)\n            }\n        },\n    }\n<\/script>\n// 样式\n<style>\n    #Demo{\n        background: orange;\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 3.3.2 基本使用\n\n 1. 引入组件\n 2. 映射成标签\n 3. 使用组件标签\n\n<template>\n    <div>\n        \x3c!--使用组件标签--\x3e\n        <School></School>\n        <Student></Student>\n    </div>\n</template>\n\n<script>\n    // 引入组件\n    import School from './School.vue'\n    import Student from './Student.vue'\n\n    export default {\n        name:'App',\n        // 映射成标签\n        components:{\n            School,\n            Student\n        }\n    }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 3.4 ref属性\n\n 1. ref被用来给元素或子组件注册引用信息（id的替代者）\n 2. 应用在html标签上获取的是真实DOM元素，应用在组件标签上获取的是组件实例对象vc\n 3. 使用方式\n    1. 打标识：<h1 ref=\"xxx\"></h1>或<School ref=\"xxx\"></School>\n    2. 获取：this.$refs.xxx\n\n\n# 3.5 props 配置项\n\n 1. props让组件接收外部传过来的数据\n 2. 传递数据<Demo name=\"xxx\" :age=\"18\"/>这里age前加:，通过v-bind使得里面的18是数字\n 3. 接收数据\n    1. 第一种方式（只接收）props:['name', 'age']\n    2. 第二种方式（限制类型）props:{name:String, age:Number}\n    3. 第三种方式（限制类型、限制必要性、指定默认值\n\nprops: {\n    name: {\n        type: String,\t // 类型\n        required: true,// 必要性\n        default: 'cess'// 默认值\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 4. props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中，然后去修改data中的数据\n\n\n# 3.6 mixin 混入\n\n 1. 功能：可以把多个组件共用的配置提取成一个混入对象\n 2. 使用方式\n    1. 定义混入\n    2. 使用混入\n       1. 全局混入Vue.mixin(xxx)\n       2. 局部混入mixins:['xxx']\n\nconst mixin = {\n    data() {....},\n    methods: {....}\n    ....\n}\n\n\n1\n2\n3\n4\n5\n\n 3. 组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”，在发生冲突时以组件优先，但生命周期全都执行\n\n\n# 3.7 plugin 插件\n\n 1. 功能：用于增强Vue\n 2. 本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据\n 3. 定义插件（见下 src/plugin.js）\n\n\n\n\n1\n\n 4. 使用插件：Vue.use()",normalizedContent:"# 3.1 组件化编程原理\n\n\n# 3.1.1 模块\n\n 1. 理解：向外提供特定功能的 js 程序，一般就是一个 js 文件\n 2. 为什么：js 文件很多很复杂\n 3. 作用：复用、简化 js 的编写，提高 js 运行效率\n 4. 模块化：当应用中的 js 都以模块来编写的，那这个应用就是一个模块化的应用\n\n\n# 3.1.2 组件\n\n 1. 定义：用来实现局部功能的代码和资源的集合（html/css/js/image…）\n 2. 为什么：一个界面的功能很复杂\n 3. 作用：复用编码，简化项目编码，提高运行效率\n 4. 组件化：当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用\n\n\n# 3.2 非单文件组件\n\n非单文件组件：一个文件中包含有 n 个组件\n\n\n# 3.2.1 基本使用\n\n 1. 定义组件 使用vue.extend(options)创建，其中options和new vue(options)时传入的options几乎一样，但也有点区别\n    1. el不要写，因为最终所有的组件都要经过一个vm的管理，由vm中的el才决定服务哪个容器\n    2. data必须写成函数，避免组件被复用时，数据存在引用关系\n 2. 注册组件\n    1. 局部注册：new vue()的时候options传入components选项\n    2. 全局注册：vue.component('组件名',组件)\n 3. 使用组件：编写组件标签如<school></school>\n\n\n# 3.2.3 组件注意事项\n\n# 关于组件名\n\n 1. 一个单词组成\n    1. 第一种写法（首字母小写）：school\n    2. 第二种写法（首字母大写）：school\n 2. 多个单词组成\n    1. 第一种写法（kebab-case 命名）：my-school\n    2. 第二种写法（camelcase 命名）：myschool（需要vue脚手架支持）\n 3. 其他\n    1. 组件名尽可能回避html中已有的元素名称，例如：h2、h2都不行\n    2. 可以使用name配置项指定组件在开发者工具中呈现的名字\n\n# 关于组件标签\n\n 1. 第一种写法：<school></school>\n 2. 第二种写法：<school/>（需要vue脚手架支持）\n 3. 备注：不使用脚手架时，<school/>会导致后续组件不能渲染\n 4. 一个简写方式：const school = vue.extend(options)可简写为const school = options，因为父组件components引入的时候会自动创建\n\n\n# 3.2.4 vuecomponent\n\n 1. school 组件本质是一个名为vuecomponent的构造函数，且不是程序员定义的，而是vue.extend()生成的\n 2. 我们只需要写<school/>或<school></school>，vue 解析时会帮我们创建 school 组件的实例对象，即vue帮我们执行的new vuecomponent(options)\n 3. 每次调用vue.extend，返回的都是一个全新的vuecomponent，即不同组件是不同的对象\n 4. 关于 this 指向\n    1. 组件配置中data函数、methods中的函数、watch中的函数、computed中的函数 它们的 this 均是 vuecomponent实例对象\n    2. new vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的 this 均是 vue实例对象\n 5. vuecomponent的实例对象，以后简称vc（组件实例对象）vue的实例对象，以后简称vm\n 6. 一个重要的内置关系：vuecomponent.prototype.__proto__ === vue.prototype,让组件实例对象vc可以访问到 vue原型上的属性、方法\n\n\n# 3.3 单文件组件\n\n\n# 3.3.1 vue文件组成\n\n// 模板页面\n<template>\n    <div id='demo'>\n        <h2>学校名称：{{name}}</h2>\n        <h2>学校地址：{{address}}</h2>\n        <button @click=\"showname\">点我提示学校名</button>\n    </div>\n</template>\n// js模块对象\n<script>\n    export default {\n        name:'school',\n        data() {\n            return {\n                name:'uestc',\n                address:'成都'\n            }\n        },\n        methods: {\n            showname(){\n                alert(this.name)\n            }\n        },\n    }\n<\/script>\n// 样式\n<style>\n    #demo{\n        background: orange;\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 3.3.2 基本使用\n\n 1. 引入组件\n 2. 映射成标签\n 3. 使用组件标签\n\n<template>\n    <div>\n        \x3c!--使用组件标签--\x3e\n        <school></school>\n        <student></student>\n    </div>\n</template>\n\n<script>\n    // 引入组件\n    import school from './school.vue'\n    import student from './student.vue'\n\n    export default {\n        name:'app',\n        // 映射成标签\n        components:{\n            school,\n            student\n        }\n    }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 3.4 ref属性\n\n 1. ref被用来给元素或子组件注册引用信息（id的替代者）\n 2. 应用在html标签上获取的是真实dom元素，应用在组件标签上获取的是组件实例对象vc\n 3. 使用方式\n    1. 打标识：<h1 ref=\"xxx\"></h1>或<school ref=\"xxx\"></school>\n    2. 获取：this.$refs.xxx\n\n\n# 3.5 props 配置项\n\n 1. props让组件接收外部传过来的数据\n 2. 传递数据<demo name=\"xxx\" :age=\"18\"/>这里age前加:，通过v-bind使得里面的18是数字\n 3. 接收数据\n    1. 第一种方式（只接收）props:['name', 'age']\n    2. 第二种方式（限制类型）props:{name:string, age:number}\n    3. 第三种方式（限制类型、限制必要性、指定默认值\n\nprops: {\n    name: {\n        type: string,\t // 类型\n        required: true,// 必要性\n        default: 'cess'// 默认值\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 4. props是只读的，vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中，然后去修改data中的数据\n\n\n# 3.6 mixin 混入\n\n 1. 功能：可以把多个组件共用的配置提取成一个混入对象\n 2. 使用方式\n    1. 定义混入\n    2. 使用混入\n       1. 全局混入vue.mixin(xxx)\n       2. 局部混入mixins:['xxx']\n\nconst mixin = {\n    data() {....},\n    methods: {....}\n    ....\n}\n\n\n1\n2\n3\n4\n5\n\n 3. 组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”，在发生冲突时以组件优先，但生命周期全都执行\n\n\n# 3.7 plugin 插件\n\n 1. 功能：用于增强vue\n 2. 本质：包含install方法的一个对象，install的第一个参数是vue，第二个以后的参数是插件使用者传递的数据\n 3. 定义插件（见下 src/plugin.js）\n\n\n\n\n1\n\n 4. 使用插件：vue.use()",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"Vue CLI",frontmatter:{title:"Vue CLI",date:"2022-04-10T20:52:37.000Z",permalink:"/pages/9c8d2a/",categories:["《Vue》"],tags:["Vue"],author:{name:"年华惊风雨",link:"https://github.com/wsy425"}},regularPath:"/%E3%80%8AVue%E3%80%8B/15.%20Vue%20CLI.html",relativePath:"《Vue》/15. Vue CLI.md",key:"v-6e91eb02",path:"/pages/9c8d2a/",headers:[{level:2,title:"4.1 脚手架文件结构",slug:"_4-1-脚手架文件结构",normalizedTitle:"4.1 脚手架文件结构",charIndex:2},{level:2,title:"4.2 render函数",slug:"_4-2-render函数",normalizedTitle:"4.2 render函数",charIndex:439},{level:2,title:"4.3 vue.config.js 配置文件",slug:"_4-3-vue-config-js-配置文件",normalizedTitle:"4.3 vue.config.js 配置文件",charIndex:834},{level:2,title:"4.4 scoped样式",slug:"_4-4-scoped样式",normalizedTitle:"4.4 scoped样式",charIndex:909},{level:2,title:"4.5 Vue脚手架配置代理",slug:"_4-5-vue脚手架配置代理",normalizedTitle:"4.5 vue脚手架配置代理",charIndex:970},{level:3,title:"4.5.1 方法一",slug:"_4-5-1-方法一",normalizedTitle:"4.5.1 方法一",charIndex:1138},{level:3,title:"4.5.2 方法二",slug:"_4-5-2-方法二",normalizedTitle:"4.5.2 方法二",charIndex:1359}],headersStr:"4.1 脚手架文件结构 4.2 render函数 4.3 vue.config.js 配置文件 4.4 scoped样式 4.5 Vue脚手架配置代理 4.5.1 方法一 4.5.2 方法二",content:"# 4.1 脚手架文件结构\n\n.文件目录\n├── node_modules \n├── public\n│   ├── favicon.ico: 页签图标\n│   └── index.html: 主页面\n├── src\n│   ├── assets: 存放静态资源\n│   │   └── logo.png\n│   │── component: 存放组件\n│   │   └── HelloWorld.vue\n│   │── App.vue: 汇总所有组件\n│   └── main.js: 入口文件\n├── .gitignore: git版本管制忽略的配置\n├── babel.config.js: babel的配置文件\n├── package.json: 应用包配置文件 \n├── README.md: 应用描述文件\n└── package-lock.json: 包版本控制文件\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 4.2 render函数\n\n因为 vue.runtime.xxx.js 没有模板解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数去指定具体内容\n\nimport Vue from 'vue'\nimport App from './App.vue'                 \nVue.config.productionTip = false\nnew Vue({\n  el:'#app',\n  // render函数功能：将App组件放入容器中\n  // 简写形式\n  render: h => h(App),\n  // 完整形式\n  render(createElement){\n    return createElement(App)\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 4.3 vue.config.js 配置文件\n\n使用vue.config.js可以对脚手架进行个性化定制，和package.json同级目录\n\n\n# 4.4 scoped样式\n\n 1. 作用：让样式在局部生效，防止冲突\n 2. 写法：<style scoped>\n\n\n# 4.5 Vue脚手架配置代理\n\nvue.config.js 是一个可选的配置文件，如果项目的 (和 package.json 同级的) 根目录中存在这个文件，那么它会被 @vue/cli-service 自动加载。你也可以使用 package.json 中的 vue 字段，但是注意这种写法需要你严格遵照 JSON 的格式来写\n\n\n# 4.5.1 方法一\n\nmodule.exports = {\n  devServer:{\n    proxy:\"http://localhost:5000\"\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n 1. 优点：配置简单，请求资源时直接发给前端（8080）即可\n 2. 缺点：不能配置多个代理，不能灵活的控制请求是否走代理\n 3. 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，才会将请求会转发给服务器 （优先匹配前端资源）\n\n\n# 4.5.2 方法二\n\nmodule.exports = {\n\tdevServer: {\n      proxy: {\n      '/api1': {\t\t\t\t\t\t\t// 匹配所有以 '/api1'开头的请求路径\n        target: 'http://localhost:5000',\t// 代理目标的基础路径\n        pathRewrite: {'^/api1':''},\t\t\t// 代理往后端服务器的请求去掉 /api1 前缀\n        ws: true,\t\t\t\t\t\t\t// WebSocket\n        changeOrigin: true,\n      }\n    }\n  }\n}\n/*\n   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000\n   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080\n   changeOrigin默认值为true\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 1. 优点：可以配置多个代理，且可以灵活的控制请求是否走代理\n 2. 缺点：配置略微繁琐，请求资源时必须加前缀",normalizedContent:"# 4.1 脚手架文件结构\n\n.文件目录\n├── node_modules \n├── public\n│   ├── favicon.ico: 页签图标\n│   └── index.html: 主页面\n├── src\n│   ├── assets: 存放静态资源\n│   │   └── logo.png\n│   │── component: 存放组件\n│   │   └── helloworld.vue\n│   │── app.vue: 汇总所有组件\n│   └── main.js: 入口文件\n├── .gitignore: git版本管制忽略的配置\n├── babel.config.js: babel的配置文件\n├── package.json: 应用包配置文件 \n├── readme.md: 应用描述文件\n└── package-lock.json: 包版本控制文件\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 4.2 render函数\n\n因为 vue.runtime.xxx.js 没有模板解析器，所以不能使用template配置项，需要使用render函数接收到的createelement函数去指定具体内容\n\nimport vue from 'vue'\nimport app from './app.vue'                 \nvue.config.productiontip = false\nnew vue({\n  el:'#app',\n  // render函数功能：将app组件放入容器中\n  // 简写形式\n  render: h => h(app),\n  // 完整形式\n  render(createelement){\n    return createelement(app)\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 4.3 vue.config.js 配置文件\n\n使用vue.config.js可以对脚手架进行个性化定制，和package.json同级目录\n\n\n# 4.4 scoped样式\n\n 1. 作用：让样式在局部生效，防止冲突\n 2. 写法：<style scoped>\n\n\n# 4.5 vue脚手架配置代理\n\nvue.config.js 是一个可选的配置文件，如果项目的 (和 package.json 同级的) 根目录中存在这个文件，那么它会被 @vue/cli-service 自动加载。你也可以使用 package.json 中的 vue 字段，但是注意这种写法需要你严格遵照 json 的格式来写\n\n\n# 4.5.1 方法一\n\nmodule.exports = {\n  devserver:{\n    proxy:\"http://localhost:5000\"\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n 1. 优点：配置简单，请求资源时直接发给前端（8080）即可\n 2. 缺点：不能配置多个代理，不能灵活的控制请求是否走代理\n 3. 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，才会将请求会转发给服务器 （优先匹配前端资源）\n\n\n# 4.5.2 方法二\n\nmodule.exports = {\n\tdevserver: {\n      proxy: {\n      '/api1': {\t\t\t\t\t\t\t// 匹配所有以 '/api1'开头的请求路径\n        target: 'http://localhost:5000',\t// 代理目标的基础路径\n        pathrewrite: {'^/api1':''},\t\t\t// 代理往后端服务器的请求去掉 /api1 前缀\n        ws: true,\t\t\t\t\t\t\t// websocket\n        changeorigin: true,\n      }\n    }\n  }\n}\n/*\n   changeorigin设置为true时，服务器收到的请求头中的host为：localhost:5000\n   changeorigin设置为false时，服务器收到的请求头中的host为：localhost:8080\n   changeorigin默认值为true\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 1. 优点：可以配置多个代理，且可以灵活的控制请求是否走代理\n 2. 缺点：配置略微繁琐，请求资源时必须加前缀",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"Vuex",frontmatter:{title:"Vuex",date:"2022-06-09T16:21:37.000Z",permalink:"/pages/ea2c16/",categories:["《Vue》"],tags:[null]},regularPath:"/%E3%80%8AVue%E3%80%8B/20.%20Vuex.html",relativePath:"《Vue》/20. Vuex.md",key:"v-1d5af834",path:"/pages/ea2c16/",headers:[{level:2,title:"5.1 Vuex概述",slug:"_5-1-vuex概述",normalizedTitle:"5.1 vuex概述",charIndex:2},{level:3,title:"5.1.1 Vuex概念",slug:"_5-1-1-vuex概念",normalizedTitle:"5.1.1 vuex概念",charIndex:17},{level:3,title:"5.1.2 Vuex使用场景",slug:"_5-1-2-vuex使用场景",normalizedTitle:"5.1.2 vuex使用场景",charIndex:128},{level:3,title:"5.1.3 Vuex工作原理",slug:"_5-1-3-vuex工作原理",normalizedTitle:"5.1.3 vuex工作原理",charIndex:186},{level:2,title:"5.2 搭建Vuex环境",slug:"_5-2-搭建vuex环境",normalizedTitle:"5.2 搭建vuex环境",charIndex:207},{level:2,title:"5.3 Vuex基本使用",slug:"_5-3-vuex基本使用",normalizedTitle:"5.3 vuex基本使用",charIndex:956},{level:2,title:"5.4 getters 配置项",slug:"_5-4-getters-配置项",normalizedTitle:"5.4 getters 配置项",charIndex:2377},{level:2,title:"5.5 四个map方法",slug:"_5-5-四个map方法",normalizedTitle:"5.5 四个map方法",charIndex:2678},{level:3,title:"5.5.1 mapState",slug:"_5-5-1-mapstate",normalizedTitle:"5.5.1 mapstate",charIndex:2694},{level:3,title:"5.5.2 mapGetters",slug:"_5-5-2-mapgetters",normalizedTitle:"5.5.2 mapgetters",charIndex:2978},{level:3,title:"5.5.3 mapActions",slug:"_5-5-3-mapactions",normalizedTitle:"5.5.3 mapactions",charIndex:3207},{level:3,title:"5.5.4 mapMutations",slug:"_5-5-4-mapmutations",normalizedTitle:"5.5.4 mapmutations",charIndex:3524},{level:2,title:"5.6 Vuex模块化",slug:"_5-6-vuex模块化",normalizedTitle:"5.6 vuex模块化",charIndex:3880}],headersStr:"5.1 Vuex概述 5.1.1 Vuex概念 5.1.2 Vuex使用场景 5.1.3 Vuex工作原理 5.2 搭建Vuex环境 5.3 Vuex基本使用 5.4 getters 配置项 5.5 四个map方法 5.5.1 mapState 5.5.2 mapGetters 5.5.3 mapActions 5.5.4 mapMutations 5.6 Vuex模块化",content:"# 5.1 Vuex概述\n\n\n# 5.1.1 Vuex概念\n\n 1. 概念：专门在Vue中实现集中式状态（数据）**管理的一个Vue插件，对Vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信\n\n\n# 5.1.2 Vuex使用场景\n\n 1. 多个组件依赖于同一状态\n 2. 来自不同组件的行为需要变更同一状态\n\n\n# 5.1.3 Vuex工作原理\n\n\n\n\n# 5.2 搭建Vuex环境\n\n 1. 下载安装Vuex npm i vuex\n 2. 创建src/store/index.js该文件用于创建Vuex中最为核心的store\n\nimport Vue from 'vue'\nimport Vuex from 'vuex'\t// 引入Vuex\n\nVue.use(Vuex)\t// 应用Vuex插件\n\nconst actions = {}\t\t// 准备actions——用于响应组件中的动作\nconst mutations = {}\t// 准备mutations——用于操作数据（state）\nconst state = {}\t\t\t// 准备state——用于存储数据\n\n// 创建并暴露store\nexport default new Vuex.Store({\n\tactions,\n\tmutations,\n\tstate,\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n 3. 在src/main.js中创建vm时传入store配置项\n\nimport Vue from 'vue'\nimport App from './App.vue'\nimport store from './store'\t// 引入store\n\nVue.config.productionTip = false\n\nnew Vue({\n\tel: '#app',\n\trender: h => h(App),\n\tstore,\t\t\t\t\t\t\t\t\t\t// 配置项添加store\n\tbeforeCreate() {\n\t\tVue.prototype.$bus = this\n\t}\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 5.3 Vuex基本使用\n\n 1. 初始化数据state，配置actions、mutations，操作文件store.js\n 2. 组件中读取vuex中的数据$store.state.数据\n 3. 组件中修改vuex中的数据$store.dispatch('action中的方法名',数据) 或$store.commit('mutations中的方法名',数据)\n 4. 若没有网络请求或其他业务逻辑，组件中也可越过actions，即不写dispatch，直接编写commit\n 5. actions一般写小写，mutations一般大写\n\n//src/components/Count.vue\n// 数据使用\n$store.state.sum\n// 修改数据\nmethods: {\n    increment(){\n        this.$store.commit('JIA',this.n)\n    },\n    decrement(){\n        this.$store.commit('JIAN',this.n)\n    },\n    incrementOdd(){\n        this.$store.dispatch('jiaOdd',this.n)\n    },\n    incrementWait(){\n        this.$store.dispatch('jiaWait',this.n)\n    },\n}\n//`src/store/index.js`内容\nconst actions = {\n\tjiaOdd(context,value){\t// context 相当于精简版的 $store，是一种上下文对象\n\t\tconsole.log('actions中的jiaOdd被调用了')\n\t\tif(context.state.sum % 2){\n\t\t\tcontext.commit('JIA',value)\n\t\t}\n\t},\n\tjiaWait(context,value){\n\t\tconsole.log('actions中的jiaWait被调用了')\n\t\tsetTimeout(()=>{\n\t\t\tcontext.commit('JIA',value)\n\t\t},500)\n\t}\n}\n// 一般都大写\nconst mutations = {\n\tJIA(state,value){\n\t\tconsole.log('mutations中的JIA被调用了')\n\t\tstate.sum += value\n\t},\n\tJIAN(state,value){\n\t\tconsole.log('mutations中的JIAN被调用了')\n\t\tstate.sum -= value\n\t}\n}\nconst state = {\n\tsum:0 //当前的和\n}\n\n// 创建并暴露store\nexport default new Vuex.Store({\n\tactions,\n\tmutations,\n\tstate,\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 5.4 getters 配置项\n\n 1. 概念：当state中的数据需要经过加工后再使用时，可以使用getters加工，相当于全局计算属性\n 2. 在store.js中追加getters配置\n 3. 组件中读取数据$store.getters.bigSum\n\n......\nconst getters = {\n\tbigSum(state){\n\t\treturn state.sum * 10\n\t}\n}\n\n// 创建并暴露store\nexport default new Vuex.Store({\n\t......\n\tgetters\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 5.5 四个map方法\n\n\n# 5.5.1 mapState\n\n 1. 用于帮助映射state中的数据为计算属性\n\ncomputed: {\n  \t// 借助mapState生成计算属性：sum、school、subject（对象写法一）\n  \t...mapState({sum:'sum',school:'school',subject:'subject'}),\n\n  \t// 借助mapState生成计算属性：sum、school、subject（数组写法二）\n  \t...mapState(['sum','school','subject']),\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 5.5.2 mapGetters\n\n 1. 用于帮助映射getters中的数据为计算属性\n\ncomputed: {\n    //借助mapGetters生成计算属性：bigSum（对象写法一）\n    ...mapGetters({bigSum:'bigSum'}),\n\n    //借助mapGetters生成计算属性：bigSum（数组写法二）\n    ...mapGetters(['bigSum'])\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 5.5.3 mapActions\n\n 1. 用于帮助生成与actions对话的方法，即包含$store.dispatch(xxx)的函数\n\nmethods:{\n    //靠mapActions生成：incrementOdd、incrementWait（对象形式）\n    ...mapActions({incrementOdd:'jiaOdd',incrementWait:'jiaWait'})\n\n    //靠mapActions生成：incrementOdd、incrementWait（数组形式）\n    ...mapActions(['jiaOdd','jiaWait'])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 5.5.4 mapMutations\n\n 1. 用于帮助生成与mutations对话的方法，即包含$store.commit(xxx)的函数\n\nmethods:{\n    //靠mapActions生成：increment、decrement（对象形式）\n    ...mapMutations({increment:'JIA',decrement:'JIAN'}),\n    \n    //靠mapMutations生成：JIA、JIAN（对象形式）\n    ...mapMutations(['JIA','JIAN']),\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 2. 注意：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象\n\n\n# 5.6 Vuex模块化\n\n 1. 目的：让代码更好维护，让多种数据分类更加明确\n 2. 修改store.js：为了解决不同模块命名冲突的问题，将不同模块的namespaced: true，之后在不同页面中引入getter``actions``mutations时，需要加上所属的模块名\n\nconst countAbout = {\n  namespaced: true,\t// 开启命名空间\n  state: {x:1},\n  mutations: { ... },\n  actions: { ... },\n  getters: {\n    bigSum(state){ return state.sum * 10 }\n  }\n}\n\nconst personAbout = {\n  namespaced: true,\t// 开启命名空间\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    countAbout,\n    personAbout\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n 3. 开启命名空间后，组件中读取state数据\n\n// 方式一：自己直接读取\nthis.$store.state.personAbout.list\n// 方式二：借助mapState读取：\n...mapState('countAbout',['sum','school','subject']),\n\n\n1\n2\n3\n4\n\n 4. 开启命名空间后，组件中读取getters数据\n\n//方式一：自己直接读取\nthis.$store.getters['personAbout/firstPersonName']\n//方式二：借助mapGetters读取：\n...mapGetters('countAbout',['bigSum'])\n\n\n1\n2\n3\n4\n\n 5. 开启命名空间后，组件中调用dispatch\n\n//方式一：自己直接dispatch\nthis.$store.dispatch('personAbout/addPersonWang',person)\n//方式二：借助mapActions：\n...mapActions('countAbout',{incrementOdd:'jiaOdd',incrementWait:'jiaWait'})\n\n\n1\n2\n3\n4\n\n 6. 开启命名空间后，组件中调用commit\n\n//方式一：自己直接commit\nthis.$store.commit('personAbout/ADD_PERSON',person)\n//方式二：借助mapMutations：\n...mapMutations('countAbout',{increment:'JIA',decrement:'JIAN'}),\n\n\n1\n2\n3\n4\n",normalizedContent:"# 5.1 vuex概述\n\n\n# 5.1.1 vuex概念\n\n 1. 概念：专门在vue中实现集中式状态（数据）**管理的一个vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信\n\n\n# 5.1.2 vuex使用场景\n\n 1. 多个组件依赖于同一状态\n 2. 来自不同组件的行为需要变更同一状态\n\n\n# 5.1.3 vuex工作原理\n\n\n\n\n# 5.2 搭建vuex环境\n\n 1. 下载安装vuex npm i vuex\n 2. 创建src/store/index.js该文件用于创建vuex中最为核心的store\n\nimport vue from 'vue'\nimport vuex from 'vuex'\t// 引入vuex\n\nvue.use(vuex)\t// 应用vuex插件\n\nconst actions = {}\t\t// 准备actions——用于响应组件中的动作\nconst mutations = {}\t// 准备mutations——用于操作数据（state）\nconst state = {}\t\t\t// 准备state——用于存储数据\n\n// 创建并暴露store\nexport default new vuex.store({\n\tactions,\n\tmutations,\n\tstate,\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n 3. 在src/main.js中创建vm时传入store配置项\n\nimport vue from 'vue'\nimport app from './app.vue'\nimport store from './store'\t// 引入store\n\nvue.config.productiontip = false\n\nnew vue({\n\tel: '#app',\n\trender: h => h(app),\n\tstore,\t\t\t\t\t\t\t\t\t\t// 配置项添加store\n\tbeforecreate() {\n\t\tvue.prototype.$bus = this\n\t}\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 5.3 vuex基本使用\n\n 1. 初始化数据state，配置actions、mutations，操作文件store.js\n 2. 组件中读取vuex中的数据$store.state.数据\n 3. 组件中修改vuex中的数据$store.dispatch('action中的方法名',数据) 或$store.commit('mutations中的方法名',数据)\n 4. 若没有网络请求或其他业务逻辑，组件中也可越过actions，即不写dispatch，直接编写commit\n 5. actions一般写小写，mutations一般大写\n\n//src/components/count.vue\n// 数据使用\n$store.state.sum\n// 修改数据\nmethods: {\n    increment(){\n        this.$store.commit('jia',this.n)\n    },\n    decrement(){\n        this.$store.commit('jian',this.n)\n    },\n    incrementodd(){\n        this.$store.dispatch('jiaodd',this.n)\n    },\n    incrementwait(){\n        this.$store.dispatch('jiawait',this.n)\n    },\n}\n//`src/store/index.js`内容\nconst actions = {\n\tjiaodd(context,value){\t// context 相当于精简版的 $store，是一种上下文对象\n\t\tconsole.log('actions中的jiaodd被调用了')\n\t\tif(context.state.sum % 2){\n\t\t\tcontext.commit('jia',value)\n\t\t}\n\t},\n\tjiawait(context,value){\n\t\tconsole.log('actions中的jiawait被调用了')\n\t\tsettimeout(()=>{\n\t\t\tcontext.commit('jia',value)\n\t\t},500)\n\t}\n}\n// 一般都大写\nconst mutations = {\n\tjia(state,value){\n\t\tconsole.log('mutations中的jia被调用了')\n\t\tstate.sum += value\n\t},\n\tjian(state,value){\n\t\tconsole.log('mutations中的jian被调用了')\n\t\tstate.sum -= value\n\t}\n}\nconst state = {\n\tsum:0 //当前的和\n}\n\n// 创建并暴露store\nexport default new vuex.store({\n\tactions,\n\tmutations,\n\tstate,\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 5.4 getters 配置项\n\n 1. 概念：当state中的数据需要经过加工后再使用时，可以使用getters加工，相当于全局计算属性\n 2. 在store.js中追加getters配置\n 3. 组件中读取数据$store.getters.bigsum\n\n......\nconst getters = {\n\tbigsum(state){\n\t\treturn state.sum * 10\n\t}\n}\n\n// 创建并暴露store\nexport default new vuex.store({\n\t......\n\tgetters\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 5.5 四个map方法\n\n\n# 5.5.1 mapstate\n\n 1. 用于帮助映射state中的数据为计算属性\n\ncomputed: {\n  \t// 借助mapstate生成计算属性：sum、school、subject（对象写法一）\n  \t...mapstate({sum:'sum',school:'school',subject:'subject'}),\n\n  \t// 借助mapstate生成计算属性：sum、school、subject（数组写法二）\n  \t...mapstate(['sum','school','subject']),\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 5.5.2 mapgetters\n\n 1. 用于帮助映射getters中的数据为计算属性\n\ncomputed: {\n    //借助mapgetters生成计算属性：bigsum（对象写法一）\n    ...mapgetters({bigsum:'bigsum'}),\n\n    //借助mapgetters生成计算属性：bigsum（数组写法二）\n    ...mapgetters(['bigsum'])\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 5.5.3 mapactions\n\n 1. 用于帮助生成与actions对话的方法，即包含$store.dispatch(xxx)的函数\n\nmethods:{\n    //靠mapactions生成：incrementodd、incrementwait（对象形式）\n    ...mapactions({incrementodd:'jiaodd',incrementwait:'jiawait'})\n\n    //靠mapactions生成：incrementodd、incrementwait（数组形式）\n    ...mapactions(['jiaodd','jiawait'])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 5.5.4 mapmutations\n\n 1. 用于帮助生成与mutations对话的方法，即包含$store.commit(xxx)的函数\n\nmethods:{\n    //靠mapactions生成：increment、decrement（对象形式）\n    ...mapmutations({increment:'jia',decrement:'jian'}),\n    \n    //靠mapmutations生成：jia、jian（对象形式）\n    ...mapmutations(['jia','jian']),\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 2. 注意：mapactions与mapmutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象\n\n\n# 5.6 vuex模块化\n\n 1. 目的：让代码更好维护，让多种数据分类更加明确\n 2. 修改store.js：为了解决不同模块命名冲突的问题，将不同模块的namespaced: true，之后在不同页面中引入getter``actions``mutations时，需要加上所属的模块名\n\nconst countabout = {\n  namespaced: true,\t// 开启命名空间\n  state: {x:1},\n  mutations: { ... },\n  actions: { ... },\n  getters: {\n    bigsum(state){ return state.sum * 10 }\n  }\n}\n\nconst personabout = {\n  namespaced: true,\t// 开启命名空间\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new vuex.store({\n  modules: {\n    countabout,\n    personabout\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n 3. 开启命名空间后，组件中读取state数据\n\n// 方式一：自己直接读取\nthis.$store.state.personabout.list\n// 方式二：借助mapstate读取：\n...mapstate('countabout',['sum','school','subject']),\n\n\n1\n2\n3\n4\n\n 4. 开启命名空间后，组件中读取getters数据\n\n//方式一：自己直接读取\nthis.$store.getters['personabout/firstpersonname']\n//方式二：借助mapgetters读取：\n...mapgetters('countabout',['bigsum'])\n\n\n1\n2\n3\n4\n\n 5. 开启命名空间后，组件中调用dispatch\n\n//方式一：自己直接dispatch\nthis.$store.dispatch('personabout/addpersonwang',person)\n//方式二：借助mapactions：\n...mapactions('countabout',{incrementodd:'jiaodd',incrementwait:'jiawait'})\n\n\n1\n2\n3\n4\n\n 6. 开启命名空间后，组件中调用commit\n\n//方式一：自己直接commit\nthis.$store.commit('personabout/add_person',person)\n//方式二：借助mapmutations：\n...mapmutations('countabout',{increment:'jia',decrement:'jian'}),\n\n\n1\n2\n3\n4\n",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"Vue Router",frontmatter:{title:"Vue Router",date:"2022-06-09T16:22:20.000Z",permalink:"/pages/2ab1b4/",categories:["《Vue》"],tags:[null]},regularPath:"/%E3%80%8AVue%E3%80%8B/25.%20Vue%20Router.html",relativePath:"《Vue》/25. Vue Router.md",key:"v-7001a452",path:"/pages/2ab1b4/",headers:[{level:2,title:"6.1 相关概念",slug:"_6-1-相关概念",normalizedTitle:"6.1 相关概念",charIndex:2},{level:3,title:"6.1.1 路由",slug:"_6-1-1-路由",normalizedTitle:"6.1.1 路由",charIndex:15},{level:3,title:"6.1.2 SPA应用",slug:"_6-1-2-spa应用",normalizedTitle:"6.1.2 spa应用",charIndex:312},{level:2,title:"6.2 基本路由",slug:"_6-2-基本路由",normalizedTitle:"6.2 基本路由",charIndex:443},{level:3,title:"6.2.1 基本路由使用",slug:"_6-2-1-基本路由使用",normalizedTitle:"6.2.1 基本路由使用",charIndex:456},{level:3,title:"6.2.2 注意事项",slug:"_6-2-2-注意事项",normalizedTitle:"6.2.2 注意事项",charIndex:1132},{level:2,title:"6.3 多级路由",slug:"_6-3-多级路由",normalizedTitle:"6.3 多级路由",charIndex:1306},{level:2,title:"6.4 路由传参",slug:"_6-4-路由传参",normalizedTitle:"6.4 路由传参",charIndex:1742},{level:3,title:"6.4.1 query参数",slug:"_6-4-1-query参数",normalizedTitle:"6.4.1 query参数",charIndex:1755},{level:3,title:"6.4.2 params参数",slug:"_6-4-2-params参数",normalizedTitle:"6.4.2 params参数",charIndex:2159},{level:3,title:"6.4.3 路由props配置",slug:"_6-4-3-路由props配置",normalizedTitle:"6.4.3 路由props配置",charIndex:2902},{level:2,title:"6.5 命名路由",slug:"_6-5-命名路由",normalizedTitle:"6.5 命名路由",charIndex:3396},{level:3,title:"6.5.1 命名路由使用",slug:"_6-5-1-命名路由使用",normalizedTitle:"6.5.1 命名路由使用",charIndex:3427},{level:2,title:"6.6 路由跳转replace模式",slug:"_6-6-路由跳转replace模式",normalizedTitle:"6.6 路由跳转replace模式",charIndex:4032},{level:2,title:"6.7 编程式路由导航",slug:"_6-7-编程式路由导航",normalizedTitle:"6.7 编程式路由导航",charIndex:4367},{level:2,title:"6.8 缓存路由组件",slug:"_6-8-缓存路由组件",normalizedTitle:"6.8 缓存路由组件",charIndex:4603},{level:2,title:"6.9 路由相关生命钩子",slug:"_6-9-路由相关生命钩子",normalizedTitle:"6.9 路由相关生命钩子",charIndex:4805},{level:2,title:"6.10 路由守卫",slug:"_6-10-路由守卫",normalizedTitle:"6.10 路由守卫",charIndex:4925},{level:3,title:"6.10.1 全局前置守卫",slug:"_6-10-1-全局前置守卫",normalizedTitle:"6.10.1 全局前置守卫",charIndex:4980},{level:3,title:"6.10.2 全局后置守卫",slug:"_6-10-2-全局后置守卫",normalizedTitle:"6.10.2 全局后置守卫",charIndex:5413},{level:3,title:"6.10.3 独享守卫",slug:"_6-10-3-独享守卫",normalizedTitle:"6.10.3 独享守卫",charIndex:5674},{level:3,title:"6.10.4 组件内守卫",slug:"_6-10-4-组件内守卫",normalizedTitle:"6.10.4 组件内守卫",charIndex:5919},{level:2,title:"6.11 路由器的工作模式",slug:"_6-11-路由器的工作模式",normalizedTitle:"6.11 路由器的工作模式",charIndex:6142},{level:3,title:"6.11.1 hash模式",slug:"_6-11-1-hash模式",normalizedTitle:"6.11.1 hash模式",charIndex:6228},{level:3,title:"6.11.2 history模式",slug:"_6-11-2-history模式",normalizedTitle:"6.11.2 history模式",charIndex:6319}],headersStr:"6.1 相关概念 6.1.1 路由 6.1.2 SPA应用 6.2 基本路由 6.2.1 基本路由使用 6.2.2 注意事项 6.3 多级路由 6.4 路由传参 6.4.1 query参数 6.4.2 params参数 6.4.3 路由props配置 6.5 命名路由 6.5.1 命名路由使用 6.6 路由跳转replace模式 6.7 编程式路由导航 6.8 缓存路由组件 6.9 路由相关生命钩子 6.10 路由守卫 6.10.1 全局前置守卫 6.10.2 全局后置守卫 6.10.3 独享守卫 6.10.4 组件内守卫 6.11 路由器的工作模式 6.11.1 hash模式 6.11.2 history模式",content:"# 6.1 相关概念\n\n\n# 6.1.1 路由\n\n 1. 路由概念\n    1. 一个路由就是一组映射关系（key - value）\n    2. key为路径，value可能是function或componen\n 2. 路由分类\n    1. 后端路由\n       1. 理解：value是function，用于处理客户端提交的请求\n       2. 工作过程：服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据\n    2. 前端路由\n       1. 理解：value是component，用于展示页面内容\n       2. 工作过程：当浏览器的路径改变时，对应的组件就会显示\n\n\n# 6.1.2 SPA应用\n\n 1. 单页Web应用（single page web application，SPA）\n 2. 整个应用只有一个完整的页面\n 3. 点击页面中的导航链接不会刷新页面，只会做页面的局部更新\n 4. 数据需要通过ajax请求获取\n\n\n# 6.2 基本路由\n\n\n# 6.2.1 基本路由使用\n\n 1. 安装vue-router，命令npm i vue-router\n 2. 应用插件Vue.use(VueRouter)\n 3. 编写router配置项\n\nimport VueRouter from 'vue-router'\t\t\t// 引入VueRouter\nimport About from '../components/About'\t// 路由组件\nimport Home from '../components/Home'\t\t// 路由组件\n\n// 创建router实例对象，去管理一组一组的路由规则\nconst router = new VueRouter({\n\troutes:[\n\t\t{\n\t\t\tpath:'/about',\n\t\t\tcomponent:About\n\t\t},\n\t\t{\n\t\t\tpath:'/home',\n\t\t\tcomponent:Home\n\t\t}\n\t]\n})\n\n//暴露router\nexport default router\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n 4. 实现切换<router-link></router-link>浏览器会被替换为a标签,active-class可配置高亮样式\n\n<router-link active-class=\"active\" to=\"/about\">About</router-link>\n\n\n1\n\n 5. 指定展示位<router-view></router-view>\n\n\n# 6.2.2 注意事项\n\n 1. 路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹\n 2. 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载\n 3. 每个组件都有自己的$route属性，里面存储着自己的路由信息\n 4. 整个应用只有一个router，可以通过组件的$router属性获取到\n\n\n# 6.3 多级路由\n\n 1. 配置路由规则，使用children配置项\n\nroutes:[\n\t{\n\t\tpath:'/about',\n\t\tcomponent:About,\n\t},\n\t{\n\t\tpath:'/home',\n\t\tcomponent:Home,\n\t\tchildren:[ \t\t\t\t\t// 通过children配置子级路由\n\t\t\t{\n\t\t\t\tpath:'news', \t\t// 此处一定不要带斜杠，写成 /news\n\t\t\t\tcomponent:News\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:'message',\t// 此处一定不要写成 /message\n\t\t\t\tcomponent:Message\n\t\t\t}\n\t\t]\n\t}\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n 2. 跳转（要写完整路径）<router-link to=\"/home/news\">News</router-link>\n\n\n# 6.4 路由传参\n\n\n# 6.4.1 query参数\n\n 1. 传递query参数\n\n\x3c!-- 跳转并携带query参数，to的字符串写法 --\x3e\n<router-link :to=\"`/home/message/detail?id=${m.id}&title=${m.title}`\">跳转</router-link>\n\t\t\t\t\n\x3c!-- 跳转并携带query参数，to的对象写法（推荐） --\x3e\n<router-link \n\t:to=\"{\n\t\tpath:'/home/message/detail',\n\t\tquery:{\n\t\t    id: m.id,\n            title: m.title\n\t\t}\n\t}\"\n>跳转</router-link>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 2. 接收query参数$route.query.id,$route.query.title\n\n\n# 6.4.2 params参数\n\n 1. 配置路由，声明接收params参数\n\n{\n\tpath:'/home',\n\tcomponent:Home,\n\tchildren:[\n\t\t{\n\t\t\tpath:'news',\n\t\t\tcomponent:News\n\t\t},\n\t\t{\n\t\t\tcomponent:Message,\n\t\t\tchildren:[\n\t\t\t\t{\n\t\t\t\t\tname:'xiangqing',\n\t\t\t\t\tpath:'detail/:id/:title', // 🔴使用占位符声明接收params参数\n\t\t\t\t\tcomponent:Detail\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n 2. 传递参数：特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！\n\n\x3c!-- 跳转并携带params参数，to的字符串写法 --\x3e\n<router-link :to=\"/home/message/detail/666/你好\">跳转</router-link>\n\t\t\t\t\n\x3c!-- 跳转并携带params参数，to的对象写法 --\x3e\n<router-link \n\t:to=\"{\n\t\tname:'xiangqing',\n\t\tparams:{\n\t\t    id:666,\n            title:'你好'\n\t\t}\n\t}\"\n>跳转</router-link>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 3. 接收参数$route.params.id``$route.params.title\n\n\n# 6.4.3 路由props配置\n\n 1. props作用：让路由组件更方便的收到参数\n 2. 在router/index.js里增加props配置\n\n{\n\tname:'xiangqing',\n\tpath:'detail/:id',\n\tcomponent:Detail,\n\n\t//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件\n\tprops:{a:900},\n\n\t//第二种写法：props值为布尔值，为true时，则把路由收到的所有params参数通过props传给Detail组件\n\tprops:true,\n\t\n\t//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件\n\tprops($route){\n\t\treturn {\n\t\t\tid: $route.query.id,\n\t\t\ttitle: $route.query.title\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 6.5 命名路由\n\n 1. 作用：可以简化路由的跳转\n\n\n# 6.5.1 命名路由使用\n\n 1. 给路由命名\n\n{\n\tpath:'/demo',\n\tcomponent:Demo,\n\tchildren:[\n\t\t{\n\t\t\tpath:'test',\n\t\t\tcomponent:Test,\n\t\t\tchildren:[\n\t\t\t\t{\n          name:'hello' // 给路由命名\n\t\t\t\t\tpath:'welcome',\n\t\t\t\t\tcomponent:Hello,\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 2. 简化跳转\n\n\x3c!--简化前，需要写完整的路径 --\x3e\n<router-link to=\"/demo/test/welcome\">跳转</router-link>\n\n\x3c!--简化后，直接通过名字跳转 --\x3e\n<router-link :to=\"{name:'hello'}\">跳转</router-link>\n\n\x3c!--简化写法配合传递参数 --\x3e\n<router-link \n\t:to=\"{\n\t\tname:'hello',\n\t\tquery:{\n\t\t    id:666,\n            title:'你好'\n\t\t}\n\t}\"\n>跳转</router-link>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 6.6 路由跳转replace模式\n\n 1. 作用：控制路由跳转时操作浏览器历史记录的模式\n 2. 浏览器的历史记录有两种写入方式：push和replace\n    1. push是追加历史记录\n    2. replace是替换当前记录，路由跳转时候默认为push方式\n 3. 开启replace模式<router-link :replace=\"true\" ...>News</router-link>\n 4. 简写<router-link replace ...>News</router-link>\n 5. 总结：浏览记录本质是一个栈，默认push，点开新页面就会在栈顶追加一个地址，后退，栈顶指针向下移动，改为replace就是不追加，而将栈顶地址替换\n\n\n# 6.7 编程式路由导航\n\n 1. 作用：不借助<router-link>实现路由跳转，让路由跳转更加灵活\n 2. this.$router.push({})内传的对象与<router-link>中的to相同\n 3. this.$router.replace({})\n 4. this.$router.forward()前进\n 5. this.$router.back()后退\n 6. this.$router.go(n)可前进也可后退，n为正数前进n，为负数后退\n\n\n# 6.8 缓存路由组件\n\n 1. 作用：让不展示的路由组件保持挂载，不被销毁\n 2. <keep-alive include=\"News\"><router-view></router-view></keep-alive>\n 3. <keep-alive :include=\"['News', 'Message']\"><router-view></router-view></keep-alive>\n\n\n# 6.9 路由相关生命钩子\n\n 1. activated和deactivated是路由组件所独有的两个钩子，用于捕获路由组件的激活状态\n 2. activated路由组件被激活时触发\n 3. deactivated路由组件失活时触发\n\n\n# 6.10 路由守卫\n\n 1. 作用：对路由进行权限控制\n 2. 分类：全局守卫、独享守卫、组件内守卫\n\n\n# 6.10.1 全局前置守卫\n\n 1. 每次路由切换之前和初始化时被调用\n 2. router.beforeEach((to,from,next) => {})\n 3. to是路由去往的信息，from是跳转路由前的信息，next()放行\n 4. meta路由元信息，是可以自定义的信息\n\nrouter.beforeEach((to,from,next) => {\n\tconsole.log('beforeEach',to,from)\n\tif(to.meta.isAuth){ // 判断当前路由是否需要进行权限控制\n\t\tif(localStorage.getItem('school') === 'atguigu'){ // 权限控制的具体规则\n\t\t\tnext()\t// 放行\n\t\t}else{\n\t\t\talert('暂无权限查看')\n\t\t}\n\t}else{\n\t\tnext()\t// 放行\n\t}\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 6.10.2 全局后置守卫\n\n 1. 每次路由切换后和初始化时被调用，没有next()方法\n 2. 用来切换标签页名字\n\nrouter.afterEach((to,from) => {\n\tconsole.log('afterEach',to,from)\n\tif(to.meta.title){ \n\t\tdocument.title = to.meta.title //修改网页的title\n\t}else{\n\t\tdocument.title = 'vue_test'\n\t}\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 6.10.3 独享守卫\n\n 1. 是routes的一个配置项\n 2. 没有独享后置路由守卫\n\nbeforeEnter(to,from,next){\n\tconsole.log('beforeEnter',to,from)\n    if(localStorage.getItem('school') === 'atguigu'){\n        next()\n    }else{\n        alert('暂无权限查看')\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 6.10.4 组件内守卫\n\n 1. 类似于生命周期\n 2. 是通过路由进入离开组件才会触发，直接放在页面上的是不触发的\n\n//进入守卫：通过路由规则，进入该组件时被调用\nbeforeRouteEnter (to, from, next) {... next()},\n\n//离开守卫：通过路由规则，离开该组件时被调用\nbeforeRouteLeave (to, from, next) {... next()},\n\n\n1\n2\n3\n4\n5\n\n\n\n# 6.11 路由器的工作模式\n\n 1. 对于一个url来说，#及其后面的内容就是hash值\n 2. hash值不会包含在HTTP请求中，即：hash值不会带给服务器\n\n\n# 6.11.1 hash模式\n\n 1. 地址中永远带着#号，不美观\n 2. 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法\n 3. 兼容性较好\n\n\n# 6.11.2 history模式\n\n 1. 地址干净，美观\n 2. 兼容性和hash模式相比略差\n 3. 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题\n\nconst router =  new VueRouter({\n\tmode:'history',\n\troutes:[...]\n})\n\nexport default router\n\n\n1\n2\n3\n4\n5\n6\n",normalizedContent:"# 6.1 相关概念\n\n\n# 6.1.1 路由\n\n 1. 路由概念\n    1. 一个路由就是一组映射关系（key - value）\n    2. key为路径，value可能是function或componen\n 2. 路由分类\n    1. 后端路由\n       1. 理解：value是function，用于处理客户端提交的请求\n       2. 工作过程：服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据\n    2. 前端路由\n       1. 理解：value是component，用于展示页面内容\n       2. 工作过程：当浏览器的路径改变时，对应的组件就会显示\n\n\n# 6.1.2 spa应用\n\n 1. 单页web应用（single page web application，spa）\n 2. 整个应用只有一个完整的页面\n 3. 点击页面中的导航链接不会刷新页面，只会做页面的局部更新\n 4. 数据需要通过ajax请求获取\n\n\n# 6.2 基本路由\n\n\n# 6.2.1 基本路由使用\n\n 1. 安装vue-router，命令npm i vue-router\n 2. 应用插件vue.use(vuerouter)\n 3. 编写router配置项\n\nimport vuerouter from 'vue-router'\t\t\t// 引入vuerouter\nimport about from '../components/about'\t// 路由组件\nimport home from '../components/home'\t\t// 路由组件\n\n// 创建router实例对象，去管理一组一组的路由规则\nconst router = new vuerouter({\n\troutes:[\n\t\t{\n\t\t\tpath:'/about',\n\t\t\tcomponent:about\n\t\t},\n\t\t{\n\t\t\tpath:'/home',\n\t\t\tcomponent:home\n\t\t}\n\t]\n})\n\n//暴露router\nexport default router\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n 4. 实现切换<router-link></router-link>浏览器会被替换为a标签,active-class可配置高亮样式\n\n<router-link active-class=\"active\" to=\"/about\">about</router-link>\n\n\n1\n\n 5. 指定展示位<router-view></router-view>\n\n\n# 6.2.2 注意事项\n\n 1. 路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹\n 2. 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载\n 3. 每个组件都有自己的$route属性，里面存储着自己的路由信息\n 4. 整个应用只有一个router，可以通过组件的$router属性获取到\n\n\n# 6.3 多级路由\n\n 1. 配置路由规则，使用children配置项\n\nroutes:[\n\t{\n\t\tpath:'/about',\n\t\tcomponent:about,\n\t},\n\t{\n\t\tpath:'/home',\n\t\tcomponent:home,\n\t\tchildren:[ \t\t\t\t\t// 通过children配置子级路由\n\t\t\t{\n\t\t\t\tpath:'news', \t\t// 此处一定不要带斜杠，写成 /news\n\t\t\t\tcomponent:news\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:'message',\t// 此处一定不要写成 /message\n\t\t\t\tcomponent:message\n\t\t\t}\n\t\t]\n\t}\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n 2. 跳转（要写完整路径）<router-link to=\"/home/news\">news</router-link>\n\n\n# 6.4 路由传参\n\n\n# 6.4.1 query参数\n\n 1. 传递query参数\n\n\x3c!-- 跳转并携带query参数，to的字符串写法 --\x3e\n<router-link :to=\"`/home/message/detail?id=${m.id}&title=${m.title}`\">跳转</router-link>\n\t\t\t\t\n\x3c!-- 跳转并携带query参数，to的对象写法（推荐） --\x3e\n<router-link \n\t:to=\"{\n\t\tpath:'/home/message/detail',\n\t\tquery:{\n\t\t    id: m.id,\n            title: m.title\n\t\t}\n\t}\"\n>跳转</router-link>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 2. 接收query参数$route.query.id,$route.query.title\n\n\n# 6.4.2 params参数\n\n 1. 配置路由，声明接收params参数\n\n{\n\tpath:'/home',\n\tcomponent:home,\n\tchildren:[\n\t\t{\n\t\t\tpath:'news',\n\t\t\tcomponent:news\n\t\t},\n\t\t{\n\t\t\tcomponent:message,\n\t\t\tchildren:[\n\t\t\t\t{\n\t\t\t\t\tname:'xiangqing',\n\t\t\t\t\tpath:'detail/:id/:title', // 🔴使用占位符声明接收params参数\n\t\t\t\t\tcomponent:detail\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n 2. 传递参数：特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！\n\n\x3c!-- 跳转并携带params参数，to的字符串写法 --\x3e\n<router-link :to=\"/home/message/detail/666/你好\">跳转</router-link>\n\t\t\t\t\n\x3c!-- 跳转并携带params参数，to的对象写法 --\x3e\n<router-link \n\t:to=\"{\n\t\tname:'xiangqing',\n\t\tparams:{\n\t\t    id:666,\n            title:'你好'\n\t\t}\n\t}\"\n>跳转</router-link>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 3. 接收参数$route.params.id``$route.params.title\n\n\n# 6.4.3 路由props配置\n\n 1. props作用：让路由组件更方便的收到参数\n 2. 在router/index.js里增加props配置\n\n{\n\tname:'xiangqing',\n\tpath:'detail/:id',\n\tcomponent:detail,\n\n\t//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给detail组件\n\tprops:{a:900},\n\n\t//第二种写法：props值为布尔值，为true时，则把路由收到的所有params参数通过props传给detail组件\n\tprops:true,\n\t\n\t//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给detail组件\n\tprops($route){\n\t\treturn {\n\t\t\tid: $route.query.id,\n\t\t\ttitle: $route.query.title\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 6.5 命名路由\n\n 1. 作用：可以简化路由的跳转\n\n\n# 6.5.1 命名路由使用\n\n 1. 给路由命名\n\n{\n\tpath:'/demo',\n\tcomponent:demo,\n\tchildren:[\n\t\t{\n\t\t\tpath:'test',\n\t\t\tcomponent:test,\n\t\t\tchildren:[\n\t\t\t\t{\n          name:'hello' // 给路由命名\n\t\t\t\t\tpath:'welcome',\n\t\t\t\t\tcomponent:hello,\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 2. 简化跳转\n\n\x3c!--简化前，需要写完整的路径 --\x3e\n<router-link to=\"/demo/test/welcome\">跳转</router-link>\n\n\x3c!--简化后，直接通过名字跳转 --\x3e\n<router-link :to=\"{name:'hello'}\">跳转</router-link>\n\n\x3c!--简化写法配合传递参数 --\x3e\n<router-link \n\t:to=\"{\n\t\tname:'hello',\n\t\tquery:{\n\t\t    id:666,\n            title:'你好'\n\t\t}\n\t}\"\n>跳转</router-link>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 6.6 路由跳转replace模式\n\n 1. 作用：控制路由跳转时操作浏览器历史记录的模式\n 2. 浏览器的历史记录有两种写入方式：push和replace\n    1. push是追加历史记录\n    2. replace是替换当前记录，路由跳转时候默认为push方式\n 3. 开启replace模式<router-link :replace=\"true\" ...>news</router-link>\n 4. 简写<router-link replace ...>news</router-link>\n 5. 总结：浏览记录本质是一个栈，默认push，点开新页面就会在栈顶追加一个地址，后退，栈顶指针向下移动，改为replace就是不追加，而将栈顶地址替换\n\n\n# 6.7 编程式路由导航\n\n 1. 作用：不借助<router-link>实现路由跳转，让路由跳转更加灵活\n 2. this.$router.push({})内传的对象与<router-link>中的to相同\n 3. this.$router.replace({})\n 4. this.$router.forward()前进\n 5. this.$router.back()后退\n 6. this.$router.go(n)可前进也可后退，n为正数前进n，为负数后退\n\n\n# 6.8 缓存路由组件\n\n 1. 作用：让不展示的路由组件保持挂载，不被销毁\n 2. <keep-alive include=\"news\"><router-view></router-view></keep-alive>\n 3. <keep-alive :include=\"['news', 'message']\"><router-view></router-view></keep-alive>\n\n\n# 6.9 路由相关生命钩子\n\n 1. activated和deactivated是路由组件所独有的两个钩子，用于捕获路由组件的激活状态\n 2. activated路由组件被激活时触发\n 3. deactivated路由组件失活时触发\n\n\n# 6.10 路由守卫\n\n 1. 作用：对路由进行权限控制\n 2. 分类：全局守卫、独享守卫、组件内守卫\n\n\n# 6.10.1 全局前置守卫\n\n 1. 每次路由切换之前和初始化时被调用\n 2. router.beforeeach((to,from,next) => {})\n 3. to是路由去往的信息，from是跳转路由前的信息，next()放行\n 4. meta路由元信息，是可以自定义的信息\n\nrouter.beforeeach((to,from,next) => {\n\tconsole.log('beforeeach',to,from)\n\tif(to.meta.isauth){ // 判断当前路由是否需要进行权限控制\n\t\tif(localstorage.getitem('school') === 'atguigu'){ // 权限控制的具体规则\n\t\t\tnext()\t// 放行\n\t\t}else{\n\t\t\talert('暂无权限查看')\n\t\t}\n\t}else{\n\t\tnext()\t// 放行\n\t}\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 6.10.2 全局后置守卫\n\n 1. 每次路由切换后和初始化时被调用，没有next()方法\n 2. 用来切换标签页名字\n\nrouter.aftereach((to,from) => {\n\tconsole.log('aftereach',to,from)\n\tif(to.meta.title){ \n\t\tdocument.title = to.meta.title //修改网页的title\n\t}else{\n\t\tdocument.title = 'vue_test'\n\t}\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 6.10.3 独享守卫\n\n 1. 是routes的一个配置项\n 2. 没有独享后置路由守卫\n\nbeforeenter(to,from,next){\n\tconsole.log('beforeenter',to,from)\n    if(localstorage.getitem('school') === 'atguigu'){\n        next()\n    }else{\n        alert('暂无权限查看')\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 6.10.4 组件内守卫\n\n 1. 类似于生命周期\n 2. 是通过路由进入离开组件才会触发，直接放在页面上的是不触发的\n\n//进入守卫：通过路由规则，进入该组件时被调用\nbeforerouteenter (to, from, next) {... next()},\n\n//离开守卫：通过路由规则，离开该组件时被调用\nbeforerouteleave (to, from, next) {... next()},\n\n\n1\n2\n3\n4\n5\n\n\n\n# 6.11 路由器的工作模式\n\n 1. 对于一个url来说，#及其后面的内容就是hash值\n 2. hash值不会包含在http请求中，即：hash值不会带给服务器\n\n\n# 6.11.1 hash模式\n\n 1. 地址中永远带着#号，不美观\n 2. 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法\n 3. 兼容性较好\n\n\n# 6.11.2 history模式\n\n 1. 地址干净，美观\n 2. 兼容性和hash模式相比略差\n 3. 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题\n\nconst router =  new vuerouter({\n\tmode:'history',\n\troutes:[...]\n})\n\nexport default router\n\n\n1\n2\n3\n4\n5\n6\n",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"Vue3",frontmatter:{title:"Vue3",date:"2022-06-09T16:22:50.000Z",permalink:"/pages/d6c83e/",categories:["《Vue》"],tags:[null]},regularPath:"/%E3%80%8AVue%E3%80%8B/30.%20Vue3.html",relativePath:"《Vue》/30. Vue3.md",key:"v-529c581c",path:"/pages/d6c83e/",headers:[{level:2,title:"7.1 创建VUE3工程",slug:"_7-1-创建vue3工程",normalizedTitle:"7.1 创建vue3工程",charIndex:2},{level:3,title:"7.1.1 vue-cli创建",slug:"_7-1-1-vue-cli创建",normalizedTitle:"7.1.1 vue-cli创建",charIndex:19},{level:3,title:"7.1.2 vite创建",slug:"_7-1-2-vite创建",normalizedTitle:"7.1.2 vite创建",charIndex:214},{level:2,title:"7.2 响应式原理",slug:"_7-2-响应式原理",normalizedTitle:"7.2 响应式原理",charIndex:465},{level:3,title:"7.2.1 VUE2响应式",slug:"_7-2-1-vue2响应式",normalizedTitle:"7.2.1 vue2响应式",charIndex:479},{level:3,title:"7.2.2 VUE3响应式",slug:"_7-2-2-vue3响应式",normalizedTitle:"7.2.2 vue3响应式",charIndex:812},{level:2,title:"7.3 常见Composition API",slug:"_7-3-常见composition-api",normalizedTitle:"7.3 常见composition api",charIndex:1630},{level:3,title:"7.3.1 setup",slug:"_7-3-1-setup",normalizedTitle:"7.3.1 setup",charIndex:1656},{level:3,title:"7.3.2 ref函数",slug:"_7-3-2-ref函数",normalizedTitle:"7.3.2 ref函数",charIndex:2436},{level:3,title:"7.3.3 reactive函数",slug:"_7-3-3-reactive函数",normalizedTitle:"7.3.3 reactive函数",charIndex:2775},{level:3,title:"7.3.4 computed函数",slug:"_7-3-4-computed函数",normalizedTitle:"7.3.4 computed函数",charIndex:3394},{level:3,title:"7.3.5 watch函数",slug:"_7-3-5-watch函数",normalizedTitle:"7.3.5 watch函数",charIndex:3952},{level:3,title:"7.3.6 watchEffect函数",slug:"_7-3-6-watcheffect函数",normalizedTitle:"7.3.6 watcheffect函数",charIndex:5140},{level:3,title:"7.3.7 自定义hook函数",slug:"_7-3-7-自定义hook函数",normalizedTitle:"7.3.7 自定义hook函数",charIndex:5546},{level:3,title:"7.3.8 toRef",slug:"_7-3-8-toref",normalizedTitle:"7.3.8 toref",charIndex:5678},{level:2,title:"7.4 其它 Composition API",slug:"_7-4-其它-composition-api",normalizedTitle:"7.4 其它 composition api",charIndex:5870},{level:3,title:"7.4.1 shallowReactive 与 shallowRef",slug:"_7-4-1-shallowreactive-与-shallowref",normalizedTitle:"7.4.1 shallowreactive 与 shallowref",charIndex:5897},{level:3,title:"7.4.2 readonly 与 shallowReadonly",slug:"_7-4-2-readonly-与-shallowreadonly",normalizedTitle:"7.4.2 readonly 与 shallowreadonly",charIndex:6154},{level:3,title:"7.4.3 toRaw 与 markRaw",slug:"_7-4-3-toraw-与-markraw",normalizedTitle:"7.4.3 toraw 与 markraw",charIndex:6287},{level:3,title:"7.4.4 customRef",slug:"_7-4-4-customref",normalizedTitle:"7.4.4 customref",charIndex:6552},{level:3,title:"7.4.5 provide 与 inject",slug:"_7-4-5-provide-与-inject",normalizedTitle:"7.4.5 provide 与 inject",charIndex:7455},{level:3,title:"7.4.6.响应式数据的判断",slug:"_7-4-6-响应式数据的判断",normalizedTitle:"7.4.6.响应式数据的判断",charIndex:7953},{level:2,title:"7.5 Composition API 的优势",slug:"_7-5-composition-api-的优势",normalizedTitle:"7.5 composition api 的优势",charIndex:8144},{level:3,title:"7.5.1 Options API 存在的问题",slug:"_7-5-1-options-api-存在的问题",normalizedTitle:"7.5.1 options api 存在的问题",charIndex:8172},{level:3,title:"7.5.2 Composition API 的优势",slug:"_7-5-2-composition-api-的优势",normalizedTitle:"7.5.2 composition api 的优势",charIndex:8261},{level:2,title:"7.6 Vue3新组件",slug:"_7-6-vue3新组件",normalizedTitle:"7.6 vue3新组件",charIndex:8332},{level:3,title:"7.6.1 Fragment",slug:"_7-6-1-fragment",normalizedTitle:"7.6.1 fragment",charIndex:8348},{level:3,title:"7.6.2 Teleport",slug:"_7-6-2-teleport",normalizedTitle:"7.6.2 teleport",charIndex:8464},{level:3,title:"7.6.3 Suspense",slug:"_7-6-3-suspense",normalizedTitle:"7.6.3 suspense",charIndex:8731},{level:2,title:"7.7 Vue3其他",slug:"_7-7-vue3其他",normalizedTitle:"7.7 vue3其他",charIndex:9386},{level:3,title:"7.7.1 全局API的转移",slug:"_7-7-1-全局api的转移",normalizedTitle:"7.7.1 全局api的转移",charIndex:9401},{level:3,title:"7.7.2 data选项",slug:"_7-7-2-data选项",normalizedTitle:"7.7.2 data选项",charIndex:10247},{level:3,title:"7.7.3 过度类名的更改：",slug:"_7-7-3-过度类名的更改",normalizedTitle:"7.7.3 过度类名的更改：",charIndex:10284},{level:3,title:"7.7.4 v-on 的修饰符",slug:"_7-7-4-v-on-的修饰符",normalizedTitle:"7.7.4 v-on 的修饰符",charIndex:10668},{level:3,title:"7.7.5 父组件中绑定事件",slug:"_7-7-5-父组件中绑定事件",normalizedTitle:"7.7.5 父组件中绑定事件",charIndex:10764},{level:3,title:"7.7.5 移除过滤器",slug:"_7-7-5-移除过滤器",normalizedTitle:"7.7.5 移除过滤器",charIndex:11023}],headersStr:"7.1 创建VUE3工程 7.1.1 vue-cli创建 7.1.2 vite创建 7.2 响应式原理 7.2.1 VUE2响应式 7.2.2 VUE3响应式 7.3 常见Composition API 7.3.1 setup 7.3.2 ref函数 7.3.3 reactive函数 7.3.4 computed函数 7.3.5 watch函数 7.3.6 watchEffect函数 7.3.7 自定义hook函数 7.3.8 toRef 7.4 其它 Composition API 7.4.1 shallowReactive 与 shallowRef 7.4.2 readonly 与 shallowReadonly 7.4.3 toRaw 与 markRaw 7.4.4 customRef 7.4.5 provide 与 inject 7.4.6.响应式数据的判断 7.5 Composition API 的优势 7.5.1 Options API 存在的问题 7.5.2 Composition API 的优势 7.6 Vue3新组件 7.6.1 Fragment 7.6.2 Teleport 7.6.3 Suspense 7.7 Vue3其他 7.7.1 全局API的转移 7.7.2 data选项 7.7.3 过度类名的更改： 7.7.4 v-on 的修饰符 7.7.5 父组件中绑定事件 7.7.5 移除过滤器",content:"# 7.1 创建VUE3工程\n\n\n# 7.1.1 vue-cli创建\n\n## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上\nvue --version\n## 安装或者升级你的@vue/cli\nnpm install -g @vue/cli\n## 创建\nvue create vue_test\n## 启动\ncd vue_test\nnpm run serve\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 7.1.2 vite创建\n\n 1. 优势\n    1. 开发环境中，无需打包操作，可快速的冷启动。\n    2. 轻量快速的热重载（HMR）。\n    3. 真正的按需编译，不再等待整个应用编译完成。\n 2. 传统构建与vite构建对比图\n\n## 创建工程\nnpm init vite-app <project-name>\n## 进入工程目录\ncd <project-name>\n## 安装依赖\nnpm install\n## 运行\nnpm run dev\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 7.2 响应式原理\n\n\n# 7.2.1 VUE2响应式\n\n 1. 实现原理：\n    1. 对象类型：通过Object.defineProperty()对属性的读取、修改进行拦截（数据劫持）。\n    2. 数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。\n    \n    Object.defineProperty(data, 'count', {\n        get () {}, \n        set () {}\n    })\n    \n    \n    1\n    2\n    3\n    4\n    \n 2. 存在问题：\n    1. 新增属性、删除属性, 界面不会更新。\n    2. 直接通过下标修改数组, 界面不会自动更新。\n\n\n# 7.2.2 VUE3响应式\n\n 1. 实现原理:\n    1. 通过Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。\n    2. 通过Reflect（反射）: 对源对象的属性进行操作。\n    3. MDN文档中描述的Proxy与Reflect：\n       1. Proxy\n       2. Reflect\n       \n       new Proxy(data, {\n       \t// 拦截读取属性值\n           get (target, prop) {\n           \treturn Reflect.get(target, prop)\n           },\n           // 拦截设置属性值或添加新属性\n           set (target, prop, value) {\n           \treturn Reflect.set(target, prop, value)\n           },\n           // 拦截删除属性\n           deleteProperty (target, prop) {\n           \treturn Reflect.deleteProperty(target, prop)\n           }\n       })\n       \n       proxy.name = 'tom'   \n       \n       \n       1\n       2\n       3\n       4\n       5\n       6\n       7\n       8\n       9\n       10\n       11\n       12\n       13\n       14\n       15\n       16\n       \n\n\n# 7.3 常见Composition API\n\n\n# 7.3.1 setup\n\n 1. 理解：Vue3.0中一个新的配置项，值为一个函数。\n 2. setup是所有Composition API（组合API）“ 表演的舞台 ”。\n 3. 组件中所用到的：数据、方法等等，均要配置在setup中。\n 4. setup函数的两种返回值：\n    1. 若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）\n    2. 若返回一个渲染函数：则可以自定义渲染内容。（了解）\n 5. setup执行的时机：在beforeCreate之前执行一次，this是undefined。\n 6. setup的参数\n\n * props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。\n * context：上下文对象\n   * attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 this.$attrs。\n   * slots: 收到的插槽内容, 相当于 this.$slots。\n   * emit: 分发自定义事件的函数, 相当于 this.$emit。\n\n 7. 注意点：\n    1. 尽量不要与Vue2.x配置混用\n       * Vue2.x配置（data、methos、computed...）中可以访问到setup中的属性、方法。\n       * 但在setup中不能访问到Vue2.x配置（data、methos、computed...）。\n       * 如果有重名, setup优先。\n    2. setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）\n\n\n# 7.3.2 ref函数\n\n 1. 作用: 定义一个响应式的数据\n 2. 语法: const xxx = ref(initValue)\n    1. 创建一个包含响应式数据的引用对象（reference对象，简称ref对象）\n    2. JS中操作数据： xxx.value\n    3. 模板中读取数据: 不需要.value，直接：<div>{{xxx}}</div>\n 3. 备注：\n    1. 接收的数据可以是：基本类型、也可以是对象类型。\n    2. 基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。\n    3. 对象类型的数据：内部“ 求助 ”了Vue3.0中的一个新函数—— reactive函数。\n\n\n# 7.3.3 reactive函数\n\n 1. 作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用ref函数）\n 2. 语法：const 代理对象= reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象）\n 3. reactive定义的响应式数据是“深层次的”。\n 4. 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。\n 5. 与ref的对比\n    1. 从定义数据角度对比：\n       1. ref用来定义：基本类型数据。\n       2. reactive用来定义：对象（或数组）类型数据。\n       3. 备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。\n    2. 从原理角度对比：\n       1. ref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。\n       2. reactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作对象内部的数据。\n    3. 从使用角度对比：\n       1. ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。\n       2. reactive定义的数据：操作数据与读取数据：均不需要.value。\n\n\n# 7.3.4 computed函数\n\n 1. 与Vue2.x中computed配置功能一致\n\nimport {computed} from 'vue'\n\nsetup(){\n    ...\n\t//计算属性——简写\n    let fullName = computed(()=>{\n        return person.firstName + '-' + person.lastName\n    })\n    //计算属性——完整\n    let fullName = computed({\n        get(){\n            return person.firstName + '-' + person.lastName\n        },\n        set(value){\n            const nameArr = value.split('-')\n            person.firstName = nameArr[0]\n            person.lastName = nameArr[1]\n        }\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 7.3.5 watch函数\n\n 1. 与Vue2.x中watch配置功能一致\n 2. 监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。\n 3. 监视reactive定义的响应式数据中某个属性时：deep配置有效。\n\n//情况一：监视ref定义的响应式数据\nwatch(sum,(newValue,oldValue)=>{\n\tconsole.log('sum变化了',newValue,oldValue)\n},{immediate:true})\n\n//情况二：监视多个ref定义的响应式数据\nwatch([sum,msg],(newValue,oldValue)=>{\n\tconsole.log('sum或msg变化了',newValue,oldValue)\n}) \n\n/* 情况三：监视reactive定义的响应式数据\n\t若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！\n\t若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 \n*/\nwatch(person,(newValue,oldValue)=>{\n\tconsole.log('person变化了',newValue,oldValue)\n},{immediate:true,deep:false}) //此处的deep配置不再奏效\n\n//情况四：监视reactive定义的响应式数据中的某个属性\nwatch(()=>person.job,(newValue,oldValue)=>{\n\tconsole.log('person的job变化了',newValue,oldValue)\n},{immediate:true,deep:true}) \n\n//情况五：监视reactive定义的响应式数据中的某些属性\nwatch([()=>person.job,()=>person.name],(newValue,oldValue)=>{\n\tconsole.log('person的job变化了',newValue,oldValue)\n},{immediate:true,deep:true})\n\n//特殊情况\nwatch(()=>person.job,(newValue,oldValue)=>{\n    console.log('person的job变化了',newValue,oldValue)\n},{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 7.3.6 watchEffect函数\n\n 1. watch的套路是：既要指明监视的属性，也要指明监视的回调。\n 2. watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。\n 3. watchEffect有点像computed：\n    1. 但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。\n    2. 而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。\n\n//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。\nwatchEffect(()=>{\n    const x1 = sum.value\n    const x2 = person.age\n    console.log('watchEffect配置的回调执行了')\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 7.3.7 自定义hook函数\n\n 1. hook本质是一个函数，把setup函数中使用的Composition API进行了封装。\n 2. 类似于vue2.x中的mixin。\n 3. 自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。\n\n\n# 7.3.8 toRef\n\n 1. 作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。\n 2. 语法：const name = toRef(person,'name')\n 3. 应用: 要将响应式对象中的某个属性单独提供给外部使用时。\n 4. 扩展：toRefs 与toRef功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person)\n\n\n# 7.4 其它 Composition API\n\n\n# 7.4.1 shallowReactive 与 shallowRef\n\n 1. shallowReactive：只处理对象最外层属性的响应式（浅响应式）。\n 2. shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。\n 3. 什么时候使用?\n    1. 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===> shallowReactive。\n    2. 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===> shallowRef。\n\n\n# 7.4.2 readonly 与 shallowReadonly\n\n 1. readonly: 让一个响应式数据变为只读的（深只读）。\n 2. shallowReadonly：让一个响应式数据变为只读的（浅只读）。\n 3. 应用场景: 不希望数据被修改时。\n\n\n# 7.4.3 toRaw 与 markRaw\n\n 1. toRaw：\n    1. 作用：将一个由reactive生成的响应式对象转为普通对象\n    2. 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。\n 2. markRaw：\n    1. 作用：标记一个对象，使其永远不会再成为响应式对象。\n    2. 应用场景:\n       1. 有些值不应被设置为响应式的，例如复杂的第三方类库等。\n       2. 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。\n\n\n# 7.4.4 customRef\n\n 1. 作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。\n 2. 实现防抖效果：\n\n<template>\n\t<input type=\"text\" v-model=\"keyword\">\n\t<h3>{{keyword}}</h3>\n</template>\n\n<script>\n\timport {ref,customRef} from 'vue'\n\texport default {\n\t\tname:'Demo',\n\t\tsetup(){\n\t\t\t// let keyword = ref('hello') //使用Vue准备好的内置ref\n\t\t\t//自定义一个myRef\n\t\t\tfunction myRef(value,delay){\n\t\t\t\tlet timer\n\t\t\t\t//通过customRef去实现自定义\n\t\t\t\treturn customRef((track,trigger)=>{\n\t\t\t\t\treturn{\n\t\t\t\t\t\tget(){\n\t\t\t\t\t\t\ttrack() //告诉Vue这个value值是需要被“追踪”的\n\t\t\t\t\t\t\treturn value\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset(newValue){\n\t\t\t\t\t\t\tclearTimeout(timer)\n\t\t\t\t\t\t\ttimer = setTimeout(()=>{\n\t\t\t\t\t\t\t\tvalue = newValue\n\t\t\t\t\t\t\t\ttrigger() //告诉Vue去更新界面\n\t\t\t\t\t\t\t},delay)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t\tlet keyword = myRef('hello',500) //使用程序员自定义的ref\n\t\t\treturn {\n\t\t\t\tkeyword\n\t\t\t}\n\t\t}\n\t}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 7.4.5 provide 与 inject\n\n\n\n 1. 作用：实现祖与后代组件间通信\n\n 2. 套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据\n\n 3. 具体写法：\n    \n    1. 祖组件中：\n    \n    setup(){\n    \t......\n        let car = reactive({name:'奔驰',price:'40万'})\n        provide('car',car)\n        ......\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n    2. 后代组件中：\n    \n    setup(props,context){\n    \t......\n        const car = inject('car')\n        return {car}\n    \t......\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n\n# 7.4.6.响应式数据的判断\n\n 1. isRef: 检查一个值是否为一个 ref 对象\n 2. isReactive: 检查一个对象是否是由 reactive 创建的响应式代理\n 3. isReadonly: 检查一个对象是否是由 readonly 创建的只读代理\n 4. isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理\n\n\n# 7.5 Composition API 的优势\n\n\n# 7.5.1 Options API 存在的问题\n\n使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。\n\n\n# 7.5.2 Composition API 的优势\n\n我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。\n\n\n# 7.6 Vue3新组件\n\n\n# 7.6.1 Fragment\n\n 1. 在Vue2中: 组件必须有一个根标签\n 2. 在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中\n 3. 好处: 减少标签层级, 减小内存占用\n\n\n# 7.6.2 Teleport\n\n什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术\n\n<teleport to=\"移动位置\">\n\t<div v-if=\"isShow\" class=\"mask\">\n\t\t<div class=\"dialog\">\n\t\t\t<h3>我是一个弹窗</h3>\n\t\t\t<button @click=\"isShow = false\">关闭弹窗</button>\n\t\t</div>\n\t</div>\n</teleport>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 7.6.3 Suspense\n\n 1. 等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n\n 2. 使用步骤：\n    \n    1. 异步引入组件\n    \n    import {defineAsyncComponent} from 'vue'\n    const Child = defineAsyncComponent(()=>import('./components/Child.vue'))\n    \n    \n    1\n    2\n    \n    2. 使用Suspense包裹组件，并配置好default 与 fallback\n    \n    <template>\n    \t<div class=\"app\">\n    \t\t<h3>我是App组件</h3>\n    \t\t<Suspense>\n    \t\t\t<template v-slot:default>\n    \t\t\t\t<Child/>\n    \t\t\t</template>\n    \t\t\t<template v-slot:fallback>\n    \t\t\t\t<h3>加载中.....</h3>\n    \t\t\t</template>\n    \t\t</Suspense>\n    \t</div>\n    </template>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n\n# 7.7 Vue3其他\n\n\n# 7.7.1 全局API的转移\n\n 1. Vue 2.x 有许多全局 API 和配置。\n\n 2. 例如：注册全局组件、注册全局指令等。\n    \n    //注册全局组件\n    Vue.component('MyButton', {\n      data: () => ({\n        count: 0\n      }),\n      template: '<button @click=\"count++\">Clicked {{ count }} times.</button>'\n    })\n    \n    //注册全局指令\n    Vue.directive('focus', {\n      inserted: el => el.focus()\n    })\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n\n 3. Vue3.0中对这些API做出了调整：\n\n * 将全局的API，即：Vue.xxx调整到应用实例（app）上\n   \n   2.X 全局 API（VUE）            3.X 实例 API (APP)\n   Vue.config.xxxx            app.config.xxxx\n   Vue.config.productionTip   移除\n   Vue.component              app.component\n   Vue.directive              app.directive\n   Vue.mixin                  app.mixin\n   Vue.use                    app.use\n   Vue.prototype              app.config.globalProperties\n\n\n# 7.7.2 data选项\n\ndata选项应始终被声明为一个函数。\n\n\n# 7.7.3 过度类名的更改：\n\n * Vue2.x写法\n   \n   .v-enter,\n   .v-leave-to {\n     opacity: 0;\n   }\n   .v-leave,\n   .v-enter-to {\n     opacity: 1;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * Vue3.x写法\n   \n   .v-enter-from,\n   .v-leave-to {\n     opacity: 0;\n   }\n   \n   .v-leave-from,\n   .v-enter-to {\n     opacity: 1;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n\n# 7.7.4 v-on 的修饰符\n\n 1. 移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes\n 2. 移除``v-on.native```修饰符\n\n\n# 7.7.5 父组件中绑定事件\n\n```html\n<my-component\n  v-on:close=\"handleComponentEvent\"\n  v-on:click=\"handleNativeClickEvent\"\n/>\n```\n\n\n * 子组件中声明自定义事件\n   \n   <script>\n     export default {\n       emits: ['close']\n     }\n   <\/script>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# 7.7.5 移除过滤器\n\n过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。",normalizedContent:"# 7.1 创建vue3工程\n\n\n# 7.1.1 vue-cli创建\n\n## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上\nvue --version\n## 安装或者升级你的@vue/cli\nnpm install -g @vue/cli\n## 创建\nvue create vue_test\n## 启动\ncd vue_test\nnpm run serve\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 7.1.2 vite创建\n\n 1. 优势\n    1. 开发环境中，无需打包操作，可快速的冷启动。\n    2. 轻量快速的热重载（hmr）。\n    3. 真正的按需编译，不再等待整个应用编译完成。\n 2. 传统构建与vite构建对比图\n\n## 创建工程\nnpm init vite-app <project-name>\n## 进入工程目录\ncd <project-name>\n## 安装依赖\nnpm install\n## 运行\nnpm run dev\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 7.2 响应式原理\n\n\n# 7.2.1 vue2响应式\n\n 1. 实现原理：\n    1. 对象类型：通过object.defineproperty()对属性的读取、修改进行拦截（数据劫持）。\n    2. 数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。\n    \n    object.defineproperty(data, 'count', {\n        get () {}, \n        set () {}\n    })\n    \n    \n    1\n    2\n    3\n    4\n    \n 2. 存在问题：\n    1. 新增属性、删除属性, 界面不会更新。\n    2. 直接通过下标修改数组, 界面不会自动更新。\n\n\n# 7.2.2 vue3响应式\n\n 1. 实现原理:\n    1. 通过proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。\n    2. 通过reflect（反射）: 对源对象的属性进行操作。\n    3. mdn文档中描述的proxy与reflect：\n       1. proxy\n       2. reflect\n       \n       new proxy(data, {\n       \t// 拦截读取属性值\n           get (target, prop) {\n           \treturn reflect.get(target, prop)\n           },\n           // 拦截设置属性值或添加新属性\n           set (target, prop, value) {\n           \treturn reflect.set(target, prop, value)\n           },\n           // 拦截删除属性\n           deleteproperty (target, prop) {\n           \treturn reflect.deleteproperty(target, prop)\n           }\n       })\n       \n       proxy.name = 'tom'   \n       \n       \n       1\n       2\n       3\n       4\n       5\n       6\n       7\n       8\n       9\n       10\n       11\n       12\n       13\n       14\n       15\n       16\n       \n\n\n# 7.3 常见composition api\n\n\n# 7.3.1 setup\n\n 1. 理解：vue3.0中一个新的配置项，值为一个函数。\n 2. setup是所有composition api（组合api）“ 表演的舞台 ”。\n 3. 组件中所用到的：数据、方法等等，均要配置在setup中。\n 4. setup函数的两种返回值：\n    1. 若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）\n    2. 若返回一个渲染函数：则可以自定义渲染内容。（了解）\n 5. setup执行的时机：在beforecreate之前执行一次，this是undefined。\n 6. setup的参数\n\n * props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。\n * context：上下文对象\n   * attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 this.$attrs。\n   * slots: 收到的插槽内容, 相当于 this.$slots。\n   * emit: 分发自定义事件的函数, 相当于 this.$emit。\n\n 7. 注意点：\n    1. 尽量不要与vue2.x配置混用\n       * vue2.x配置（data、methos、computed...）中可以访问到setup中的属性、方法。\n       * 但在setup中不能访问到vue2.x配置（data、methos、computed...）。\n       * 如果有重名, setup优先。\n    2. setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个promise实例，但需要suspense和异步组件的配合）\n\n\n# 7.3.2 ref函数\n\n 1. 作用: 定义一个响应式的数据\n 2. 语法: const xxx = ref(initvalue)\n    1. 创建一个包含响应式数据的引用对象（reference对象，简称ref对象）\n    2. js中操作数据： xxx.value\n    3. 模板中读取数据: 不需要.value，直接：<div>{{xxx}}</div>\n 3. 备注：\n    1. 接收的数据可以是：基本类型、也可以是对象类型。\n    2. 基本类型的数据：响应式依然是靠object.defineproperty()的get与set完成的。\n    3. 对象类型的数据：内部“ 求助 ”了vue3.0中的一个新函数—— reactive函数。\n\n\n# 7.3.3 reactive函数\n\n 1. 作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用ref函数）\n 2. 语法：const 代理对象= reactive(源对象)接收一个对象（或数组），返回一个代理对象（proxy的实例对象，简称proxy对象）\n 3. reactive定义的响应式数据是“深层次的”。\n 4. 内部基于 es6 的 proxy 实现，通过代理对象操作源对象内部数据进行操作。\n 5. 与ref的对比\n    1. 从定义数据角度对比：\n       1. ref用来定义：基本类型数据。\n       2. reactive用来定义：对象（或数组）类型数据。\n       3. 备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。\n    2. 从原理角度对比：\n       1. ref通过object.defineproperty()的get与set来实现响应式（数据劫持）。\n       2. reactive通过使用proxy来实现响应式（数据劫持）, 并通过reflect操作对象内部的数据。\n    3. 从使用角度对比：\n       1. ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。\n       2. reactive定义的数据：操作数据与读取数据：均不需要.value。\n\n\n# 7.3.4 computed函数\n\n 1. 与vue2.x中computed配置功能一致\n\nimport {computed} from 'vue'\n\nsetup(){\n    ...\n\t//计算属性——简写\n    let fullname = computed(()=>{\n        return person.firstname + '-' + person.lastname\n    })\n    //计算属性——完整\n    let fullname = computed({\n        get(){\n            return person.firstname + '-' + person.lastname\n        },\n        set(value){\n            const namearr = value.split('-')\n            person.firstname = namearr[0]\n            person.lastname = namearr[1]\n        }\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 7.3.5 watch函数\n\n 1. 与vue2.x中watch配置功能一致\n 2. 监视reactive定义的响应式数据时：oldvalue无法正确获取、强制开启了深度监视（deep配置失效）。\n 3. 监视reactive定义的响应式数据中某个属性时：deep配置有效。\n\n//情况一：监视ref定义的响应式数据\nwatch(sum,(newvalue,oldvalue)=>{\n\tconsole.log('sum变化了',newvalue,oldvalue)\n},{immediate:true})\n\n//情况二：监视多个ref定义的响应式数据\nwatch([sum,msg],(newvalue,oldvalue)=>{\n\tconsole.log('sum或msg变化了',newvalue,oldvalue)\n}) \n\n/* 情况三：监视reactive定义的响应式数据\n\t若watch监视的是reactive定义的响应式数据，则无法正确获得oldvalue！！\n\t若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 \n*/\nwatch(person,(newvalue,oldvalue)=>{\n\tconsole.log('person变化了',newvalue,oldvalue)\n},{immediate:true,deep:false}) //此处的deep配置不再奏效\n\n//情况四：监视reactive定义的响应式数据中的某个属性\nwatch(()=>person.job,(newvalue,oldvalue)=>{\n\tconsole.log('person的job变化了',newvalue,oldvalue)\n},{immediate:true,deep:true}) \n\n//情况五：监视reactive定义的响应式数据中的某些属性\nwatch([()=>person.job,()=>person.name],(newvalue,oldvalue)=>{\n\tconsole.log('person的job变化了',newvalue,oldvalue)\n},{immediate:true,deep:true})\n\n//特殊情况\nwatch(()=>person.job,(newvalue,oldvalue)=>{\n    console.log('person的job变化了',newvalue,oldvalue)\n},{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 7.3.6 watcheffect函数\n\n 1. watch的套路是：既要指明监视的属性，也要指明监视的回调。\n 2. watcheffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。\n 3. watcheffect有点像computed：\n    1. 但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。\n    2. 而watcheffect更注重的是过程（回调函数的函数体），所以不用写返回值。\n\n//watcheffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。\nwatcheffect(()=>{\n    const x1 = sum.value\n    const x2 = person.age\n    console.log('watcheffect配置的回调执行了')\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 7.3.7 自定义hook函数\n\n 1. hook本质是一个函数，把setup函数中使用的composition api进行了封装。\n 2. 类似于vue2.x中的mixin。\n 3. 自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。\n\n\n# 7.3.8 toref\n\n 1. 作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。\n 2. 语法：const name = toref(person,'name')\n 3. 应用: 要将响应式对象中的某个属性单独提供给外部使用时。\n 4. 扩展：torefs 与toref功能一致，但可以批量创建多个 ref 对象，语法：torefs(person)\n\n\n# 7.4 其它 composition api\n\n\n# 7.4.1 shallowreactive 与 shallowref\n\n 1. shallowreactive：只处理对象最外层属性的响应式（浅响应式）。\n 2. shallowref：只处理基本数据类型的响应式, 不进行对象的响应式处理。\n 3. 什么时候使用?\n    1. 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===> shallowreactive。\n    2. 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===> shallowref。\n\n\n# 7.4.2 readonly 与 shallowreadonly\n\n 1. readonly: 让一个响应式数据变为只读的（深只读）。\n 2. shallowreadonly：让一个响应式数据变为只读的（浅只读）。\n 3. 应用场景: 不希望数据被修改时。\n\n\n# 7.4.3 toraw 与 markraw\n\n 1. toraw：\n    1. 作用：将一个由reactive生成的响应式对象转为普通对象\n    2. 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。\n 2. markraw：\n    1. 作用：标记一个对象，使其永远不会再成为响应式对象。\n    2. 应用场景:\n       1. 有些值不应被设置为响应式的，例如复杂的第三方类库等。\n       2. 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。\n\n\n# 7.4.4 customref\n\n 1. 作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。\n 2. 实现防抖效果：\n\n<template>\n\t<input type=\"text\" v-model=\"keyword\">\n\t<h3>{{keyword}}</h3>\n</template>\n\n<script>\n\timport {ref,customref} from 'vue'\n\texport default {\n\t\tname:'demo',\n\t\tsetup(){\n\t\t\t// let keyword = ref('hello') //使用vue准备好的内置ref\n\t\t\t//自定义一个myref\n\t\t\tfunction myref(value,delay){\n\t\t\t\tlet timer\n\t\t\t\t//通过customref去实现自定义\n\t\t\t\treturn customref((track,trigger)=>{\n\t\t\t\t\treturn{\n\t\t\t\t\t\tget(){\n\t\t\t\t\t\t\ttrack() //告诉vue这个value值是需要被“追踪”的\n\t\t\t\t\t\t\treturn value\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset(newvalue){\n\t\t\t\t\t\t\tcleartimeout(timer)\n\t\t\t\t\t\t\ttimer = settimeout(()=>{\n\t\t\t\t\t\t\t\tvalue = newvalue\n\t\t\t\t\t\t\t\ttrigger() //告诉vue去更新界面\n\t\t\t\t\t\t\t},delay)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t\tlet keyword = myref('hello',500) //使用程序员自定义的ref\n\t\t\treturn {\n\t\t\t\tkeyword\n\t\t\t}\n\t\t}\n\t}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 7.4.5 provide 与 inject\n\n\n\n 1. 作用：实现祖与后代组件间通信\n\n 2. 套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据\n\n 3. 具体写法：\n    \n    1. 祖组件中：\n    \n    setup(){\n    \t......\n        let car = reactive({name:'奔驰',price:'40万'})\n        provide('car',car)\n        ......\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n    2. 后代组件中：\n    \n    setup(props,context){\n    \t......\n        const car = inject('car')\n        return {car}\n    \t......\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n\n# 7.4.6.响应式数据的判断\n\n 1. isref: 检查一个值是否为一个 ref 对象\n 2. isreactive: 检查一个对象是否是由 reactive 创建的响应式代理\n 3. isreadonly: 检查一个对象是否是由 readonly 创建的只读代理\n 4. isproxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理\n\n\n# 7.5 composition api 的优势\n\n\n# 7.5.1 options api 存在的问题\n\n使用传统optionsapi中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。\n\n\n# 7.5.2 composition api 的优势\n\n我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。\n\n\n# 7.6 vue3新组件\n\n\n# 7.6.1 fragment\n\n 1. 在vue2中: 组件必须有一个根标签\n 2. 在vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个fragment虚拟元素中\n 3. 好处: 减少标签层级, 减小内存占用\n\n\n# 7.6.2 teleport\n\n什么是teleport？—— teleport 是一种能够将我们的组件html结构移动到指定位置的技术\n\n<teleport to=\"移动位置\">\n\t<div v-if=\"isshow\" class=\"mask\">\n\t\t<div class=\"dialog\">\n\t\t\t<h3>我是一个弹窗</h3>\n\t\t\t<button @click=\"isshow = false\">关闭弹窗</button>\n\t\t</div>\n\t</div>\n</teleport>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 7.6.3 suspense\n\n 1. 等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n\n 2. 使用步骤：\n    \n    1. 异步引入组件\n    \n    import {defineasynccomponent} from 'vue'\n    const child = defineasynccomponent(()=>import('./components/child.vue'))\n    \n    \n    1\n    2\n    \n    2. 使用suspense包裹组件，并配置好default 与 fallback\n    \n    <template>\n    \t<div class=\"app\">\n    \t\t<h3>我是app组件</h3>\n    \t\t<suspense>\n    \t\t\t<template v-slot:default>\n    \t\t\t\t<child/>\n    \t\t\t</template>\n    \t\t\t<template v-slot:fallback>\n    \t\t\t\t<h3>加载中.....</h3>\n    \t\t\t</template>\n    \t\t</suspense>\n    \t</div>\n    </template>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n\n# 7.7 vue3其他\n\n\n# 7.7.1 全局api的转移\n\n 1. vue 2.x 有许多全局 api 和配置。\n\n 2. 例如：注册全局组件、注册全局指令等。\n    \n    //注册全局组件\n    vue.component('mybutton', {\n      data: () => ({\n        count: 0\n      }),\n      template: '<button @click=\"count++\">clicked {{ count }} times.</button>'\n    })\n    \n    //注册全局指令\n    vue.directive('focus', {\n      inserted: el => el.focus()\n    })\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n\n 3. vue3.0中对这些api做出了调整：\n\n * 将全局的api，即：vue.xxx调整到应用实例（app）上\n   \n   2.x 全局 api（vue）            3.x 实例 api (app)\n   vue.config.xxxx            app.config.xxxx\n   vue.config.productiontip   移除\n   vue.component              app.component\n   vue.directive              app.directive\n   vue.mixin                  app.mixin\n   vue.use                    app.use\n   vue.prototype              app.config.globalproperties\n\n\n# 7.7.2 data选项\n\ndata选项应始终被声明为一个函数。\n\n\n# 7.7.3 过度类名的更改：\n\n * vue2.x写法\n   \n   .v-enter,\n   .v-leave-to {\n     opacity: 0;\n   }\n   .v-leave,\n   .v-enter-to {\n     opacity: 1;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * vue3.x写法\n   \n   .v-enter-from,\n   .v-leave-to {\n     opacity: 0;\n   }\n   \n   .v-leave-from,\n   .v-enter-to {\n     opacity: 1;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n\n# 7.7.4 v-on 的修饰符\n\n 1. 移除keycode作为 v-on 的修饰符，同时也不再支持config.keycodes\n 2. 移除``v-on.native```修饰符\n\n\n# 7.7.5 父组件中绑定事件\n\n```html\n<my-component\n  v-on:close=\"handlecomponentevent\"\n  v-on:click=\"handlenativeclickevent\"\n/>\n```\n\n\n * 子组件中声明自定义事件\n   \n   <script>\n     export default {\n       emits: ['close']\n     }\n   <\/script>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# 7.7.5 移除过滤器\n\n过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 javascript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。",charsets:{cjk:!0},lastUpdated:"2022/06/24, 10:36:25",lastUpdatedTimestamp:1656038185e3},{title:"课程概论",frontmatter:{title:"课程概论",date:"2023-08-08T09:09:00.000Z",permalink:"/pages/9ba5d9/",categories:["《Web3D理论基础》","《现代计算机图形学》"],tags:["Web3D"]},regularPath:"/%E3%80%8AWeb3D%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E3%80%8B/01.%E3%80%8A%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E3%80%8B/00.%20%E8%AF%BE%E7%A8%8B%E6%A6%82%E8%AE%BA.html",relativePath:"《Web3D理论基础》/01.《现代计算机图形学》/00. 课程概论.md",key:"v-60d5e8ae",path:"/pages/9ba5d9/",headers:[{level:2,title:"1 计算机图形学概述",slug:"_1-计算机图形学概述",normalizedTitle:"1 计算机图形学概述",charIndex:2},{level:2,title:"2 Rasterization 光栅化",slug:"_2-rasterization-光栅化",normalizedTitle:"2 rasterization 光栅化",charIndex:150},{level:2,title:"3 曲线和曲面",slug:"_3-曲线和曲面",normalizedTitle:"3 曲线和曲面",charIndex:251},{level:2,title:"4 光线追踪",slug:"_4-光线追踪",normalizedTitle:"4 光线追踪",charIndex:280},{level:2,title:"5 动画与模拟",slug:"_5-动画与模拟",normalizedTitle:"5 动画与模拟",charIndex:360}],headersStr:"1 计算机图形学概述 2 Rasterization 光栅化 3 曲线和曲面 4 光线追踪 5 动画与模拟",content:"# 1 计算机图形学概述\n\n课程主要会学习四个部分的内容\n\n 1. Rasterization 光栅化（OpenGL shader）\n 2. Curve and Meshes 曲线和曲面\n 3. Ray Tracing 光线追踪\n 4. Animation/Simulation 动画与模拟\n\n\n# 2 Rasterization 光栅化\n\n 1. 光栅化就是把三维空间的几何形体显示在屏幕上\n 2. 计算机图形学实时的概念：计算机每秒30帧，否则叫离线\n 3. 光栅化是实时图形学应用的基础\n\n\n# 3 曲线和曲面\n\n如何表征计算机图形曲面拓扑结构\n\n\n# 4 光线追踪\n\n 1. 离线图形渲染的黄金法则\n 2. 相机拍摄每个像素的广信\n    1. 计算光线交汇以及阴影\n    2. 高光下持续的光线弹跳\n\n\n# 5 动画与模拟\n\n 1. 关键帧\n 2. 物理引擎",normalizedContent:"# 1 计算机图形学概述\n\n课程主要会学习四个部分的内容\n\n 1. rasterization 光栅化（opengl shader）\n 2. curve and meshes 曲线和曲面\n 3. ray tracing 光线追踪\n 4. animation/simulation 动画与模拟\n\n\n# 2 rasterization 光栅化\n\n 1. 光栅化就是把三维空间的几何形体显示在屏幕上\n 2. 计算机图形学实时的概念：计算机每秒30帧，否则叫离线\n 3. 光栅化是实时图形学应用的基础\n\n\n# 3 曲线和曲面\n\n如何表征计算机图形曲面拓扑结构\n\n\n# 4 光线追踪\n\n 1. 离线图形渲染的黄金法则\n 2. 相机拍摄每个像素的广信\n    1. 计算光线交汇以及阴影\n    2. 高光下持续的光线弹跳\n\n\n# 5 动画与模拟\n\n 1. 关键帧\n 2. 物理引擎",charsets:{cjk:!0}},{title:"向量与线性代数",frontmatter:{title:"向量与线性代数",date:"2023-08-09T17:21:23.000Z",permalink:"/pages/26dab9/",categories:["《Web3D理论基础》","《现代计算机图形学》"],tags:["Web3D"]},regularPath:"/%E3%80%8AWeb3D%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E3%80%8B/01.%E3%80%8A%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E3%80%8B/02.%20%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0.html",relativePath:"《Web3D理论基础》/01.《现代计算机图形学》/02. 向量与线性代数.md",key:"v-ea0af4f6",path:"/pages/26dab9/",headers:[{level:2,title:"1 图形学依赖",slug:"_1-图形学依赖",normalizedTitle:"1 图形学依赖",charIndex:2},{level:2,title:"2 向量Vectors",slug:"_2-向量vectors",normalizedTitle:"2 向量vectors",charIndex:72},{level:2,title:"2.1 向量标准化Vector Normalization",slug:"_2-1-向量标准化vector-normalization",normalizedTitle:"2.1 向量标准化vector normalization",charIndex:156},{level:2,title:"2.2 向量标准化Vector Addition",slug:"_2-2-向量标准化vector-addition",normalizedTitle:"2.2 向量标准化vector addition",charIndex:263},{level:2,title:"2.3 向量相乘Vector Multiplication",slug:"_2-3-向量相乘vector-multiplication",normalizedTitle:"2.3 向量相乘vector multiplication",charIndex:332},{level:3,title:"2.3.1 向量点乘Dot product",slug:"_2-3-1-向量点乘dot-product",normalizedTitle:"2.3.1 向量点乘dot product",charIndex:366},{level:3,title:"2.3.2 向量叉乘Cross product",slug:"_2-3-2-向量叉乘cross-product",normalizedTitle:"2.3.2 向量叉乘cross product",charIndex:1043},{level:2,title:"3 矩阵",slug:"_3-矩阵",normalizedTitle:"3 矩阵",charIndex:1581},{level:3,title:"3.1 矩阵乘积 Matrix-Matrix Multiplication",slug:"_3-1-矩阵乘积-matrix-matrix-multiplication",normalizedTitle:"3.1 矩阵乘积 matrix-matrix multiplication",charIndex:1652},{level:3,title:"3.2 矩阵转置 Transpose of a Matrix",slug:"_3-2-矩阵转置-transpose-of-a-matrix",normalizedTitle:"3.2 矩阵转置 transpose of a matrix",charIndex:1814},{level:3,title:"3.3 单位矩阵",slug:"_3-3-单位矩阵",normalizedTitle:"3.3 单位矩阵",charIndex:1881},{level:3,title:"3.4 向量乘法以矩阵形式展示",slug:"_3-4-向量乘法以矩阵形式展示",normalizedTitle:"3.4 向量乘法以矩阵形式展示",charIndex:2038}],headersStr:"1 图形学依赖 2 向量Vectors 2.1 向量标准化Vector Normalization 2.2 向量标准化Vector Addition 2.3 向量相乘Vector Multiplication 2.3.1 向量点乘Dot product 2.3.2 向量叉乘Cross product 3 矩阵 3.1 矩阵乘积 Matrix-Matrix Multiplication 3.2 矩阵转置 Transpose of a Matrix 3.3 单位矩阵 3.4 向量乘法以矩阵形式展示",content:"# 1 图形学依赖\n\n 1. 基础数学：线性代数、微积分、统计学\n 2. 基础物理：光学、力学\n 3. 其他：信号处理、数值分析、美学\n\n\n# 2 向量Vectors\n\n 1. 用结束点坐标-起始点坐标 $\\overrightarrow{AB}=A-B$\n 2. 方向和长度\n 3. 没有确定的开始位置\n\n\n# 2.1 向量标准化Vector Normalization\n\n 1. $|\\vec{a}|$表示向量的长度\n 2. 单位向量$\\hat{a}=\\frac{\\vec{a}}{|\\vec{a}|}$，表达方向\n\n\n# 2.2 向量标准化Vector Addition\n\n 1. 几何学：平行四边形法则&三角形法则\n 2. 代数：直接将向量坐标相加\n\n\n# 2.3 向量相乘Vector Multiplication\n\n\n# 2.3.1 向量点乘Dot product\n\n$$ \\vec{a}\\cdot \\vec{b} = |\\vec{a}| |\\vec{b}| \\cos\\theta $$ 对于单位向量$\\cos\\theta = \\hat{a} \\cdot \\hat{b}$ 在二维里 $$ \\vec{a} \\cdot \\vec{b} = \\begin{pmatrix}x_a \\y_a \\end{pmatrix} \\cdot \\begin{pmatrix}x_b \\y_b \\end{pmatrix} = x_ax_b + y_ay_b $$ 在三维里 $$ \\vec{a} \\cdot \\vec{b} = \\begin{pmatrix}x_a \\y_a \\z_a \\end{pmatrix} \\cdot \\begin{pmatrix}x_b \\y_b \\z_b \\end{pmatrix} = x_ax_b + y_ay_b +z_az_b $$\n\n点乘在图形学里\n\n 1. 找到两个方向之间的夹角\n 2. 找到一个向量到另一个向量的投影,$\\vec{b_\\bot}=k\\hat{a}$,$k=|\\vec{b_\\bot}| = |\\vec{b}|\\cos\\theta$\n 3. 将一个向量按照某个方向垂直平行分解，平行的是$\\vec{b_\\bot}$，垂直的是$\\vec{b}-\\vec{b_\\bot}$\n 4. 可以计算两个方向向量在方向上是否接近，点乘接近1就两个方向向量接近，远离就会逐渐变为1\n 5. 计算向量的前后(光照模型基础)，点乘>0向前，<0向后\n\n\n# 2.3.2 向量叉乘Cross product\n\n$|\\vec{a}\\times\\vec{b}| = |\\vec{a}| |\\vec{b}| \\sin\\theta$\n\n 1. 叉乘后得到的向量要同时与a、b垂直\n 2. 叉乘后向量的方向遵循右手螺旋定则\n 3. 叉乘不符合交换律\n 4. 可以建立三维坐标中的直角坐标系$\\vec{x}\\times\\vec{y}=+\\vec{z}$（右手坐标系）\n    $$ \\vec{a}\\times\\vec{b}= \\begin{pmatrix}y_az_b-y_bz_a \\z_ax_b-x_az_b\\x_ay_b-y_ax_b \\end{pmatrix} $$ $$ \\vec{a}\\times\\vec{b}= A*b= \\begin{pmatrix}0 & -z_a & y_a\\z_a & 0 & -x_a\\-y_a & x_a & 0 \\end{pmatrix} \\begin{pmatrix}x_b\\y_b\\z_b \\end{pmatrix} $$\n\n叉乘在图形学里\n\n 1. 判定向量的左右侧关系，$\\vec{a}\\times\\vec{b}>0$则b在a的左侧，a逆时针旋转可以转到b的方向\n 2. 判定向量的内外\n\n\n# 3 矩阵\n\n 1. 一个二维的Array（m*n，m是行数，n是列数）\n 2. 矩阵和数字的加减乘除都是直接运算到矩阵里的每一个数字\n\n\n# 3.1 矩阵乘积 Matrix-Matrix Multiplication\n\n 1. 乘积对矩阵大小有要求(M*N)(N*P)=(M*P)，第一个矩阵的列数必须等于第二个举证的行数\n 2. 矩阵乘积得到的元素(i,j)就是第一个矩阵i行依次与第二个矩阵j列乘积求和\n 3. 矩阵乘积没有任何交换律，有结合律和分配率\n\n\n# 3.2 矩阵转置 Transpose of a Matrix\n\n 1. 行列互换\n 2. $(AB)^T = B^TA^T$\n\n\n# 3.3 单位矩阵\n\n 1. $I_{3\\times3} = \\begin{pmatrix}1 & 0 & 0\\0 & 1 & 0\\0 & 0 & 1 \\end{pmatrix}$\n 2. $AA^{-1} = A^{-1}A = I$\n 3. $(AB)^{-1} = B^{-1}A^{-1} = I$\n\n\n# 3.4 向量乘法以矩阵形式展示\n\n 1. 点乘$\\vec{a}\\cdot \\vec{b} = \\vec{a}^T\\vec{b} = \\begin{pmatrix}x_a\\y_a\\z_a\\end{pmatrix}\\begin{pmatrix}x_b&y_b&z_b\\end{pmatrix} =(x_ax_b+y_ay_b+z_az_b)$\n 2. 叉乘$\\vec{a}\\times \\vec{b} = A^*b=\\begin{pmatrix}0&-z_a&y_a\\z_a&0&-x_a\\-y_a&x_a&0\\end{pmatrix}\\begin{pmatrix}x_b\\y_b\\x_b\\end{pmatrix}$",normalizedContent:"# 1 图形学依赖\n\n 1. 基础数学：线性代数、微积分、统计学\n 2. 基础物理：光学、力学\n 3. 其他：信号处理、数值分析、美学\n\n\n# 2 向量vectors\n\n 1. 用结束点坐标-起始点坐标 $\\overrightarrow{ab}=a-b$\n 2. 方向和长度\n 3. 没有确定的开始位置\n\n\n# 2.1 向量标准化vector normalization\n\n 1. $|\\vec{a}|$表示向量的长度\n 2. 单位向量$\\hat{a}=\\frac{\\vec{a}}{|\\vec{a}|}$，表达方向\n\n\n# 2.2 向量标准化vector addition\n\n 1. 几何学：平行四边形法则&三角形法则\n 2. 代数：直接将向量坐标相加\n\n\n# 2.3 向量相乘vector multiplication\n\n\n# 2.3.1 向量点乘dot product\n\n$$ \\vec{a}\\cdot \\vec{b} = |\\vec{a}| |\\vec{b}| \\cos\\theta $$ 对于单位向量$\\cos\\theta = \\hat{a} \\cdot \\hat{b}$ 在二维里 $$ \\vec{a} \\cdot \\vec{b} = \\begin{pmatrix}x_a \\y_a \\end{pmatrix} \\cdot \\begin{pmatrix}x_b \\y_b \\end{pmatrix} = x_ax_b + y_ay_b $$ 在三维里 $$ \\vec{a} \\cdot \\vec{b} = \\begin{pmatrix}x_a \\y_a \\z_a \\end{pmatrix} \\cdot \\begin{pmatrix}x_b \\y_b \\z_b \\end{pmatrix} = x_ax_b + y_ay_b +z_az_b $$\n\n点乘在图形学里\n\n 1. 找到两个方向之间的夹角\n 2. 找到一个向量到另一个向量的投影,$\\vec{b_\\bot}=k\\hat{a}$,$k=|\\vec{b_\\bot}| = |\\vec{b}|\\cos\\theta$\n 3. 将一个向量按照某个方向垂直平行分解，平行的是$\\vec{b_\\bot}$，垂直的是$\\vec{b}-\\vec{b_\\bot}$\n 4. 可以计算两个方向向量在方向上是否接近，点乘接近1就两个方向向量接近，远离就会逐渐变为1\n 5. 计算向量的前后(光照模型基础)，点乘>0向前，<0向后\n\n\n# 2.3.2 向量叉乘cross product\n\n$|\\vec{a}\\times\\vec{b}| = |\\vec{a}| |\\vec{b}| \\sin\\theta$\n\n 1. 叉乘后得到的向量要同时与a、b垂直\n 2. 叉乘后向量的方向遵循右手螺旋定则\n 3. 叉乘不符合交换律\n 4. 可以建立三维坐标中的直角坐标系$\\vec{x}\\times\\vec{y}=+\\vec{z}$（右手坐标系）\n    $$ \\vec{a}\\times\\vec{b}= \\begin{pmatrix}y_az_b-y_bz_a \\z_ax_b-x_az_b\\x_ay_b-y_ax_b \\end{pmatrix} $$ $$ \\vec{a}\\times\\vec{b}= a*b= \\begin{pmatrix}0 & -z_a & y_a\\z_a & 0 & -x_a\\-y_a & x_a & 0 \\end{pmatrix} \\begin{pmatrix}x_b\\y_b\\z_b \\end{pmatrix} $$\n\n叉乘在图形学里\n\n 1. 判定向量的左右侧关系，$\\vec{a}\\times\\vec{b}>0$则b在a的左侧，a逆时针旋转可以转到b的方向\n 2. 判定向量的内外\n\n\n# 3 矩阵\n\n 1. 一个二维的array（m*n，m是行数，n是列数）\n 2. 矩阵和数字的加减乘除都是直接运算到矩阵里的每一个数字\n\n\n# 3.1 矩阵乘积 matrix-matrix multiplication\n\n 1. 乘积对矩阵大小有要求(m*n)(n*p)=(m*p)，第一个矩阵的列数必须等于第二个举证的行数\n 2. 矩阵乘积得到的元素(i,j)就是第一个矩阵i行依次与第二个矩阵j列乘积求和\n 3. 矩阵乘积没有任何交换律，有结合律和分配率\n\n\n# 3.2 矩阵转置 transpose of a matrix\n\n 1. 行列互换\n 2. $(ab)^t = b^ta^t$\n\n\n# 3.3 单位矩阵\n\n 1. $i_{3\\times3} = \\begin{pmatrix}1 & 0 & 0\\0 & 1 & 0\\0 & 0 & 1 \\end{pmatrix}$\n 2. $aa^{-1} = a^{-1}a = i$\n 3. $(ab)^{-1} = b^{-1}a^{-1} = i$\n\n\n# 3.4 向量乘法以矩阵形式展示\n\n 1. 点乘$\\vec{a}\\cdot \\vec{b} = \\vec{a}^t\\vec{b} = \\begin{pmatrix}x_a\\y_a\\z_a\\end{pmatrix}\\begin{pmatrix}x_b&y_b&z_b\\end{pmatrix} =(x_ax_b+y_ay_b+z_az_b)$\n 2. 叉乘$\\vec{a}\\times \\vec{b} = a^*b=\\begin{pmatrix}0&-z_a&y_a\\z_a&0&-x_a\\-y_a&x_a&0\\end{pmatrix}\\begin{pmatrix}x_b\\y_b\\x_b\\end{pmatrix}$",charsets:{cjk:!0}},{title:"变换",frontmatter:{title:"变换",date:"2023-08-10T13:44:59.000Z",permalink:"/pages/37eb01/",categories:["《Web3D理论基础》","《现代计算机图形学》"],tags:["Web3D"]},regularPath:"/%E3%80%8AWeb3D%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E3%80%8B/01.%E3%80%8A%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E3%80%8B/03.%E5%8F%98%E6%8D%A2.html",relativePath:"《Web3D理论基础》/01.《现代计算机图形学》/03.变换.md",key:"v-17908965",path:"/pages/37eb01/",headers:[{level:2,title:"1 变换概论 Transformation",slug:"_1-变换概论-transformation",normalizedTitle:"1 变换概论 transformation",charIndex:2},{level:3,title:"1.1 模型变化 Modeling",slug:"_1-1-模型变化-modeling",normalizedTitle:"1.1 模型变化 modeling",charIndex:28},{level:3,title:"1.2 视角变换 Viewing",slug:"_1-2-视角变换-viewing",normalizedTitle:"1.2 视角变换 viewing",charIndex:50},{level:2,title:"2 二维变换",slug:"_2-二维变换",normalizedTitle:"2 二维变换",charIndex:71},{level:3,title:"2.1 线性变换 Linear Transforms",slug:"_2-1-线性变换-linear-transforms",normalizedTitle:"2.1 线性变换 linear transforms",charIndex:82},{level:4,title:"2.1.1 缩放变换 Scale",slug:"_2-1-1-缩放变换-scale",normalizedTitle:"2.1.1 缩放变换 scale",charIndex:131},{level:4,title:"2.1.2 翻转变换 Reflection",slug:"_2-1-2-翻转变换-reflection",normalizedTitle:"2.1.2 翻转变换 reflection",charIndex:153},{level:4,title:"2.1.3 拉伸变换 Shear",slug:"_2-1-3-拉伸变换-shear",normalizedTitle:"2.1.3 拉伸变换 shear",charIndex:180},{level:4,title:"2.1.4 旋转变换 Rotation",slug:"_2-1-4-旋转变换-rotation",normalizedTitle:"2.1.4 旋转变换 rotation",charIndex:202},{level:3,title:"2.2 平移变换 Translation",slug:"_2-2-平移变换-translation",normalizedTitle:"2.2 平移变换 translation",charIndex:249},{level:4,title:"2.2.1 齐次坐标 Homogeneous coordinates",slug:"_2-2-1-齐次坐标-homogeneous-coordinates",normalizedTitle:"2.2.1 齐次坐标 homogeneous coordinates",charIndex:316},{level:3,title:"2.3 齐次坐标下各类变换",slug:"_2-3-齐次坐标下各类变换",normalizedTitle:"2.3 齐次坐标下各类变换",charIndex:504},{level:4,title:"2.3.1 仿射变换 Affine Transformations",slug:"_2-3-1-仿射变换-affine-transformations",normalizedTitle:"2.3.1 仿射变换 affine transformations",charIndex:521},{level:4,title:"2.3.1 缩放变换 Scale",slug:"_2-3-1-缩放变换-scale",normalizedTitle:"2.3.1 缩放变换 scale",charIndex:560},{level:4,title:"2.3.2 旋转变换 Rotation",slug:"_2-3-2-旋转变换-rotation",normalizedTitle:"2.3.2 旋转变换 rotation",charIndex:582},{level:4,title:"2.3.3 平移变换 Translation",slug:"_2-3-3-平移变换-translation",normalizedTitle:"2.3.3 平移变换 translation",charIndex:607},{level:4,title:"2.3.4 逆变换 Inverse Transform",slug:"_2-3-4-逆变换-inverse-transform",normalizedTitle:"2.3.4 逆变换 inverse transform",charIndex:635},{level:3,title:"2.4 变换组合 Composite Transform",slug:"_2-4-变换组合-composite-transform",normalizedTitle:"2.4 变换组合 composite transform",charIndex:669},{level:2,title:"3 三维变换",slug:"_3-三维变换",normalizedTitle:"3 三维变换",charIndex:801},{level:3,title:"3.1 三维的齐次坐标",slug:"_3-1-三维的齐次坐标",normalizedTitle:"3.1 三维的齐次坐标",charIndex:812},{level:3,title:"3.2 三维齐次坐标下的各类变换",slug:"_3-2-三维齐次坐标下的各类变换",normalizedTitle:"3.2 三维齐次坐标下的各类变换",charIndex:905},{level:4,title:"3.2.1 仿射变换 Affine Transformations",slug:"_3-2-1-仿射变换-affine-transformations",normalizedTitle:"3.2.1 仿射变换 affine transformations",charIndex:925},{level:4,title:"3.2.2 缩放变换 Scale",slug:"_3-2-2-缩放变换-scale",normalizedTitle:"3.2.2 缩放变换 scale",charIndex:983},{level:4,title:"3.2.3 平移变换 Translation",slug:"_3-2-3-平移变换-translation",normalizedTitle:"3.2.3 平移变换 translation",charIndex:1005},{level:3,title:"3.3 旋转",slug:"_3-3-旋转",normalizedTitle:"3.3 旋转",charIndex:1034},{level:4,title:"3.3.1 绕着坐标轴旋转",slug:"_3-3-1-绕着坐标轴旋转",normalizedTitle:"3.3.1 绕着坐标轴旋转",charIndex:1044},{level:4,title:"3.3.2 罗德里格斯旋转公式 Rodrigues’ Rotation Formula",slug:"_3-3-2-罗德里格斯旋转公式-rodrigues-rotation-formula",normalizedTitle:"3.3.2 罗德里格斯旋转公式 rodrigues’ rotation formula",charIndex:1114},{level:2,title:"4 观测变换 Viewing transformation",slug:"_4-观测变换-viewing-transformation",normalizedTitle:"4 观测变换 viewing transformation",charIndex:1238},{level:3,title:"4.1 视图变换 View / Camera Transformation",slug:"_4-1-视图变换-view-camera-transformation",normalizedTitle:"4.1 视图变换 view / camera transformation",charIndex:1388},{level:4,title:"4.1.1 首先定义相机",slug:"_4-1-1-首先定义相机",normalizedTitle:"4.1.1 首先定义相机",charIndex:1429},{level:4,title:"4.1.2 相机移动到约定位置",slug:"_4-1-2-相机移动到约定位置",normalizedTitle:"4.1.2 相机移动到约定位置",charIndex:1667},{level:3,title:"4.2 投影变换 Projection transformation",slug:"_4-2-投影变换-projection-transformation",normalizedTitle:"4.2 投影变换 projection transformation",charIndex:1837},{level:4,title:"4.2.1 正交投影 Orthographic projection",slug:"_4-2-1-正交投影-orthographic-projection",normalizedTitle:"4.2.1 正交投影 orthographic projection",charIndex:1954},{level:4,title:"4.2.2 透视投影 Perspective projection",slug:"_4-2-2-透视投影-perspective-projection",normalizedTitle:"4.2.2 透视投影 perspective projection",charIndex:2163},{level:5,title:"x，y坐标关系",slug:"x-y坐标关系",normalizedTitle:"x，y坐标关系",charIndex:2275},{level:5,title:"z坐标关系",slug:"z坐标关系",normalizedTitle:"z坐标关系",charIndex:2320}],headersStr:"1 变换概论 Transformation 1.1 模型变化 Modeling 1.2 视角变换 Viewing 2 二维变换 2.1 线性变换 Linear Transforms 2.1.1 缩放变换 Scale 2.1.2 翻转变换 Reflection 2.1.3 拉伸变换 Shear 2.1.4 旋转变换 Rotation 2.2 平移变换 Translation 2.2.1 齐次坐标 Homogeneous coordinates 2.3 齐次坐标下各类变换 2.3.1 仿射变换 Affine Transformations 2.3.1 缩放变换 Scale 2.3.2 旋转变换 Rotation 2.3.3 平移变换 Translation 2.3.4 逆变换 Inverse Transform 2.4 变换组合 Composite Transform 3 三维变换 3.1 三维的齐次坐标 3.2 三维齐次坐标下的各类变换 3.2.1 仿射变换 Affine Transformations 3.2.2 缩放变换 Scale 3.2.3 平移变换 Translation 3.3 旋转 3.3.1 绕着坐标轴旋转 3.3.2 罗德里格斯旋转公式 Rodrigues’ Rotation Formula 4 观测变换 Viewing transformation 4.1 视图变换 View / Camera Transformation 4.1.1 首先定义相机 4.1.2 相机移动到约定位置 4.2 投影变换 Projection transformation 4.2.1 正交投影 Orthographic projection 4.2.2 透视投影 Perspective projection x，y坐标关系 z坐标关系",content:"# 1 变换概论 Transformation\n\n\n# 1.1 模型变化 Modeling\n\n\n# 1.2 视角变换 Viewing\n\n\n# 2 二维变换\n\n\n# 2.1 线性变换 Linear Transforms\n\n线性变换的矩阵是一个相同维度的矩阵\n\n# 2.1.1 缩放变换 Scale\n\n\n\n# 2.1.2 翻转变换 Reflection\n\n\n\n# 2.1.3 拉伸变换 Shear\n\n\n\n# 2.1.4 旋转变换 Rotation\n\n 1. 基于(0,0)旋转，默认逆时针旋转\n\n\n# 2.2 平移变换 Translation\n\n 1. 平移变换不是一种线性变换\n 2. 为了解决这个问题，引入齐次坐标\n 3. \n\n# 2.2.1 齐次坐标 Homogeneous coordinates\n\n 1. 增加一个维度来描述空间\n\n * 2维点(x,y,1)T\n * 2维向量(x,y,0)T\n\n 2. 齐次坐标添加0,1的原因\n    1. 向量+向量 = 向量\n    2. 点-点 = 向量\n    3. 点+向量 = 向量\n    4. 点+点 = 两个点的中点\n 3. 在齐次坐标下\n\n\n# 2.3 齐次坐标下各类变换\n\n# 2.3.1 仿射变换 Affine Transformations\n\n\n\n# 2.3.1 缩放变换 Scale\n\n\n\n# 2.3.2 旋转变换 Rotation\n\n\n\n# 2.3.3 平移变换 Translation\n\n\n\n# 2.3.4 逆变换 Inverse Transform\n\n\n\n\n# 2.4 变换组合 Composite Transform\n\n 1. 复杂变换可以根据一系列简单的变换得到\n 2. 复杂变换顺序很重要，因为矩阵叉乘不满足交换律\n 3. 简单变化的顺序反应到矩阵上就是下一步变换矩阵放在左侧\n 4. 变换不仅能合成还能够分解\n\n\n# 3 三维变换\n\n\n# 3.1 三维的齐次坐标\n\n 1. 3维点(x,y,z,1)T\n 2. 3维向量(x,y,z,0)T\n 3. 一般来说(x,y,z,w)表示一个三维坐标(x/w,y/w,z/w)\n\n\n# 3.2 三维齐次坐标下的各类变换\n\n# 3.2.1 仿射变换 Affine Transformations\n\n和二维空间一样，也是先线性变换，再平移\n\n# 3.2.2 缩放变换 Scale\n\n\n\n# 3.2.3 平移变换 Translation\n\n\n\n\n# 3.3 旋转\n\n# 3.3.1 绕着坐标轴旋转\n\n绕y轴旋转的矩阵与另外两个存在差异的原因是，y轴由z轴叉乘x轴得到，而不是x轴叉乘z轴。所以矩阵是反的\n\n# 3.3.2 罗德里格斯旋转公式 Rodrigues’ Rotation Formula\n\n\n\n 1. 绕着旋转轴n旋转角度α，这里默认旋转轴过原点\n 2. 如果要沿着任意轴旋转，先进行平移，使得旋转轴的起点在原点，然后旋转，最后再平移复原\n\n\n# 4 观测变换 Viewing transformation\n\n得到照片的过程（三维转二维观察的过程）\n\n 1. 模型变换 model transformation\n 2. 视图变换 view transformation\n 3. 投影变换 projection transformation\n\n\n# 4.1 视图变换 View / Camera Transformation\n\n# 4.1.1 首先定义相机\n\n 1. 相机位置 - Position （e向量）\n 2. 相机观测方向 Look-at / gaze direction （g向量）\n 3. 相机向上方向 Up direction （t向量）\n\n由于相机和物体相对不变的时候，结果不会改变，所以相机约定固定，所有的视图变换都转变为物体变换\n\n 1. 相机和物体应用同样变换的方法，对视觉没有影响\n 2. 相机约定固定在原点\n 3. 相机约定固定朝-z方向观看\n 4. 相机约定以y轴为向上\n\n# 4.1.2 相机移动到约定位置\n\n 1. 先将e点平移至原点\n 2. 将g向量旋转到-z方向\n 3. 将t向量旋转到y方向\n\n`Mview`矩阵的求法\n\n 1. 由于是先平移后旋转，所以不能写成仿射变换\n 2. 旋转变化直接写矩阵很难，所以我们先计算其逆矩阵\n 3. 因为旋转矩阵上半部分是一个正交矩阵，所以求逆就是上半部分求转置\n\n\n# 4.2 投影变换 Projection transformation\n\n 1. 投影是一种从3D到2D的过程\n 2. 分为正交投影Orthographic projection和透视Perspective projection\n\n# 4.2.1 正交投影 Orthographic projection\n\n简单理解\n\n 1. 将相机和物体统一移动旋转至相机处于约定位置\n 2. 丢弃z坐标（这样无法区分物体的上下关系）\n 3. 将x，y缩放到-1,1区间\n\n正式做法\n\n将一个把物体包裹的长方体[l, r] x [b, t] x [f, n] 变换为一个标准(canonical)立方体[-1, 1]3\n\n * 在右手系里面z坐标值是近大于远的\n\n# 4.2.2 透视投影 Perspective projection\n\n将透视的棱台变为长方体过程中遵循以下规律\n\n 1. 远平面上的点z轴坐标不变\n 2. 远平面中心点所有坐标不变\n 3. 近平面上所有店所有坐标不变\n\n# x，y坐标关系\n\n从垂直于x轴或者垂直于y轴来看得到下面的相似三角形 齐次坐标系下\n\n# z坐标关系\n\n投影变正交矩阵\n\n 1. 根据近平面所有点z坐标不变\n 2. 根据远平面z坐标不变\n 3. 联立方程组求解",normalizedContent:"# 1 变换概论 transformation\n\n\n# 1.1 模型变化 modeling\n\n\n# 1.2 视角变换 viewing\n\n\n# 2 二维变换\n\n\n# 2.1 线性变换 linear transforms\n\n线性变换的矩阵是一个相同维度的矩阵\n\n# 2.1.1 缩放变换 scale\n\n\n\n# 2.1.2 翻转变换 reflection\n\n\n\n# 2.1.3 拉伸变换 shear\n\n\n\n# 2.1.4 旋转变换 rotation\n\n 1. 基于(0,0)旋转，默认逆时针旋转\n\n\n# 2.2 平移变换 translation\n\n 1. 平移变换不是一种线性变换\n 2. 为了解决这个问题，引入齐次坐标\n 3. \n\n# 2.2.1 齐次坐标 homogeneous coordinates\n\n 1. 增加一个维度来描述空间\n\n * 2维点(x,y,1)t\n * 2维向量(x,y,0)t\n\n 2. 齐次坐标添加0,1的原因\n    1. 向量+向量 = 向量\n    2. 点-点 = 向量\n    3. 点+向量 = 向量\n    4. 点+点 = 两个点的中点\n 3. 在齐次坐标下\n\n\n# 2.3 齐次坐标下各类变换\n\n# 2.3.1 仿射变换 affine transformations\n\n\n\n# 2.3.1 缩放变换 scale\n\n\n\n# 2.3.2 旋转变换 rotation\n\n\n\n# 2.3.3 平移变换 translation\n\n\n\n# 2.3.4 逆变换 inverse transform\n\n\n\n\n# 2.4 变换组合 composite transform\n\n 1. 复杂变换可以根据一系列简单的变换得到\n 2. 复杂变换顺序很重要，因为矩阵叉乘不满足交换律\n 3. 简单变化的顺序反应到矩阵上就是下一步变换矩阵放在左侧\n 4. 变换不仅能合成还能够分解\n\n\n# 3 三维变换\n\n\n# 3.1 三维的齐次坐标\n\n 1. 3维点(x,y,z,1)t\n 2. 3维向量(x,y,z,0)t\n 3. 一般来说(x,y,z,w)表示一个三维坐标(x/w,y/w,z/w)\n\n\n# 3.2 三维齐次坐标下的各类变换\n\n# 3.2.1 仿射变换 affine transformations\n\n和二维空间一样，也是先线性变换，再平移\n\n# 3.2.2 缩放变换 scale\n\n\n\n# 3.2.3 平移变换 translation\n\n\n\n\n# 3.3 旋转\n\n# 3.3.1 绕着坐标轴旋转\n\n绕y轴旋转的矩阵与另外两个存在差异的原因是，y轴由z轴叉乘x轴得到，而不是x轴叉乘z轴。所以矩阵是反的\n\n# 3.3.2 罗德里格斯旋转公式 rodrigues’ rotation formula\n\n\n\n 1. 绕着旋转轴n旋转角度α，这里默认旋转轴过原点\n 2. 如果要沿着任意轴旋转，先进行平移，使得旋转轴的起点在原点，然后旋转，最后再平移复原\n\n\n# 4 观测变换 viewing transformation\n\n得到照片的过程（三维转二维观察的过程）\n\n 1. 模型变换 model transformation\n 2. 视图变换 view transformation\n 3. 投影变换 projection transformation\n\n\n# 4.1 视图变换 view / camera transformation\n\n# 4.1.1 首先定义相机\n\n 1. 相机位置 - position （e向量）\n 2. 相机观测方向 look-at / gaze direction （g向量）\n 3. 相机向上方向 up direction （t向量）\n\n由于相机和物体相对不变的时候，结果不会改变，所以相机约定固定，所有的视图变换都转变为物体变换\n\n 1. 相机和物体应用同样变换的方法，对视觉没有影响\n 2. 相机约定固定在原点\n 3. 相机约定固定朝-z方向观看\n 4. 相机约定以y轴为向上\n\n# 4.1.2 相机移动到约定位置\n\n 1. 先将e点平移至原点\n 2. 将g向量旋转到-z方向\n 3. 将t向量旋转到y方向\n\n`mview`矩阵的求法\n\n 1. 由于是先平移后旋转，所以不能写成仿射变换\n 2. 旋转变化直接写矩阵很难，所以我们先计算其逆矩阵\n 3. 因为旋转矩阵上半部分是一个正交矩阵，所以求逆就是上半部分求转置\n\n\n# 4.2 投影变换 projection transformation\n\n 1. 投影是一种从3d到2d的过程\n 2. 分为正交投影orthographic projection和透视perspective projection\n\n# 4.2.1 正交投影 orthographic projection\n\n简单理解\n\n 1. 将相机和物体统一移动旋转至相机处于约定位置\n 2. 丢弃z坐标（这样无法区分物体的上下关系）\n 3. 将x，y缩放到-1,1区间\n\n正式做法\n\n将一个把物体包裹的长方体[l, r] x [b, t] x [f, n] 变换为一个标准(canonical)立方体[-1, 1]3\n\n * 在右手系里面z坐标值是近大于远的\n\n# 4.2.2 透视投影 perspective projection\n\n将透视的棱台变为长方体过程中遵循以下规律\n\n 1. 远平面上的点z轴坐标不变\n 2. 远平面中心点所有坐标不变\n 3. 近平面上所有店所有坐标不变\n\n# x，y坐标关系\n\n从垂直于x轴或者垂直于y轴来看得到下面的相似三角形 齐次坐标系下\n\n# z坐标关系\n\n投影变正交矩阵\n\n 1. 根据近平面所有点z坐标不变\n 2. 根据远平面z坐标不变\n 3. 联立方程组求解",charsets:{cjk:!0}}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"前端",link:"/web/",items:[{text:"学习笔记",items:[{text:"JavaScript",link:"/note/javascript/"},{text:"HTML",link:"/pages/2eedd5/"},{text:"CSS",link:"/pages/2729d6/"},{text:"Vue",link:"/note/vue/"},{text:"Webpack",link:"http://xxpromise.gitee.io/webpack5-docs"}]},{text:"开发文档",items:[{text:"ABP故障诊断系统开发文档",link:"/pages/196903/"},{text:"Electron-vue桌面端开发总结",link:"/pages/a1eaa9/"}]}]},{text:"计算机基础",link:"/basic/",items:[{text:"计算机网络",link:"/pages/c317e3/"},{text:"操作系统",link:"/pages/8b9558/"},{text:"Git",link:"/pages/184fd9/"},{text:"Docker",link:""},{text:"Nginx",link:""},{text:"Web3D",link:"/note/Web3D/"}]},{text:"其他技术",link:"/technology/",items:[{text:"Python",link:"/pages/42ad71/"},{text:"Java",link:""},{text:"机器学习",link:""}]},{text:"更多",link:"/more/",items:[{text:"大屏故障诊断系统",link:"http://wenshuyuan.work:4900/"},{text:"面试",link:"/pages/cd11f8/"},{text:"收藏",link:"/pages/8384dd/"},{text:"实战技巧",link:""}]},{text:"索引",link:"/archives/",items:[{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"}]}],sidebarDepth:2,logo:"/img/tosaka.png",repo:"wsy425",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",bodyBgImg:"/img/background.png",bodyBgImgOpacity:.7,sidebar:{"/00.目录页/":[["01.前端.md","前端","/web"],["02.计算机基础.md","计算机基础","/basic"],["03.技术.md","其他技术","/technology"],["04.更多.md","更多","/more"]],catalogue:{"前端":"/web","计算机基础":"/basic","技术":"/technology","更多":"/more"," JavaScript":"/note/javascript"," Vue":"/note/vue"},"/01.前端/":[{title:"学习笔记",collapsable:!0,children:[["20.学习笔记/00. JavaScript.md","JavaScript","/note/javascript"],["20.学习笔记/05. HTML.md","HTML","/pages/2eedd5/"],["20.学习笔记/10. CSS.md","CSS","/pages/2729d6/"],["20.学习笔记/15. Vue.md","Vue","/note/vue"],["20.学习笔记/20. Elctron.md","Elctron","/pages/74c0eb/"],["20.学习笔记/25. ThreeJS.md","ThreeJS","/pages/3bf799/"],["20.学习笔记/35.TypeScript笔记.md","TypeScript笔记","/pages/51afd6/"]]},{title:"开发文档",collapsable:!0,children:[["40.开发文档/00.ABP故障诊断系统开发文档.md","ABP故障诊断系统开发文档","/pages/196903/"],["40.开发文档/05.Electron-vue桌面端开发总结.md","Electron-vue桌面端开发总结","/pages/a1eaa9/"]]}],"/02.计算机基础/":[{title:" 计算机网络",collapsable:!0,children:[["00. 计算机网络/00. 计算机网络.md","计算机网络","/pages/c317e3/"]]},{title:" 操作系统",collapsable:!0,children:[["05. 操作系统/05. 操作系统.md","操作系统","/pages/8b9558/"]]},{title:" Git",collapsable:!0,children:[["10. Git/00. Git.md","Git","/pages/184fd9/"]]},{title:" Docker",collapsable:!0,children:[]},{title:" Ngix",collapsable:!0,children:[]},{title:" Web3D",collapsable:!0,children:[]}],"/03.其他技术/":[{title:" Python",collapsable:!0,children:[["00. Python/00. Python语法.md","Python语法","/pages/42ad71/"],["00. Python/05. Numpy.md","Numpy","/pages/726723/"],["00. Python/10. Matplotlib.md","Matplotlib","/pages/18746f/"]]},{title:" Java",collapsable:!0,children:[]},{title:" 机器学习",collapsable:!0,children:[]}],"/04.更多/":[{title:" 面试",collapsable:!0,children:[["00. 面试/00. 前端面试八股文.md","前端面试八股文","/pages/cd11f8/"],["00. 面试/05. 美团前端实习一面.md","美团前端实习一面","/pages/8e13ff/"]]},["05. 收藏.md","收藏","/pages/8384dd/"],{title:" 实战技巧",collapsable:!0,children:[]}],"/05.关于/":[["01.关于.md","关于","/about"]],"/06.收藏夹/":[["01.网站.md","网站","/pages/beb6c0bd8a66cea6"],["02.常用的前端轮子.md","常用的前端轮子","/pages/47cf96/"]],"/《JavaScript》/":[{title:"《JavaScript初学》",collapsable:!0,children:[["01.《JavaScript初学》/00. JS基础.md","JS基础","/pages/618466/"],["01.《JavaScript初学》/05. ES6-11.md","ES6-11","/pages/2431b2/"],["01.《JavaScript初学》/10. Web APIs.md","Web APIs","/pages/f2f3bd/"]]},{title:"《现代JavaScript教程》",collapsable:!0,children:[{title:" JavaScript编程语言",collapsable:!0,children:[["02.《现代JavaScript教程》/00. JavaScript编程语言/00. 简介.md","简介","/pages/9503d3/"],["02.《现代JavaScript教程》/00. JavaScript编程语言/01. JavaScript基础知识.md","JavaScript基础知识","/pages/f7ae59/"],["02.《现代JavaScript教程》/00. JavaScript编程语言/02. JavaScript基础语法.md","JavaScript基础语法","/pages/d2d293/"],["02.《现代JavaScript教程》/00. JavaScript编程语言/03. Object对象.md","Object对象","/pages/ad315d/"],["02.《现代JavaScript教程》/00. JavaScript编程语言/04.数据类型.md","数据类型","/pages/74296a/"]]},{title:" 浏览器：文档、事件、接口",collapsable:!0,children:[]}]}],"/《TypeScript 从零实现 axios》/":[{title:"初识 TypeScript",collapsable:!0,children:[["01.初识 TypeScript/01.简介.md","简介","/pages/e05dce83e5129785"],["01.初识 TypeScript/02.安装 TypeScript.md","安装 TypeScript","/pages/064e0f7b6b6142c8"],["01.初识 TypeScript/03.编写第一个 TypeScript 程序.md","编写第一个 TypeScript 程序","/pages/c85249f40e7a3517"]]},{title:"TypeScript 常用语法",collapsable:!0,children:[["02.TypeScript 常用语法/01.基础类型.md","基础类型","/pages/28672e2743bbc3a7"],["02.TypeScript 常用语法/02.变量声明.md","变量声明","/pages/54add7f5cf78088e"],["02.TypeScript 常用语法/03.接口.md","接口","/pages/54ea89b497ec3bb3"],["02.TypeScript 常用语法/04.类.md","类","/pages/fad060bd9a8bfac6"],["02.TypeScript 常用语法/05.函数.md","函数","/pages/870a51ba2a9edfad"],["02.TypeScript 常用语法/06.泛型.md","泛型","/pages/8045759ec4ad3c01"],["02.TypeScript 常用语法/07.类型推断.md","类型推断","/pages/7279420c899c505d"],["02.TypeScript 常用语法/08.高级类型.md","高级类型","/pages/3fb6c2f52ab398e3"]]},{title:"ts-axios 项目初始化",collapsable:!0,children:[["03.ts-axios 项目初始化/01.需求分析.md","需求分析","/pages/195af93fcc871b8b"],["03.ts-axios 项目初始化/02.初始化项目.md","初始化项目","/pages/6e11ac76475a2b3e"],["03.ts-axios 项目初始化/03.编写基础请求代码.md","编写基础请求代码","/pages/acfe1e0b401fa984"]]},{title:"ts-axios 基础功能实现",collapsable:!0,children:[["04.ts-axios 基础功能实现/01.处理请求 url 参数.md","处理请求 url 参数","/pages/1313dae575f6dddf"],["04.ts-axios 基础功能实现/02.处理请求 body 数据.md","处理请求 body 数据","/pages/887cd0918e2543d8"],["04.ts-axios 基础功能实现/03.处理请求 header.md","处理请求 header","/pages/35c0ec1bb0b0faaf"],["04.ts-axios 基础功能实现/04.获取响应数据.md","获取响应数据","/pages/a57debe141e1e4f4"],["04.ts-axios 基础功能实现/05.处理响应 header.md","处理响应 header","/pages/927161662ca32c24"],["04.ts-axios 基础功能实现/06.处理响应 data.md","处理响应 data","/pages/922cb4268499dc3f"]]},{title:"ts-axios 异常情况处理",collapsable:!0,children:[["05.ts-axios 异常情况处理/01.错误处理.md","错误处理","/pages/6a8bef7b98dfdcf9"],["05.ts-axios 异常情况处理/02.错误信息增强.md","错误信息增强","/pages/22d581d8c2860b8a"]]},{title:"ts-axios 接口扩展",collapsable:!0,children:[["06.ts-axios 接口扩展/01.扩展接口.md","扩展接口","/pages/034e320f4af88bd4"],["06.ts-axios 接口扩展/02.axios 函数重载.md","axios 函数重载","/pages/8af227eae851ec97"],["06.ts-axios 接口扩展/03.响应数据支持泛型.md","响应数据支持泛型","/pages/c4489d0bab02cc0c"]]},{title:"ts-axios 拦截器实现",collapsable:!0,children:[["07.ts-axios 拦截器实现/01.拦截器设计与实现.md","拦截器设计与实现","/pages/70651900f022f586"]]},{title:"ts-axios 配置化实现",collapsable:!0,children:[["08.ts-axios 配置化实现/01.合并配置的设计与实现.md","合并配置的设计与实现","/pages/937e4de6b81edeca"],["08.ts-axios 配置化实现/02.请求和响应配置化.md","请求和响应配置化","/pages/f5b627bfebba87fc"],["08.ts-axios 配置化实现/03.扩展 create 静态接口.md","扩展 create 静态接口","/pages/7b49658c26f613bf"]]},{title:"ts-axios 取消功能实现",collapsable:!0,children:[["09.ts-axios 取消功能实现/01.取消功能的设计与实现.md","取消功能的设计与实现","/pages/fdc6da5372397430"]]},{title:"ts-axios 更多功能实现",collapsable:!0,children:[["10.ts-axios 更多功能实现/01.withCredentials.md","withCredentials","/pages/5dce43eba796a2ab"],["10.ts-axios 更多功能实现/02.XSRF 防御.md","XSRF 防御","/pages/390cb70e2b619449"],["10.ts-axios 更多功能实现/03.上传和下载的进度监控.md","上传和下载的进度监控","/pages/1376fd897809036e"],["10.ts-axios 更多功能实现/04.HTTP 授权.md","HTTP 授权","/pages/89cd6496c23159ae"],["10.ts-axios 更多功能实现/05.自定义合法状态码.md","自定义合法状态码","/pages/40b41ce8e8159567"],["10.ts-axios 更多功能实现/06.自定义参数序列化.md","自定义参数序列化","/pages/7753b8141663e54a"],["10.ts-axios 更多功能实现/07.baseURL.md","baseURL","/pages/0b9f2ee2b4dbb728"],["10.ts-axios 更多功能实现/08.静态方法扩展.md","静态方法扩展","/pages/c26b053540a7dafa"]]},{title:"ts-axios 单元测试",collapsable:!0,children:[["11.ts-axios 单元测试/01.前言.md","前言","/pages/df36888424843793"],["11.ts-axios 单元测试/02.Jest 安装和配置.md","Jest 安装和配置","/pages/bf5c625a35757b37"],["11.ts-axios 单元测试/03.辅助模块单元测试.md","辅助模块单元测试","/pages/13f147a9b355c4c1"],["11.ts-axios 单元测试/04.请求模块单元测试.md","请求模块单元测试","/pages/e1d15dec8634e6b5"],["11.ts-axios 单元测试/05.headers 模块单元测试.md","headers 模块单元测试","/pages/ddd86ec39b5dfe33"],["11.ts-axios 单元测试/06.Axios 实例模块单元测试.md","Axios 实例模块单元测试","/pages/2eac7a0a0d644c15"],["11.ts-axios 单元测试/07.拦截器模块单元测试.md","拦截器模块单元测试","/pages/97de6fd6293a2c6e"],["11.ts-axios 单元测试/08.mergeConfig 模块单元测试.md","mergeConfig 模块单元测试","/pages/cdf59840306f9e81"],["11.ts-axios 单元测试/09.请求取消模块单元测试.md","请求取消模块单元测试","/pages/6fa16aee29527032"],["11.ts-axios 单元测试/10.剩余模块单元测试.md","剩余模块单元测试","/pages/9572134781ba6a25"]]},{title:"ts-axios 部署与发布",collapsable:!0,children:[["12.ts-axios 部署与发布/01.ts-axios 编译与发布.md","ts-axios 编译与发布","/pages/3e5d5a45ad50f198"],["12.ts-axios 部署与发布/02.引用 ts-axios 库.md","引用 ts-axios 库","/pages/c6bdbd5bd60adf5a"]]}],"/《Vue》/":[["00. Vue概念原理.md","Vue概念原理","/pages/81066a/"],["05.  Vue核心.md","Vue核心","/pages/4e0a77/"],["10. Vue组件化.md","Vue组件化","/pages/ecec85/"],["15. Vue CLI.md","Vue CLI","/pages/9c8d2a/"],["20. Vuex.md","Vuex","/pages/ea2c16/"],["25. Vue Router.md","Vue Router","/pages/2ab1b4/"],["30. Vue3.md","Vue3","/pages/d6c83e/"]],"/《Web3D理论基础》/":[{title:"《现代计算机图形学》",collapsable:!0,children:[["01.《现代计算机图形学》/00. 课程概论.md","课程概论","/pages/9ba5d9/"],["01.《现代计算机图形学》/02. 向量与线性代数.md","向量与线性代数","/pages/26dab9/"],["01.《现代计算机图形学》/03.变换.md","变换","/pages/37eb01/"]]}]},author:{name:"年华惊风雨",link:"https://github.com/wsy425"},blogger:{avatar:"https://pic.imgdb.cn/item/625414d8239250f7c5eabd62.jpg",name:"年华惊风雨",slogan:"一时竟想不出什么可以写"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:1565330830@qq.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/wsy425"},{iconClass:"icon-erji",title:"听音乐",link:"https://music.163.com/#/playlist?id=755597173"}]},footer:{createYear:2022,copyrightInfo:""}},locales:{"/":{lang:"zh-CN",title:"年华惊风雨的知识库",description:"简简单单的知识库汇总",path:"/"}}},ll=(t(151),t(207),t(138),t(217)),cl=t(218),ul=(t(371),t(232),t(42));var dl={computed:{$filterPosts:function(){return this.$site.pages.filter((function(n){var e=n.frontmatter,t=e.pageComponent,r=e.article,a=e.home;return!(t||!1===r||!0===a)}))},$sortPosts:function(){return(n=this.$filterPosts).sort((function(n,e){var t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(ul.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(ul.a)(n,e)})),n;var n},$sortPostsByDate:function(){return(n=this.$filterPosts).sort((function(n,e){return Object(ul.a)(n,e)})),n;var n},$groupPosts:function(){return function(n){for(var e={},t={},r=function(r,a){var o=n[r].frontmatter,i=o.categories,s=o.tags;"array"===Object(ul.n)(i)&&i.forEach((function(t){t&&(e[t]||(e[t]=[]),e[t].push(n[r]))})),"array"===Object(ul.n)(s)&&s.forEach((function(e){e&&(t[e]||(t[e]=[]),t[e].push(n[r]))}))},a=0,o=n.length;a<o;a++)r(a);return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags:function(){return function(n){var e=[],t=[];for(var r in n.categories)e.push({key:r,length:n.categories[r].length});for(var a in n.tags)t.push({key:a,length:n.tags[a].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Pa.component(ll.default),Pa.component(cl.default);function pl(n){return n.toString().padStart(2,"0")}t(375);Pa.component("Badge",(function(){return Promise.all([t.e(0),t.e(3)]).then(t.bind(null,573))})),Pa.component("CodeBlock",(function(){return Promise.resolve().then(t.bind(null,217))})),Pa.component("CodeGroup",(function(){return Promise.resolve().then(t.bind(null,218))}));t(376);var ml=[function(n){n.Vue,n.options,n.router,n.siteData},function(n){var e=n.Vue,t=(n.options,n.router,n.siteData);t.pages.map((function(n){var e=n.frontmatter,r=e.date,a=e.author;"string"==typeof r&&"Z"===r.charAt(r.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return"".concat(n.getUTCFullYear(),"-").concat(pl(n.getUTCMonth()+1),"-").concat(pl(n.getUTCDate())," ").concat(pl(n.getUTCHours()),":").concat(pl(n.getUTCMinutes()),":").concat(pl(n.getUTCSeconds()))}(r)),a?n.author=a:t.themeConfig.author&&(n.author=t.themeConfig.author)})),e.mixin(dl)},{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},{},function(n){n.router;"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},function(n){var e=n.router;"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?503f098e7e5b3a5b5d8c5fc2938af002";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),e.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))}],hl=[];t(210);function fl(n,e){return(fl=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}t(211),t(212);function gl(n){return(gl=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function vl(n,e){if(e&&("object"===Ii(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n)}function xl(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,r=gl(n);if(e){var a=gl(this).constructor;t=Reflect.construct(r,arguments,a)}else t=r.apply(this,arguments);return vl(this,t)}}var bl=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),e&&fl(n,e)}(t,n);var e=xl(t);function t(){return cs(this,t),e.apply(this,arguments)}return ds(t)}(function(){function n(){cs(this,n),this.store=new Pa({data:{state:{}}})}return ds(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,e){Pa.set(this.store.state,n,e)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(bl.prototype,{getPageAsyncComponent:$i,getLayoutAsyncComponent:Ji,getAsyncComponent:Hi,getVueComponent:Fi});var yl={install:function(n){var e=new bl;n.$vuepress=e,n.prototype.$vuepress=e}};function Tl(n){n.beforeEach((function(e,t,r){if(wl(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){var a=e.path.replace(/\/$/,"")+".html";wl(n,a)?r(a):r()}else r();else{var o=e.path+"/",i=e.path+".html";wl(n,i)?r(i):wl(n,o)?r(o):r()}}))}function wl(n,e){var t=e.toLowerCase();return n.options.routes.some((function(n){return n.path.toLowerCase()===t}))}var _l={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var e=this.pageKey||this.$parent.$page.key;return Gi("pageKey",e),Pa.component(e)||Pa.component(e,$i(e)),Pa.component(e)?n(e):n("")}},kl={functional:!0,props:{slotKey:String,required:!0},render:function(n,e){var t=e.props,r=e.slots;return n("div",{class:["content__".concat(t.slotKey)]},r()[t.slotKey])}},jl={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Il=(t(377),t(378),Object(al.a)(jl,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function zl(){return(zl=Object(r.a)(regeneratorRuntime.mark((function n(e){var t,r,a,o;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:sl.routerBase||sl.base,Tl(r=new ki({base:t,mode:"history",fallback:!1,routes:il,scrollBehavior:function(n,e,t){return t||(n.hash?!Pa.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})}})),a={},n.prev=4,n.next=7,Promise.all(ml.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:Pa,options:a,router:r,siteData:sl,isServer:e})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return o=new Pa(Object.assign(a,{router:r,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},hl.map((function(e){return n(e)})))])}})),n.abrupt("return",{app:o,router:r});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}Pa.config.productionTip=!1,Pa.use(ki),Pa.use(yl),Pa.mixin(function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Pa;ji(e),t.$vuepress.$set("siteData",e);var r=n(t.$vuepress.$get("siteData")),a=new r,o=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),i={};return Object.keys(o).reduce((function(n,e){return e.startsWith("$")&&(n[e]=o[e].get),n}),i),{computed:i}}((function(n){return function(){function e(){cs(this,e)}return ds(e,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,e,t=this.$site.locales,r=void 0===t?{}:t;for(var a in r)"/"===a?e=r[a]:0===this.$page.path.indexOf(a)&&(n=r[a]);return n||e||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var n=this.$page.frontmatter.canonicalUrl;return"string"==typeof n&&n}},{key:"$title",get:function(){var n=this.$page,e=this.$page.frontmatter.metaTitle;if("string"==typeof e)return e;var t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var e=n.filter((function(n){return"description"===n.name}))[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,e){for(var t=0;t<n.length;t++){var r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),e}()}),sl)),Pa.component("Content",_l),Pa.component("ContentSlotsDistributor",kl),Pa.component("OutboundLink",Il),Pa.component("ClientOnly",{functional:!0,render:function(n,e){var t=e.parent,r=e.children;if(t._isMounted)return r;t.$once("hook:mounted",(function(){t.$forceUpdate()}))}}),Pa.component("Layout",Ji("Layout")),Pa.component("NotFound",Ji("NotFound")),Pa.prototype.$withBase=function(n){var e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"97f6a4c"},function(n){return zl.apply(this,arguments)}(!1).then((function(n){var e=n.app;n.router.onReady((function(){e.$mount("#app")}))}))}]);