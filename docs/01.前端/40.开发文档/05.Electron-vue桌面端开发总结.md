---
title: Electron-vue桌面端开发总结
date: 2023-07-31 17:10:10
permalink: /pages/a1eaa9/
categories:
  - 前端
  - 开发文档
tags:
  - 
---

---
title: Electron-vue桌面端开发总结
date: 2023-07-31 17:10:10
permalink: /pages/47efcd/
categories:
  - 前端
  - 开发文档
tags:
  - Vue
  - Electron
  - NodeJS
---
## 1 网络文件下载至指定地点

### 1.1 使渲染进程使用NodeJS
1. 在vue.config 里添加相关内容将`electronBuilder`作为一个插件进行参数配置
``` js
pluginOptions:{
    electronBuilder:{
      nodeIntegration:true
    }
  }
```
2. `background.js`的`createWindow`方法中的`webPreferences`添加`webSecurity:false`。将浏览器安全策略关闭，使`electron`中的浏览器能够使用`NodeJS`

### 1.2 使用NodeJS的fs模块与axios请求网络文件并保存
1. 组件引入fs`import fs from 'fs'`
2. 将`node_modules`里`axios/lib`的`http.js`内容覆盖`xhr.js`，为了能够使用后端`axios`流形式下载
3. `axios`请求后fs下载到指定地址
```js
axios({
  method:'get',
  url:this.res.data.data[0].middleURL,
  responseType:'stream'
}).then((response)=>{
  response.data.pipe(fs.createWriteStream('E:/code/dog.jpg'))
})
```

## 2 渲染进程开启新窗口

### 2.1 配置新窗口路由
其中router必须是Hash形式，否则会报错
```js
const router = createRouter({
  //必须是hash形式
  history: createWebHashHistory(),
  routes,
});
```

### 2.2 渲染进程向主进程通信
不需要考虑vue组件的问题，子组件也可以直接与主进程通讯

渲染进程

```js
import { ipcRenderer } from "electron";
const CreateWindow = function(){
	ipcRenderer.send("sumbit", "子进程给主进程发送数据");
}
```

主进程

```js
import { ipcMain } from 'electron'
ipcMain.on('sumbit',(event,arg)=>{
  event.reply('reply',"主进程回复")
  console.log(event)
  console.log(arg)
})
```

### 2.3 主进程打开新窗口
需要根据构建和打包的工具进行调整，但原则就是开发的时候获取`localhost:端口`,生产的时候获取`Electron`的代理
```js
ipcMain.on('sumbit',(event,arg)=>{
  event.reply('reply',"主进程回复")
  console.log(event)
  console.log(arg)
  let modal = new BrowserWindow({
    width: 800,
    height: 600,
    webPreferences: {
      nodeIntegration: process.env.ELECTRON_NODE_INTEGRATION,
      contextIsolation: !process.env.ELECTRON_NODE_INTEGRATION,
      webSecurity:false
    }
  })
  //开发环境
  if (process.env.WEBPACK_DEV_SERVER_URL) {
    modal.loadURL(process.env.WEBPACK_DEV_SERVER_URL+ "login")
  } else {
  //生产环境
    createProtocol('app')
    // Load the index.html when not in development
    modal.loadURL('app://./index.html/#/login')
  }
  modal.on("closed", () => {
    modal = null;
  });
})
```

## 3 文件监听

### 3.1 文件夹文件监听
1. 增加、删除和修改文件名的事件为`rename`，文件修改的事件为`change`
2. 其中~文件以及.文件需要判断处理，不是所有的都执行后续的文件信息获取函数
```js
fs.watch(folderUrl.value, (eventType, filename) => {
  changeEvent.value = eventType;
  changeFile.value = filename;
  console.log(eventType, filename);
//   执行文件状态读取函数
  ReadLocal();
});
```

### 3.2 文件夹文件信息获取
1. 存在文件夹叠套的问题还没有解决
```js
const ReadLocal = function () {
  fs.readdir(folderUrl.value + "/", (err, files) => {
    if (err) console.warn(err);
    else {
      FileData.value = [];
      files.forEach((file) => {
        fs.stat(folderUrl.value + "/" + file, (err, stats) => {
          if (err) console.warn(err);
          else {
            const filedata = {
              name: file,
              url: folderUrl.value + file,
              ctime: stats.ctime,
              atime: stats.atime,
              mtime: stats.mtime,
              ctimeMs: stats.ctimeMs,
              mtimeMs: stats.mtimeMs,
              size: stats.size,
              directory: stats.isDirectory(),
            };
            FileData.value.push(filedata);
          }
        });
      });
    }
  });
};
```

## 4 搜索注册表并且启动对应软件

### 4.1 搜索注册表并固化
#### 4.1.1 搜索注册表并保存bat
1. 从卸载目录里面寻找软件是否安装，以及安装的信息
2. `%1`第一个参数是保存至本地的文件路径+文件名
3. `%2`第二个参数是对应软件的注册表key
```sh
@echo off
@REM 将之前的固化注册表信息清空
type nul > %1
@REM ·连接需要查找的注册表键
set str=HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\%2
@REM ·reg query %str% 用来获取注册表指定软件的安装信息
@REM ·for /f "tokens=1,2*" %%i in 按照行循环，并且按照空格将一行的内容分割成3分，忽略第二个空格后的所有空格
for /f "tokens=1,2*" %%i in ('reg query %str%') do (
    @REM ·将3个部分用,隔开逐行写入固化注册表文件
    echo %%i,%%j,%%k>>%1
)
```
#### 4.1.2 渲染进程执行bat文件
1. `exec`执行bat时通过空格进行参数的分割
2. `exec`执行时需要bat的绝对路径而非相对路径
3. 这里使用`process.cwd()`能够通过开发环境，但不能通过生产环境
```js
import { exec } from "child_process";
const GetRegistration = function (software) {
  const url = folder.value + software["DisplayName"] + ".txt";
  console.log("__dirname" + __dirname);
  console.log("__filename" + __filename);
  console.log("process.cwd()" + process.cwd());
  exec(
    process.cwd() + "/public/reg1.bat " + url + " " + software["ID"],
    (error, stdout, stderr) => {
      if (error) {
        console.error("error: " + error);
        return;
      }
      console.log("stdout: " + stdout);
      console.log("stderr: " + typeof stderr);
      ReadRegFile(url, software);
    }
  );
};
```

### 4.2 读取固化的注册表内容并记录在前端
#### 4.2.1 前端用于维护的应用信息
```js
const softwareStats = ref({
  AECmate: {
    DisplayName: "AECMate",
    Name: "AnyBuidingCAD.exe",
    ID: "{61CDF82A-16BB-4FD5-9B8A-5B12C8349D8E}",
    Version: "",
    InstallLocation: "",
    Install: false,
  },
  Revit: {
    DisplayName: "Revit",
    Name: "Revit.exe",
    ID: "{61CDF82A-16BB-4FD5-9B8A-5B12C8349D8E1}",
    Version: "",
    InstallLocation: "",
    Install: false,
  },
  Wukong: {
    DisplayName: "Wukong",
    Name: "WuKong.exe",
    ID: "{85B05B30-FA7A-4698-80F3-022F489ABAEE}",
    Version: "",
    InstallLocation: "",
    Install: false,
  },
});
```
#### 4.2.2 读取固化注册表并修改`softwareStats`
```js
const ReadRegFile = function (url, software) {
  fs.readFile(url, "utf-8", (err, result) => {
    //通过判断文件是否存在确定应用是否安装
    if (err) {
      console.error("error: " + err);
      software["Install"] = false;
    } else {
      software["Install"] = true;
      //将信息按照行分割
      let list = result.split("\r\n");
      //行信息遍历获取需要的
      list.forEach((item) => {
        if (item.includes("InstallLocation")) {
          software["InstallLocation"] = item.split(",")[2];
        }
        if (item.includes("Version")) {
          software["Version"] = item.split(",")[2];
        }
      });
    }
  });
};
```

## 4.3 启动软件
1. 通过\`"${}"\`将字符串强制用`""`包裹，这样可以避免运行路径里面存在空格导致无法执行的问题
```js
const StartSoftware = function (software) {
  exec(
    `"${software["InstallLocation"] + software["Name"]}"`,
    (error, stdout, stderr) => {
      if (error) {
        console.error("error: " + error);
        return;
      }
      console.log("stdout: " + stdout);
      console.log("stderr: " + typeof stderr);
    }
  );
};
```