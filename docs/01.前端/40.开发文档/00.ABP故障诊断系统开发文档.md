---
title: ABP故障诊断系统开发文档
date: 2022-03-27 21:31:48
permalink: /pages/196903/
categories:
  - 前端
  - 开发文档
tags:
  - Angular
  - 开发文档
---
> 本系列旨在以实验室大屏智能监测系统为原型，将开发中使用的技术归纳梳理，记录从头开发类似项目的过程。原型项目实际开发过程中存在很多试错勉强能用的代码，在本次开发过程中尽可能考虑周全，在了解各技术原理的基础上选择合适的方式开发

​	本系列主要分成前端与后端两个部分。前端技术栈主要包含：[Angular](https://angular.cn/docs)，[NG-ZORRO](https://ng.ant.design/docs/introduce/zh)，[ECharts](https://echarts.apache.org)，[fabric](http://fabricjs.com)，signalR。后端技术栈主要包含：cs，Python，后端使用的框架包括[ASP.Net Core](https://docs.microsoft.com/en-us/aspnet/core/getting-started/?view=aspnetcore-6.0&tabs=windows)，ABP，[IdentityServer](https://identityserver4.readthedocs.io/en/latest/)，部署技术使用[Docker](https://www.docker.com/)，操作系统包括Windows和Linux，后端开发主要框架为[ABP](https://abp.io/)。同时本系列预计还包括系统开发前的功能梳理、UI设计以及系统开发后的打包上线部分。

# 启动项目

## 项目模板下载

1. `dotnet tool install -g Volo.Abp.Cli`下载abp框架，需要dotnet。这部分下载可以使用蒋师兄的装机代码从chocolatey上下载
2. `abp new 项目名称 -u angular -dbms MySQL -csf`建立一个包含abp内容的前端模板，以及使用MySQL为数据库的后端模板

![abp模板生成结果](https://pic.imgdb.cn/item/61bf21992ab3f51d919faa8e.png)

下载完毕后会生成两个文件夹，angular是前端文件夹，aspnet-core是后端文件夹

## 项目配置修改

1. `docker run --name 容器名 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=数据库密码 -d mysql:latest`通过docker启动数据库，其中3306:3306前一个是本机访问mysql的端口，后一个是docker镜像内部端口，不建议改
2. 修改后端中数据库连接配置

在	HTTPApi.Host文件夹里的appsetting.json修改以下内容

```cs
 "ConnectionStrings": {
    "Default": "Server=localhost;Port=3306;Database=数据库名称;Uid=root;Pwd=数据库密码;"
  },
```

在DbMigrator里的appsetting.json数据库修改以下内容

```cs
"ConnectionStrings": {
    "Default": "Server=localhost;Port=3306;Database=数据库名称;Uid=root;Pwd=数据库密码;"
  },
```



3. `cd Dashboard.DbMigrator`然后执行`dotnet run`迁移数据库

![数据库迁移成功图](https://pic.imgdb.cn/item/61bf22112ab3f51d919ff07d.png)

4. 启动HTTPApi.Host就可以开启Swagger，证明后端已开启

![Swagger开启图](https://pic.imgdb.cn/item/61bf225b2ab3f51d91a01651.png)

5. 进去前端文件夹`yarn`从package.json中下载依赖项
6. `yarn satrt`开启项目，在本机4200端口就可以看到启动的前端网页

![前端初始页面图](https://pic.imgdb.cn/item/61bf22aa2ab3f51d91a03ae8.jpg)

> 如果你和我一样有其他的angular项目，就需要修改一下端口。因为Angular项目的默认端口都是4200，会存在冲突问题。

7. 在前端`src/enviroments`里的两个ts文件做同样的修改

```typescript
const baseUrl = 'http://localhost:你希望的端口号';
```

8. 在package.json文件中修改`"start": "ng serve --open --port 你希望的端口号",`

9. 保存之后你会发现你的前端报错了，这是因为后端写的端口号是原先默认的4200，所有我们需要对后端做同样的处理。找到之前修改过的两个appsetting.json文件，将其中的4200改成你修改后的端口号，重新启动项目。前端网页刷新后又会显示原先的页面，证明你已经将端口号修改好了

# 项目目录介绍

## 前端项目目录介绍

![前端项目目录](https://pic.imgdb.cn/item/61bf22d32ab3f51d91a05128.png)

> 本人对webpack打包还有前端自动化测试方面的内容一知半解，所以这里只介绍一些与内容直接相关的文件

### node_modules

是你yarn之后下载下来的依赖项，开发过程中可以不用管，你对这个文件夹的修改一般只会来自npm包下载和卸载，不要手动去修改里面的内容

### src

前端开发的内容都在里面

#### app

前端开发的组件，服务等实际的页面内容和页面逻辑

##### home

abp帮你写好的首页组件

##### shared

一般多个组件共用的东西放在里面，比如之后会用到的服务和UI库的自定义主题

##### app的三个文件

app的路由设置，组件依赖注入和app这个挂载自身ts

##### route.provider.ts

abp提供的导航栏中的路由设置

#### assets

静态文件存储的地方，一般放一些项目所需的图片、json文件

#### environments

项目的环境配置，可以在这里设置项目所用到的所有后端url以及自身的输入端口。其中prod是打包后使用的环境配置，另一个是开发阶段使用的环境配置

#### index.html

整个项目的入口文件，主要用来修改网页head的内容

#### main.ts

整个项目的ts文件，基本没改过

#### styles.scss

项目的总scss文件

### package.json

其他的文件基本都是angular自己生成的，不会做修改。比较重要的就是这个文件，你所有的npm包操作都会反应到这个文件里，这里会记载该项目的依赖项，以及你项目开启，打包的命令。

## 后端项目目录介绍

后端项目大方向分为两个部分，一部分为cs语言包含的后端逻辑功能，一部分为Python语言包含的数据诊断与发送功能

### c#

1. 首先是权限管理后端，其项目文件目录结构如下所示：
   ![权限管理后端](https://pic.imgdb.cn/item/61bf23222ab3f51d91a07e36.jpg)
   
   其中src为源文件文件夹，test为功能测试文件夹。使用Rider打开*.sln项目，目录结构如下所示：
   ![权限管理后端目录](https://pic.imgdb.cn/item/61bf234e2ab3f51d91a09488.jpg)
   
   其中：
    - Application：后端逻辑实现，实体间映射目录
    - Contracts：接口定义以及权限定义目录
    - Domain：实体定义、权限种子数据、密码格式设置目录
    - Shared：本地化配置文件目录
    - EFCore：后端与MySQL数据表联系建立
    - DbMigrations：EF数据库管理迁移目录
    - Host：项目模块配置以及项目启动项

# 项目需求分析



## 前端项目需求

1. 登录、注册界面
2. 通过signalR获取数据，进行阈值判断，并显示状态信息
3. 切换数据源
4. 通过监视的状态信息，直接反馈到二维平面图上
5. 系统基础的登录、注销、权限管理
6. 生成报告单，并提供打印功能
7. 通过二维平面图获取单个数据的长期信息和诊断信息
8. 系统基础的查看数据库，下载数据库信息
9. 提供设置算法参数，并绘制算法结果图接口

## 后端项目需求

1. 用户登录
2. 实时数据
3. 配置文件
4. 算法接入
5. 检测报告输出



# UI设计

> 不是专业做UI设计的，但一般做前端开发应该先在脑子里有大致的页面分配，主要页面布局，每个功能在哪个部分实现。这里为了全面展示一个系统的开发流程，就做了比较细致的UI设计。

## 页面分配

首先根据需求确定页面的个数，这里因为有原型系统，所以这里很确定一共是4个界面：登录和注册、主监视界面、检测报告界面和统计分析界面。还有一个权限管理界面，主要是应用abp框架自带的。

## 风格确定

页面首先应该确定颜色风格，可以先在dribbble上搜索相关的设计方案，比如我这里就搜索了dashboard，这里参考了下面这个

![参考页面风格](https://cdn.dribbble.com/users/2253180/screenshots/15223174/media/83b2ac94850951a219cda00a3662e526.png)

## 具体页面参考

像比较具体且通用的页面，如登录等可以在b站上搜索一下例子。一是可以快速了解流行的页面样式；二是这种一般是纯HTML和CSS写成的，各种框架都可以应用；三是这种一般会带着你写，让你更容易理解和修改代码。

我这里参考了

![登录界面参考1](https://pic.imgdb.cn/item/61bf25422ab3f51d91a19a84.jpg)

![登录界面参考2](https://pic.imgdb.cn/item/61bf25662ab3f51d91a1ac73.jpg)

这两个登录界面，我主要关注的前端样式up有*总监日记*、*山羊の前端小窝*、*阿阳热爱前端*，还有一个设计类的up主*子牧说*。

## 页面设计

我这里使用的figma，主要考虑到它可以直接导出css样式，可以有效减少前端的工作。另外就是可以多人协作，发送连接给别人就可以共享，比较方便。figma的操作还是比较简单的，有些基础的原理可以参考原先邓师兄的PS教程。如果需要可以看一下[UI教程 | 手把手教你用Figma做UI界面设计_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1844y1k7Ck)，基本你需要什么到里面找就可以了

最后的设计方案

![登录界面](https://pic.imgdb.cn/item/61bf258a2ab3f51d91a1c27a.jpg

![监控主界面](https://pic.imgdb.cn/item/61bf25a52ab3f51d91a1cf68.jpg)
设计的连接在这里[Dashboard – Figma](https://www.figma.com/file/uLnMcKiFv1ndKXh2fE1yE3/Dashboard?node-id=0%3A1)

## 主题颜色

背景色<span style="background-color:#F2F7FF;">#F2F7FF</span>

主题色<span style="background-color:#9590C7;">#9590C7</span>

装饰色 <span style="background-color:#C4D3F9;">#C4D3F9</span> <span style="background-color:#51459E;">#51459E</span> <span style="background-color:#F2F7FF;">#F2F7FF</span>

状态色 <span style="background-color:#84E8F4;">#84E8F4</span> <span style="background-color:#FCBE30;">#FCBE30</span> <span style="background-color:#41B674;">#41B674</span>
文字色 <span style="background-color:#000000;color:white">#000000</span> <span style="background-color:#9CA0AB;">#9CA0AB</span> <span style="background-color:#FFFFFF;">#FFFFFF</span>



>本篇文章内容全部是前端开发内容，主要包括监测主界面生成、项目初始化开发与登录界面的开发。  
>主要的技术点有：**Angular新页面生成**、ui库依赖使用、响应式布局基础、**Angular组件**、登录界面CSS、修改ui库样式、**Angular表单**、**Angular http请求**、**Angular/ABP用户登录**、**Angular服务**  
>因为系列是前端开发的第一篇文章，命令行与CSS都会介绍得比较详细，后续文章没有很特殊的不会再做介绍

# 监测主界面生成
>介绍如何一步步在Angular中生成一个新页面，了解Angular的依赖注入

## Angular页面包含内容

参考home文件夹，可以发现angular一个页面需要至少有5个文件，其中有component存在的html、scss、ts属于home组件的内容。home.module.ts是保存home页面使用的组件的文件。home-routing.module.ts是app通过路由确定到home页面的文件。

![home文件夹内容](https://pic.imgdb.cn/item/61c6ff0c2ab3f51d91b98cb5.png)

## Angular Cli生成命令

### 生成dashboard.module.ts文件

我们直接在醒目的路径下使用`ng generate module dashboard`，就会生成一个叫dashboard的文件夹，里面包含一个dashboard.module.ts文件。使用命令生成的module会自动生成一些依赖内容。

### 生成dashboard.component的三个文件

使用`cd src\app\dashboard`命令，转到对应的dashboard文件夹，再使用`ng generate component dashboardLayout`生成一个dashboardLayout组件。<span style="font-style:italic;font-size:0.5rem">这里为了方便理解使用了不同的组件名称，为了方便一个页面多组件之后查看我也一般会把一个页面的根组件命名为Layout</span>

### 生成dashboard-routing.module.ts文件

在dashboard目录下，使用`ng generate module dashboardRouting`生成dashboard-routing.module.ts，可以把其从文件夹中取出来

## angular各文件之间的依赖、引入、声明补充

### dashboard.module.ts

将dashboard-routing.module引入

```typescript
import { DashboardRoutingModule } from './dashboard-routing.module';

@NgModule({
  declarations: [
    DashboardLayoutComponent
  ],
  imports: [
    CommonModule,
    DashboardRoutingModule,
  ]
})
```

这里的DashboardLayoutComponent是生成的时候会自动补充的

### dashboard-routing.module.ts

按照home-routing.module.ts修改

```typescript
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { DashboardLayoutComponent } from './dashboard-layout/dashboard-layout.component';

const routes: Routes = [{ path: '', component: DashboardLayoutComponent }];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule],
})
export class DashboardRoutingModule { }
```

### app.module.ts

将dashboard import进来

```typescript
@NgModule({
  imports: [
      此处省略
    DashboardModule,
  ],
    此处省略
})
```



### app-routing.module.ts

添加app路由

```typescript
{
    path: 'dashboard',
    pathMatch: 'full',
    loadChildren: () => import('./dashboard/dashboard.module').then(m => m.DashboardModule),
  },
```

完成以上步骤就可以通过理由跳转到新的页面了

### route.provider.ts

这里添加主页上的跳转按钮，修改初始样式。这里为了方便后续布局使用的是空样式

```typescript
routesService.add([
      {
        path: '/dashboard',
        name: '::监视主屏',
        iconClass: 'fas fa-home',
        order: 1,
        layout: eLayoutType.empty
      },
    ]);
```



# 响应式基础

> 这种监测大屏不存在响应式适配手机的需求，只需要适配不同分辨率的显示屏以及pad。所以这里没有考虑手机的适配，基本按照16:9等比例缩放。以后可以做手机适配的优化

在这样的前提下，项目使用rem对宽高、字体大小进行限值，通过设备窗口对项目HTML的font-size进行调节即可。

我们在main.ts里添加如下内容即可

```typescript
function remSize() {
  const deviceWidth = document.body.clientWidth
  // 在1920px宽的设计稿里10px=1rem
  document.documentElement.style.fontSize = (deviceWidth / 192) + 'px'
}
//已启动项目就执行remSize
remSize()
//项目窗口变化就执行remSize
window.onresize = () => {
  remSize()
}
```



在dashboard-layout.component.html里验证响应式，

```html
<div style="font-size: 3rem;height: 96rem;width: 96rem;background-color: aqua;">
    新页面测试代码
</div>
```

![响应式布局测试](https://pic.imgdb.cn/item/61c701642ab3f51d91cb7022.jpg)

该方块会一直是一个占据半边宽度的正方形

# 引入ui库

> 原本是准备使用Vue、React都可以使用的Element ui的，但其适配Angular的版本是8以前的，目前Angular已经更新到12了。所以使用了官方推荐且适配较好的[NG-ZORRO](https://ng.ant.design/docs/introduce/zh)。   
> 各类ui库都会提供大量的交互组件，避免你从头开发。在开发具体页面前建议先看一下使用的ui库都提供了哪些组件，组件效果是什么样的，这样可以在你拿到页面需求的时候能快速反应有没有现成的组件可用。


## 安装NG-ZORRO

`yarn add ng-zorro-antd`

`ng add ng-zorro-antd`

使用上述命令后会自动配置一些需要的内容

## 全局配置

在angular.json中添加"src/theme.less"

```json
"styles": [
              "src/theme.less",
    此后省略
```

## 模块配置

在全局配置的NG-ZORRO无法直接使用，还是需要在对应的模块进行配置。这里为了检验NG-ZORRO引入成功在dashboard.module.ts文件中引入NzButtonModule

```typescript
import { NzButtonModule } from 'ng-zorro-antd/button';
@NgModule({
  declarations: [
    DashboardLayoutComponent
  ],
  imports: [
    CommonModule,
    DashboardRoutingModule,
    NzButtonModule
  ]
})
```

在dashboard-layout.component.html里测试NG-ZORRO的使用

```html
<button nz-button nzType="primary">Primary Button</button>
```

![NG-ZORRO使用测试](https://pic.imgdb.cn/item/61c702072ab3f51d91d07f6a.png)

这里截的图是修改主题色之后的，原本应该是蓝色。按钮自带颜色，有点击动效证明ng-zorro的NzButtonModule可以使用了

## 自定义主题

在theme.less文件中可以自定义主题

```less
@import "../node_modules/ng-zorro-antd/ng-zorro-antd.less";

@primary-color: #9590C7;
@info-color:#9CA0AB;
@body-background:#F2F7FF;
@error-color:#FC5B5D;
@warning-color:#FCBE30;
@processing-color:#84E8F4;
@success-color:#41B674;
@normal-color:#51459E;
@text-color:#9CA0AB;
```

这里根据ui设计定义了一下颜色，后续可能还会根据需要进行调整。像vue比较常用的element ui是可以可视化定义主题的，会比ng-zorro要更好用一些。

[这个网址](https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/components/style/themes/default.less)可以看到所有可以自定义的内容

# 登录页面布局

## 登录页面模块划分

根据业务逻辑将登录页面划分成了四个部分，1是登录的表单，2是注册的表单，3是用来遮盖的翻转图片，4是点击后浮动到页面上的重置密码弹窗。于是将登录页面划分成了四个组件：reset-modal负责重置密码弹窗、login-form负责登录表单、sign-up-form负责注册表单、loginlayout是登录页面的根，负责整体布局和遮盖翻转图片逻辑

![展示登录表单，图片遮挡注册表单](https://pic.imgdb.cn/item/61c7029e2ab3f51d91d14c41.png)

![展示注册表单，图片遮挡登录表单](https://pic.imgdb.cn/item/61c702b42ab3f51d91d16850.jpg)

## 登录页面生成

按照前文主页面生成的方法生成登录页面，一并生成登录表单与注册表单组件

## loginlayout组件

> 该组件要实现的功能是登录页面整体布局：登录框水平垂直居中，图片翻转遮盖

### 整体布局

页面通过.backgroud的div实现设计图背景颜色和后续子元素.container div页面水平垂直居中

```css
.background {
    //flex布局，子元素水平垂直居中
    display: flex;
    align-items: center;
    justify-content: center;
    //背景颜色
    background-color: #C4D3F9;
    //保证页面大小占满屏幕
    width: 100%;
    height: 100%;
}
.container {
    //登录页面核心部分颜色，大小，阴影
    background-color: #F2F7FF;
    width: 115rem;
    height: 60rem;
    box-shadow: 0.5rem 1rem 1rem 0.2rem rgba(0, 0, 0, 0.3);
}
```

通过.cover的div放置遮挡用的图片，以及上面的文字。与.container组成子绝父相

```css
.container {
    position: relative;
}
.container .cover{
    //确定图片初始位置
    position: absolute;
    top: 0;
    left: 0;
    width: 80rem;
    height: 100%;
    z-index: 98;
    //图片层样式，颜色后续可以删掉
    background-color: aquamarine;
    filter: drop-shadow(0.5rem 0px 1rem rgba(0, 0, 0, 0.25));
  }
```

通过.forms的div嵌套两个div，分别嵌入两个组件，将用于翻转图片的内容放在组件外面。这里设置background-color是为了在初步构建代码时直观看到各个盒子的位置

```css
.forms .signupform{
    position: absolute;
    top: 0;
    left: 0;
    width: 35rem;
    height: 100%;
    background-color: blueviolet;
  }
.forms .loginform{
    position: absolute;
    top: 0;
    left: 80rem;
    width: 35rem;
    height: 100%;
    background-color: blueviolet;

}
.forms .signupform, .forms .loginform {
	//flex布局，子元素水平垂直居中
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
```

### 图片翻转

>图片翻转是通过一个不在页面上显示的#flip的checkbox完成的

.cover整体翻转。**.container #flip:checked**是选择#flip这个元素被选中；**~** 选择前面选择元素的后续兄弟元素；这样再.cover就是#flip这个元素被选中时.cover元素要执行的CSS样式了

```css
.container {
    //元素距离视图的距离，翻转时z轴最高高度
    perspective: 280rem;
}

.container .cover{
    //动画样式相关设置
    transition: all 0.8s ease;
    //翻转轴位置
    transform-origin: 71.875%;
    transform-style: preserve-3d;
  }

.container #flip:checked ~ .cover{
    transform: rotateY(180deg);
 }
```

但这样直接翻转会导致，图片和上面的文字翻转后颠倒。所以要把.cover分成两个面，分别显示。本来应该使用`backface-visibility: hidden;`来隐藏背面，但不知为何我的浏览器显示有这个样式，但没有这个效果。所以只能退而求其次，使背面元素`display:none`不渲染

```css
//正面设置
.container .cover .front {
	width: 100%;
    height: 100%;
    background-image: url(~src/assets/login.jpg);
    background-size: 100% 100%;
    background-repeat:no-repeat;
}
.container #flip:checked ~ .cover .front {
    display:none
}
//背面设置
.container .cover .back{
    width: 100%;
    height: 100%;
    background-image: url(~src/assets/login.jpg);
    background-size: 100% 100%;
    background-repeat:no-repeat;
    transform: rotateY(180deg);
    display:none
}
.container #flip:checked ~ .cover .back {
    display:flex
}
```

还有一些文字样式就不一一介绍了

## login-form组件

表单组件在NG-ZZORO有相应的组件了，使用和前文一样的方法把NzFormModule配置进来。但为了更好的自定义样式，没有引入NzInputModule和NzButtonModule，而是自己写的样式

### 表单

在对应的module导入`import { FormsModule, ReactiveFormsModule } from '@angular/forms'`;

对应ts中引入`import { FormBuilder, FormControl, FormGroup, Validators } from '@angular/forms';`并定义表单

```typescript
loginForm = new FormGroup({
	userName: new FormControl('', [Validators.required]),
    password: new FormControl('', [Validators.required]),
})
```

```HTML
<form nz-form [formGroup]="loginForm">
	<nz-form-item>
		<nz-form-control nzErrorTip="用户名不能为空">
			<input type="text" formControlName="userName" placeholder="用户名" />
		</nz-form-control>
	</nz-form-item>
  
	<nz-form-item>
		<nz-form-control nzErrorTip="密码至少6位且包含小写字母与数字">
			<input type="password" formControlName="password"			</nz-form-control>
	</nz-form-item>

  <button>登录</button>
</form>
```



[formGroup]设置整个表单名称，在ts需要定义这个名称，后续也用这个名称接收整个表单数据

formControlName设置单个输入对应的键，实现双向绑定

### 修改ui库样式

除去在自定义主题里修改ui库里的样式，我们遇到具体的ui库样式不合要求时可以直接不配置ui库，比如下面的input，也可以使用ng-deep修改，比如下面的.ant-form-item-explain.ant-form-item-explain-error。

```css
input{
	width: 100%;
	outline: none;
	border: 0;
    border-bottom: 0.25rem solid rgba(81, 69, 158, 0.58);
    background-color: transparent;
}
:host ::ng-deep .ant-form-item-explain.ant-form-item-explain-error{
	font-size: 1.2rem;
    color: #F9896B;
}
```

遇到引入ui库导致的样式不合适时，使用F12，查看是哪个部分的样式在起作用，用浏览器更改后有效果，就可以复制其css选择器，在前面添上**:host ::ng-deep**就可以在本文件作用域下修改ui组件库样式，添上**::ng-deep**就会使修改的样式全局生效

### 伪类选择器添加图形

在登录两个字下面添加了一个小方块儿，使用伪类选择器也是常规操作了

```css
.name::before{
	content: "";
	position: absolute;
	left: 0;
	bottom: 0rem;
	height: 0.5rem;
	width: 3rem;
	background-color: #B1ABED;
}
```

## sign-up-form组件

这个组件内容与login-form组件基本一致，就是添加了一个email输入。后续考虑是否将两个合并到一个里面去，使用传参来动态修改组件内容

## reset-modal组件

由于这个组件的点击文字分配在了登录按钮之上，所以把该组件作为login-form组件的子组件开发。组件内容与sign-up-form组件一致，其部分样式与在login-form打开弹窗里定义，在介绍业务逻辑时进行纤细说明。

# 登录页面业务逻辑

## 打开重置密码弹窗

这部分使用NG-ZORRO提供的服务，将弹窗里的内容抽象成一个组件打开

首先要在拥有打开弹窗逻辑的组件里引入依赖`import { NzModalService } from 'ng-zorro-antd/modal';`

然后在对应打开弹窗的地方绑定事件逻辑，并编写处理的逻辑

```typescript
resetModal() {
	const modal = this.modal.create({
        //定义弹窗标题
		nzTitle: '找回密码',
        //定义弹窗主体的组件
		nzContent: ResetModalComponent,
        //定义弹窗尾部
		nzFooter: [
        //定义取消按钮，点击后摧毁弹窗
			{
				label: '取消',
				onClick: () => modal.destroy()
			},
		//定义确认按钮，点击确认后执行组件里的reset方法
			{
				label: '确认',
				type: 'primary',
				loading: false,
				onClick(component): void {
					this.loading = true;// 让提交按钮显示加载动画，防止重复提交
					setTimeout(() => {
						this.loading = false
					}, 3000)
				component.reset();
				}
			},
		],
		nzWidth: 40 * this.rem
    });
  }
```

## 确定表单内容

这个方面需要和后端进行协同，首先要弄清楚登录、注册、找回密码都需要向后端传输哪些信息。这些信息里哪些是用户输入的，这一部分需要在界面上提供输入；哪些是系统自动传输的，这一部分需要自己在前端代码中定义。而且沟通的时候也要确定好数据的类型和要求，方便后续进行表单验证。

## 表单验证逻辑

### angular自带的表单验证

angular自带的表单验证可以验证常规的邮箱、电话号码和正则表达式，在创建表单组的时候定义其需要验证的逻辑即可。以注册表单为例，实例化FormControl对象时传入的第一个参数是这个量的初始值，第二个参数是采取的表单验证逻辑。Validators.required是这个量不能为空，Validators.email是这个量格式为邮箱，Validators.pattern则是这个量要满足后面的正则表达式

```typescript
signupForm = new FormGroup({
    userName: new FormControl(null, [Validators.required]),
    email: new FormControl(null, [Validators.required, Validators.email]),
    password: new FormControl(null, [Validators.required, Validators.pattern(/^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{6,10}$/)]),
})
```

### 自定义的表单验证

业务上存在angular自带的表单验证无法覆盖的内容，比如重置密码的时候第二次输入的密码应该与第一次一致。这个时候就需要自定义一个表单验证逻辑。这里就定义了一个新的表单验证逻辑confirmValidator，为了能够展示不同的两种信息所以设计了两种状态值error和required。

```typescript
confirmValidator = (control: FormControl): { [s: string]: boolean } => {
	if (!control.value) {
		return { error: true, required: true };
    } else if (control.value !== this.resetForm.controls.password.value) {
		return { confirm: true, error: true };
    }
    return {};
};

resetForm = new FormGroup({
	userName: new FormControl(null, [Validators.required]),
	email: new FormControl(null, [Validators.required, Validators.email]),
    password: new FormControl(null, [Validators.required, Validators.pattern(/^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{6,10}$/)]),
    password1: new FormControl(null, [this.confirmValidator]),
})
```

## 表单提交逻辑

### 表单数据回收

因为和后端定义的关于权限部分的http请求全部使用post，所以这里都使用直接定义对象来回收表单数据，将表单组的对应值直接幅值到后端定义的对象中。这里因为this.resetForm是一个观察对象，和vue里的ref类似，需要使用value来获取值。

```typescript
let resetForm = {
	username: this.resetForm.value.userName,
	userEmail: this.resetForm.value.email,
	newPassword: this.resetForm.value.password,
}
```

### 数据提交与返回状态处理

angular的自己封装了http请求的服务，不需要像vue那样引入，只要在组件里注入`import { HttpClient, HttpHeaders } from '@angular/common/http';`的依赖就可以使用。对于post请求需要定义请求头。

由于很多地方都需要用到后端的网址，为了应对项目落地调试时频繁修改IP的问题，这里将后端的IP定义在environment里面，通过`import { accountUrl } from 'src/environments/environment'`来使用

请求返回的内容是与后端协商确定的，根据statusCode的不同来确定后续启用的逻辑，这里成功就提示成功并关闭弹窗；不成功则提示错误信息，保留弹窗

```typescript
interface responseProps {
      statusCode: number
      message: string
}

const httpOptions = { headers: new HttpHeaders({ 'Content-Type': 'application/json' }) }
let api = accountUrl + '/api/app/reset-password'
this.http.post(api, resetForm, httpOptions).subscribe((response: responseProps) => {
	if (response.statusCode === 200) {
		this.alert.MessageAlert('success', response.message, 3000)
		this.nzModalRef.destroy(true);
	} else {
		this.alert.MessageAlert('error', response.message, 3000)
	}
});
```

## 提示信息服务

由于浏览器自带的alert很丑，且必须手动关闭会阻塞代码运行。结合NG-ZORRO封装的全局信息提示，项目创建了一个提示的服务，供全局使用

使用`ng generate service alert `命令创建提示信息服务，将

NG-ZORRO封装的全局信息提示注入`import { NzMessageService } from 'ng-zorro-antd/message';`，并且在构造函数里定义`private message: NzMessageService`。

```typescript
MessageAlert(type: string, message: string, duration: number): void {
	this.message.create(type, `${message}`, { nzDuration: duration });
}
```

这样在其他组件里注入这个服务`import { AlertService } from 'src/app/service/alert.service'`，构造函数里定义`private *alert*: AlertService`，就可以直接使用` this.alert.MessageAlert('success', response.message, 3000)`

## 登录获取保存token

一般来说登录之后后端会返回token，你需要将其保存在LocalStorage或者sessionStorage里面。但Angular与abp给你做了封装只要拿过来用就可以了。

首先是要设置好登录的方式，以及给后端传的值。这部分内容在environment.ts和environment.prod.ts里设置。前者是开发的时候使用的，后者是打包的时候使用，在不涉及打包上线的时候后者完全不起作用。但为了防止你到了打包上线的时候忘记修改，最好两个一起修改

```typescript
oAuthConfig: {
    //验证信息往哪里传
	issuer: accountUrl,
    //获取token的api
    tokenEndpoint: accountUrl + '/connect/token',
	//使用token方法验证，abp默认的是跳转到后端页面上验证
	requestAccessToken: true,
    //这是后端需要给你的前端设备标识和密码
    clientId: 'Dashboard_App',
    dummyClientSecret: '1q2w3e*',
    //这个是目前还没做https的授权那一套先给他关掉，免得报不安全
    requireHttps: false,
    //你前端设备名称，是什么不重要
    scope: 'offline_access Dashboard',
},
```

然后将登录相关的服务注入`import { OAuthService } from 'angular-oauth2-oidc';` `import { AuthService } from '@abp/ng.core';`。构造函数定义，之后直接使用接口就可以了

```typescript
this.authService.login(user).toPromise()
	.then(data => {
		this.alert.MessageAlert('success', "恭喜您登录成功！", 1000)
		setTimeout(() => {
			this.router.navigateByUrl('/dashboard');
		}, 1000)
	})
	.catch(() => {
		this.alert.MessageAlert('error', "您输入的用户名或密码不正确！", 3000)
});
```

如果你发现你登录之后在LocalStorage里多出了很多信息证明登录获取保存token就成功了。但我们做的时候出现了一些问题，本来不注销账号刷新页面是token是会一直保留的，但我们当时出现了token不保留的bug，打印后端返回的数据后发现，只是返回了token但没有返回用户信息，修改后端代码后解决。

## 前端开发3

### 主页面布局

#### nav公共组件

#### 栅格布局

### nav公共组件开发

