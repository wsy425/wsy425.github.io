---
title:  Vue Router
date: 2022-06-09 16:22:20
permalink: /pages/2ab1b4/
categories:
  - 《Vue》
tags:
  - 
---
## 6.1 相关概念
### 6.1.1 路由
1. 路由概念
   1. 一个路由就是一组映射关系（key - value）
   2. key为路径，value可能是function或componen
2. 路由分类
   1. 后端路由
      1. 理解：value是function，用于处理客户端提交的请求
      2. 工作过程：服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据
   2. 前端路由
      1. 理解：value是component，用于展示页面内容
      2. 工作过程：当浏览器的路径改变时，对应的组件就会显示
### 6.1.2 SPA应用
1. 单页Web应用（single page web application，SPA）
2. 整个应用只有一个完整的页面
3. 点击页面中的导航链接不会刷新页面，只会做页面的局部更新
4. 数据需要通过ajax请求获取

## 6.2 基本路由
### 6.2.1 基本路由使用
1. 安装vue-router，命令`npm i vue-router`
2. 应用插件`Vue.use(VueRouter)`
3. 编写router配置项
```javascript
import VueRouter from 'vue-router'			// 引入VueRouter
import About from '../components/About'	// 路由组件
import Home from '../components/Home'		// 路由组件

// 创建router实例对象，去管理一组一组的路由规则
const router = new VueRouter({
	routes:[
		{
			path:'/about',
			component:About
		},
		{
			path:'/home',
			component:Home
		}
	]
})

//暴露router
export default router
```
4. 实现切换`<router-link></router-link>`浏览器会被替换为a标签,`active-class`可配置高亮样式
```html
<router-link active-class="active" to="/about">About</router-link>
```
5. 指定展示位`<router-view></router-view>`
### 6.2.2 注意事项
1. 路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹
2. 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载
3. 每个组件都有自己的`$route`属性，里面存储着自己的路由信息
4. 整个应用只有一个router，可以通过组件的`$router`属性获取到

## 6.3 多级路由
1. 配置路由规则，使用children配置项
```javascript
routes:[
	{
		path:'/about',
		component:About,
	},
	{
		path:'/home',
		component:Home,
		children:[ 					// 通过children配置子级路由
			{
				path:'news', 		// 此处一定不要带斜杠，写成 /news
				component:News
			},
			{
				path:'message',	// 此处一定不要写成 /message
				component:Message
			}
		]
	}
]
```
2. 跳转（要写完整路径）`<router-link to="/home/news">News</router-link>`

## 6.4 路由传参
### 6.4.1 query参数
1. 传递query参数
```html
<!-- 跳转并携带query参数，to的字符串写法 -->
<router-link :to="`/home/message/detail?id=${m.id}&title=${m.title}`">跳转</router-link>
				
<!-- 跳转并携带query参数，to的对象写法（推荐） -->
<router-link 
	:to="{
		path:'/home/message/detail',
		query:{
		    id: m.id,
            title: m.title
		}
	}"
>跳转</router-link>
```
2. 接收query参数`$route.query.id`,`$route.query.title`
### 6.4.2 params参数
1. 配置路由，声明接收params参数
```javascript
{
	path:'/home',
	component:Home,
	children:[
		{
			path:'news',
			component:News
		},
		{
			component:Message,
			children:[
				{
					name:'xiangqing',
					path:'detail/:id/:title', // 🔴使用占位符声明接收params参数
					component:Detail
				}
			]
		}
	]
}
```
2. 传递参数：**特别注意**：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！
```html
<!-- 跳转并携带params参数，to的字符串写法 -->
<router-link :to="/home/message/detail/666/你好">跳转</router-link>
				
<!-- 跳转并携带params参数，to的对象写法 -->
<router-link 
	:to="{
		name:'xiangqing',
		params:{
		    id:666,
            title:'你好'
		}
	}"
>跳转</router-link>
```
3. 接收参数`$route.params.id``$route.params.title`
### 6.4.3 路由props配置
1. props作用：让路由组件更方便的收到参数
2. 在`router/index.js`里增加props配置
```javascript
{
	name:'xiangqing',
	path:'detail/:id',
	component:Detail,

	//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件
	props:{a:900},

	//第二种写法：props值为布尔值，为true时，则把路由收到的所有params参数通过props传给Detail组件
	props:true,
	
	//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件
	props($route){
		return {
			id: $route.query.id,
			title: $route.query.title
		}
	}
}
```

## 6.5 命名路由
1. 作用：可以简化路由的跳转
### 6.5.1 命名路由使用
1. 给路由命名 
```javascript
{
	path:'/demo',
	component:Demo,
	children:[
		{
			path:'test',
			component:Test,
			children:[
				{
          name:'hello' // 给路由命名
					path:'welcome',
					component:Hello,
				}
			]
		}
	]
}
```
2. 简化跳转
```html
<!--简化前，需要写完整的路径 -->
<router-link to="/demo/test/welcome">跳转</router-link>

<!--简化后，直接通过名字跳转 -->
<router-link :to="{name:'hello'}">跳转</router-link>

<!--简化写法配合传递参数 -->
<router-link 
	:to="{
		name:'hello',
		query:{
		    id:666,
            title:'你好'
		}
	}"
>跳转</router-link>
```

## 6.6 路由跳转replace模式
1. 作用：控制路由跳转时操作浏览器历史记录的模式
2. 浏览器的历史记录有两种写入方式：push和replace
   1. push是追加历史记录
   2. replace是替换当前记录，路由跳转时候默认为push方式
3. 开启replace模式`<router-link :replace="true" ...>News</router-link>`
4. 简写`<router-link replace ...>News</router-link>`
5. 总结：浏览记录本质是一个栈，默认push，点开新页面就会在栈顶追加一个地址，后退，栈顶指针向下移动，改为replace就是不追加，而将栈顶地址替换

## 6.7 编程式路由导航
1. 作用：不借助`<router-link>`实现路由跳转，让路由跳转更加灵活
2. `this.$router.push({})`内传的对象与`<router-link>`中的to相同
3. `this.$router.replace({})`	
4. `this.$router.forward()`前进
5. `this.$router.back()`后退
6. `this.$router.go(n)`可前进也可后退，n为正数前进n，为负数后退

## 6.8 缓存路由组件
1. 作用：让不展示的路由组件保持挂载，不被销毁
2. `<keep-alive include="News"><router-view></router-view></keep-alive>`
3. `<keep-alive :include="['News', 'Message']"><router-view></router-view></keep-alive>`

## 6.9 路由相关生命钩子
1. activated和deactivated是路由组件所独有的两个钩子，用于捕获路由组件的激活状态
2. activated路由组件被激活时触发
3. deactivated路由组件失活时触发

## 6.10 路由守卫
1. 作用：对路由进行权限控制 
2. 分类：全局守卫、独享守卫、组件内守卫 
### 6.10.1 全局前置守卫
1. 每次路由切换之前和初始化时被调用
2. `router.beforeEach((to,from,next) => {})`
3. `to`是路由去往的信息，`from`是跳转路由前的信息，`next()`放行
4. `meta`路由元信息，是可以自定义的信息
```javascript
router.beforeEach((to,from,next) => {
	console.log('beforeEach',to,from)
	if(to.meta.isAuth){ // 判断当前路由是否需要进行权限控制
		if(localStorage.getItem('school') === 'atguigu'){ // 权限控制的具体规则
			next()	// 放行
		}else{
			alert('暂无权限查看')
		}
	}else{
		next()	// 放行
	}
})
```
### 6.10.2 全局后置守卫
1. 每次路由切换后和初始化时被调用，没有`next()`方法
2. 用来切换标签页名字
```javascript
router.afterEach((to,from) => {
	console.log('afterEach',to,from)
	if(to.meta.title){ 
		document.title = to.meta.title //修改网页的title
	}else{
		document.title = 'vue_test'
	}
})
```
### 6.10.3 独享守卫
1. 是routes的一个配置项
2. 没有独享后置路由守卫
```javascript
beforeEnter(to,from,next){
	console.log('beforeEnter',to,from)
    if(localStorage.getItem('school') === 'atguigu'){
        next()
    }else{
        alert('暂无权限查看')
    }
}
```
### 6.10.4 组件内守卫
1. 类似于生命周期
2. 是通过路由进入离开组件才会触发，直接放在页面上的是不触发的
```javascript
//进入守卫：通过路由规则，进入该组件时被调用
beforeRouteEnter (to, from, next) {... next()},

//离开守卫：通过路由规则，离开该组件时被调用
beforeRouteLeave (to, from, next) {... next()},
```

## 6.11 路由器的工作模式
1. 对于一个url来说，#及其后面的内容就是hash值
2. hash值不会包含在HTTP请求中，即：hash值不会带给服务器 
### 6.11.1 hash模式 
1. 地址中永远带着#号，不美观
2. 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法
3. 兼容性较好
### 6.11.2 history模式
1. 地址干净，美观
2. 兼容性和hash模式相比略差
3. 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题
```javascript
const router =  new VueRouter({
	mode:'history',
	routes:[...]
})

export default router
```