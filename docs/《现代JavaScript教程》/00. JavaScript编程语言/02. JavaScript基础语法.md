---
title:  JavaScript基础语法
date: 2022-06-28 18:57:55
permalink: /pages/d2d293/
categories:
  - 《现代JavaScript教程》
  -  JavaScript编程语言
tags:
  - JavaScript
---
##  3.1 类型转换
大多数情况下，运算符和函数会自动将赋予它们的值转换为正确的类型。

比如，`alert` 会自动将任何值都转换为字符串以进行显示。算术运算符会将值转换为数字

###  3.1.1 字符串转换
`alert(value)` 将 `value` 转换为字符串类型，然后显示这个值
我们也可以显式地调用 `String(value)` 来将 `value` 转换为字符串类型
```js{3,4}
let value = true;
alert(typeof value); // boolean
value = String(value); // 现在，值是一个字符串形式的 "true"
alert(typeof value); // string
```

###  3.1.2 数字型转换
在算术函数和表达式中，会自动进行 number 类型转换
```js
alert( "6" / "2" ); // 3, string 类型的值被自动转换成 number 类型后进行计算
```
我们也可以使用 `Number(value)` 显式地将这个 `value` 转换为 number 类型
```js
let str = "123";
alert(typeof str); // string
let num = Number(str); // 变成 number 类型 123
alert(typeof num); // number
```
number 类型转换规则：

| 值                                   | 变成……                                                                                                                                                  |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `undefined`                          | `NaN`                                                                                                                                                   |
| `null`                               | `0`                                                                                                                                                     |
| <code>true&nbsp;和&nbsp;false</code> | `1` and `0`                                                                                                                                             |
| `string`                             | 去掉首尾空格后的纯数字字符串中含有的数字。如果剩余字符串为空，则转换结果为 `0`。否则，将会从剩余字符串中“读取”数字。当类型转换出现 error 时返回 `NaN`。 |

```js
alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN（从字符串“读取”数字，读到 "z" 时出现错误）
alert( Number(true) );        // 1
alert( Number(false) );       // 0
```
::: warning
请注意 `null` 和 `undefined` 在这有点不同：`null` 变成数字 `0`，`undefined` 变成 `NaN`
:::

###  3.1.3 布尔型转换
它发生在逻辑运算中（稍后我们将进行条件判断和其他类似的东西），但是也可以通过调用 Boolean(value) 显式地进行转换
| 值                                    | 变成……  |
| ------------------------------------- | ------- |
| `0`, `null`, `undefined`, `NaN`, `""` | `false` |
| 其他值                                | `true`  |
```js
alert( Boolean(1) ); // true
alert( Boolean(0) ); // false
alert( Boolean("hello") ); // true
alert( Boolean("") ); // false
```
::: warning
包含 0 的字符串 `"0"` 是 `true`
:::

###  3.1.4 总结
有三种常用的类型转换：转换为 string 类型、转换为 number 类型和转换为 boolean 类型。

**字符串转换** —— 转换发生在输出内容的时候，也可以通过 `String(value)` 进行显式转换。原始类型值的 string 类型转换通常是很明显的。

**数字型转换** —— 转换发生在进行算术操作时，也可以通过 `Number(value)` 进行显式转换
**布尔型转换** —— 转换发生在进行逻辑操作时，也可以通过 `Boolean(value)` 进行显式转换
上述的大多数规则都容易理解和记忆。人们通常会犯错误的值得注意的例子有以下几个：

- 对 `undefined` 进行数字型转换时，输出结果为 `NaN`，而非 `0`。
- 对 `"0"` 和只有空格的字符串（比如：`"   "`）进行布尔型转换时，输出结果为 `true`

##  3.2 基础运算符
###  3.2.1 运算符相关术语
####  运算元
运算符应用的对象。比如说乘法运算 `5 * 2`，有两个运算元：左运算元 `5` 和右运算元 `2`。有时候人们也称其为“参数”而不是“运算元”
####  一元运算符
如果一个运算符对应的只有一个运算元，那么它是 **一元运算符**
```js
let x = 1;
x = -x;
alert( x ); // -1，一元负号运算符生效
```
####  二元运算符
如果一个运算符拥有两个运算元，那么它是 **二元运算符**
```js
let x = 1, y = 3;
alert( y - x ); // 2，二元运算符减号做减运算
```

###  3.2.2 数学运算符
支持以下数学运算：

- 加法 `+`,
- 减法 `-`,
- 乘法 `*`,
- 除法 `/`,
- 取余 `%`,
- 求幂 `**`.

####  取余 %
`a % b` 的结果是 `a` 整除 `b` 的 余数
```js
alert( 5 % 2 ); // 1，5 除以 2 的余数
alert( 8 % 3 ); // 2，8 除以 3 的余数
```
####  求幂 **
求幂运算 `a ** b` 将 `a` 提升至 `a` 的 `b` 次幂
```js 
alert( 2 ** 2 ); // 2² = 4
alert( 2 ** 3 ); // 2³ = 8
alert( 2 ** 4 ); // 2⁴ = 16
```

###  3.2.3  用二元运算符 + 连接字符串
通常，加号 `+` 用于求和。

但是如果加号 `+` 被应用于字符串，它将合并（连接）各个字符串：

```js
let s = "my" + "string";
alert(s); // mystring
```

注意：只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串。

举个例子：

```js 
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```
```js run
alert(2 + 2 + '1' ); // "41"，不是 "221"
```

在这里，运算符是按顺序工作。第一个 `+` 将两个数字相加，所以返回 `4`，然后下一个 `+` 将字符串 `1` 加入其中，所以就是 `4 + '1' = '41'`。

```js run
alert('1' + 2 + 2); // "122"，不是 "14"
```
这里，第一个操作数是一个字符串，所以编译器将其他两个操作数也视为了字符串。`2` 被与 `'1'` 连接到了一起，也就是像 `'1' + 2 = "12"` 然后 `"12" + 2 = "122"` 这样。

二元 `+` 是唯一一个以这种方式支持字符串的运算符。其他算术运算符只对数字起作用，并且总是将其运算元转换为数字。

下面是减法和除法运算的示例：

```js run
alert( 6 - '2' ); // 4，将 '2' 转换为数字
alert( '6' / '2' ); // 3，将两个运算元都转换为数字
```

###  3.2.4 数字转化，一元运算符 +
加号 `+` 有两种形式。一种是上面我们刚刚讨论的二元运算符，还有一种是一元运算符。

一元运算符加号，或者说，加号 `+` 应用于单个值，对数字没有任何作用。但是如果运算元不是数字，加号 `+` 则会将其转化为数字。

例如：

```js{7,8}
// 对数字无效
let x = 1;
alert( +x ); // 1
let y = -2;
alert( +y ); // -2
// 转化非数字
alert( +true ); // 1
alert( +"" );   // 0
```

它的效果和 `Number(...)` 相同，但是更加简短

###  3.2.5 运算符优先级
这是一个摘抄自 Mozilla 的 [优先级表](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)（你没有必要把这全记住，但要记住一元运算符优先级高于二元运算符）：

| 优先级 | 名称     | 符号 |
| ------ | -------- | ---- |
| ...    | ...      | ...  |
| 15     | 一元加号 | `+`  |
| 15     | 一元负号 | `-`  |
| 14     | 求幂     | `**` |
| 13     | 乘号     | `*`  |
| 13     | 除号     | `/`  |
| 12     | 加号     | `+`  |
| 12     | 减号     | `-`  |
| ...    | ...      | ...  |
| 2      | 赋值符   | `=`  |
| ...    | ...      | ...  |

我们可以看到，“一元加号运算符”的优先级是 `15`，高于“二元加号运算符”的优先级 `12`。这也是为什么表达式 `"+apples + +oranges"` 中的一元加号先生效，然后才是二元加法

###  3.2.6 赋值运算符
赋值符号 `=` 也是一个运算符。从优先级表中可以看到它的优先级非常低，只有 `2`。
所以当我们赋值时，比如 `x = 2 * 2 + 1`，所有的计算先执行，然后 `=` 才执行，将计算结果存储到 `x`
####   赋值 = 返回一个值
在 JavaScript 中，所有运算符都会返回一个值。这对于 `+` 和 `-` 来说是显而易见的，但对于 `=` 来说也是如此
语句 `x = value` 将值 `value` 写入 `x` **然后返回 value**。

下面是一个在复杂语句中使用赋值的例子：

```js {3}
let a = 1;
let b = 2;
let c = 3 - (a = b + 1);
alert( a ); // 3
alert( c ); // 0
```

上面这个例子，`(a = b + 1)` 的结果是赋给 `a` 的值（也就是 `3`）。然后该值被用于进一步的运算
####  链式赋值（Chaining assignments）
```js run
let a, b, c;
a = b = c = 2 + 2;
alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```
链式赋值从右到左进行计算。首先，对最右边的表达式 `2 + 2` 求值，然后将其赋给左边的变量：`c`、`b` 和 `a`。最后，所有的变量共享一个值

###  3.2.7 原地修改
我们经常需要对一个变量做运算，并将新的结果存储在同一个变量中
可以使用运算符 `+=` 和 `*=` 来缩写这种表示，所有算术和位运算符都有简短的“修改并赋值”运算符
```js
let n = 2;
n += 5; // 现在 n = 7（等同于 n = n + 5）
n *= 2; // 现在 n = 14（等同于 n = n * 2）
alert( n ); // 14
```
这类运算符的优先级与普通赋值运算符的优先级相同，所以它们在大多数其他运算之后执行：

```js run
let n = 2;
n *= 3 + 5;
alert( n ); // 16 （右边部分先被计算，等同于 n *= 8）
```

###  3.2.8 自增/自减
####  自增`++`
将变量与 1 相加
```js
let counter = 2;
counter++;      // 和 counter = counter + 1 效果一样，但是更洁
alert( counter ); // 3
```
####  自减`--`
```js run no-beautify
let counter = 2;
counter--;      // 和 counter = counter - 1 效果一样，但是更洁
alert( counter ); // 1
```
:::warning 只用于变量
自增/自减只能应用于变量。试一下，将其应用于数值（比如 `5++`）则会报错
:::
####  前置与后置
运算符 `++` 和 `--` 可以置于变量前，也可以置于变量后。

- 当运算符置于变量后，被称为“后置形式”：`counter++`。
- 当运算符置于变量前，被称为“前置形式”：`++counter`。


```js
let counter = 1;
let a = ++counter; // (*)
alert(a); // 2
```

`(*)` 所在的行是前置形式 `++counter`，对 `counter` 做自增运算，返回的是新的值 `2`。因此 `alert` 显示的是 `2`。

下面让我们看看后置形式：

```js
let counter = 1;
let a = counter++; // (*) 将 ++counter 改为 counter++
alert(a); // 1
```

`(*)` 所在的行是后置形式 `counter++`，它同样对 `counter` 做加法，但是返回的是 **旧值**（做加法之前的值）。因此 `alert` 显示的是 `1`。
::: tip 自增/自减和其它运算符的对比
`++/--` 运算符同样可以在表达式内部使用。它们的优先级比绝大部分的算数运算符要高。
举个例子：
```js run
let counter = 1;
alert( 2 * ++counter ); // 4
```
:::

###  3.2.9 位运算符
下面是位运算符：

- 按位与 ( `&` )
- 按位或 ( `|` )
- 按位异或 ( `^` )
- 按位非 ( `~` )
- 左移 ( `<<` )
- 右移 ( `>>` )
- 无符号右移 ( `>>>` )

###  3.2.10 逗号运算符
逗号运算符能让我们处理多个语句，使用 `,` 将它们分开。每个语句都运行了，但是只有最后的语句的结果会被返回

```js {0}
let a = (1 + 2, 3 + 4);
alert( a ); // 7（3 + 4 的结果）
```
这里，第一个语句 `1 + 2` 运行了，但是它的结果被丢弃了。随后计算 `3 + 4`，并且该计算结果被返回
::: tip 逗号运算符的优先级非常低
请注意逗号运算符的优先级非常低，比 `=` 还要低，因此上面你的例子中圆括号非常重要。
如果没有圆括号：`a = 1 + 2, 3 + 4` 会先执行 `+`，将数值相加得到 `a = 3, 7`，然后赋值运算符 `=` 执行 `a = 3`，然后逗号之后的数值 `7` 不会再执行，它被忽略掉了。相当于 `(a = 1 + 2), 3 + 4`。
:::

##  3.3 比较运算符
- 大于 / 小于：<code>a &gt; b</code>，<code>a &lt; b</code>。
- 大于等于 / 小于等于：<code>a &gt;= b</code>，<code>a &lt;= b</code>。
- 检查两个值的相等：`a == b`，请注意双等号 `==` 表示相等性检查，而单等号 `a = b` 表示赋值。
- 检查两个值不相等：不相等在数学中的符号是 <code>&ne;</code>，但在 JavaScript 中写成 <code>a != b</code>。

###  3.3.1 比较运算符结果为Boolean 类型
所有比较运算符均返回布尔值：

- `true` —— 表示“yes（是）”，“correct（正确）”或“the truth（真）”。
- `false` ——  表示“no（否）”，“wrong（错误）”或“not the truth（非真）”。

和其他类型的值一样，比较的结果可以被赋值给任意变量
```js
let result = 5 > 4; // 把比较的结果赋值给 result
alert( result ); // true
```

###  3.3.2 字符串比较
在比较字符串的大小时，JavaScript 会使用“字典（dictionary）”或“词典（lexicographical）”顺序进行判定，字符串是按字符（母）逐个进行比较的
```js
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```
字符串的比较算法非常简单：

1. 首先比较两个字符串的首位字符大小。
2. 如果一方字符较大（或较小），则该字符串大于（或小于）另一个字符串。算法结束。
3. 否则，如果两个字符串的首位字符相等，则继续取出两个字符串各自的后一位字符进行比较。
4. 重复上述步骤进行比较，直到比较完成某字符串的所有字符为止。
5. 如果两个字符串的字符同时用完，那么则判定它们相等，否则未结束（还有未比较的字符）的字符串更大

:::tip 非真正的字典顺序，而是 Unicode 编码顺序
在上面的算法中，比较大小的逻辑与字典或电话簿中的排序很像，但也不完全相同。
比如说，字符串比较对字母大小写是敏感的。大写的 `"A"` 并不等于小写的 `"a"`。哪一个更大呢？实际上小写的 `"a"` 更大。这是因为在 JavaScript 使用的内部编码表中（Unicode），小写字母的字符索引值更大
:::

###  3.3.3 不同类型间的比较
当对不同类型的值进行比较时，JavaScript 会首先将其转化为数字（number）再判定大小
```js
alert( '2' > 1 ); // true，字符串 '2' 会被转化为数字 2
alert( '01' == 1 ); // true，字符串 '01' 会被转化为数字 1
alert( true == 1 ); // true
alert( false == 0 ); // true
```
:::tip 一个有趣的现象
有时候，以下两种情况会同时发生：
- 若直接比较两个值，其结果是相等的。
- 若把两个值转为布尔值，它们可能得出完全相反的结果，即一个是 `true`，一个是 `false`。
例如：
```js run
let a = 0;
alert( Boolean(a) ); // false
let b = "0";
alert( Boolean(b) ); // true
alert(a == b); // true!
```
对于 JavaScript 而言，这种现象其实挺正常的。因为 JavaScript 会把待比较的值转化为数字后再做比较（因此 `"0"` 变成了 `0`）。若只是将一个变量转化为 `Boolean` 值，则会使用其他的类型转换规则。
:::

###  3.3.4 严格相等
普通的相等性检查 `==` 存在一个问题，它不能区分出 `0` 和 `false`,也同样无法区分空字符串和 `false`
这是因为在比较不同类型的值时，处于相等判断符号 `==` 两侧的值会先被转化为数字。空字符串和 `false` 也是如此，转化后它们都为数字 0
**严格相等运算符 `===` 在进行比较时不会做任何的类型转换。**
```js run
alert( 0 === false ); // false，因为被比较值的数据类型不同
```
同样的，与“不相等”符号 `!=` 类似，“严格不相等”表示为 `!==`

###  3.3.5 对 null 和 undefined 进行比较
当使用严格相等 `===` 比较二者时 
: 它们不相等，因为它们属于不同的类型。

    ```js run
    alert( null === undefined ); // false
    ```

当使用非严格相等 `==` 比较二者时
: JavaScript 存在一个特殊的规则，会判定它们相等。它们俩就像“一对恋人”，仅仅等于对方而不等于其他任何的值（只在非严格相等下成立）。

    ```js run
    alert( null == undefined ); // true
    ```

当使用数学式或其他比较方法 `< > <= >=` 时：
: `null/undefined` 会被转化为数字：`null` 被转化为 `0`，`undefined` 被转化为 `NaN`。

####  null vs 0
```js{3}
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```
相等性检查 `==` 和普通比较符 `> < >= <=` 的代码逻辑是相互独立的
进行值的比较时，`null` 会被转化为数字，因此它被转化为了 `0`。这就是为什么（3）中 `null >= 0` 返回值是 true，（1）中 `null > 0` 返回值是 false。  
`undefined` 和 `null` 在相等性检查 `==` 中不会进行任何的类型转换，它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值。这就解释了为什么（2）中 `null == 0` 会返回 false。


####  undefined
```js run
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```
`(1)` 和 `(2)` 都返回 `false` 是因为 `undefined` 在比较中被转换为了 `NaN`，而 `NaN` 是一个特殊的数值型值，它与任何值进行比较都会返回 `false`
`(3)` 返回 `false` 是因为这是一个相等性检查，而 `undefined` 只与 `null` 相等，不会与其他值相等


##  3.4 条件分支
###  3.4.1 "if" 语句
`if(...)` 语句计算括号里的条件表达式，如果计算结果是 `true`，就会执行对应的代码块
```js
if (year == 2015) {
  alert( "That's correct!" );
  alert( "You're so smart!" );
}
```

###  3.4.2 布尔转换
`if (…)` 语句会计算圆括号内的表达式，并将计算结果转换为布尔型

###  3.4.3 "else" 语句
`if` 语句有时会包含一个可选的 "else" 块。如果判断条件不成立，就会执行它内部的代码

###  3.4.4 多个条件："else if"
有时我们需要测试一个条件的几个变体。我们可以通过使用 `else if` 子句实现
```js run
let year = prompt('In which year was ECMAScript-2015 specification published?', '');
if (year < 2015) {
  alert( 'Too early...' );
} else if (year > 2015) {
  alert( 'Too late' );
} else {
  alert( 'Exactly!' );
}
```
可以有更多的 `else if` 块。结尾的 `else` 是可选的

###  3.4.5 条件运算符 '?'
问号 `?` 有时它被称为三元运算符，被称为“三元”是因为该运算符中有三个操作数
```js
let result = condition ? value1 : value2;
```
计算条件结果，如果结果为真，则返回 `value1`，否则返回 `value2`

###  3.4.6 多个 '?'
使用一系列问号 `?` 运算符可以返回一个取决于多个条件的值
```js run
let age = prompt('age?', 18);
let message = (age < 3) ? 'Hi, baby!' :
  (age < 18) ? 'Hello!' :
  (age < 100) ? 'Greetings!' :
  'What an unusual age!';
alert( message );
```
1. 第一个问号检查 `age < 3`。
2. 如果为真 — 返回 `'Hi, baby!'`。否则，会继续执行冒号 `":"` 后的表达式，检查 `age < 18`。
3. 如果为真 — 返回 `'Hello!'`。否则，会继续执行下一个冒号 `":"` 后的表达式，检查 `age < 100`。
4. 如果为真 — 返回 `'Greetings!'`。否则，会继续执行最后一个冒号 `":"` 后面的表达式，返回 `'What an unusual age!'`

###  3.4.6 '?' 的非常规使用
有时可以使用问号 `?` 来代替 `if` 语句
```js run no-beautify
let company = prompt('Which company created JavaScript?', '');
(company == 'Netscape') ?
   alert('Right!') : alert('Wrong.');
```
根据条件 `company =='Netscape'`，要么执行 `?` 后面的第一个表达式并显示对应内容，要么执行第二个表达式并显示对应内容
**不建议这样使用问号运算符。**

##  3.5 逻辑运算符
JavaScript 中有四个逻辑运算符：`||`（或），`&&`（与），`!`（非），`??`（空值合并运算符）
虽然它们被称为“逻辑”运算符，但这些运算符却可以被应用于任意类型的值，而不仅仅是布尔值。它们的结果也同样可以是任意类型

###  3.5.1 ||（或）
两个竖线符号表示“或”运算符：

```js
result = a || b;
```
```js run
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```
如果操作数不是布尔值，那么它将会被转化为布尔值来参与运算
####  或运算寻找第一个真值
给定多个参与或运算的值：

```js
result = value1 || value2 || value3;
```

或运算符 `||` 做了如下的事情：

- 从左到右依次计算操作数。
- 处理每一个操作数时，都将其转化为布尔值。如果结果是 `true`，就停止计算，返回这个操作数的初始值。
- 如果所有的操作数都被计算过（也就是，转换结果都是 `false`），则返回最后一个操作数。

返回的值是操作数的初始形式，不会做布尔转换。

换句话说，一个或运算 `||` 的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值
```js run
alert( 1 || 0 ); // 1（1 是真值）
alert( null || 1 ); // 1（1 是第一个真值）
alert( null || 0 || 1 ); // 1（第一个真值）
alert( undefined || null || 0 ); // 0（都是假值，返回最后一个值）
```
1. **获取变量列表或者表达式中的第一个真值**
    我们用或运算 `||` 来选择有数据的那一个，并显示出来（如果没有设置，则用 `"Anonymous"`）：

    ```js{4}
    let firstName = "";
    let lastName = "";
    let nickName = "SuperCoder";
    alert( firstName || lastName || nickName || "Anonymous"); // SuperCoder
    ```
2. **短路求值（Short-circuit evaluation）**
    `||` 对其参数进行处理，直到达到第一个真值，然后立即返回该值，而无需处理其他参数
    ```js
    true || alert("not printed");
    false || alert("printed");
    ```
    在第一行中，或运算符 `||` 在遇到 `true` 时立即停止运算，所以 `alert` 没有运行

###  3.5.2 &&（与）
两个 & 符号表示 `&&` 与运算符
```js
result = a && b;
```
在传统的编程中，当两个操作数都是真值时，与运算返回 `true`，否则返回 `false`：

```js run
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```
就像或运算一样，与运算的操作数可以是任意类型的值：

```js run
if (1 && 0) { // 作为 true && false 来执行
  alert( "won't work, because the result is falsy" );
}
```
####  与运算寻找第一个假值
```js
result = value1 && value2 && value3;
```
与运算 `&&` 做了如下的事：

- 从左到右依次计算操作数。
- 在处理每一个操作数时，都将其转化为布尔值。如果结果是 `false`，就停止计算，并返回这个操作数的初始值。
- 如果所有的操作数都被计算过（例如都是真值），则返回最后一个操作数。

换句话说，与运算返回第一个假值，如果没有假值就返回最后一个值
```js
// 如果第一个操作数是真值，
// 与运算返回第二个操作数：
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5
// 如果第一个操作数是假值，
// 与运算将直接返回它。第二个操作数会被忽略
alert( null && 5 ); // null
alert( 0 && "no matter what" ); // 0

alert( 1 && 2 && null && 3 ); // null
//如果所有的值都是真值，最后一个值将会被返回
alert( 1 && 2 && 3 ); // 3，最后一个值
```
::: tip 与运算 `&&` 在或运算 `||` 之前进行
与运算 `&&` 的优先级比或运算 `||` 要高。
所以代码 `a && b || c && d` 跟 `&&` 表达式加了括号完全一样：`(a && b) || (c && d)`
:::
::: warning
不要用 `||` 或 `&&` 来取代 `if`
:::

###  3.5.3 !（非）
感叹符号 `!` 表示布尔非运算符
```js
result = !value;
```
逻辑非运算符接受一个参数，并按如下运作：

1. 将操作数转化为布尔类型：`true/false`。
2. 返回相反的值

```js run
alert( !true ); // false
alert( !0 ); // true
```
非运算符 `!` 的<mark>优先级</mark>在所有逻辑运算符里面<mark>最高</mark>，所以它总是在 `&&` 和 `||` 之前执行

####  `!!`
两个非运算 `!!` 有时候用来将某个值转化为布尔类型

###  3.5.4 空值合并运算符 '??'
空值合并运算符（nullish coalescing operator）的写法为两个问号 `??`
由于它对待 `null` 和 `undefined` 的方式类似，所以在本文中我们将使用一个特殊的术语对其进行表示。为简洁起见，当一个值既不是 `null` 也不是 `undefined` 时，我们将其称为“已定义的（defined）”

`a ?? b` 的结果是：
- 如果 `a` 是已定义的，则结果为 `a`，
- 如果 `a` 不是已定义的，则结果为 `b`

```js run
let user;
alert(user ?? "匿名"); // 匿名（user 未定义）
```
```js run
let user = "John";
alert(user ?? "匿名"); // John（user 已定义）
```

我们还可以使用 `??` 序列从一系列的值中选择出第一个非 `null/undefined` 的值
```js run
let firstName = null;
let lastName = null;
let nickName = "Supercoder";
// 显示第一个已定义的值：
alert(firstName ?? lastName ?? nickName ?? "匿名"); // Supercoder
```

####  与 || 比较
或运算符 `||` 可以以与 `??` 运算符相同的方式使用

它们之间重要的区别是：
- `||` 返回第一个 **真** 值。
- `??` 返回第一个 **已定义的** 值

####  优先级
`??` 运算符的优先级与 `||` 相同，它们的的优先级都为 `4`
####  ?? 与 && 或 || 一起使用
出于安全原因，JavaScript 禁止将 `??` 运算符与 `&&` 和 `||` 运算符一起使用，除非使用括号明确指定了优先级